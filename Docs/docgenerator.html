<!-- Generated by DocGen-LM -->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>docgenerator</title>
    <link rel="stylesheet" href="static/style.css">
</head>
<body>
    <div class="sidebar">
        <h2>Navigation</h2>
        <ul>
        <li><a href="index.html"><strong>üè† Project Overview</strong></a></li>
<li><a href="cache.html">cache</a></li>
<li><a href="docgenerator.html">docgenerator</a></li>
<li><a href="html_writer.html">html_writer</a></li>
<li><a href="llm_client.html">llm_client</a></li>
<li><a href="parser_matlab.html">parser_matlab</a></li>
<li><a href="parser_python.html">parser_python</a></li>
<li><a href="reviewer.html">reviewer</a></li>
<li><a href="scanner.html">scanner</a></li>
<li><a href="test_cache.html">test_cache</a></li>
<li><a href="test_docgenerator.html">test_docgenerator</a></li>
<li><a href="test_docgenerator_subclasses.html">test_docgenerator_subclasses</a></li>
<li><a href="test_html_writer.html">test_html_writer</a></li>
<li><a href="test_integration.html">test_integration</a></li>
<li><a href="test_llm_client.html">test_llm_client</a></li>
<li><a href="test_parser_matlab.html">test_parser_matlab</a></li>
<li><a href="test_parser_python.html">test_parser_python</a></li>
<li><a href="test_reviewer.html">test_reviewer</a></li>
<li><a href="test_scanner.html">test_scanner</a></li>
        </ul>
    </div>
    <div class="content">
        <h1>docgenerator</h1>
        <p>The `main` function generates HTML documentation using a local Large Language Model (LLM) by parsing Python and MATLAB files in a specified source directory. It summarizes content, caches responses to avoid redundant requests, and outputs summaries as HTML pages for modules, classes, functions, and includes a project summary based on README.md and other Markdown files, all organized into an index page and individual module pages in the output directory.</p>
<h2>Functions</h2>
<h3 id="clean_output_dir">clean_output_dir(output_dir: str) -&gt; None</h3>
<p>The function `clean_output_dir` takes a string representing an output directory path and iterates through all files within that directory. If a file has a `.html` extension, it reads the first line of the file. If the first line contains the string &quot;Generated by DocGen-LM&quot;, the file is deleted. If any exceptions occur during this process, a warning message is printed indicating which file could not be checked and the reason for the exception.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">clean_output_dir</span>(output_dir: <span style="color: #008000">str</span>) <span style="color: #666666">-&gt;</span> <span style="color: #008000; font-weight: bold">None</span>:
    <span style="color: #008000; font-weight: bold">for</span> filename <span style="color: #AA22FF; font-weight: bold">in</span> os<span style="color: #666666">.</span>listdir(output_dir):
        <span style="color: #008000; font-weight: bold">if</span> filename<span style="color: #666666">.</span>endswith(<span style="color: #BA2121">&quot;.html&quot;</span>):
            full_path <span style="color: #666666">=</span> os<span style="color: #666666">.</span>path<span style="color: #666666">.</span>join(output_dir, filename)
            <span style="color: #008000; font-weight: bold">try</span>:
                <span style="color: #008000; font-weight: bold">with</span> <span style="color: #008000">open</span>(full_path, <span style="color: #BA2121">&quot;r&quot;</span>, encoding<span style="color: #666666">=</span><span style="color: #BA2121">&quot;utf-8&quot;</span>) <span style="color: #008000; font-weight: bold">as</span> f:
                    first_line <span style="color: #666666">=</span> f<span style="color: #666666">.</span>readline()
                    <span style="color: #008000; font-weight: bold">if</span> <span style="color: #BA2121">&quot;Generated by DocGen-LM&quot;</span> <span style="color: #AA22FF; font-weight: bold">in</span> first_line:
                        os<span style="color: #666666">.</span>remove(full_path)
            <span style="color: #008000; font-weight: bold">except</span> <span style="color: #CB3F38; font-weight: bold">Exception</span> <span style="color: #008000; font-weight: bold">as</span> e:
                <span style="color: #008000">print</span>(<span style="color: #BA2121">f&quot;[WARNING] Could not check </span><span style="color: #A45A77; font-weight: bold">{</span>filename<span style="color: #A45A77; font-weight: bold">}</span><span style="color: #BA2121">: </span><span style="color: #A45A77; font-weight: bold">{</span>e<span style="color: #A45A77; font-weight: bold">}</span><span style="color: #BA2121">&quot;</span>)
</code></pre>
<h3 id="_summarize">_summarize(client: LLMClient, cache: ResponseCache, key: str, text: str, prompt_type: str) -&gt; str</h3>
<p>The function `_summarize` takes an `LLMClient`, a `ResponseCache`, a `key`, a `text`, and a `prompt_type` as parameters. It checks if the summary for the given `key` is already cached. If it is, it returns the cached summary. Otherwise, it uses the `client` to generate a summary of the `text` based on the `prompt_type`. The generated summary is then stored in the cache under the specified `key` and returned.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">_summarize</span>(client: LLMClient, cache: ResponseCache, key: <span style="color: #008000">str</span>, text: <span style="color: #008000">str</span>, prompt_type: <span style="color: #008000">str</span>) <span style="color: #666666">-&gt;</span> <span style="color: #008000">str</span>:
    cached <span style="color: #666666">=</span> cache<span style="color: #666666">.</span>get(key)
    <span style="color: #008000; font-weight: bold">if</span> cached <span style="color: #AA22FF; font-weight: bold">is</span> <span style="color: #AA22FF; font-weight: bold">not</span> <span style="color: #008000; font-weight: bold">None</span>:
        <span style="color: #008000; font-weight: bold">return</span> cached
    summary <span style="color: #666666">=</span> client<span style="color: #666666">.</span>summarize(text, prompt_type)
    cache<span style="color: #666666">.</span>set(key, summary)
    <span style="color: #008000; font-weight: bold">return</span> summary
</code></pre>
<h3 id="_get_tokenizer">_get_tokenizer()</h3>
<p>Returns a tokenizer object for estimating token counts. If the `tiktoken` library is installed, it uses the `cl100k_base` encoding; otherwise, it falls back to a simple tokenizer that splits text by spaces and joins tokens with spaces.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">_get_tokenizer</span>():
<span style="color: #bbbbbb">    </span><span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;Return a tokenizer object used for estimating token counts.&quot;&quot;&quot;</span>

    <span style="color: #008000; font-weight: bold">if</span> tiktoken <span style="color: #AA22FF; font-weight: bold">is</span> <span style="color: #AA22FF; font-weight: bold">not</span> <span style="color: #008000; font-weight: bold">None</span>:  <span style="color: #3D7B7B; font-style: italic"># pragma: no cover - optional branch</span>
        <span style="color: #008000; font-weight: bold">try</span>:
            <span style="color: #008000; font-weight: bold">return</span> tiktoken<span style="color: #666666">.</span>get_encoding(<span style="color: #BA2121">&quot;cl100k_base&quot;</span>)
        <span style="color: #008000; font-weight: bold">except</span> <span style="color: #CB3F38; font-weight: bold">Exception</span>:  <span style="color: #3D7B7B; font-style: italic"># pragma: no cover - fallback if model unknown</span>
            <span style="color: #008000; font-weight: bold">return</span> tiktoken<span style="color: #666666">.</span>encoding_for_model(<span style="color: #BA2121">&quot;gpt-3.5-turbo&quot;</span>)

    <span style="color: #008000">print</span>(
        <span style="color: #BA2121">&quot;[WARNING] tiktoken is not installed; token counts will be approximate.&quot;</span>,
        file<span style="color: #666666">=</span>sys<span style="color: #666666">.</span>stderr,
    )

    <span style="color: #008000; font-weight: bold">class</span> <span style="color: #0000FF; font-weight: bold">_Simple</span>:
        <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">encode</span>(<span style="color: #008000">self</span>, text: <span style="color: #008000">str</span>):
            <span style="color: #008000; font-weight: bold">return</span> text<span style="color: #666666">.</span>split()

        <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">decode</span>(<span style="color: #008000">self</span>, tokens):
            <span style="color: #008000; font-weight: bold">return</span> <span style="color: #BA2121">&quot; &quot;</span><span style="color: #666666">.</span>join(tokens)

    <span style="color: #008000; font-weight: bold">return</span> _Simple()
</code></pre>
<h3 id="chunk_text">chunk_text(text: str, tokenizer, chunk_size_tokens: int)</h3>
<p>The `chunk_text` function splits a given text into smaller chunks based on the specified number of tokens. It uses a tokenizer to encode the input text into tokens, then iterates through these tokens in steps of `chunk_size_tokens`, decoding each chunk back into text and appending it to the result list.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">chunk_text</span>(text: <span style="color: #008000">str</span>, tokenizer, chunk_size_tokens: <span style="color: #008000">int</span>):
<span style="color: #bbbbbb">    </span><span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;Split ``text`` into chunks roughly ``chunk_size_tokens`` each.&quot;&quot;&quot;</span>

    tokens <span style="color: #666666">=</span> tokenizer<span style="color: #666666">.</span>encode(text)
    chunks <span style="color: #666666">=</span> []
    <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(<span style="color: #666666">0</span>, <span style="color: #008000">len</span>(tokens), chunk_size_tokens):
        chunk <span style="color: #666666">=</span> tokens[i : i <span style="color: #666666">+</span> chunk_size_tokens]
        chunks<span style="color: #666666">.</span>append(tokenizer<span style="color: #666666">.</span>decode(chunk))
    <span style="color: #008000; font-weight: bold">return</span> chunks
</code></pre>
<h3 id="_chunk_module_by_structure">_chunk_module_by_structure(module: dict, tokenizer, chunk_size_tokens: int)</h3>
<p>The function `_chunk_module_by_structure` processes a parsed module dictionary, breaking down its content into text chunks based on token size limits. It starts with the module&#x27;s docstring, then iterates through classes and their methods, as well as standalone functions. Each block of code is encoded using a tokenizer to determine if it fits within the specified chunk size. If a block exceeds the limit, it is further split into smaller chunks. The function returns a list of text chunks that can be used for documentation generation while respecting token limits.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">_chunk_module_by_structure</span>(module: <span style="color: #008000">dict</span>, tokenizer, chunk_size_tokens: <span style="color: #008000">int</span>):
<span style="color: #bbbbbb">    </span><span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;Return a list of text chunks for ``module`` using its parsed structure.&quot;&quot;&quot;</span>

    blocks <span style="color: #666666">=</span> []
    module_doc <span style="color: #666666">=</span> module<span style="color: #666666">.</span>get(<span style="color: #BA2121">&quot;module_docstring&quot;</span>)
    <span style="color: #008000; font-weight: bold">if</span> module_doc:
        blocks<span style="color: #666666">.</span>append(module_doc)

    <span style="color: #008000; font-weight: bold">for</span> <span style="color: #008000">cls</span> <span style="color: #AA22FF; font-weight: bold">in</span> module<span style="color: #666666">.</span>get(<span style="color: #BA2121">&quot;classes&quot;</span>, []):
        src <span style="color: #666666">=</span> <span style="color: #008000">cls</span><span style="color: #666666">.</span>get(<span style="color: #BA2121">&quot;source&quot;</span>, <span style="color: #BA2121">&quot;&quot;</span>)
        <span style="color: #008000; font-weight: bold">if</span> <span style="color: #008000">len</span>(tokenizer<span style="color: #666666">.</span>encode(src)) <span style="color: #666666">&lt;=</span> chunk_size_tokens:
            blocks<span style="color: #666666">.</span>append(src)
        <span style="color: #008000; font-weight: bold">else</span>:
            <span style="color: #008000; font-weight: bold">for</span> method <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">cls</span><span style="color: #666666">.</span>get(<span style="color: #BA2121">&quot;methods&quot;</span>, []):
                m_src <span style="color: #666666">=</span> method<span style="color: #666666">.</span>get(<span style="color: #BA2121">&quot;source&quot;</span>, <span style="color: #BA2121">&quot;&quot;</span>)
                blocks<span style="color: #666666">.</span>append(m_src)

    <span style="color: #008000; font-weight: bold">for</span> func <span style="color: #AA22FF; font-weight: bold">in</span> module<span style="color: #666666">.</span>get(<span style="color: #BA2121">&quot;functions&quot;</span>, []):
        blocks<span style="color: #666666">.</span>append(func<span style="color: #666666">.</span>get(<span style="color: #BA2121">&quot;source&quot;</span>, func<span style="color: #666666">.</span>get(<span style="color: #BA2121">&quot;signature&quot;</span>, <span style="color: #BA2121">&quot;&quot;</span>)))

    chunks <span style="color: #666666">=</span> []
    current: <span style="color: #008000">list</span>[<span style="color: #008000">str</span>] <span style="color: #666666">=</span> []
    current_tokens <span style="color: #666666">=</span> <span style="color: #666666">0</span>
    sep_tokens <span style="color: #666666">=</span> <span style="color: #008000">len</span>(tokenizer<span style="color: #666666">.</span>encode(<span style="color: #BA2121">&quot;</span><span style="color: #AA5D1F; font-weight: bold">\n\n</span><span style="color: #BA2121">&quot;</span>))

    <span style="color: #008000; font-weight: bold">for</span> block <span style="color: #AA22FF; font-weight: bold">in</span> blocks:
        block_tokens <span style="color: #666666">=</span> <span style="color: #008000">len</span>(tokenizer<span style="color: #666666">.</span>encode(block))
        <span style="color: #008000; font-weight: bold">if</span> block_tokens <span style="color: #666666">&gt;</span> chunk_size_tokens:
            <span style="color: #008000; font-weight: bold">if</span> current:
                chunks<span style="color: #666666">.</span>append(<span style="color: #BA2121">&quot;</span><span style="color: #AA5D1F; font-weight: bold">\n\n</span><span style="color: #BA2121">&quot;</span><span style="color: #666666">.</span>join(current))
                current <span style="color: #666666">=</span> []
                current_tokens <span style="color: #666666">=</span> <span style="color: #666666">0</span>
            chunks<span style="color: #666666">.</span>extend(chunk_text(block, tokenizer, chunk_size_tokens))
            <span style="color: #008000; font-weight: bold">continue</span>

        additional <span style="color: #666666">=</span> block_tokens <span style="color: #008000; font-weight: bold">if</span> <span style="color: #AA22FF; font-weight: bold">not</span> current <span style="color: #008000; font-weight: bold">else</span> block_tokens <span style="color: #666666">+</span> sep_tokens
        <span style="color: #008000; font-weight: bold">if</span> current_tokens <span style="color: #666666">+</span> additional <span style="color: #666666">&lt;=</span> chunk_size_tokens:
            current<span style="color: #666666">.</span>append(block)
            current_tokens <span style="color: #666666">+=</span> additional
        <span style="color: #008000; font-weight: bold">else</span>:
            <span style="color: #008000; font-weight: bold">if</span> current:
                chunks<span style="color: #666666">.</span>append(<span style="color: #BA2121">&quot;</span><span style="color: #AA5D1F; font-weight: bold">\n\n</span><span style="color: #BA2121">&quot;</span><span style="color: #666666">.</span>join(current))
            current <span style="color: #666666">=</span> [block]
            current_tokens <span style="color: #666666">=</span> block_tokens

    <span style="color: #008000; font-weight: bold">if</span> current:
        chunks<span style="color: #666666">.</span>append(<span style="color: #BA2121">&quot;</span><span style="color: #AA5D1F; font-weight: bold">\n\n</span><span style="color: #BA2121">&quot;</span><span style="color: #666666">.</span>join(current))

    <span style="color: #008000; font-weight: bold">return</span> chunks
</code></pre>
<h3 id="_summarize_chunked">_summarize_chunked(client: LLMClient, cache: ResponseCache, key_prefix: str, text: str, prompt_type: str, tokenizer, max_context_tokens: int, chunk_token_budget: int) -&gt; str</h3>
<p>This function `_summarize_chunked` is designed to summarize a given text by breaking it into chunks if necessary. It uses an LLM client for summarization and a response cache to store previously computed summaries. The function handles the following steps:

1. Retrieves a template based on the `prompt_type`.
2. Calculates overhead tokens for system prompt and template.
3. Determines available tokens for summarization.
4. Checks if the text can be summarized in one chunk; if so, it proceeds with summarization using the `_summarize` function.
5. If the text is too long, it chunks the text into smaller parts based on `chunk_token_budget`.
6. Summarizes each chunk individually and stores the results in the cache.
7. Merges the summaries of individual chunks into a single technical summary.
8. Returns the sanitized final summary.

The function ensures efficient use of tokens by limiting the size of each chunk and leveraging caching to avoid redundant computations.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">_summarize_chunked</span>(
    client: LLMClient,
    cache: ResponseCache,
    key_prefix: <span style="color: #008000">str</span>,
    text: <span style="color: #008000">str</span>,
    prompt_type: <span style="color: #008000">str</span>,
    tokenizer,
    max_context_tokens: <span style="color: #008000">int</span>,
    chunk_token_budget: <span style="color: #008000">int</span>,
) <span style="color: #666666">-&gt;</span> <span style="color: #008000">str</span>:
<span style="color: #bbbbbb">    </span><span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;Summarize ``text`` by chunking if necessary.&quot;&quot;&quot;</span>

    template <span style="color: #666666">=</span> PROMPT_TEMPLATES<span style="color: #666666">.</span>get(prompt_type, PROMPT_TEMPLATES[<span style="color: #BA2121">&quot;module&quot;</span>])
    overhead_tokens <span style="color: #666666">=</span> <span style="color: #008000">len</span>(tokenizer<span style="color: #666666">.</span>encode(SYSTEM_PROMPT)) <span style="color: #666666">+</span> <span style="color: #008000">len</span>(
        tokenizer<span style="color: #666666">.</span>encode(template<span style="color: #666666">.</span>format(text<span style="color: #666666">=</span><span style="color: #BA2121">&quot;&quot;</span>))
    )
    available_tokens <span style="color: #666666">=</span> <span style="color: #008000">max</span>(<span style="color: #666666">1</span>, max_context_tokens <span style="color: #666666">-</span> overhead_tokens)

    <span style="color: #008000; font-weight: bold">if</span> <span style="color: #008000">len</span>(tokenizer<span style="color: #666666">.</span>encode(text)) <span style="color: #666666">&lt;=</span> available_tokens:
        key <span style="color: #666666">=</span> ResponseCache<span style="color: #666666">.</span>make_key(key_prefix, text)
        <span style="color: #008000; font-weight: bold">return</span> _summarize(client, cache, key, text, prompt_type)

    chunk_size_tokens <span style="color: #666666">=</span> <span style="color: #008000">min</span>(chunk_token_budget, available_tokens)
    parts <span style="color: #666666">=</span> chunk_text(text, tokenizer, chunk_size_tokens)
    partials <span style="color: #666666">=</span> []
    <span style="color: #008000; font-weight: bold">for</span> idx, part <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">enumerate</span>(parts):
        key <span style="color: #666666">=</span> ResponseCache<span style="color: #666666">.</span>make_key(<span style="color: #BA2121">f&quot;</span><span style="color: #A45A77; font-weight: bold">{</span>key_prefix<span style="color: #A45A77; font-weight: bold">}</span><span style="color: #BA2121">:part</span><span style="color: #A45A77; font-weight: bold">{</span>idx<span style="color: #A45A77; font-weight: bold">}</span><span style="color: #BA2121">&quot;</span>, part)
        partials<span style="color: #666666">.</span>append(_summarize(client, cache, key, part, prompt_type))

    merge_text <span style="color: #666666">=</span> <span style="color: #BA2121">&quot;</span><span style="color: #AA5D1F; font-weight: bold">\n</span><span style="color: #BA2121">&quot;</span><span style="color: #666666">.</span>join(<span style="color: #BA2121">f&quot;- </span><span style="color: #A45A77; font-weight: bold">{</span>p<span style="color: #A45A77; font-weight: bold">}</span><span style="color: #BA2121">&quot;</span> <span style="color: #008000; font-weight: bold">for</span> p <span style="color: #AA22FF; font-weight: bold">in</span> partials)
    merge_prompt <span style="color: #666666">=</span> (
        <span style="color: #BA2121">&quot;Merge the following chunk-level summaries into a single technical summary (2‚Äì3 sentences).</span><span style="color: #AA5D1F; font-weight: bold">\n\n</span><span style="color: #BA2121">&quot;</span>
        <span style="color: #666666">+</span> merge_text
    )
    merge_key <span style="color: #666666">=</span> ResponseCache<span style="color: #666666">.</span>make_key(<span style="color: #BA2121">f&quot;</span><span style="color: #A45A77; font-weight: bold">{</span>key_prefix<span style="color: #A45A77; font-weight: bold">}</span><span style="color: #BA2121">:merge&quot;</span>, merge_prompt)
    final_summary <span style="color: #666666">=</span> _summarize(client, cache, merge_key, merge_prompt, <span style="color: #BA2121">&quot;docstring&quot;</span>)
    <span style="color: #008000; font-weight: bold">return</span> sanitize_summary(final_summary)
</code></pre>
<h3 id="_summarize_module_chunked">_summarize_module_chunked(client: LLMClient, cache: ResponseCache, key_prefix: str, module_text: str, module: dict, tokenizer, max_context_tokens: int, chunk_token_budget: int) -&gt; str</h3>
<p>This function `_summarize_module_chunked` summarizes a Python module using a structure-aware chunking approach. It takes an LLM client, response cache, key prefix, module text, module dictionary, tokenizer, maximum context tokens, and chunk token budget as inputs. The function first calculates the available tokens for summarization after accounting for overhead from system prompt and template encoding. If the module text fits within the available tokens, it generates a summary directly. Otherwise, it splits the module into chunks based on structure using `_chunk_module_by_structure`. Each chunk is summarized individually, and then all partial summaries are merged into a single technical summary using another summarization call. The final summary is sanitized before being returned.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">_summarize_module_chunked</span>(
    client: LLMClient,
    cache: ResponseCache,
    key_prefix: <span style="color: #008000">str</span>,
    module_text: <span style="color: #008000">str</span>,
    module: <span style="color: #008000">dict</span>,
    tokenizer,
    max_context_tokens: <span style="color: #008000">int</span>,
    chunk_token_budget: <span style="color: #008000">int</span>,
) <span style="color: #666666">-&gt;</span> <span style="color: #008000">str</span>:
<span style="color: #bbbbbb">    </span><span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;Summarize a module using structure-aware chunking.&quot;&quot;&quot;</span>

    template <span style="color: #666666">=</span> PROMPT_TEMPLATES[<span style="color: #BA2121">&quot;module&quot;</span>]
    overhead_tokens <span style="color: #666666">=</span> <span style="color: #008000">len</span>(tokenizer<span style="color: #666666">.</span>encode(SYSTEM_PROMPT)) <span style="color: #666666">+</span> <span style="color: #008000">len</span>(
        tokenizer<span style="color: #666666">.</span>encode(template<span style="color: #666666">.</span>format(text<span style="color: #666666">=</span><span style="color: #BA2121">&quot;&quot;</span>))
    )
    available_tokens <span style="color: #666666">=</span> <span style="color: #008000">max</span>(<span style="color: #666666">1</span>, max_context_tokens <span style="color: #666666">-</span> overhead_tokens)

    <span style="color: #008000; font-weight: bold">if</span> <span style="color: #008000">len</span>(tokenizer<span style="color: #666666">.</span>encode(module_text)) <span style="color: #666666">&lt;=</span> available_tokens:
        key <span style="color: #666666">=</span> ResponseCache<span style="color: #666666">.</span>make_key(key_prefix, module_text)
        <span style="color: #008000; font-weight: bold">return</span> _summarize(client, cache, key, module_text, <span style="color: #BA2121">&quot;module&quot;</span>)

    chunk_size_tokens <span style="color: #666666">=</span> <span style="color: #008000">min</span>(chunk_token_budget, available_tokens)
    parts <span style="color: #666666">=</span> _chunk_module_by_structure(module, tokenizer, chunk_size_tokens)
    partials <span style="color: #666666">=</span> []
    <span style="color: #008000; font-weight: bold">for</span> idx, part <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">enumerate</span>(parts):
        key <span style="color: #666666">=</span> ResponseCache<span style="color: #666666">.</span>make_key(<span style="color: #BA2121">f&quot;</span><span style="color: #A45A77; font-weight: bold">{</span>key_prefix<span style="color: #A45A77; font-weight: bold">}</span><span style="color: #BA2121">:part</span><span style="color: #A45A77; font-weight: bold">{</span>idx<span style="color: #A45A77; font-weight: bold">}</span><span style="color: #BA2121">&quot;</span>, part)
        partials<span style="color: #666666">.</span>append(_summarize(client, cache, key, part, <span style="color: #BA2121">&quot;module&quot;</span>))

    merge_text <span style="color: #666666">=</span> <span style="color: #BA2121">&quot;</span><span style="color: #AA5D1F; font-weight: bold">\n</span><span style="color: #BA2121">&quot;</span><span style="color: #666666">.</span>join(<span style="color: #BA2121">f&quot;- </span><span style="color: #A45A77; font-weight: bold">{</span>p<span style="color: #A45A77; font-weight: bold">}</span><span style="color: #BA2121">&quot;</span> <span style="color: #008000; font-weight: bold">for</span> p <span style="color: #AA22FF; font-weight: bold">in</span> partials)
    merge_prompt <span style="color: #666666">=</span> (
        <span style="color: #BA2121">&quot;Merge the following chunk-level summaries into a single technical summary (2‚Äì3 sentences).</span><span style="color: #AA5D1F; font-weight: bold">\n\n</span><span style="color: #BA2121">&quot;</span>
        <span style="color: #666666">+</span> merge_text
    )
    merge_key <span style="color: #666666">=</span> ResponseCache<span style="color: #666666">.</span>make_key(<span style="color: #BA2121">f&quot;</span><span style="color: #A45A77; font-weight: bold">{</span>key_prefix<span style="color: #A45A77; font-weight: bold">}</span><span style="color: #BA2121">:merge&quot;</span>, merge_prompt)
    final_summary <span style="color: #666666">=</span> _summarize(client, cache, merge_key, merge_prompt, <span style="color: #BA2121">&quot;docstring&quot;</span>)
    <span style="color: #008000; font-weight: bold">return</span> sanitize_summary(final_summary)
</code></pre>
<h3 id="_build_function_prompt">_build_function_prompt(source: str, class_name: str | None=None, class_summary: str | None=None, project_summary: str | None=None) -&gt; str</h3>
<p>This function `_build_function_prompt` constructs a prompt for summarizing a Python function. It takes the source code of the function, an optional class name, an optional class summary, and an optional project summary as inputs. The function returns a string that includes these details and instructions on how to summarize the function based solely on its source code.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">_build_function_prompt</span>(
    source: <span style="color: #008000">str</span>,
    class_name: <span style="color: #008000">str</span> <span style="color: #666666">|</span> <span style="color: #008000; font-weight: bold">None</span> <span style="color: #666666">=</span> <span style="color: #008000; font-weight: bold">None</span>,
    class_summary: <span style="color: #008000">str</span> <span style="color: #666666">|</span> <span style="color: #008000; font-weight: bold">None</span> <span style="color: #666666">=</span> <span style="color: #008000; font-weight: bold">None</span>,
    project_summary: <span style="color: #008000">str</span> <span style="color: #666666">|</span> <span style="color: #008000; font-weight: bold">None</span> <span style="color: #666666">=</span> <span style="color: #008000; font-weight: bold">None</span>,
) <span style="color: #666666">-&gt;</span> <span style="color: #008000">str</span>:
<span style="color: #bbbbbb">    </span><span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;Return a context-enriched prompt for summarizing ``source``.&quot;&quot;&quot;</span>

    lines <span style="color: #666666">=</span> [<span style="color: #BA2121">&quot;You are a documentation generator.&quot;</span>]
    <span style="color: #008000; font-weight: bold">if</span> class_name:
        lines<span style="color: #666666">.</span>append(<span style="color: #BA2121">f&quot;The following function is part of the class `</span><span style="color: #A45A77; font-weight: bold">{</span>class_name<span style="color: #A45A77; font-weight: bold">}</span><span style="color: #BA2121">`.&quot;</span>)
    <span style="color: #008000; font-weight: bold">if</span> class_summary:
        lines<span style="color: #666666">.</span>append(<span style="color: #BA2121">f&quot;This class </span><span style="color: #A45A77; font-weight: bold">{</span>class_summary<span style="color: #A45A77; font-weight: bold">}</span><span style="color: #BA2121">&quot;</span>)
    <span style="color: #008000; font-weight: bold">if</span> project_summary:
        lines<span style="color: #666666">.</span>append(<span style="color: #BA2121">f&quot;This project </span><span style="color: #A45A77; font-weight: bold">{</span>project_summary<span style="color: #A45A77; font-weight: bold">}</span><span style="color: #BA2121">&quot;</span>)
    lines<span style="color: #666666">.</span>extend(
        [
            <span style="color: #BA2121">&quot;Summarize the function based on its source code below.&quot;</span>,
            <span style="color: #BA2121">&quot;- Do not include assistant phrasing or usage instructions.&quot;</span>,
            <span style="color: #BA2121">&quot;- Do not mention unrelated games or systems.&quot;</span>,
            <span style="color: #BA2121">&quot;- Only use the context and code provided.&quot;</span>,
            <span style="color: #BA2121">&quot;&quot;</span>,
            <span style="color: #BA2121">&quot;```python&quot;</span>,
            source,
            <span style="color: #BA2121">&quot;```&quot;</span>,
        ]
    )
    <span style="color: #008000; font-weight: bold">return</span> <span style="color: #BA2121">&quot;</span><span style="color: #AA5D1F; font-weight: bold">\n</span><span style="color: #BA2121">&quot;</span><span style="color: #666666">.</span>join(lines)
</code></pre>
<h3 id="_rewrite_docstring">_rewrite_docstring(client: LLMClient, cache: ResponseCache, file_path: str, item: dict[str, str], *, class_name: str | None=None, class_summary: str | None=None, project_summary: str | None=None) -&gt; None</h3>
<p>The function `_rewrite_docstring` rewrites the docstring of a code item using an LLM client. It takes a client, a cache, a file path, and an item dictionary as inputs. The function first checks if there is source code or a docstring in the item. If not, it prints a warning and returns. If there is a docstring, it constructs a prompt based on optional context such as class name, summary, and project summary. It then generates a key for caching purposes and calls `_summarize` to get a rewritten docstring from the LLM client. The result is sanitized and assigned back to the item&#x27;s docstring field. If no summary is available, it sets the docstring to &quot;No summary available.&quot;</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">_rewrite_docstring</span>(
    client: LLMClient,
    cache: ResponseCache,
    file_path: <span style="color: #008000">str</span>,
    item: <span style="color: #008000">dict</span>[<span style="color: #008000">str</span>, <span style="color: #008000">str</span>],
    <span style="color: #666666">*</span>,
    class_name: <span style="color: #008000">str</span> <span style="color: #666666">|</span> <span style="color: #008000; font-weight: bold">None</span> <span style="color: #666666">=</span> <span style="color: #008000; font-weight: bold">None</span>,
    class_summary: <span style="color: #008000">str</span> <span style="color: #666666">|</span> <span style="color: #008000; font-weight: bold">None</span> <span style="color: #666666">=</span> <span style="color: #008000; font-weight: bold">None</span>,
    project_summary: <span style="color: #008000">str</span> <span style="color: #666666">|</span> <span style="color: #008000; font-weight: bold">None</span> <span style="color: #666666">=</span> <span style="color: #008000; font-weight: bold">None</span>,
) <span style="color: #666666">-&gt;</span> <span style="color: #008000; font-weight: bold">None</span>:
<span style="color: #bbbbbb">    </span><span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;Rewrite ``item`` docstring using optional context.&quot;&quot;&quot;</span>

    source <span style="color: #666666">=</span> item<span style="color: #666666">.</span>get(<span style="color: #BA2121">&quot;source&quot;</span>, <span style="color: #BA2121">&quot;&quot;</span>)
    docstring <span style="color: #666666">=</span> item<span style="color: #666666">.</span>get(<span style="color: #BA2121">&quot;docstring&quot;</span>, <span style="color: #BA2121">&quot;&quot;</span>) <span style="color: #AA22FF; font-weight: bold">or</span> <span style="color: #BA2121">&quot;&quot;</span>
    <span style="color: #008000; font-weight: bold">if</span> <span style="color: #AA22FF; font-weight: bold">not</span> source <span style="color: #AA22FF; font-weight: bold">and</span> <span style="color: #AA22FF; font-weight: bold">not</span> docstring:
        <span style="color: #008000">print</span>(
            <span style="color: #BA2121">f&quot;Warning: no source or docstring for </span><span style="color: #A45A77; font-weight: bold">{</span>file_path<span style="color: #A45A77; font-weight: bold">}</span><span style="color: #BA2121">:</span><span style="color: #A45A77; font-weight: bold">{</span>item<span style="color: #666666">.</span>get(<span style="color: #BA2121">&#39;name&#39;</span>)<span style="color: #A45A77; font-weight: bold">}</span><span style="color: #BA2121">&quot;</span>,
            file<span style="color: #666666">=</span>sys<span style="color: #666666">.</span>stderr,
        )
        <span style="color: #008000; font-weight: bold">return</span>

    <span style="color: #008000; font-weight: bold">if</span> <span style="color: #AA22FF; font-weight: bold">not</span> docstring:
        <span style="color: #008000; font-weight: bold">return</span>

    <span style="color: #008000; font-weight: bold">if</span> class_name <span style="color: #AA22FF; font-weight: bold">or</span> class_summary <span style="color: #AA22FF; font-weight: bold">or</span> project_summary:
        prompt <span style="color: #666666">=</span> _build_function_prompt(
            source,
            class_name<span style="color: #666666">=</span>class_name,
            class_summary<span style="color: #666666">=</span>class_summary,
            project_summary<span style="color: #666666">=</span>project_summary,
        )
        key_content <span style="color: #666666">=</span> source <span style="color: #666666">+</span> (class_name <span style="color: #AA22FF; font-weight: bold">or</span> <span style="color: #BA2121">&quot;&quot;</span>) <span style="color: #666666">+</span> (class_summary <span style="color: #AA22FF; font-weight: bold">or</span> <span style="color: #BA2121">&quot;&quot;</span>) <span style="color: #666666">+</span> (project_summary <span style="color: #AA22FF; font-weight: bold">or</span> <span style="color: #BA2121">&quot;&quot;</span>)
    <span style="color: #008000; font-weight: bold">else</span>:
        prompt <span style="color: #666666">=</span> DOC_PROMPT<span style="color: #666666">.</span>format(source<span style="color: #666666">=</span>source, docstring<span style="color: #666666">=</span>docstring)
        key_content <span style="color: #666666">=</span> source <span style="color: #666666">+</span> docstring

    key <span style="color: #666666">=</span> ResponseCache<span style="color: #666666">.</span>make_key(
        <span style="color: #BA2121">f&quot;REWRITE:</span><span style="color: #A45A77; font-weight: bold">{</span>file_path<span style="color: #A45A77; font-weight: bold">}</span><span style="color: #BA2121">:</span><span style="color: #A45A77; font-weight: bold">{</span>item<span style="color: #666666">.</span>get(<span style="color: #BA2121">&#39;name&#39;</span>)<span style="color: #A45A77; font-weight: bold">}</span><span style="color: #BA2121">&quot;</span>,
        key_content,
    )
    result <span style="color: #666666">=</span> _summarize(client, cache, key, prompt, <span style="color: #BA2121">&quot;docstring&quot;</span>)
    item[<span style="color: #BA2121">&quot;docstring&quot;</span>] <span style="color: #666666">=</span> sanitize_summary(result) <span style="color: #AA22FF; font-weight: bold">or</span> <span style="color: #BA2121">&quot;No summary available.&quot;</span>
</code></pre>
<h3 id="_summarize_methods_recursive">_summarize_methods_recursive(class_data: dict[str, Any], path: str, client: LLMClient, cache: ResponseCache) -&gt; None</h3>
<p>This function recursively summarizes methods within a class and its subclasses. It iterates through each method in the provided `class_data`, generates a unique key using the class and method names, and fetches or computes a summary using an LLM client. The summary is then assigned to both the &quot;summary&quot; and &quot;docstring&quot; fields of the method dictionary. If the class has subclasses, the function calls itself recursively to process each subclass.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">_summarize_methods_recursive</span>(
    class_data: <span style="color: #008000">dict</span>[<span style="color: #008000">str</span>, Any],
    path: <span style="color: #008000">str</span>,
    client: LLMClient,
    cache: ResponseCache,
) <span style="color: #666666">-&gt;</span> <span style="color: #008000; font-weight: bold">None</span>:
<span style="color: #bbbbbb">    </span><span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;Summarize methods of ``class_data`` and any subclasses.&quot;&quot;&quot;</span>

    <span style="color: #008000; font-weight: bold">for</span> method <span style="color: #AA22FF; font-weight: bold">in</span> class_data<span style="color: #666666">.</span>get(<span style="color: #BA2121">&quot;methods&quot;</span>, []):
        src <span style="color: #666666">=</span> method<span style="color: #666666">.</span>get(<span style="color: #BA2121">&quot;source&quot;</span>) <span style="color: #AA22FF; font-weight: bold">or</span> method<span style="color: #666666">.</span>get(<span style="color: #BA2121">&quot;signature&quot;</span>) <span style="color: #AA22FF; font-weight: bold">or</span> method<span style="color: #666666">.</span>get(<span style="color: #BA2121">&quot;name&quot;</span>, <span style="color: #BA2121">&quot;&quot;</span>)
        key <span style="color: #666666">=</span> ResponseCache<span style="color: #666666">.</span>make_key(
            <span style="color: #BA2121">f&quot;</span><span style="color: #A45A77; font-weight: bold">{</span>path<span style="color: #A45A77; font-weight: bold">}</span><span style="color: #BA2121">:</span><span style="color: #A45A77; font-weight: bold">{</span>class_data<span style="color: #666666">.</span>get(<span style="color: #BA2121">&#39;name&#39;</span>)<span style="color: #A45A77; font-weight: bold">}</span><span style="color: #BA2121">:</span><span style="color: #A45A77; font-weight: bold">{</span>method<span style="color: #666666">.</span>get(<span style="color: #BA2121">&#39;name&#39;</span>)<span style="color: #A45A77; font-weight: bold">}</span><span style="color: #BA2121">&quot;</span>, src
        )
        summary <span style="color: #666666">=</span> _summarize(client, cache, key, src, <span style="color: #BA2121">&quot;function&quot;</span>)
        method[<span style="color: #BA2121">&quot;summary&quot;</span>] <span style="color: #666666">=</span> summary
        method[<span style="color: #BA2121">&quot;docstring&quot;</span>] <span style="color: #666666">=</span> summary

    <span style="color: #008000; font-weight: bold">for</span> sub <span style="color: #AA22FF; font-weight: bold">in</span> class_data<span style="color: #666666">.</span>get(<span style="color: #BA2121">&quot;subclasses&quot;</span>, []):
        _summarize_methods_recursive(sub, path, client, cache)
</code></pre>
<h3 id="_summarize_class_recursive">_summarize_class_recursive(class_data: dict[str, Any], path: str, project_summary: str, tokenizer, client: LLMClient, cache: ResponseCache, max_context_tokens: int, chunk_token_budget: int) -&gt; None</h3>
<p>This function recursively summarizes a class and its methods. It first summarizes the methods, then constructs a prompt for summarizing the class itself. Using an LLM client, it generates a summary for the class docstring and updates the class data with this new summary. If the original docstring exists, it rewrites the docstring to include the new summary. The function also recursively processes any subclasses of the current class.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">_summarize_class_recursive</span>(
    class_data: <span style="color: #008000">dict</span>[<span style="color: #008000">str</span>, Any],
    path: <span style="color: #008000">str</span>,
    project_summary: <span style="color: #008000">str</span>,
    tokenizer,
    client: LLMClient,
    cache: ResponseCache,
    max_context_tokens: <span style="color: #008000">int</span>,
    chunk_token_budget: <span style="color: #008000">int</span>,
) <span style="color: #666666">-&gt;</span> <span style="color: #008000; font-weight: bold">None</span>:
<span style="color: #bbbbbb">    </span><span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;Summarize ``class_data`` and rewrite its docstring and methods.&quot;&quot;&quot;</span>

    _summarize_methods_recursive(class_data, path, client, cache)

    method_lines <span style="color: #666666">=</span> []
    <span style="color: #008000; font-weight: bold">for</span> method <span style="color: #AA22FF; font-weight: bold">in</span> class_data<span style="color: #666666">.</span>get(<span style="color: #BA2121">&quot;methods&quot;</span>, []):
        summary <span style="color: #666666">=</span> method<span style="color: #666666">.</span>get(<span style="color: #BA2121">&quot;summary&quot;</span>, <span style="color: #BA2121">&quot;&quot;</span>)
        name <span style="color: #666666">=</span> method<span style="color: #666666">.</span>get(<span style="color: #BA2121">&quot;name&quot;</span>, <span style="color: #BA2121">&quot;&quot;</span>)
        method_lines<span style="color: #666666">.</span>append(<span style="color: #BA2121">f&quot;- </span><span style="color: #A45A77; font-weight: bold">{</span>name<span style="color: #A45A77; font-weight: bold">}</span><span style="color: #BA2121">: </span><span style="color: #A45A77; font-weight: bold">{</span>summary<span style="color: #A45A77; font-weight: bold">}</span><span style="color: #BA2121">&quot;</span> <span style="color: #008000; font-weight: bold">if</span> summary <span style="color: #008000; font-weight: bold">else</span> <span style="color: #BA2121">f&quot;- </span><span style="color: #A45A77; font-weight: bold">{</span>name<span style="color: #A45A77; font-weight: bold">}</span><span style="color: #BA2121">&quot;</span>)

    methods_text <span style="color: #666666">=</span> <span style="color: #BA2121">&quot;</span><span style="color: #AA5D1F; font-weight: bold">\n</span><span style="color: #BA2121">&quot;</span><span style="color: #666666">.</span>join(method_lines) <span style="color: #008000; font-weight: bold">if</span> method_lines <span style="color: #008000; font-weight: bold">else</span> <span style="color: #BA2121">&quot;- (no methods)&quot;</span>
    class_prompt <span style="color: #666666">=</span> CLASS_PROMPT<span style="color: #666666">.</span>format(
        class_name<span style="color: #666666">=</span>class_data<span style="color: #666666">.</span>get(<span style="color: #BA2121">&quot;name&quot;</span>, <span style="color: #BA2121">&quot;&quot;</span>),
        project_summary<span style="color: #666666">=</span>project_summary,
        methods<span style="color: #666666">=</span>methods_text,
    )
    cls_key <span style="color: #666666">=</span> ResponseCache<span style="color: #666666">.</span>make_key(<span style="color: #BA2121">f&quot;</span><span style="color: #A45A77; font-weight: bold">{</span>path<span style="color: #A45A77; font-weight: bold">}</span><span style="color: #BA2121">:</span><span style="color: #A45A77; font-weight: bold">{</span>class_data<span style="color: #666666">.</span>get(<span style="color: #BA2121">&#39;name&#39;</span>)<span style="color: #A45A77; font-weight: bold">}</span><span style="color: #BA2121">&quot;</span>, class_prompt)
    cls_summary <span style="color: #666666">=</span> _summarize_chunked(
        client,
        cache,
        cls_key,
        class_prompt,
        <span style="color: #BA2121">&quot;docstring&quot;</span>,
        tokenizer,
        max_context_tokens,
        chunk_token_budget,
    )
    cls_summary <span style="color: #666666">=</span> sanitize_summary(cls_summary)
    original_doc <span style="color: #666666">=</span> class_data<span style="color: #666666">.</span>get(<span style="color: #BA2121">&quot;docstring&quot;</span>, <span style="color: #BA2121">&quot;&quot;</span>)
    class_data[<span style="color: #BA2121">&quot;summary&quot;</span>] <span style="color: #666666">=</span> cls_summary
    class_data[<span style="color: #BA2121">&quot;docstring&quot;</span>] <span style="color: #666666">=</span> cls_summary
    <span style="color: #008000; font-weight: bold">if</span> original_doc:
        class_data[<span style="color: #BA2121">&quot;docstring&quot;</span>] <span style="color: #666666">=</span> original_doc
        _rewrite_docstring(client, cache, path, class_data)

    <span style="color: #008000; font-weight: bold">for</span> method <span style="color: #AA22FF; font-weight: bold">in</span> class_data<span style="color: #666666">.</span>get(<span style="color: #BA2121">&quot;methods&quot;</span>, []):
        _rewrite_docstring(
            client,
            cache,
            path,
            method,
            class_name<span style="color: #666666">=</span>class_data<span style="color: #666666">.</span>get(<span style="color: #BA2121">&quot;name&quot;</span>),
            class_summary<span style="color: #666666">=</span>cls_summary,
            project_summary<span style="color: #666666">=</span>project_summary,
        )

    <span style="color: #008000; font-weight: bold">for</span> sub <span style="color: #AA22FF; font-weight: bold">in</span> class_data<span style="color: #666666">.</span>get(<span style="color: #BA2121">&quot;subclasses&quot;</span>, []):
        _summarize_class_recursive(
            sub,
            path,
            project_summary,
            tokenizer,
            client,
            cache,
            max_context_tokens,
            chunk_token_budget,
        )
</code></pre>
<h3 id="main">main(argv: list[str] | None=None) -&gt; int</h3>
<p>The `main` function is the entry point of the DocGen-LM tool. It sets up command-line arguments to specify the source directory, output directory, and various optional parameters such as LLM server URL, model name, and token limits. The function initializes an LLM client, checks its connectivity, and configures a tokenizer.

It then processes each file in the specified source directory:
- Reads the file content.
- Parses the file to extract Python or MATLAB code structures (functions and classes).
- Caches previously generated summaries using a `ResponseCache`.
- Summarizes each module and its components (classes and functions) using the LLM client, handling potential errors like invalid encoding or syntax issues.

After processing all files, it generates an HTML project summary based on the parsed structure. It also reads any README.md files in the source directory to include additional documentation.

Finally, the function writes the generated summaries to HTML files in the output directory, creating an index page and individual pages for each module.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">main</span>(argv: <span style="color: #008000">list</span>[<span style="color: #008000">str</span>] <span style="color: #666666">|</span> <span style="color: #008000; font-weight: bold">None</span> <span style="color: #666666">=</span> <span style="color: #008000; font-weight: bold">None</span>) <span style="color: #666666">-&gt;</span> <span style="color: #008000">int</span>:
    parser <span style="color: #666666">=</span> argparse<span style="color: #666666">.</span>ArgumentParser(description<span style="color: #666666">=</span><span style="color: #BA2121">&quot;Generate HTML documentation using a local LLM&quot;</span>)
    parser<span style="color: #666666">.</span>add_argument(<span style="color: #BA2121">&quot;source&quot;</span>, help<span style="color: #666666">=</span><span style="color: #BA2121">&quot;Path to the source directory&quot;</span>)
    parser<span style="color: #666666">.</span>add_argument(<span style="color: #BA2121">&quot;--output&quot;</span>, required<span style="color: #666666">=</span><span style="color: #008000; font-weight: bold">True</span>, help<span style="color: #666666">=</span><span style="color: #BA2121">&quot;Destination directory for HTML output&quot;</span>)
    parser<span style="color: #666666">.</span>add_argument(
        <span style="color: #BA2121">&quot;--ignore&quot;</span>,
        action<span style="color: #666666">=</span><span style="color: #BA2121">&quot;append&quot;</span>,
        default<span style="color: #666666">=</span>[],
        help<span style="color: #666666">=</span><span style="color: #BA2121">&quot;Paths relative to source that should be ignored (repeatable)&quot;</span>,
    )
    parser<span style="color: #666666">.</span>add_argument(
        <span style="color: #BA2121">&quot;--llm-url&quot;</span>,
        default<span style="color: #666666">=</span><span style="color: #BA2121">&quot;http://localhost:1234&quot;</span>,
        help<span style="color: #666666">=</span><span style="color: #BA2121">&quot;Base URL of the LLM API&quot;</span>,
    )
    parser<span style="color: #666666">.</span>add_argument(
        <span style="color: #BA2121">&quot;--model&quot;</span>,
        default<span style="color: #666666">=</span><span style="color: #BA2121">&quot;local&quot;</span>,
        help<span style="color: #666666">=</span><span style="color: #BA2121">&quot;Model name to use when contacting the LLM&quot;</span>,
    )
    parser<span style="color: #666666">.</span>add_argument(
        <span style="color: #BA2121">&quot;--max-context-tokens&quot;</span>,
        <span style="color: #008000">type</span><span style="color: #666666">=</span><span style="color: #008000">int</span>,
        default<span style="color: #666666">=4096</span>,
        help<span style="color: #666666">=</span><span style="color: #BA2121">&quot;Maximum token context window for the LLM&quot;</span>,
    )
    args <span style="color: #666666">=</span> parser<span style="color: #666666">.</span>parse_args(argv)

    client <span style="color: #666666">=</span> LLMClient(base_url<span style="color: #666666">=</span>args<span style="color: #666666">.</span>llm_url, model<span style="color: #666666">=</span>args<span style="color: #666666">.</span>model)
    <span style="color: #008000; font-weight: bold">try</span>:
        client<span style="color: #666666">.</span>ping()
    <span style="color: #008000; font-weight: bold">except</span> <span style="color: #CB3F38; font-weight: bold">ConnectionError</span> <span style="color: #008000; font-weight: bold">as</span> exc:
        <span style="color: #008000">print</span>(<span style="color: #008000">str</span>(exc), file<span style="color: #666666">=</span>sys<span style="color: #666666">.</span>stderr)
        <span style="color: #008000; font-weight: bold">return</span> <span style="color: #666666">1</span>

    tokenizer <span style="color: #666666">=</span> _get_tokenizer()
    max_context_tokens <span style="color: #666666">=</span> args<span style="color: #666666">.</span>max_context_tokens
    chunk_token_budget <span style="color: #666666">=</span> <span style="color: #008000">int</span>(max_context_tokens <span style="color: #666666">*</span> <span style="color: #666666">0.75</span>)

    output_dir <span style="color: #666666">=</span> Path(args<span style="color: #666666">.</span>output)
    output_dir<span style="color: #666666">.</span>mkdir(parents<span style="color: #666666">=</span><span style="color: #008000; font-weight: bold">True</span>, exist_ok<span style="color: #666666">=</span><span style="color: #008000; font-weight: bold">True</span>)
    clean_output_dir(<span style="color: #008000">str</span>(output_dir))
    static_dir <span style="color: #666666">=</span> Path(<span style="color: #19177C">__file__</span>)<span style="color: #666666">.</span>parent <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;static&quot;</span>
    <span style="color: #3D7B7B; font-style: italic"># use absolute path so execution works from any current working directory</span>
    shutil<span style="color: #666666">.</span>copytree(static_dir, output_dir <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;static&quot;</span>, dirs_exist_ok<span style="color: #666666">=</span><span style="color: #008000; font-weight: bold">True</span>)

    cache <span style="color: #666666">=</span> ResponseCache(<span style="color: #008000">str</span>(output_dir <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;cache.json&quot;</span>))

    files <span style="color: #666666">=</span> scan_directory(args<span style="color: #666666">.</span>source, args<span style="color: #666666">.</span>ignore)
    modules <span style="color: #666666">=</span> []
    <span style="color: #008000; font-weight: bold">for</span> path <span style="color: #AA22FF; font-weight: bold">in</span> files:
        <span style="color: #008000; font-weight: bold">try</span>:
            text <span style="color: #666666">=</span> Path(path)<span style="color: #666666">.</span>read_text(encoding<span style="color: #666666">=</span><span style="color: #BA2121">&quot;utf-8&quot;</span>)
        <span style="color: #008000; font-weight: bold">except</span> <span style="color: #CB3F38; font-weight: bold">UnicodeDecodeError</span> <span style="color: #008000; font-weight: bold">as</span> exc:  <span style="color: #3D7B7B; font-style: italic"># skip files with invalid encoding</span>
            <span style="color: #008000">print</span>(<span style="color: #BA2121">f&quot;Skipping </span><span style="color: #A45A77; font-weight: bold">{</span>path<span style="color: #A45A77; font-weight: bold">}</span><span style="color: #BA2121">: </span><span style="color: #A45A77; font-weight: bold">{</span>exc<span style="color: #A45A77; font-weight: bold">}</span><span style="color: #BA2121">&quot;</span>, file<span style="color: #666666">=</span>sys<span style="color: #666666">.</span>stderr)
            <span style="color: #008000; font-weight: bold">continue</span>

        <span style="color: #008000; font-weight: bold">try</span>:
            <span style="color: #008000; font-weight: bold">if</span> path<span style="color: #666666">.</span>endswith(<span style="color: #BA2121">&quot;.py&quot;</span>):
                parsed <span style="color: #666666">=</span> parse_python_file(path)
                language <span style="color: #666666">=</span> <span style="color: #BA2121">&quot;python&quot;</span>
            <span style="color: #008000; font-weight: bold">else</span>:
                parsed <span style="color: #666666">=</span> parse_matlab_file(path)
                language <span style="color: #666666">=</span> <span style="color: #BA2121">&quot;matlab&quot;</span>
        <span style="color: #008000; font-weight: bold">except</span> <span style="color: #CB3F38; font-weight: bold">SyntaxError</span> <span style="color: #008000; font-weight: bold">as</span> exc:  <span style="color: #3D7B7B; font-style: italic"># malformed file should be ignored</span>
            <span style="color: #008000">print</span>(<span style="color: #BA2121">f&quot;Skipping </span><span style="color: #A45A77; font-weight: bold">{</span>path<span style="color: #A45A77; font-weight: bold">}</span><span style="color: #BA2121">: </span><span style="color: #A45A77; font-weight: bold">{</span>exc<span style="color: #A45A77; font-weight: bold">}</span><span style="color: #BA2121">&quot;</span>, file<span style="color: #666666">=</span>sys<span style="color: #666666">.</span>stderr)
            <span style="color: #008000; font-weight: bold">continue</span>

        key <span style="color: #666666">=</span> ResponseCache<span style="color: #666666">.</span>make_key(path, text)
        summary <span style="color: #666666">=</span> _summarize_module_chunked(
            client,
            cache,
            key,
            text,
            parsed,
            tokenizer,
            max_context_tokens,
            chunk_token_budget,
        )

        module <span style="color: #666666">=</span> {
            <span style="color: #BA2121">&quot;name&quot;</span>: Path(path)<span style="color: #666666">.</span>stem,
            <span style="color: #BA2121">&quot;language&quot;</span>: language,
            <span style="color: #BA2121">&quot;summary&quot;</span>: summary,
            <span style="color: #BA2121">&quot;filename&quot;</span>: Path(path)<span style="color: #666666">.</span>name,
            <span style="color: #BA2121">&quot;path&quot;</span>: path,
        }
        module<span style="color: #666666">.</span>update(parsed)

        <span style="color: #3D7B7B; font-style: italic"># summarize methods now so class summaries can reference them later</span>
        <span style="color: #008000; font-weight: bold">for</span> <span style="color: #008000">cls</span> <span style="color: #AA22FF; font-weight: bold">in</span> module<span style="color: #666666">.</span>get(<span style="color: #BA2121">&quot;classes&quot;</span>, []):
            _summarize_methods_recursive(<span style="color: #008000">cls</span>, path, client, cache)

        <span style="color: #3D7B7B; font-style: italic"># and for standalone functions (summarized later with project context)</span>
        <span style="color: #008000; font-weight: bold">for</span> func <span style="color: #AA22FF; font-weight: bold">in</span> module<span style="color: #666666">.</span>get(<span style="color: #BA2121">&quot;functions&quot;</span>, []):
            func[<span style="color: #BA2121">&quot;summary&quot;</span>] <span style="color: #666666">=</span> <span style="color: #BA2121">&quot;&quot;</span>

        modules<span style="color: #666666">.</span>append(module)

    page_links <span style="color: #666666">=</span> [(m[<span style="color: #BA2121">&quot;name&quot;</span>], <span style="color: #BA2121">f&quot;</span><span style="color: #A45A77; font-weight: bold">{</span>m[<span style="color: #BA2121">&#39;name&#39;</span>]<span style="color: #A45A77; font-weight: bold">}</span><span style="color: #BA2121">.html&quot;</span>) <span style="color: #008000; font-weight: bold">for</span> m <span style="color: #AA22FF; font-weight: bold">in</span> modules]

    project_lines <span style="color: #666666">=</span> [<span style="color: #BA2121">&quot;Project structure:&quot;</span>]
    <span style="color: #008000; font-weight: bold">for</span> mod <span style="color: #AA22FF; font-weight: bold">in</span> modules:
        project_lines<span style="color: #666666">.</span>append(<span style="color: #BA2121">f&quot;- </span><span style="color: #A45A77; font-weight: bold">{</span>mod[<span style="color: #BA2121">&#39;filename&#39;</span>]<span style="color: #A45A77; font-weight: bold">}</span><span style="color: #BA2121">&quot;</span>)
        classes <span style="color: #666666">=</span> mod<span style="color: #666666">.</span>get(<span style="color: #BA2121">&quot;classes&quot;</span>, []) <span style="color: #AA22FF; font-weight: bold">or</span> []
        functions <span style="color: #666666">=</span> mod<span style="color: #666666">.</span>get(<span style="color: #BA2121">&quot;functions&quot;</span>, []) <span style="color: #AA22FF; font-weight: bold">or</span> []

        <span style="color: #008000; font-weight: bold">if</span> <span style="color: #AA22FF; font-weight: bold">not</span> classes <span style="color: #AA22FF; font-weight: bold">and</span> <span style="color: #AA22FF; font-weight: bold">not</span> functions:
            <span style="color: #008000">print</span>(
                <span style="color: #BA2121">f&quot;Warning: </span><span style="color: #A45A77; font-weight: bold">{</span>mod[<span style="color: #BA2121">&#39;filename&#39;</span>]<span style="color: #A45A77; font-weight: bold">}</span><span style="color: #BA2121"> has no classes or functions&quot;</span>,
                file<span style="color: #666666">=</span>sys<span style="color: #666666">.</span>stderr,
            )
            project_lines<span style="color: #666666">.</span>append(<span style="color: #BA2121">&quot;  - (no classes or functions defined)&quot;</span>)
            <span style="color: #008000; font-weight: bold">continue</span>

        <span style="color: #008000; font-weight: bold">for</span> <span style="color: #008000">cls</span> <span style="color: #AA22FF; font-weight: bold">in</span> classes:
            project_lines<span style="color: #666666">.</span>append(<span style="color: #BA2121">f&quot;  - Class: </span><span style="color: #A45A77; font-weight: bold">{</span><span style="color: #008000">cls</span><span style="color: #666666">.</span>get(<span style="color: #BA2121">&#39;name&#39;</span>,<span style="color: #bbbbbb"> </span><span style="color: #BA2121">&#39;&#39;</span>)<span style="color: #A45A77; font-weight: bold">}</span><span style="color: #BA2121">&quot;</span>)
            method_names <span style="color: #666666">=</span> [m<span style="color: #666666">.</span>get(<span style="color: #BA2121">&quot;name&quot;</span>, <span style="color: #BA2121">&quot;&quot;</span>) <span style="color: #008000; font-weight: bold">for</span> m <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">cls</span><span style="color: #666666">.</span>get(<span style="color: #BA2121">&quot;methods&quot;</span>, [])]
            methods_text <span style="color: #666666">=</span> <span style="color: #BA2121">&quot;, &quot;</span><span style="color: #666666">.</span>join(method_names) <span style="color: #008000; font-weight: bold">if</span> method_names <span style="color: #008000; font-weight: bold">else</span> <span style="color: #BA2121">&quot;(none)&quot;</span>
            project_lines<span style="color: #666666">.</span>append(<span style="color: #BA2121">f&quot;    - Methods: </span><span style="color: #A45A77; font-weight: bold">{</span>methods_text<span style="color: #A45A77; font-weight: bold">}</span><span style="color: #BA2121">&quot;</span>)

        <span style="color: #008000; font-weight: bold">if</span> functions:
            func_names <span style="color: #666666">=</span> <span style="color: #BA2121">&quot;, &quot;</span><span style="color: #666666">.</span>join(f<span style="color: #666666">.</span>get(<span style="color: #BA2121">&quot;name&quot;</span>, <span style="color: #BA2121">&quot;&quot;</span>) <span style="color: #008000; font-weight: bold">for</span> f <span style="color: #AA22FF; font-weight: bold">in</span> functions)
            project_lines<span style="color: #666666">.</span>append(<span style="color: #BA2121">f&quot;  - Functions: </span><span style="color: #A45A77; font-weight: bold">{</span>func_names<span style="color: #A45A77; font-weight: bold">}</span><span style="color: #BA2121">&quot;</span>)

    project_outline <span style="color: #666666">=</span> <span style="color: #BA2121">&quot;</span><span style="color: #AA5D1F; font-weight: bold">\n</span><span style="color: #BA2121">&quot;</span><span style="color: #666666">.</span>join(project_lines)

    <span style="color: #3D7B7B; font-style: italic"># gather markdown documentation</span>
    md_files <span style="color: #666666">=</span> []
    readme <span style="color: #666666">=</span> Path(args<span style="color: #666666">.</span>source) <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;README.md&quot;</span>
    <span style="color: #008000; font-weight: bold">if</span> readme<span style="color: #666666">.</span>exists():
        md_files<span style="color: #666666">.</span>append(readme)
    <span style="color: #008000; font-weight: bold">for</span> p <span style="color: #AA22FF; font-weight: bold">in</span> Path(args<span style="color: #666666">.</span>source)<span style="color: #666666">.</span>rglob(<span style="color: #BA2121">&#39;*&#39;</span>):
        <span style="color: #008000; font-weight: bold">if</span> p<span style="color: #666666">.</span>is_dir() <span style="color: #AA22FF; font-weight: bold">and</span> p<span style="color: #666666">.</span>name<span style="color: #666666">.</span>lower() <span style="color: #666666">==</span> <span style="color: #BA2121">&#39;docs&#39;</span>:
            <span style="color: #008000; font-weight: bold">for</span> md <span style="color: #AA22FF; font-weight: bold">in</span> p<span style="color: #666666">.</span>rglob(<span style="color: #BA2121">&#39;*.md&#39;</span>):
                md_files<span style="color: #666666">.</span>append(md)

    md_parts <span style="color: #666666">=</span> []
    <span style="color: #008000; font-weight: bold">for</span> md_file <span style="color: #AA22FF; font-weight: bold">in</span> md_files:
        <span style="color: #008000; font-weight: bold">try</span>:
            md_parts<span style="color: #666666">.</span>append(md_file<span style="color: #666666">.</span>read_text(encoding<span style="color: #666666">=</span><span style="color: #BA2121">&#39;utf-8&#39;</span>))
        <span style="color: #008000; font-weight: bold">except</span> <span style="color: #CB3F38; font-weight: bold">Exception</span> <span style="color: #008000; font-weight: bold">as</span> exc:  <span style="color: #3D7B7B; font-style: italic"># pragma: no cover - filesystem edge case</span>
            <span style="color: #008000">print</span>(<span style="color: #BA2121">f&quot;Skipping </span><span style="color: #A45A77; font-weight: bold">{</span>md_file<span style="color: #A45A77; font-weight: bold">}</span><span style="color: #BA2121">: </span><span style="color: #A45A77; font-weight: bold">{</span>exc<span style="color: #A45A77; font-weight: bold">}</span><span style="color: #BA2121">&quot;</span>, file<span style="color: #666666">=</span>sys<span style="color: #666666">.</span>stderr)

    md_context <span style="color: #666666">=</span> <span style="color: #BA2121">&quot;</span><span style="color: #AA5D1F; font-weight: bold">\n</span><span style="color: #BA2121">&quot;</span><span style="color: #666666">.</span>join(md_parts)<span style="color: #666666">.</span>strip()
    readme_summary <span style="color: #666666">=</span> <span style="color: #BA2121">&quot;&quot;</span>
    <span style="color: #008000; font-weight: bold">if</span> md_context:
        readme_key <span style="color: #666666">=</span> ResponseCache<span style="color: #666666">.</span>make_key(<span style="color: #BA2121">&quot;README&quot;</span>, md_context)
        readme_summary <span style="color: #666666">=</span> _summarize_chunked(
            client,
            cache,
            readme_key,
            md_context,
            <span style="color: #BA2121">&quot;readme&quot;</span>,
            tokenizer,
            max_context_tokens,
            chunk_token_budget,
        )
        readme_summary <span style="color: #666666">=</span> sanitize_summary(readme_summary)

    project_key <span style="color: #666666">=</span> ResponseCache<span style="color: #666666">.</span>make_key(<span style="color: #BA2121">&quot;PROJECT&quot;</span>, project_outline)
    raw_summary <span style="color: #666666">=</span> _summarize_chunked(
        client,
        cache,
        project_key,
        project_outline,
        <span style="color: #BA2121">&quot;project&quot;</span>,
        tokenizer,
        max_context_tokens,
        chunk_token_budget,
    )
    project_summary <span style="color: #666666">=</span> sanitize_summary(raw_summary)
    <span style="color: #008000; font-weight: bold">if</span> readme_summary:
        project_summary <span style="color: #666666">=</span> <span style="color: #BA2121">f&quot;</span><span style="color: #A45A77; font-weight: bold">{</span>readme_summary<span style="color: #A45A77; font-weight: bold">}</span><span style="color: #AA5D1F; font-weight: bold">\n</span><span style="color: #A45A77; font-weight: bold">{</span>project_summary<span style="color: #A45A77; font-weight: bold">}</span><span style="color: #BA2121">&quot;</span><span style="color: #666666">.</span>strip()

    <span style="color: #3D7B7B; font-style: italic"># Now that the project summary is available, generate class and function summaries</span>
    <span style="color: #3D7B7B; font-style: italic"># and rewrite method/function docstrings with context.</span>
    <span style="color: #008000; font-weight: bold">for</span> module <span style="color: #AA22FF; font-weight: bold">in</span> modules:
        path <span style="color: #666666">=</span> module<span style="color: #666666">.</span>get(<span style="color: #BA2121">&quot;path&quot;</span>, <span style="color: #BA2121">&quot;&quot;</span>)
        <span style="color: #008000; font-weight: bold">for</span> <span style="color: #008000">cls</span> <span style="color: #AA22FF; font-weight: bold">in</span> module<span style="color: #666666">.</span>get(<span style="color: #BA2121">&quot;classes&quot;</span>, []):
            _summarize_class_recursive(
                <span style="color: #008000">cls</span>,
                path,
                project_summary,
                tokenizer,
                client,
                cache,
                max_context_tokens,
                chunk_token_budget,
            )
        <span style="color: #008000; font-weight: bold">for</span> func <span style="color: #AA22FF; font-weight: bold">in</span> module<span style="color: #666666">.</span>get(<span style="color: #BA2121">&quot;functions&quot;</span>, []):
            src <span style="color: #666666">=</span> func<span style="color: #666666">.</span>get(<span style="color: #BA2121">&quot;source&quot;</span>) <span style="color: #AA22FF; font-weight: bold">or</span> func<span style="color: #666666">.</span>get(<span style="color: #BA2121">&quot;signature&quot;</span>) <span style="color: #AA22FF; font-weight: bold">or</span> func<span style="color: #666666">.</span>get(<span style="color: #BA2121">&quot;name&quot;</span>, <span style="color: #BA2121">&quot;&quot;</span>)
            prompt <span style="color: #666666">=</span> _build_function_prompt(src, project_summary<span style="color: #666666">=</span>project_summary)
            func_key <span style="color: #666666">=</span> ResponseCache<span style="color: #666666">.</span>make_key(<span style="color: #BA2121">f&quot;</span><span style="color: #A45A77; font-weight: bold">{</span>path<span style="color: #A45A77; font-weight: bold">}</span><span style="color: #BA2121">:</span><span style="color: #A45A77; font-weight: bold">{</span>func<span style="color: #666666">.</span>get(<span style="color: #BA2121">&#39;name&#39;</span>)<span style="color: #A45A77; font-weight: bold">}</span><span style="color: #BA2121">&quot;</span>, prompt)
            func_summary <span style="color: #666666">=</span> _summarize(client, cache, func_key, prompt, <span style="color: #BA2121">&quot;docstring&quot;</span>)
            func[<span style="color: #BA2121">&quot;summary&quot;</span>] <span style="color: #666666">=</span> func_summary
            _rewrite_docstring(
                client,
                cache,
                path,
                func,
                project_summary<span style="color: #666666">=</span>project_summary,
            )

    module_summaries <span style="color: #666666">=</span> {m[<span style="color: #BA2121">&quot;name&quot;</span>]: m<span style="color: #666666">.</span>get(<span style="color: #BA2121">&quot;summary&quot;</span>, <span style="color: #BA2121">&quot;&quot;</span>) <span style="color: #008000; font-weight: bold">for</span> m <span style="color: #AA22FF; font-weight: bold">in</span> modules}
    write_index(<span style="color: #008000">str</span>(output_dir), project_summary, page_links, module_summaries)
    <span style="color: #008000; font-weight: bold">for</span> module <span style="color: #AA22FF; font-weight: bold">in</span> modules:
        write_module_page(<span style="color: #008000">str</span>(output_dir), module, page_links)

    <span style="color: #008000; font-weight: bold">return</span> <span style="color: #666666">0</span>
</code></pre>
    </div>
</body>
</html>
