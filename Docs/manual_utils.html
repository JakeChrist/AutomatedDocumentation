<!-- Generated by DocGen-LM -->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>manual_utils</title>
    <link rel="stylesheet" href="static/style.css">
</head>
<body>
    <button id="sidebar-toggle">Menu</button>
    <div class="sidebar">
        <h2>Navigation</h2>
        <ul><li><a href="index.html"><strong>üè† Project Overview</strong></a></li><li><a href="cache.html">cache</a></li><li><a href="chunk_utils.html">chunk_utils</a></li><li><a href="docgenerator.html">docgenerator</a></li><li><a href="explaincode.html">explaincode</a></li><li><a href="gui_wrapper.html">gui_wrapper</a></li><li><a href="html_writer.html">html_writer</a></li><li><a href="llm_client.html">llm_client</a></li><li><a href="manual_utils.html">manual_utils</a></li><li><a href="parser_cpp.html">parser_cpp</a></li><li><a href="parser_java.html">parser_java</a></li><li><a href="parser_matlab.html">parser_matlab</a></li><li><a href="parser_python.html">parser_python</a></li><li><a href="retrofit_sidebar.html">retrofit_sidebar</a></li><li><a href="reviewer.html">reviewer</a></li><li><a href="sanitize_docs.html">sanitize_docs</a></li><li><a href="scanner.html">scanner</a></li><li><a href="setup.html">setup</a></li><li><a href="summarize_utils.html">summarize_utils</a></li><li><details><summary>tests</summary><ul><li><a href="test_cache.html">test_cache</a></li><li><a href="test_chunk_utils.html">test_chunk_utils</a></li><li><a href="test_docgenerator.html">test_docgenerator</a></li><li><a href="test_docgenerator_subclasses.html">test_docgenerator_subclasses</a></li><li><a href="test_explaincode.html">test_explaincode</a></li><li><a href="test_html_writer.html">test_html_writer</a></li><li><a href="test_integration.html">test_integration</a></li><li><a href="test_llm_client.html">test_llm_client</a></li><li><a href="test_manual_utils.html">test_manual_utils</a></li><li><a href="test_parser_cpp.html">test_parser_cpp</a></li><li><a href="test_parser_java.html">test_parser_java</a></li><li><a href="test_parser_matlab.html">test_parser_matlab</a></li><li><a href="test_parser_python.html">test_parser_python</a></li><li><a href="test_resume_progress.html">test_resume_progress</a></li><li><a href="test_retrofit_sidebar.html">test_retrofit_sidebar</a></li><li><a href="test_reviewer.html">test_reviewer</a></li><li><a href="test_sanitize_docs.html">test_sanitize_docs</a></li><li><a href="test_scanner.html">test_scanner</a></li></ul></details></li></ul>
    </div>
    <div class="content">
        <h1>manual_utils</h1>
        <p>The module implements functions for splitting documentation into chunks, summarizing content using an LLM client, and merging summaries into a structured user manual. It includes logic for handling token and character limits, caching responses, and managing parallel processing of document parts. The module supports different chunking strategies‚Äîautomatic, manual, or none‚Äîand applies system prompts tailored to chunking or merging tasks. Placeholder tokens are identified and handled during the summarization process. The implementation uses a tokenizer for estimating token counts and includes error handling for network failures and chunking issues.</p>
<h2>Functions</h2>
<h3 id="_count_tokens">_count_tokens(text: str) -&gt; int</h3>
<p>The function `_count_tokens` takes a string input `text` and returns an integer representing the approximate number of tokens in that text. It uses a global `TOKENIZER` object to encode the text and then counts the length of the resulting encoded sequence.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">_count_tokens</span>(text: <span style="color: #008000">str</span>) <span style="color: #666666">-&gt;</span> <span style="color: #008000">int</span>:
<span style="color: #bbbbbb">    </span><span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;Return the approximate token count for ``text``.&quot;&quot;&quot;</span>
    <span style="color: #008000; font-weight: bold">return</span> <span style="color: #008000">len</span>(TOKENIZER<span style="color: #666666">.</span>encode(text))
</code></pre>
<h3 id="_split_text">_split_text(text: str, max_tokens: int=2000, max_chars: int=6000) -&gt; list[str]</h3>
<p>The function `_split_text` splits a given text into chunks based on token and character limits. It takes a string `text`, and optional parameters `max_tokens` (default 2000) and `max_chars` (default 6000). The text is first split into paragraphs using double newlines as delimiters. Each paragraph is evaluated for token and character count, and if it exceeds the limits, it is further chunked using `chunk_text`. Paragraphs are added to the current chunk until adding another would exceed either limit. When a limit is exceeded, the current chunk is finalized and added to the list of chunks, and a new chunk is started with the current paragraph. The function returns a list of text chunks that respect both token and character constraints.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">_split_text</span>(text: <span style="color: #008000">str</span>, max_tokens: <span style="color: #008000">int</span> <span style="color: #666666">=</span> <span style="color: #666666">2000</span>, max_chars: <span style="color: #008000">int</span> <span style="color: #666666">=</span> <span style="color: #666666">6000</span>) <span style="color: #666666">-&gt;</span> <span style="color: #008000">list</span>[<span style="color: #008000">str</span>]:
<span style="color: #bbbbbb">    </span><span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;Split ``text`` into chunks respecting ``max_tokens`` and ``max_chars``.&quot;&quot;&quot;</span>
    paragraphs <span style="color: #666666">=</span> re<span style="color: #666666">.</span>split(<span style="color: #BA2121">r&quot;\n{2,}&quot;</span>, text<span style="color: #666666">.</span>strip())
    chunks: <span style="color: #008000">list</span>[<span style="color: #008000">str</span>] <span style="color: #666666">=</span> []
    current: <span style="color: #008000">list</span>[<span style="color: #008000">str</span>] <span style="color: #666666">=</span> []
    token_count <span style="color: #666666">=</span> <span style="color: #666666">0</span>
    char_count <span style="color: #666666">=</span> <span style="color: #666666">0</span>
    sep_tokens <span style="color: #666666">=</span> <span style="color: #008000">max</span>(_count_tokens(<span style="color: #BA2121">&quot;</span><span style="color: #AA5D1F; font-weight: bold">\n\n</span><span style="color: #BA2121">&quot;</span>), <span style="color: #666666">1</span>)
    sep_chars <span style="color: #666666">=</span> <span style="color: #666666">2</span>
    <span style="color: #008000; font-weight: bold">for</span> para <span style="color: #AA22FF; font-weight: bold">in</span> paragraphs:
        para <span style="color: #666666">=</span> para<span style="color: #666666">.</span>strip()
        <span style="color: #008000; font-weight: bold">if</span> <span style="color: #AA22FF; font-weight: bold">not</span> para:
            <span style="color: #008000; font-weight: bold">continue</span>
        ptokens <span style="color: #666666">=</span> _count_tokens(para)
        pchars <span style="color: #666666">=</span> <span style="color: #008000">len</span>(para)
        <span style="color: #008000; font-weight: bold">if</span> ptokens <span style="color: #666666">&gt;</span> max_tokens <span style="color: #AA22FF; font-weight: bold">or</span> pchars <span style="color: #666666">&gt;</span> max_chars:
            <span style="color: #008000; font-weight: bold">if</span> current:
                chunks<span style="color: #666666">.</span>append(<span style="color: #BA2121">&quot;</span><span style="color: #AA5D1F; font-weight: bold">\n\n</span><span style="color: #BA2121">&quot;</span><span style="color: #666666">.</span>join(current)<span style="color: #666666">.</span>strip())
                current <span style="color: #666666">=</span> []
                token_count <span style="color: #666666">=</span> <span style="color: #666666">0</span>
                char_count <span style="color: #666666">=</span> <span style="color: #666666">0</span>
            <span style="color: #008000; font-weight: bold">for</span> piece <span style="color: #AA22FF; font-weight: bold">in</span> chunk_text(para, TOKENIZER, max_tokens):
                chunks<span style="color: #666666">.</span>append(piece<span style="color: #666666">.</span>strip())
            <span style="color: #008000; font-weight: bold">continue</span>
        extra_tokens <span style="color: #666666">=</span> ptokens <span style="color: #008000; font-weight: bold">if</span> <span style="color: #AA22FF; font-weight: bold">not</span> current <span style="color: #008000; font-weight: bold">else</span> ptokens <span style="color: #666666">+</span> sep_tokens
        extra_chars <span style="color: #666666">=</span> pchars <span style="color: #008000; font-weight: bold">if</span> <span style="color: #AA22FF; font-weight: bold">not</span> current <span style="color: #008000; font-weight: bold">else</span> pchars <span style="color: #666666">+</span> sep_chars
        <span style="color: #008000; font-weight: bold">if</span> token_count <span style="color: #666666">+</span> extra_tokens <span style="color: #666666">&gt;</span> max_tokens <span style="color: #AA22FF; font-weight: bold">or</span> char_count <span style="color: #666666">+</span> extra_chars <span style="color: #666666">&gt;</span> max_chars:
            <span style="color: #008000; font-weight: bold">if</span> current:
                chunks<span style="color: #666666">.</span>append(<span style="color: #BA2121">&quot;</span><span style="color: #AA5D1F; font-weight: bold">\n\n</span><span style="color: #BA2121">&quot;</span><span style="color: #666666">.</span>join(current)<span style="color: #666666">.</span>strip())
            current <span style="color: #666666">=</span> [para]
            token_count <span style="color: #666666">=</span> ptokens
            char_count <span style="color: #666666">=</span> pchars
        <span style="color: #008000; font-weight: bold">else</span>:
            current<span style="color: #666666">.</span>append(para)
            token_count <span style="color: #666666">+=</span> extra_tokens
            char_count <span style="color: #666666">+=</span> extra_chars
    <span style="color: #008000; font-weight: bold">if</span> current:
        chunks<span style="color: #666666">.</span>append(<span style="color: #BA2121">&quot;</span><span style="color: #AA5D1F; font-weight: bold">\n\n</span><span style="color: #BA2121">&quot;</span><span style="color: #666666">.</span>join(current)<span style="color: #666666">.</span>strip())
    <span style="color: #008000; font-weight: bold">return</span> chunks
</code></pre>
<h3 id="chunk_docs">chunk_docs(docs: list[str], token_limit: int=2000) -&gt; list[str]</h3>
<p>The function `chunk_docs` takes a list of strings (`docs`) and an optional integer parameter `token_limit` (defaulting to 2000) as inputs. It joins the non-empty strings from the input list with double newlines, then splits the resulting text into chunks of approximately `token_limit` tokens using the helper function `_split_text`. The maximum character limit for each chunk is set to three times the token limit. If the joined text is empty, it returns an empty list. Otherwise, it returns a list of chunked text strings.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">chunk_docs</span>(docs: <span style="color: #008000">list</span>[<span style="color: #008000">str</span>], token_limit: <span style="color: #008000">int</span> <span style="color: #666666">=</span> <span style="color: #666666">2000</span>) <span style="color: #666666">-&gt;</span> <span style="color: #008000">list</span>[<span style="color: #008000">str</span>]:
<span style="color: #bbbbbb">    </span><span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;Split ``docs`` into roughly ``token_limit`` sized chunks.&quot;&quot;&quot;</span>
    text <span style="color: #666666">=</span> <span style="color: #BA2121">&quot;</span><span style="color: #AA5D1F; font-weight: bold">\n\n</span><span style="color: #BA2121">&quot;</span><span style="color: #666666">.</span>join(d<span style="color: #666666">.</span>strip() <span style="color: #008000; font-weight: bold">for</span> d <span style="color: #AA22FF; font-weight: bold">in</span> docs <span style="color: #008000; font-weight: bold">if</span> d <span style="color: #AA22FF; font-weight: bold">and</span> d<span style="color: #666666">.</span>strip())
    <span style="color: #008000; font-weight: bold">if</span> <span style="color: #AA22FF; font-weight: bold">not</span> text:
        <span style="color: #008000; font-weight: bold">return</span> []
    <span style="color: #008000; font-weight: bold">return</span> _split_text(text, max_tokens<span style="color: #666666">=</span>token_limit, max_chars<span style="color: #666666">=</span>token_limit <span style="color: #666666">*</span> <span style="color: #666666">3</span>)
</code></pre>
<h3 id="find_placeholders">find_placeholders(text: str) -&gt; Set[str]</h3>
<p>The function `find_placeholders` takes a string input `text` and returns a set of placeholder tokens found within that text. These placeholders are defined as strings matching the pattern `[[TOKEN]]`, where `TOKEN` represents the content between the double square brackets. The function utilizes a regular expression object `PLACEHOLDER_RE` to identify all occurrences of this pattern in the input text and returns them as a set, ensuring uniqueness of the found placeholders.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">find_placeholders</span>(text: <span style="color: #008000">str</span>) <span style="color: #666666">-&gt;</span> Set[<span style="color: #008000">str</span>]:
<span style="color: #bbbbbb">    </span><span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;Return placeholder tokens of the form ``[[TOKEN]]`` found in ``text``.&quot;&quot;&quot;</span>
    <span style="color: #008000; font-weight: bold">return</span> <span style="color: #008000">set</span>(PLACEHOLDER_RE<span style="color: #666666">.</span>findall(text))
</code></pre>
<h3 id="_summarize_manual">_summarize_manual(client: LLMClient, cache: ResponseCache, text: str, chunking: str=&#x27;auto&#x27;, source: str=&#x27;combined&#x27;, post_chunk_hook: Callable[[list[str]], list[str]] | None=None) -&gt; str</h3>
<p>The function `_summarize_manual` generates a manual summary of input text using a specified chunking strategy. It supports &quot;manual&quot;, &quot;auto&quot;, and &quot;none&quot; chunking modes, and employs caching to avoid recomputation. The function splits text into chunks when necessary, processes each chunk with an LLM client, and merges results hierarchically if needed. It handles errors gracefully, logs debug and info messages, and sanitizes outputs to prevent token limit issues. If the input is within limits and chunking is not required, it summarizes the entire text in one call. The function also supports a post-processing hook for modifying chunked summaries before merging.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">_summarize_manual</span>(
    client: LLMClient,
    cache: ResponseCache,
    text: <span style="color: #008000">str</span>,
    chunking: <span style="color: #008000">str</span> <span style="color: #666666">=</span> <span style="color: #BA2121">&quot;auto&quot;</span>,
    source: <span style="color: #008000">str</span> <span style="color: #666666">=</span> <span style="color: #BA2121">&quot;combined&quot;</span>,
    post_chunk_hook: Callable[[<span style="color: #008000">list</span>[<span style="color: #008000">str</span>]], <span style="color: #008000">list</span>[<span style="color: #008000">str</span>]] <span style="color: #666666">|</span> <span style="color: #008000; font-weight: bold">None</span> <span style="color: #666666">=</span> <span style="color: #008000; font-weight: bold">None</span>,
) <span style="color: #666666">-&gt;</span> <span style="color: #008000">str</span>:
<span style="color: #bbbbbb">    </span><span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;Return a manual summary for ``text`` using ``chunking`` strategy.&quot;&quot;&quot;</span>
    <span style="color: #008000; font-weight: bold">if</span> <span style="color: #AA22FF; font-weight: bold">not</span> text:
        <span style="color: #008000; font-weight: bold">return</span> <span style="color: #BA2121">&quot;&quot;</span>

    <span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">explaincode</span> <span style="color: #008000; font-weight: bold">import</span> infer_sections  <span style="color: #3D7B7B; font-style: italic"># imported lazily to avoid circular dependency</span>

    within_limits <span style="color: #666666">=</span> _count_tokens(text) <span style="color: #666666">&lt;=</span> <span style="color: #666666">2000</span> <span style="color: #AA22FF; font-weight: bold">and</span> <span style="color: #008000">len</span>(text) <span style="color: #666666">&lt;=</span> <span style="color: #666666">6000</span>

    <span style="color: #008000; font-weight: bold">if</span> chunking <span style="color: #666666">==</span> <span style="color: #BA2121">&quot;manual&quot;</span> <span style="color: #AA22FF; font-weight: bold">or</span> (chunking <span style="color: #666666">==</span> <span style="color: #BA2121">&quot;auto&quot;</span> <span style="color: #AA22FF; font-weight: bold">and</span> <span style="color: #AA22FF; font-weight: bold">not</span> within_limits):
        <span style="color: #008000; font-weight: bold">try</span>:
            parts <span style="color: #666666">=</span> _split_text(text)
        <span style="color: #008000; font-weight: bold">except</span> <span style="color: #CB3F38; font-weight: bold">Exception</span> <span style="color: #008000; font-weight: bold">as</span> exc:  <span style="color: #3D7B7B; font-style: italic"># pragma: no cover - defensive</span>
            <span style="color: #008000">print</span>(<span style="color: #BA2121">f&quot;[WARN] Chunking failed: </span><span style="color: #A45A77; font-weight: bold">{</span>exc<span style="color: #A45A77; font-weight: bold">}</span><span style="color: #BA2121">&quot;</span>, file<span style="color: #666666">=</span>sys<span style="color: #666666">.</span>stderr)
            sections <span style="color: #666666">=</span> infer_sections(text)
            <span style="color: #008000; font-weight: bold">return</span> <span style="color: #BA2121">&quot;</span><span style="color: #AA5D1F; font-weight: bold">\n</span><span style="color: #BA2121">&quot;</span><span style="color: #666666">.</span>join(<span style="color: #BA2121">f&quot;</span><span style="color: #A45A77; font-weight: bold">{</span>k<span style="color: #A45A77; font-weight: bold">}</span><span style="color: #BA2121">: </span><span style="color: #A45A77; font-weight: bold">{</span>v<span style="color: #A45A77; font-weight: bold">}</span><span style="color: #BA2121">&quot;</span> <span style="color: #008000; font-weight: bold">for</span> k, v <span style="color: #AA22FF; font-weight: bold">in</span> sections<span style="color: #666666">.</span>items())

        total <span style="color: #666666">=</span> <span style="color: #008000">len</span>(parts)
        partials: <span style="color: #008000">dict</span>[<span style="color: #008000">int</span>, <span style="color: #008000">str</span>] <span style="color: #666666">=</span> {}
        work: <span style="color: #008000">list</span>[<span style="color: #008000">tuple</span>[<span style="color: #008000">int</span>, <span style="color: #008000">str</span>, <span style="color: #008000">str</span>]] <span style="color: #666666">=</span> []
        <span style="color: #008000; font-weight: bold">for</span> idx, part <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">enumerate</span>(parts, <span style="color: #666666">1</span>):
            logging<span style="color: #666666">.</span>debug(
                <span style="color: #BA2121">&quot;Chunk </span><span style="color: #A45A77; font-weight: bold">%s</span><span style="color: #BA2121">/</span><span style="color: #A45A77; font-weight: bold">%s</span><span style="color: #BA2121"> from </span><span style="color: #A45A77; font-weight: bold">%s</span><span style="color: #BA2121">: </span><span style="color: #A45A77; font-weight: bold">%s</span><span style="color: #BA2121"> tokens, </span><span style="color: #A45A77; font-weight: bold">%s</span><span style="color: #BA2121"> characters&quot;</span>,
                idx,
                total,
                source,
                _count_tokens(part),
                <span style="color: #008000">len</span>(part),
            )
            key <span style="color: #666666">=</span> ResponseCache<span style="color: #666666">.</span>make_key(<span style="color: #BA2121">f&quot;</span><span style="color: #A45A77; font-weight: bold">{</span>source<span style="color: #A45A77; font-weight: bold">}</span><span style="color: #BA2121">:chunk</span><span style="color: #A45A77; font-weight: bold">{</span>idx<span style="color: #A45A77; font-weight: bold">}</span><span style="color: #BA2121">&quot;</span>, part)
            cached <span style="color: #666666">=</span> cache<span style="color: #666666">.</span>get(key)
            <span style="color: #008000; font-weight: bold">if</span> cached <span style="color: #AA22FF; font-weight: bold">is</span> <span style="color: #AA22FF; font-weight: bold">not</span> <span style="color: #008000; font-weight: bold">None</span>:
                <span style="color: #3D7B7B; font-style: italic"># Cached responses may predate sanitization; clean them to</span>
                <span style="color: #3D7B7B; font-style: italic"># avoid reserved-token issues downstream.</span>
                cached <span style="color: #666666">=</span> sanitize_summary(cached)
                partials[idx] <span style="color: #666666">=</span> cached
                logging<span style="color: #666666">.</span>debug(
                    <span style="color: #BA2121">&quot;LLM response </span><span style="color: #A45A77; font-weight: bold">%s</span><span style="color: #BA2121">/</span><span style="color: #A45A77; font-weight: bold">%s</span><span style="color: #BA2121"> length: </span><span style="color: #A45A77; font-weight: bold">%s</span><span style="color: #BA2121"> characters&quot;</span>,
                    idx,
                    total,
                    <span style="color: #008000">len</span>(cached),
                )
            <span style="color: #008000; font-weight: bold">else</span>:
                work<span style="color: #666666">.</span>append((idx, part, key))

        <span style="color: #008000; font-weight: bold">if</span> work:
            <span style="color: #008000; font-weight: bold">with</span> ThreadPoolExecutor() <span style="color: #008000; font-weight: bold">as</span> executor:
                future_map <span style="color: #666666">=</span> {
                    executor<span style="color: #666666">.</span>submit(
                        client<span style="color: #666666">.</span>summarize,
                        part,
                        <span style="color: #BA2121">&quot;docstring&quot;</span>,
                        system_prompt<span style="color: #666666">=</span>CHUNK_SYSTEM_PROMPT,
                    ): (idx, key)
                    <span style="color: #008000; font-weight: bold">for</span> idx, part, key <span style="color: #AA22FF; font-weight: bold">in</span> work
                }
                <span style="color: #008000; font-weight: bold">for</span> future <span style="color: #AA22FF; font-weight: bold">in</span> as_completed(future_map):
                    idx, key <span style="color: #666666">=</span> future_map[future]
                    <span style="color: #008000; font-weight: bold">try</span>:
                        resp <span style="color: #666666">=</span> future<span style="color: #666666">.</span>result()
                    <span style="color: #008000; font-weight: bold">except</span> <span style="color: #CB3F38; font-weight: bold">Exception</span> <span style="color: #008000; font-weight: bold">as</span> exc:  <span style="color: #3D7B7B; font-style: italic"># pragma: no cover - network failure</span>
                        <span style="color: #008000">print</span>(
                            <span style="color: #BA2121">f&quot;[WARN] Summarization failed for chunk </span><span style="color: #A45A77; font-weight: bold">{</span>idx<span style="color: #A45A77; font-weight: bold">}</span><span style="color: #BA2121">/</span><span style="color: #A45A77; font-weight: bold">{</span>total<span style="color: #A45A77; font-weight: bold">}</span><span style="color: #BA2121">: </span><span style="color: #A45A77; font-weight: bold">{</span>exc<span style="color: #A45A77; font-weight: bold">}</span><span style="color: #BA2121">&quot;</span>,
                            file<span style="color: #666666">=</span>sys<span style="color: #666666">.</span>stderr,
                        )
                        <span style="color: #008000; font-weight: bold">continue</span>
                    cache<span style="color: #666666">.</span>set(key, resp)
                    logging<span style="color: #666666">.</span>debug(
                        <span style="color: #BA2121">&quot;LLM response </span><span style="color: #A45A77; font-weight: bold">%s</span><span style="color: #BA2121">/</span><span style="color: #A45A77; font-weight: bold">%s</span><span style="color: #BA2121"> length: </span><span style="color: #A45A77; font-weight: bold">%s</span><span style="color: #BA2121"> characters&quot;</span>,
                        idx,
                        total,
                        <span style="color: #008000">len</span>(resp),
                    )
                    partials[idx] <span style="color: #666666">=</span> resp

        <span style="color: #008000; font-weight: bold">if</span> <span style="color: #AA22FF; font-weight: bold">not</span> partials:
            sections <span style="color: #666666">=</span> infer_sections(text)
            <span style="color: #008000; font-weight: bold">return</span> <span style="color: #BA2121">&quot;</span><span style="color: #AA5D1F; font-weight: bold">\n</span><span style="color: #BA2121">&quot;</span><span style="color: #666666">.</span>join(<span style="color: #BA2121">f&quot;</span><span style="color: #A45A77; font-weight: bold">{</span>k<span style="color: #A45A77; font-weight: bold">}</span><span style="color: #BA2121">: </span><span style="color: #A45A77; font-weight: bold">{</span>v<span style="color: #A45A77; font-weight: bold">}</span><span style="color: #BA2121">&quot;</span> <span style="color: #008000; font-weight: bold">for</span> k, v <span style="color: #AA22FF; font-weight: bold">in</span> sections<span style="color: #666666">.</span>items())

        <span style="color: #008000; font-weight: bold">if</span> post_chunk_hook:
            <span style="color: #008000; font-weight: bold">try</span>:
                ordered <span style="color: #666666">=</span> [partials[i] <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">sorted</span>(partials)]
                ordered <span style="color: #666666">=</span> post_chunk_hook(ordered)
                partials <span style="color: #666666">=</span> {i <span style="color: #666666">+</span> <span style="color: #666666">1</span>: v <span style="color: #008000; font-weight: bold">for</span> i, v <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">enumerate</span>(ordered)}
            <span style="color: #008000; font-weight: bold">except</span> <span style="color: #CB3F38; font-weight: bold">Exception</span> <span style="color: #008000; font-weight: bold">as</span> exc:  <span style="color: #3D7B7B; font-style: italic"># pragma: no cover - defensive</span>
                logging<span style="color: #666666">.</span>debug(<span style="color: #BA2121">&quot;Chunk post-processing failed: </span><span style="color: #A45A77; font-weight: bold">%s</span><span style="color: #BA2121">&quot;</span>, exc)

        merge_input <span style="color: #666666">=</span> <span style="color: #BA2121">&quot;</span><span style="color: #AA5D1F; font-weight: bold">\n\n</span><span style="color: #BA2121">&quot;</span><span style="color: #666666">.</span>join(partials[i] <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">sorted</span>(partials))
        tokens <span style="color: #666666">=</span> _count_tokens(merge_input)
        chars <span style="color: #666666">=</span> <span style="color: #008000">len</span>(merge_input)
        iteration <span style="color: #666666">=</span> <span style="color: #666666">0</span>
        <span style="color: #008000; font-weight: bold">while</span> tokens <span style="color: #666666">&gt;</span> <span style="color: #666666">2000</span> <span style="color: #AA22FF; font-weight: bold">or</span> chars <span style="color: #666666">&gt;</span> <span style="color: #666666">6000</span>:
            iteration <span style="color: #666666">+=</span> <span style="color: #666666">1</span>
            logging<span style="color: #666666">.</span>info(
                <span style="color: #BA2121">&quot;Hierarchical merge pass </span><span style="color: #A45A77; font-weight: bold">%s</span><span style="color: #BA2121">: </span><span style="color: #A45A77; font-weight: bold">%s</span><span style="color: #BA2121"> tokens, </span><span style="color: #A45A77; font-weight: bold">%s</span><span style="color: #BA2121"> characters&quot;</span>,
                iteration,
                tokens,
                chars,
            )
            <span style="color: #008000; font-weight: bold">try</span>:
                sub_parts <span style="color: #666666">=</span> _split_text(merge_input)
            <span style="color: #008000; font-weight: bold">except</span> <span style="color: #CB3F38; font-weight: bold">Exception</span> <span style="color: #008000; font-weight: bold">as</span> exc:  <span style="color: #3D7B7B; font-style: italic"># pragma: no cover - defensive</span>
                <span style="color: #008000">print</span>(<span style="color: #BA2121">f&quot;[WARN] Hierarchical split failed: </span><span style="color: #A45A77; font-weight: bold">{</span>exc<span style="color: #A45A77; font-weight: bold">}</span><span style="color: #BA2121">&quot;</span>, file<span style="color: #666666">=</span>sys<span style="color: #666666">.</span>stderr)
                <span style="color: #008000; font-weight: bold">break</span>
            new_partials: <span style="color: #008000">list</span>[<span style="color: #008000">str</span>] <span style="color: #666666">=</span> []
            total <span style="color: #666666">=</span> <span style="color: #008000">len</span>(sub_parts)
            <span style="color: #008000; font-weight: bold">for</span> idx, piece <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">enumerate</span>(sub_parts, <span style="color: #666666">1</span>):
                logging<span style="color: #666666">.</span>debug(
                    <span style="color: #BA2121">&quot;Merge chunk </span><span style="color: #A45A77; font-weight: bold">%s</span><span style="color: #BA2121">/</span><span style="color: #A45A77; font-weight: bold">%s</span><span style="color: #BA2121">: </span><span style="color: #A45A77; font-weight: bold">%s</span><span style="color: #BA2121"> tokens, </span><span style="color: #A45A77; font-weight: bold">%s</span><span style="color: #BA2121"> characters&quot;</span>,
                    idx,
                    total,
                    _count_tokens(piece),
                    <span style="color: #008000">len</span>(piece),
                )
                key <span style="color: #666666">=</span> ResponseCache<span style="color: #666666">.</span>make_key(
                    <span style="color: #BA2121">f&quot;</span><span style="color: #A45A77; font-weight: bold">{</span>source<span style="color: #A45A77; font-weight: bold">}</span><span style="color: #BA2121">:merge</span><span style="color: #A45A77; font-weight: bold">{</span>iteration<span style="color: #A45A77; font-weight: bold">}</span><span style="color: #BA2121">:chunk</span><span style="color: #A45A77; font-weight: bold">{</span>idx<span style="color: #A45A77; font-weight: bold">}</span><span style="color: #BA2121">&quot;</span>, piece
                )
                cached <span style="color: #666666">=</span> cache<span style="color: #666666">.</span>get(key)
                <span style="color: #008000; font-weight: bold">if</span> cached <span style="color: #AA22FF; font-weight: bold">is</span> <span style="color: #AA22FF; font-weight: bold">not</span> <span style="color: #008000; font-weight: bold">None</span>:
                    resp <span style="color: #666666">=</span> sanitize_summary(cached)
                <span style="color: #008000; font-weight: bold">else</span>:
                    <span style="color: #008000; font-weight: bold">try</span>:
                        resp <span style="color: #666666">=</span> client<span style="color: #666666">.</span>summarize(
                            piece, <span style="color: #BA2121">&quot;docstring&quot;</span>, system_prompt<span style="color: #666666">=</span>MERGE_SYSTEM_PROMPT
                        )
                    <span style="color: #008000; font-weight: bold">except</span> <span style="color: #CB3F38; font-weight: bold">Exception</span> <span style="color: #008000; font-weight: bold">as</span> exc:  <span style="color: #3D7B7B; font-style: italic"># pragma: no cover - network failure</span>
                        <span style="color: #008000">print</span>(
                            <span style="color: #BA2121">f&quot;[WARN] Hierarchical summarization failed for chunk </span><span style="color: #A45A77; font-weight: bold">{</span>idx<span style="color: #A45A77; font-weight: bold">}</span><span style="color: #BA2121">/</span><span style="color: #A45A77; font-weight: bold">{</span>total<span style="color: #A45A77; font-weight: bold">}</span><span style="color: #BA2121">: </span><span style="color: #A45A77; font-weight: bold">{</span>exc<span style="color: #A45A77; font-weight: bold">}</span><span style="color: #BA2121">&quot;</span>,
                            file<span style="color: #666666">=</span>sys<span style="color: #666666">.</span>stderr,
                        )
                        <span style="color: #008000; font-weight: bold">continue</span>
                    cache<span style="color: #666666">.</span>set(key, resp)
                new_partials<span style="color: #666666">.</span>append(resp)
            <span style="color: #008000; font-weight: bold">if</span> <span style="color: #AA22FF; font-weight: bold">not</span> new_partials:
                <span style="color: #008000; font-weight: bold">break</span>
            merge_input <span style="color: #666666">=</span> <span style="color: #BA2121">&quot;</span><span style="color: #AA5D1F; font-weight: bold">\n\n</span><span style="color: #BA2121">&quot;</span><span style="color: #666666">.</span>join(new_partials)
            tokens <span style="color: #666666">=</span> _count_tokens(merge_input)
            chars <span style="color: #666666">=</span> <span style="color: #008000">len</span>(merge_input)
        key <span style="color: #666666">=</span> ResponseCache<span style="color: #666666">.</span>make_key(<span style="color: #BA2121">f&quot;</span><span style="color: #A45A77; font-weight: bold">{</span>source<span style="color: #A45A77; font-weight: bold">}</span><span style="color: #BA2121">:final&quot;</span>, merge_input)
        cached <span style="color: #666666">=</span> cache<span style="color: #666666">.</span>get(key)
        <span style="color: #008000; font-weight: bold">if</span> cached <span style="color: #AA22FF; font-weight: bold">is</span> <span style="color: #AA22FF; font-weight: bold">not</span> <span style="color: #008000; font-weight: bold">None</span>:
            final_resp <span style="color: #666666">=</span> sanitize_summary(cached)
        <span style="color: #008000; font-weight: bold">else</span>:
            <span style="color: #008000; font-weight: bold">try</span>:
                final_resp <span style="color: #666666">=</span> client<span style="color: #666666">.</span>summarize(
                    merge_input, <span style="color: #BA2121">&quot;docstring&quot;</span>, system_prompt<span style="color: #666666">=</span>MERGE_SYSTEM_PROMPT
                )
                cache<span style="color: #666666">.</span>set(key, final_resp)
            <span style="color: #008000; font-weight: bold">except</span> <span style="color: #CB3F38; font-weight: bold">Exception</span> <span style="color: #008000; font-weight: bold">as</span> exc:  <span style="color: #3D7B7B; font-style: italic"># pragma: no cover - network failure</span>
                <span style="color: #008000">print</span>(<span style="color: #BA2121">f&quot;[WARN] Merge failed: </span><span style="color: #A45A77; font-weight: bold">{</span>exc<span style="color: #A45A77; font-weight: bold">}</span><span style="color: #BA2121">&quot;</span>, file<span style="color: #666666">=</span>sys<span style="color: #666666">.</span>stderr)
                <span style="color: #008000; font-weight: bold">return</span> merge_input
        logging<span style="color: #666666">.</span>debug(<span style="color: #BA2121">&quot;Merged LLM response length: </span><span style="color: #A45A77; font-weight: bold">%s</span><span style="color: #BA2121"> characters&quot;</span>, <span style="color: #008000">len</span>(final_resp))
        <span style="color: #008000; font-weight: bold">return</span> sanitize_summary(final_resp)

    <span style="color: #008000; font-weight: bold">if</span> chunking <span style="color: #666666">==</span> <span style="color: #BA2121">&quot;none&quot;</span> <span style="color: #AA22FF; font-weight: bold">and</span> <span style="color: #AA22FF; font-weight: bold">not</span> within_limits:
        <span style="color: #008000">print</span>(
            <span style="color: #BA2121">&quot;[WARN] Content exceeds token or character limits; chunking disabled.&quot;</span>,
            file<span style="color: #666666">=</span>sys<span style="color: #666666">.</span>stderr,
        )
    key <span style="color: #666666">=</span> ResponseCache<span style="color: #666666">.</span>make_key(<span style="color: #BA2121">f&quot;</span><span style="color: #A45A77; font-weight: bold">{</span>source<span style="color: #A45A77; font-weight: bold">}</span><span style="color: #BA2121">:full&quot;</span>, text)
    cached <span style="color: #666666">=</span> cache<span style="color: #666666">.</span>get(key)
    <span style="color: #008000; font-weight: bold">if</span> cached <span style="color: #AA22FF; font-weight: bold">is</span> <span style="color: #AA22FF; font-weight: bold">not</span> <span style="color: #008000; font-weight: bold">None</span>:
        <span style="color: #008000; font-weight: bold">return</span> sanitize_summary(cached)
    resp <span style="color: #666666">=</span> client<span style="color: #666666">.</span>summarize(text, <span style="color: #BA2121">&quot;user_manual&quot;</span>, system_prompt<span style="color: #666666">=</span>MERGE_SYSTEM_PROMPT)
    cache<span style="color: #666666">.</span>set(key, resp)
    <span style="color: #008000; font-weight: bold">return</span> sanitize_summary(resp)
</code></pre>
    </div>
    <script src="static/toggle.js"></script>
</body>
</html>
