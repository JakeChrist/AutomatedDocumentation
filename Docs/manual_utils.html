<!-- Generated by DocGen-LM -->
<!DOCTYPE html>

<html lang="en">
<head>
<meta charset="utf-8"/><meta content="width=device-width, initial-scale=1" name="viewport"/>
<title>manual_utils</title>
<link href="static/style.css" rel="stylesheet"/>
</head>
<body><a class="skip-link" href="#main-content">Skip to main content</a><header class="topbar"><button aria-label="Toggle navigation menu" id="sidebar-toggle">Menu</button><span class="topbar-title">manual_utils</span></header>
<nav aria-label="Documentation navigation" class="sidebar">
<h2>Navigation</h2>
<ul><li><a href="index.html"><strong>üè† Project Overview</strong></a></li><li><a href="cache.html">cache</a></li><li><a href="chunk_utils.html">chunk_utils</a></li><li><a href="docgenerator.html">docgenerator</a></li><li><a href="explaincode.html">explaincode</a></li><li><a href="gui_wrapper.html">gui_wrapper</a></li><li><a href="html_writer.html">html_writer</a></li><li><a href="llm_client.html">llm_client</a></li><li><a href="manual_utils.html">manual_utils</a></li><li><a href="parser_cpp.html">parser_cpp</a></li><li><a href="parser_java.html">parser_java</a></li><li><a href="parser_matlab.html">parser_matlab</a></li><li><a href="parser_python.html">parser_python</a></li><li><a href="retrofit_sidebar.html">retrofit_sidebar</a></li><li><a href="reviewer.html">reviewer</a></li><li><a href="sanitize_docs.html">sanitize_docs</a></li><li><a href="scanner.html">scanner</a></li><li><a href="setup.html">setup</a></li><li><a href="summarize_utils.html">summarize_utils</a></li><li><details><summary>tests</summary><ul><li><a href="test_cache.html">test_cache</a></li><li><a href="test_chunk_utils.html">test_chunk_utils</a></li><li><a href="test_docgenerator.html">test_docgenerator</a></li><li><a href="test_docgenerator_subclasses.html">test_docgenerator_subclasses</a></li><li><a href="test_explaincode.html">test_explaincode</a></li><li><a href="test_html_writer.html">test_html_writer</a></li><li><a href="test_integration.html">test_integration</a></li><li><a href="test_llm_client.html">test_llm_client</a></li><li><a href="test_manual_utils.html">test_manual_utils</a></li><li><a href="test_parser_cpp.html">test_parser_cpp</a></li><li><a href="test_parser_java.html">test_parser_java</a></li><li><a href="test_parser_matlab.html">test_parser_matlab</a></li><li><a href="test_parser_python.html">test_parser_python</a></li><li><a href="test_resume_progress.html">test_resume_progress</a></li><li><a href="test_retrofit_sidebar.html">test_retrofit_sidebar</a></li><li><a href="test_reviewer.html">test_reviewer</a></li><li><a href="test_sanitize_docs.html">test_sanitize_docs</a></li><li><a href="test_scanner.html">test_scanner</a></li></ul></details></li></ul>
</nav>
<main class="content" id="main-content" role="main">
<h1>manual_utils</h1>
<p>The module implements functions for splitting documentation into chunks, summarizing those chunks using an LLM client, and merging the results into a structured user manual. It includes logic for handling token and character limits, caching responses, and managing parallel processing of chunks. The process supports automatic chunking based on limits, manual chunking, or no chunking, with fallback behaviors for errors or exceeding limits. Placeholder tokens are identified and handled during the merging phase. The module uses system prompts to guide the LLM in generating content focused on user-level instructions rather than implementation details.</p>
<h2>Functions</h2>
<h3 id="_count_tokens">_count_tokens(text: str) -&gt; int</h3>
<p>The function `_count_tokens` takes a string input `text` and returns an integer representing the approximate number of tokens in that text. It uses a global `TOKENIZER` object to encode the text and then calculates the length of the resulting token sequence.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">_count_tokens</span>(text: <span style="color: #008000">str</span>) <span style="color: #666666">-&gt;</span> <span style="color: #008000">int</span>:
<span style="color: #bbbbbb">    </span><span style="color: #BA2121; font-style: italic">"""Return the approximate token count for ``text``."""</span>
    <span style="color: #008000; font-weight: bold">return</span> <span style="color: #008000">len</span>(TOKENIZER<span style="color: #666666">.</span>encode(text))
</code></pre>
<h3 id="_split_text">_split_text(text: str, max_tokens: int=2000, max_chars: int=6000) -&gt; list[str]</h3>
<p>The function `_split_text` splits a given text into chunks based on token and character limits. It takes a string `text`, and optional parameters `max_tokens` (default 2000) and `max_chars` (default 6000). The text is split into paragraphs using double newlines as separators. Each paragraph is evaluated for token and character count, and if it exceeds the limits, it is further chunked using `chunk_text`. Paragraphs are added to chunks while respecting the maximum token and character constraints. If a paragraph alone exceeds the limits, it is directly split into smaller pieces. The function returns a list of text chunks that respect both the token and character limits.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">_split_text</span>(text: <span style="color: #008000">str</span>, max_tokens: <span style="color: #008000">int</span> <span style="color: #666666">=</span> <span style="color: #666666">2000</span>, max_chars: <span style="color: #008000">int</span> <span style="color: #666666">=</span> <span style="color: #666666">6000</span>) <span style="color: #666666">-&gt;</span> <span style="color: #008000">list</span>[<span style="color: #008000">str</span>]:
<span style="color: #bbbbbb">    </span><span style="color: #BA2121; font-style: italic">"""Split ``text`` into chunks respecting ``max_tokens`` and ``max_chars``."""</span>
    paragraphs <span style="color: #666666">=</span> re<span style="color: #666666">.</span>split(<span style="color: #BA2121">r"\n{2,}"</span>, text<span style="color: #666666">.</span>strip())
    chunks: <span style="color: #008000">list</span>[<span style="color: #008000">str</span>] <span style="color: #666666">=</span> []
    current: <span style="color: #008000">list</span>[<span style="color: #008000">str</span>] <span style="color: #666666">=</span> []
    token_count <span style="color: #666666">=</span> <span style="color: #666666">0</span>
    char_count <span style="color: #666666">=</span> <span style="color: #666666">0</span>
    sep_tokens <span style="color: #666666">=</span> <span style="color: #008000">max</span>(_count_tokens(<span style="color: #BA2121">"</span><span style="color: #AA5D1F; font-weight: bold">\n\n</span><span style="color: #BA2121">"</span>), <span style="color: #666666">1</span>)
    sep_chars <span style="color: #666666">=</span> <span style="color: #666666">2</span>
    <span style="color: #008000; font-weight: bold">for</span> para <span style="color: #AA22FF; font-weight: bold">in</span> paragraphs:
        para <span style="color: #666666">=</span> para<span style="color: #666666">.</span>strip()
        <span style="color: #008000; font-weight: bold">if</span> <span style="color: #AA22FF; font-weight: bold">not</span> para:
            <span style="color: #008000; font-weight: bold">continue</span>
        ptokens <span style="color: #666666">=</span> _count_tokens(para)
        pchars <span style="color: #666666">=</span> <span style="color: #008000">len</span>(para)
        <span style="color: #008000; font-weight: bold">if</span> ptokens <span style="color: #666666">&gt;</span> max_tokens <span style="color: #AA22FF; font-weight: bold">or</span> pchars <span style="color: #666666">&gt;</span> max_chars:
            <span style="color: #008000; font-weight: bold">if</span> current:
                chunks<span style="color: #666666">.</span>append(<span style="color: #BA2121">"</span><span style="color: #AA5D1F; font-weight: bold">\n\n</span><span style="color: #BA2121">"</span><span style="color: #666666">.</span>join(current)<span style="color: #666666">.</span>strip())
                current <span style="color: #666666">=</span> []
                token_count <span style="color: #666666">=</span> <span style="color: #666666">0</span>
                char_count <span style="color: #666666">=</span> <span style="color: #666666">0</span>
            <span style="color: #008000; font-weight: bold">for</span> piece <span style="color: #AA22FF; font-weight: bold">in</span> chunk_text(para, TOKENIZER, max_tokens):
                chunks<span style="color: #666666">.</span>append(piece<span style="color: #666666">.</span>strip())
            <span style="color: #008000; font-weight: bold">continue</span>
        extra_tokens <span style="color: #666666">=</span> ptokens <span style="color: #008000; font-weight: bold">if</span> <span style="color: #AA22FF; font-weight: bold">not</span> current <span style="color: #008000; font-weight: bold">else</span> ptokens <span style="color: #666666">+</span> sep_tokens
        extra_chars <span style="color: #666666">=</span> pchars <span style="color: #008000; font-weight: bold">if</span> <span style="color: #AA22FF; font-weight: bold">not</span> current <span style="color: #008000; font-weight: bold">else</span> pchars <span style="color: #666666">+</span> sep_chars
        <span style="color: #008000; font-weight: bold">if</span> token_count <span style="color: #666666">+</span> extra_tokens <span style="color: #666666">&gt;</span> max_tokens <span style="color: #AA22FF; font-weight: bold">or</span> char_count <span style="color: #666666">+</span> extra_chars <span style="color: #666666">&gt;</span> max_chars:
            <span style="color: #008000; font-weight: bold">if</span> current:
                chunks<span style="color: #666666">.</span>append(<span style="color: #BA2121">"</span><span style="color: #AA5D1F; font-weight: bold">\n\n</span><span style="color: #BA2121">"</span><span style="color: #666666">.</span>join(current)<span style="color: #666666">.</span>strip())
            current <span style="color: #666666">=</span> [para]
            token_count <span style="color: #666666">=</span> ptokens
            char_count <span style="color: #666666">=</span> pchars
        <span style="color: #008000; font-weight: bold">else</span>:
            current<span style="color: #666666">.</span>append(para)
            token_count <span style="color: #666666">+=</span> extra_tokens
            char_count <span style="color: #666666">+=</span> extra_chars
    <span style="color: #008000; font-weight: bold">if</span> current:
        chunks<span style="color: #666666">.</span>append(<span style="color: #BA2121">"</span><span style="color: #AA5D1F; font-weight: bold">\n\n</span><span style="color: #BA2121">"</span><span style="color: #666666">.</span>join(current)<span style="color: #666666">.</span>strip())
    <span style="color: #008000; font-weight: bold">return</span> chunks
</code></pre>
<h3 id="chunk_docs">chunk_docs(docs: list[str], token_limit: int=2000) -&gt; list[str]</h3>
<p>The function `chunk_docs` takes a list of strings (`docs`) and splits them into chunks of approximately `token_limit` tokens. It first joins the input strings with double newlines, filters out empty or whitespace-only strings, and then uses `_split_text` to divide the resulting text into segments that do not exceed the specified token limit. If the input is empty, it returns an empty list.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">chunk_docs</span>(docs: <span style="color: #008000">list</span>[<span style="color: #008000">str</span>], token_limit: <span style="color: #008000">int</span> <span style="color: #666666">=</span> <span style="color: #666666">2000</span>) <span style="color: #666666">-&gt;</span> <span style="color: #008000">list</span>[<span style="color: #008000">str</span>]:
<span style="color: #bbbbbb">    </span><span style="color: #BA2121; font-style: italic">"""Split ``docs`` into roughly ``token_limit`` sized chunks."""</span>
    text <span style="color: #666666">=</span> <span style="color: #BA2121">"</span><span style="color: #AA5D1F; font-weight: bold">\n\n</span><span style="color: #BA2121">"</span><span style="color: #666666">.</span>join(d<span style="color: #666666">.</span>strip() <span style="color: #008000; font-weight: bold">for</span> d <span style="color: #AA22FF; font-weight: bold">in</span> docs <span style="color: #008000; font-weight: bold">if</span> d <span style="color: #AA22FF; font-weight: bold">and</span> d<span style="color: #666666">.</span>strip())
    <span style="color: #008000; font-weight: bold">if</span> <span style="color: #AA22FF; font-weight: bold">not</span> text:
        <span style="color: #008000; font-weight: bold">return</span> []
    <span style="color: #008000; font-weight: bold">return</span> _split_text(text, max_tokens<span style="color: #666666">=</span>token_limit, max_chars<span style="color: #666666">=</span>token_limit <span style="color: #666666">*</span> <span style="color: #666666">3</span>)
</code></pre>
<h3 id="find_placeholders">find_placeholders(text: str) -&gt; Set[str]</h3>
<p>The function `find_placeholders` identifies and returns all unique placeholder tokens of the form `[[TOKEN]]` present in the input string `text`. It uses a regular expression pattern `PLACEHOLDER_RE` to locate these placeholders and returns them as a set, ensuring each token is listed only once regardless of how many times it appears in the text.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">find_placeholders</span>(text: <span style="color: #008000">str</span>) <span style="color: #666666">-&gt;</span> Set[<span style="color: #008000">str</span>]:
<span style="color: #bbbbbb">    </span><span style="color: #BA2121; font-style: italic">"""Return placeholder tokens of the form ``[[TOKEN]]`` found in ``text``."""</span>
    <span style="color: #008000; font-weight: bold">return</span> <span style="color: #008000">set</span>(PLACEHOLDER_RE<span style="color: #666666">.</span>findall(text))
</code></pre>
<h3 id="_summarize_manual">_summarize_manual(client: LLMClient, cache: ResponseCache, text: str, chunking: str='auto', source: str='combined', post_chunk_hook: Callable[[list[str]], list[str]] | None=None) -&gt; str</h3>
<p>The function `_summarize_manual` generates a manual summary of input text using a specified chunking strategy. It accepts an LLM client, a response cache, the input text, and optional parameters for chunking behavior, source identification, and a post-processing hook.

If the input text is empty, it returns an empty string. It determines whether to use manual or automatic chunking based on token and character limits. For chunked processing, it splits the text into parts, checks the cache for previously generated responses, and processes uncached chunks using a thread pool. Each chunk is summarized with a system prompt, and results are cached.

After processing all chunks, if a post-processing hook is provided, it applies the hook to reorder or modify the partial summaries. It then merges the partial summaries iteratively until the combined content fits within token and character limits. Final summarization is performed on the merged content using another system prompt, and the result is cached and returned.

If chunking is disabled (`chunking="none"`) and the input exceeds limits, a warning is printed. Otherwise, it summarizes the full text directly with a specified system prompt and caches the result. The function includes error handling for chunking failures, summarization errors, and post-processing issues, logging</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">_summarize_manual</span>(
    client: LLMClient,
    cache: ResponseCache,
    text: <span style="color: #008000">str</span>,
    chunking: <span style="color: #008000">str</span> <span style="color: #666666">=</span> <span style="color: #BA2121">"auto"</span>,
    source: <span style="color: #008000">str</span> <span style="color: #666666">=</span> <span style="color: #BA2121">"combined"</span>,
    post_chunk_hook: Callable[[<span style="color: #008000">list</span>[<span style="color: #008000">str</span>]], <span style="color: #008000">list</span>[<span style="color: #008000">str</span>]] <span style="color: #666666">|</span> <span style="color: #008000; font-weight: bold">None</span> <span style="color: #666666">=</span> <span style="color: #008000; font-weight: bold">None</span>,
) <span style="color: #666666">-&gt;</span> <span style="color: #008000">str</span>:
<span style="color: #bbbbbb">    </span><span style="color: #BA2121; font-style: italic">"""Return a manual summary for ``text`` using ``chunking`` strategy."""</span>
    <span style="color: #008000; font-weight: bold">if</span> <span style="color: #AA22FF; font-weight: bold">not</span> text:
        <span style="color: #008000; font-weight: bold">return</span> <span style="color: #BA2121">""</span>

    <span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">explaincode</span> <span style="color: #008000; font-weight: bold">import</span> infer_sections  <span style="color: #3D7B7B; font-style: italic"># imported lazily to avoid circular dependency</span>

    within_limits <span style="color: #666666">=</span> _count_tokens(text) <span style="color: #666666">&lt;=</span> <span style="color: #666666">2000</span> <span style="color: #AA22FF; font-weight: bold">and</span> <span style="color: #008000">len</span>(text) <span style="color: #666666">&lt;=</span> <span style="color: #666666">6000</span>

    <span style="color: #008000; font-weight: bold">if</span> chunking <span style="color: #666666">==</span> <span style="color: #BA2121">"manual"</span> <span style="color: #AA22FF; font-weight: bold">or</span> (chunking <span style="color: #666666">==</span> <span style="color: #BA2121">"auto"</span> <span style="color: #AA22FF; font-weight: bold">and</span> <span style="color: #AA22FF; font-weight: bold">not</span> within_limits):
        <span style="color: #008000; font-weight: bold">try</span>:
            parts <span style="color: #666666">=</span> _split_text(text)
        <span style="color: #008000; font-weight: bold">except</span> <span style="color: #CB3F38; font-weight: bold">Exception</span> <span style="color: #008000; font-weight: bold">as</span> exc:  <span style="color: #3D7B7B; font-style: italic"># pragma: no cover - defensive</span>
            <span style="color: #008000">print</span>(<span style="color: #BA2121">f"[WARN] Chunking failed: </span><span style="color: #A45A77; font-weight: bold">{</span>exc<span style="color: #A45A77; font-weight: bold">}</span><span style="color: #BA2121">"</span>, file<span style="color: #666666">=</span>sys<span style="color: #666666">.</span>stderr)
            sections <span style="color: #666666">=</span> infer_sections(text)
            <span style="color: #008000; font-weight: bold">return</span> <span style="color: #BA2121">"</span><span style="color: #AA5D1F; font-weight: bold">\n</span><span style="color: #BA2121">"</span><span style="color: #666666">.</span>join(<span style="color: #BA2121">f"</span><span style="color: #A45A77; font-weight: bold">{</span>k<span style="color: #A45A77; font-weight: bold">}</span><span style="color: #BA2121">: </span><span style="color: #A45A77; font-weight: bold">{</span>v<span style="color: #A45A77; font-weight: bold">}</span><span style="color: #BA2121">"</span> <span style="color: #008000; font-weight: bold">for</span> k, v <span style="color: #AA22FF; font-weight: bold">in</span> sections<span style="color: #666666">.</span>items())

        total <span style="color: #666666">=</span> <span style="color: #008000">len</span>(parts)
        partials: <span style="color: #008000">dict</span>[<span style="color: #008000">int</span>, <span style="color: #008000">str</span>] <span style="color: #666666">=</span> {}
        work: <span style="color: #008000">list</span>[<span style="color: #008000">tuple</span>[<span style="color: #008000">int</span>, <span style="color: #008000">str</span>, <span style="color: #008000">str</span>]] <span style="color: #666666">=</span> []
        <span style="color: #008000; font-weight: bold">for</span> idx, part <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">enumerate</span>(parts, <span style="color: #666666">1</span>):
            logging<span style="color: #666666">.</span>debug(
                <span style="color: #BA2121">"Chunk </span><span style="color: #A45A77; font-weight: bold">%s</span><span style="color: #BA2121">/</span><span style="color: #A45A77; font-weight: bold">%s</span><span style="color: #BA2121"> from </span><span style="color: #A45A77; font-weight: bold">%s</span><span style="color: #BA2121">: </span><span style="color: #A45A77; font-weight: bold">%s</span><span style="color: #BA2121"> tokens, </span><span style="color: #A45A77; font-weight: bold">%s</span><span style="color: #BA2121"> characters"</span>,
                idx,
                total,
                source,
                _count_tokens(part),
                <span style="color: #008000">len</span>(part),
            )
            key <span style="color: #666666">=</span> ResponseCache<span style="color: #666666">.</span>make_key(<span style="color: #BA2121">f"</span><span style="color: #A45A77; font-weight: bold">{</span>source<span style="color: #A45A77; font-weight: bold">}</span><span style="color: #BA2121">:chunk</span><span style="color: #A45A77; font-weight: bold">{</span>idx<span style="color: #A45A77; font-weight: bold">}</span><span style="color: #BA2121">"</span>, part)
            cached <span style="color: #666666">=</span> cache<span style="color: #666666">.</span>get(key)
            <span style="color: #008000; font-weight: bold">if</span> cached <span style="color: #AA22FF; font-weight: bold">is</span> <span style="color: #AA22FF; font-weight: bold">not</span> <span style="color: #008000; font-weight: bold">None</span>:
                <span style="color: #3D7B7B; font-style: italic"># Cached responses may predate sanitization; clean them to</span>
                <span style="color: #3D7B7B; font-style: italic"># avoid reserved-token issues downstream.</span>
                cached <span style="color: #666666">=</span> sanitize_summary(cached)
                partials[idx] <span style="color: #666666">=</span> cached
                logging<span style="color: #666666">.</span>debug(
                    <span style="color: #BA2121">"LLM response </span><span style="color: #A45A77; font-weight: bold">%s</span><span style="color: #BA2121">/</span><span style="color: #A45A77; font-weight: bold">%s</span><span style="color: #BA2121"> length: </span><span style="color: #A45A77; font-weight: bold">%s</span><span style="color: #BA2121"> characters"</span>,
                    idx,
                    total,
                    <span style="color: #008000">len</span>(cached),
                )
            <span style="color: #008000; font-weight: bold">else</span>:
                work<span style="color: #666666">.</span>append((idx, part, key))

        <span style="color: #008000; font-weight: bold">if</span> work:
            <span style="color: #008000; font-weight: bold">with</span> ThreadPoolExecutor() <span style="color: #008000; font-weight: bold">as</span> executor:
                future_map <span style="color: #666666">=</span> {
                    executor<span style="color: #666666">.</span>submit(
                        client<span style="color: #666666">.</span>summarize,
                        part,
                        <span style="color: #BA2121">"docstring"</span>,
                        system_prompt<span style="color: #666666">=</span>CHUNK_SYSTEM_PROMPT,
                    ): (idx, key)
                    <span style="color: #008000; font-weight: bold">for</span> idx, part, key <span style="color: #AA22FF; font-weight: bold">in</span> work
                }
                <span style="color: #008000; font-weight: bold">for</span> future <span style="color: #AA22FF; font-weight: bold">in</span> as_completed(future_map):
                    idx, key <span style="color: #666666">=</span> future_map[future]
                    <span style="color: #008000; font-weight: bold">try</span>:
                        resp <span style="color: #666666">=</span> future<span style="color: #666666">.</span>result()
                    <span style="color: #008000; font-weight: bold">except</span> <span style="color: #CB3F38; font-weight: bold">Exception</span> <span style="color: #008000; font-weight: bold">as</span> exc:  <span style="color: #3D7B7B; font-style: italic"># pragma: no cover - network failure</span>
                        <span style="color: #008000">print</span>(
                            <span style="color: #BA2121">f"[WARN] Summarization failed for chunk </span><span style="color: #A45A77; font-weight: bold">{</span>idx<span style="color: #A45A77; font-weight: bold">}</span><span style="color: #BA2121">/</span><span style="color: #A45A77; font-weight: bold">{</span>total<span style="color: #A45A77; font-weight: bold">}</span><span style="color: #BA2121">: </span><span style="color: #A45A77; font-weight: bold">{</span>exc<span style="color: #A45A77; font-weight: bold">}</span><span style="color: #BA2121">"</span>,
                            file<span style="color: #666666">=</span>sys<span style="color: #666666">.</span>stderr,
                        )
                        <span style="color: #008000; font-weight: bold">continue</span>
                    cache<span style="color: #666666">.</span>set(key, resp)
                    logging<span style="color: #666666">.</span>debug(
                        <span style="color: #BA2121">"LLM response </span><span style="color: #A45A77; font-weight: bold">%s</span><span style="color: #BA2121">/</span><span style="color: #A45A77; font-weight: bold">%s</span><span style="color: #BA2121"> length: </span><span style="color: #A45A77; font-weight: bold">%s</span><span style="color: #BA2121"> characters"</span>,
                        idx,
                        total,
                        <span style="color: #008000">len</span>(resp),
                    )
                    partials[idx] <span style="color: #666666">=</span> resp

        <span style="color: #008000; font-weight: bold">if</span> <span style="color: #AA22FF; font-weight: bold">not</span> partials:
            sections <span style="color: #666666">=</span> infer_sections(text)
            <span style="color: #008000; font-weight: bold">return</span> <span style="color: #BA2121">"</span><span style="color: #AA5D1F; font-weight: bold">\n</span><span style="color: #BA2121">"</span><span style="color: #666666">.</span>join(<span style="color: #BA2121">f"</span><span style="color: #A45A77; font-weight: bold">{</span>k<span style="color: #A45A77; font-weight: bold">}</span><span style="color: #BA2121">: </span><span style="color: #A45A77; font-weight: bold">{</span>v<span style="color: #A45A77; font-weight: bold">}</span><span style="color: #BA2121">"</span> <span style="color: #008000; font-weight: bold">for</span> k, v <span style="color: #AA22FF; font-weight: bold">in</span> sections<span style="color: #666666">.</span>items())

        <span style="color: #008000; font-weight: bold">if</span> post_chunk_hook:
            <span style="color: #008000; font-weight: bold">try</span>:
                ordered <span style="color: #666666">=</span> [partials[i] <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">sorted</span>(partials)]
                ordered <span style="color: #666666">=</span> post_chunk_hook(ordered)
                partials <span style="color: #666666">=</span> {i <span style="color: #666666">+</span> <span style="color: #666666">1</span>: v <span style="color: #008000; font-weight: bold">for</span> i, v <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">enumerate</span>(ordered)}
            <span style="color: #008000; font-weight: bold">except</span> <span style="color: #CB3F38; font-weight: bold">Exception</span> <span style="color: #008000; font-weight: bold">as</span> exc:  <span style="color: #3D7B7B; font-style: italic"># pragma: no cover - defensive</span>
                logging<span style="color: #666666">.</span>debug(<span style="color: #BA2121">"Chunk post-processing failed: </span><span style="color: #A45A77; font-weight: bold">%s</span><span style="color: #BA2121">"</span>, exc)

        merge_input <span style="color: #666666">=</span> <span style="color: #BA2121">"</span><span style="color: #AA5D1F; font-weight: bold">\n\n</span><span style="color: #BA2121">"</span><span style="color: #666666">.</span>join(partials[i] <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">sorted</span>(partials))
        tokens <span style="color: #666666">=</span> _count_tokens(merge_input)
        chars <span style="color: #666666">=</span> <span style="color: #008000">len</span>(merge_input)
        iteration <span style="color: #666666">=</span> <span style="color: #666666">0</span>
        <span style="color: #008000; font-weight: bold">while</span> tokens <span style="color: #666666">&gt;</span> <span style="color: #666666">2000</span> <span style="color: #AA22FF; font-weight: bold">or</span> chars <span style="color: #666666">&gt;</span> <span style="color: #666666">6000</span>:
            iteration <span style="color: #666666">+=</span> <span style="color: #666666">1</span>
            logging<span style="color: #666666">.</span>info(
                <span style="color: #BA2121">"Hierarchical merge pass </span><span style="color: #A45A77; font-weight: bold">%s</span><span style="color: #BA2121">: </span><span style="color: #A45A77; font-weight: bold">%s</span><span style="color: #BA2121"> tokens, </span><span style="color: #A45A77; font-weight: bold">%s</span><span style="color: #BA2121"> characters"</span>,
                iteration,
                tokens,
                chars,
            )
            <span style="color: #008000; font-weight: bold">try</span>:
                sub_parts <span style="color: #666666">=</span> _split_text(merge_input)
            <span style="color: #008000; font-weight: bold">except</span> <span style="color: #CB3F38; font-weight: bold">Exception</span> <span style="color: #008000; font-weight: bold">as</span> exc:  <span style="color: #3D7B7B; font-style: italic"># pragma: no cover - defensive</span>
                <span style="color: #008000">print</span>(<span style="color: #BA2121">f"[WARN] Hierarchical split failed: </span><span style="color: #A45A77; font-weight: bold">{</span>exc<span style="color: #A45A77; font-weight: bold">}</span><span style="color: #BA2121">"</span>, file<span style="color: #666666">=</span>sys<span style="color: #666666">.</span>stderr)
                <span style="color: #008000; font-weight: bold">break</span>
            new_partials: <span style="color: #008000">list</span>[<span style="color: #008000">str</span>] <span style="color: #666666">=</span> []
            total <span style="color: #666666">=</span> <span style="color: #008000">len</span>(sub_parts)
            <span style="color: #008000; font-weight: bold">for</span> idx, piece <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">enumerate</span>(sub_parts, <span style="color: #666666">1</span>):
                logging<span style="color: #666666">.</span>debug(
                    <span style="color: #BA2121">"Merge chunk </span><span style="color: #A45A77; font-weight: bold">%s</span><span style="color: #BA2121">/</span><span style="color: #A45A77; font-weight: bold">%s</span><span style="color: #BA2121">: </span><span style="color: #A45A77; font-weight: bold">%s</span><span style="color: #BA2121"> tokens, </span><span style="color: #A45A77; font-weight: bold">%s</span><span style="color: #BA2121"> characters"</span>,
                    idx,
                    total,
                    _count_tokens(piece),
                    <span style="color: #008000">len</span>(piece),
                )
                key <span style="color: #666666">=</span> ResponseCache<span style="color: #666666">.</span>make_key(
                    <span style="color: #BA2121">f"</span><span style="color: #A45A77; font-weight: bold">{</span>source<span style="color: #A45A77; font-weight: bold">}</span><span style="color: #BA2121">:merge</span><span style="color: #A45A77; font-weight: bold">{</span>iteration<span style="color: #A45A77; font-weight: bold">}</span><span style="color: #BA2121">:chunk</span><span style="color: #A45A77; font-weight: bold">{</span>idx<span style="color: #A45A77; font-weight: bold">}</span><span style="color: #BA2121">"</span>, piece
                )
                cached <span style="color: #666666">=</span> cache<span style="color: #666666">.</span>get(key)
                <span style="color: #008000; font-weight: bold">if</span> cached <span style="color: #AA22FF; font-weight: bold">is</span> <span style="color: #AA22FF; font-weight: bold">not</span> <span style="color: #008000; font-weight: bold">None</span>:
                    resp <span style="color: #666666">=</span> sanitize_summary(cached)
                <span style="color: #008000; font-weight: bold">else</span>:
                    <span style="color: #008000; font-weight: bold">try</span>:
                        resp <span style="color: #666666">=</span> client<span style="color: #666666">.</span>summarize(
                            piece, <span style="color: #BA2121">"docstring"</span>, system_prompt<span style="color: #666666">=</span>MERGE_SYSTEM_PROMPT
                        )
                    <span style="color: #008000; font-weight: bold">except</span> <span style="color: #CB3F38; font-weight: bold">Exception</span> <span style="color: #008000; font-weight: bold">as</span> exc:  <span style="color: #3D7B7B; font-style: italic"># pragma: no cover - network failure</span>
                        <span style="color: #008000">print</span>(
                            <span style="color: #BA2121">f"[WARN] Hierarchical summarization failed for chunk </span><span style="color: #A45A77; font-weight: bold">{</span>idx<span style="color: #A45A77; font-weight: bold">}</span><span style="color: #BA2121">/</span><span style="color: #A45A77; font-weight: bold">{</span>total<span style="color: #A45A77; font-weight: bold">}</span><span style="color: #BA2121">: </span><span style="color: #A45A77; font-weight: bold">{</span>exc<span style="color: #A45A77; font-weight: bold">}</span><span style="color: #BA2121">"</span>,
                            file<span style="color: #666666">=</span>sys<span style="color: #666666">.</span>stderr,
                        )
                        <span style="color: #008000; font-weight: bold">continue</span>
                    cache<span style="color: #666666">.</span>set(key, resp)
                new_partials<span style="color: #666666">.</span>append(resp)
            <span style="color: #008000; font-weight: bold">if</span> <span style="color: #AA22FF; font-weight: bold">not</span> new_partials:
                <span style="color: #008000; font-weight: bold">break</span>
            merge_input <span style="color: #666666">=</span> <span style="color: #BA2121">"</span><span style="color: #AA5D1F; font-weight: bold">\n\n</span><span style="color: #BA2121">"</span><span style="color: #666666">.</span>join(new_partials)
            tokens <span style="color: #666666">=</span> _count_tokens(merge_input)
            chars <span style="color: #666666">=</span> <span style="color: #008000">len</span>(merge_input)
        key <span style="color: #666666">=</span> ResponseCache<span style="color: #666666">.</span>make_key(<span style="color: #BA2121">f"</span><span style="color: #A45A77; font-weight: bold">{</span>source<span style="color: #A45A77; font-weight: bold">}</span><span style="color: #BA2121">:final"</span>, merge_input)
        cached <span style="color: #666666">=</span> cache<span style="color: #666666">.</span>get(key)
        <span style="color: #008000; font-weight: bold">if</span> cached <span style="color: #AA22FF; font-weight: bold">is</span> <span style="color: #AA22FF; font-weight: bold">not</span> <span style="color: #008000; font-weight: bold">None</span>:
            final_resp <span style="color: #666666">=</span> sanitize_summary(cached)
        <span style="color: #008000; font-weight: bold">else</span>:
            <span style="color: #008000; font-weight: bold">try</span>:
                final_resp <span style="color: #666666">=</span> client<span style="color: #666666">.</span>summarize(
                    merge_input, <span style="color: #BA2121">"docstring"</span>, system_prompt<span style="color: #666666">=</span>MERGE_SYSTEM_PROMPT
                )
                cache<span style="color: #666666">.</span>set(key, final_resp)
            <span style="color: #008000; font-weight: bold">except</span> <span style="color: #CB3F38; font-weight: bold">Exception</span> <span style="color: #008000; font-weight: bold">as</span> exc:  <span style="color: #3D7B7B; font-style: italic"># pragma: no cover - network failure</span>
                <span style="color: #008000">print</span>(<span style="color: #BA2121">f"[WARN] Merge failed: </span><span style="color: #A45A77; font-weight: bold">{</span>exc<span style="color: #A45A77; font-weight: bold">}</span><span style="color: #BA2121">"</span>, file<span style="color: #666666">=</span>sys<span style="color: #666666">.</span>stderr)
                <span style="color: #008000; font-weight: bold">return</span> merge_input
        logging<span style="color: #666666">.</span>debug(<span style="color: #BA2121">"Merged LLM response length: </span><span style="color: #A45A77; font-weight: bold">%s</span><span style="color: #BA2121"> characters"</span>, <span style="color: #008000">len</span>(final_resp))
        <span style="color: #008000; font-weight: bold">return</span> sanitize_summary(final_resp)

    <span style="color: #008000; font-weight: bold">if</span> chunking <span style="color: #666666">==</span> <span style="color: #BA2121">"none"</span> <span style="color: #AA22FF; font-weight: bold">and</span> <span style="color: #AA22FF; font-weight: bold">not</span> within_limits:
        <span style="color: #008000">print</span>(
            <span style="color: #BA2121">"[WARN] Content exceeds token or character limits; chunking disabled."</span>,
            file<span style="color: #666666">=</span>sys<span style="color: #666666">.</span>stderr,
        )
    key <span style="color: #666666">=</span> ResponseCache<span style="color: #666666">.</span>make_key(<span style="color: #BA2121">f"</span><span style="color: #A45A77; font-weight: bold">{</span>source<span style="color: #A45A77; font-weight: bold">}</span><span style="color: #BA2121">:full"</span>, text)
    cached <span style="color: #666666">=</span> cache<span style="color: #666666">.</span>get(key)
    <span style="color: #008000; font-weight: bold">if</span> cached <span style="color: #AA22FF; font-weight: bold">is</span> <span style="color: #AA22FF; font-weight: bold">not</span> <span style="color: #008000; font-weight: bold">None</span>:
        <span style="color: #008000; font-weight: bold">return</span> sanitize_summary(cached)
    resp <span style="color: #666666">=</span> client<span style="color: #666666">.</span>summarize(text, <span style="color: #BA2121">"user_manual"</span>, system_prompt<span style="color: #666666">=</span>MERGE_SYSTEM_PROMPT)
    cache<span style="color: #666666">.</span>set(key, resp)
    <span style="color: #008000; font-weight: bold">return</span> sanitize_summary(resp)
</code></pre>
</main>
<footer aria-label="Page footer" class="page-footer"><p>Generated documentation</p></footer><script src="static/toggle.js"></script>
</body>
</html>
