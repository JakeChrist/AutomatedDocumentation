<!-- Generated by DocGen-LM -->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>manual_utils</title>
    <link rel="stylesheet" href="static/style.css">
</head>
<body>
    <button id="sidebar-toggle">Menu</button>
    <div class="sidebar">
        <h2>Navigation</h2>
        <ul>
        <li><a href="index.html"><strong>üè† Project Overview</strong></a></li>
<li><a href="cache.html">cache</a></li>
<li><a href="chunk_utils.html">chunk_utils</a></li>
<li><a href="docgenerator.html">docgenerator</a></li>
<li><a href="explaincode.html">explaincode</a></li>
<li><a href="gui_wrapper.html">gui_wrapper</a></li>
<li><a href="html_writer.html">html_writer</a></li>
<li><a href="llm_client.html">llm_client</a></li>
<li><a href="manual_utils.html">manual_utils</a></li>
<li><a href="parser_matlab.html">parser_matlab</a></li>
<li><a href="parser_python.html">parser_python</a></li>
<li><a href="reviewer.html">reviewer</a></li>
<li><a href="scanner.html">scanner</a></li>
<li><a href="setup.html">setup</a></li>
<li><a href="summarize_utils.html">summarize_utils</a></li>
<li><a href="test_cache.html">test_cache</a></li>
<li><a href="test_chunk_utils.html">test_chunk_utils</a></li>
<li><a href="test_docgenerator.html">test_docgenerator</a></li>
<li><a href="test_docgenerator_subclasses.html">test_docgenerator_subclasses</a></li>
<li><a href="test_explaincode.html">test_explaincode</a></li>
<li><a href="test_html_writer.html">test_html_writer</a></li>
<li><a href="test_integration.html">test_integration</a></li>
<li><a href="test_llm_client.html">test_llm_client</a></li>
<li><a href="test_manual_utils.html">test_manual_utils</a></li>
<li><a href="test_parser_matlab.html">test_parser_matlab</a></li>
<li><a href="test_parser_python.html">test_parser_python</a></li>
<li><a href="test_reviewer.html">test_reviewer</a></li>
<li><a href="test_scanner.html">test_scanner</a></li>
        </ul>
    </div>
    <div class="content">
        <h1>manual_utils</h1>
        <p>This module provides functions for splitting text into chunks and generating summaries using a language model. It includes:

- `_count_tokens`: Counts the number of tokens in a given text.
- `_split_text`: Splits a text into chunks based on token and character limits.
- `chunk_docs`: Splits multiple documents into roughly equal-sized chunks.
- `find_placeholders`: Finds placeholder tokens in a text.
- `_summarize_manual`: Generates a manual summary for a given text using a specified chunking strategy. It handles both automatic and manual chunking, caching responses to avoid redundant requests.</p>
<h2>Functions</h2>
<h3 id="_count_tokens">_count_tokens(text: str) -&gt; int</h3>
<p>This function `_count_tokens` takes a string `text` as input and returns an integer representing the approximate number of tokens in the text. It uses a tokenizer to encode the text, which converts it into a sequence of tokens, and then calculates the length of this sequence to determine the token count.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">_count_tokens</span>(text: <span style="color: #008000">str</span>) <span style="color: #666666">-&gt;</span> <span style="color: #008000">int</span>:
<span style="color: #bbbbbb">    </span><span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;Return the approximate token count for ``text``.&quot;&quot;&quot;</span>
    <span style="color: #008000; font-weight: bold">return</span> <span style="color: #008000">len</span>(TOKENIZER<span style="color: #666666">.</span>encode(text))
</code></pre>
<h3 id="_split_text">_split_text(text: str, max_tokens: int=2000, max_chars: int=6000) -&gt; list[str]</h3>
<p>This function `_split_text` splits a given text into chunks while respecting specified maximum token and character limits. It first splits the input text into paragraphs, then iterates through each paragraph to determine if it fits within the token and character constraints. If a paragraph exceeds these limits, it is further chunked using another function `chunk_text`. The resulting chunks are collected in a list and returned.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">_split_text</span>(text: <span style="color: #008000">str</span>, max_tokens: <span style="color: #008000">int</span> <span style="color: #666666">=</span> <span style="color: #666666">2000</span>, max_chars: <span style="color: #008000">int</span> <span style="color: #666666">=</span> <span style="color: #666666">6000</span>) <span style="color: #666666">-&gt;</span> <span style="color: #008000">list</span>[<span style="color: #008000">str</span>]:
<span style="color: #bbbbbb">    </span><span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;Split ``text`` into chunks respecting ``max_tokens`` and ``max_chars``.&quot;&quot;&quot;</span>
    paragraphs <span style="color: #666666">=</span> re<span style="color: #666666">.</span>split(<span style="color: #BA2121">r&quot;\n{2,}&quot;</span>, text<span style="color: #666666">.</span>strip())
    chunks: <span style="color: #008000">list</span>[<span style="color: #008000">str</span>] <span style="color: #666666">=</span> []
    current: <span style="color: #008000">list</span>[<span style="color: #008000">str</span>] <span style="color: #666666">=</span> []
    token_count <span style="color: #666666">=</span> <span style="color: #666666">0</span>
    char_count <span style="color: #666666">=</span> <span style="color: #666666">0</span>
    <span style="color: #008000; font-weight: bold">for</span> para <span style="color: #AA22FF; font-weight: bold">in</span> paragraphs:
        para <span style="color: #666666">=</span> para<span style="color: #666666">.</span>strip()
        <span style="color: #008000; font-weight: bold">if</span> <span style="color: #AA22FF; font-weight: bold">not</span> para:
            <span style="color: #008000; font-weight: bold">continue</span>
        ptokens <span style="color: #666666">=</span> _count_tokens(para)
        pchars <span style="color: #666666">=</span> <span style="color: #008000">len</span>(para)
        <span style="color: #008000; font-weight: bold">if</span> ptokens <span style="color: #666666">&gt;</span> max_tokens <span style="color: #AA22FF; font-weight: bold">or</span> pchars <span style="color: #666666">&gt;</span> max_chars:
            <span style="color: #008000; font-weight: bold">if</span> current:
                chunks<span style="color: #666666">.</span>append(<span style="color: #BA2121">&quot;</span><span style="color: #AA5D1F; font-weight: bold">\n\n</span><span style="color: #BA2121">&quot;</span><span style="color: #666666">.</span>join(current)<span style="color: #666666">.</span>strip())
                current <span style="color: #666666">=</span> []
                token_count <span style="color: #666666">=</span> <span style="color: #666666">0</span>
                char_count <span style="color: #666666">=</span> <span style="color: #666666">0</span>
            <span style="color: #008000; font-weight: bold">for</span> piece <span style="color: #AA22FF; font-weight: bold">in</span> chunk_text(para, TOKENIZER, max_tokens):
                chunks<span style="color: #666666">.</span>append(piece<span style="color: #666666">.</span>strip())
            <span style="color: #008000; font-weight: bold">continue</span>
        <span style="color: #008000; font-weight: bold">if</span> token_count <span style="color: #666666">+</span> ptokens <span style="color: #666666">&gt;</span> max_tokens <span style="color: #AA22FF; font-weight: bold">or</span> char_count <span style="color: #666666">+</span> pchars <span style="color: #666666">&gt;</span> max_chars:
            <span style="color: #008000; font-weight: bold">if</span> current:
                chunks<span style="color: #666666">.</span>append(<span style="color: #BA2121">&quot;</span><span style="color: #AA5D1F; font-weight: bold">\n\n</span><span style="color: #BA2121">&quot;</span><span style="color: #666666">.</span>join(current)<span style="color: #666666">.</span>strip())
            current <span style="color: #666666">=</span> [para]
            token_count <span style="color: #666666">=</span> ptokens
            char_count <span style="color: #666666">=</span> pchars
        <span style="color: #008000; font-weight: bold">else</span>:
            current<span style="color: #666666">.</span>append(para)
            token_count <span style="color: #666666">+=</span> ptokens
            char_count <span style="color: #666666">+=</span> pchars
    <span style="color: #008000; font-weight: bold">if</span> current:
        chunks<span style="color: #666666">.</span>append(<span style="color: #BA2121">&quot;</span><span style="color: #AA5D1F; font-weight: bold">\n\n</span><span style="color: #BA2121">&quot;</span><span style="color: #666666">.</span>join(current)<span style="color: #666666">.</span>strip())
    <span style="color: #008000; font-weight: bold">return</span> chunks
</code></pre>
<h3 id="chunk_docs">chunk_docs(docs: list[str], token_limit: int=2000) -&gt; list[str]</h3>
<p>The function `chunk_docs` takes a list of strings (`docs`) and an integer (`token_limit`) as input. It joins the non-empty strings in `docs`, separated by double newlines, into a single string. If the resulting string is empty, it returns an empty list. Otherwise, it calls `_split_text` with the joined string, using both `max_tokens` and `max_chars` set to `token_limit`. The function&#x27;s purpose is to split the input text into chunks that do not exceed the specified token limit.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">chunk_docs</span>(docs: <span style="color: #008000">list</span>[<span style="color: #008000">str</span>], token_limit: <span style="color: #008000">int</span> <span style="color: #666666">=</span> <span style="color: #666666">2000</span>) <span style="color: #666666">-&gt;</span> <span style="color: #008000">list</span>[<span style="color: #008000">str</span>]:
<span style="color: #bbbbbb">    </span><span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;Split ``docs`` into roughly ``token_limit`` sized chunks.&quot;&quot;&quot;</span>
    text <span style="color: #666666">=</span> <span style="color: #BA2121">&quot;</span><span style="color: #AA5D1F; font-weight: bold">\n\n</span><span style="color: #BA2121">&quot;</span><span style="color: #666666">.</span>join(d<span style="color: #666666">.</span>strip() <span style="color: #008000; font-weight: bold">for</span> d <span style="color: #AA22FF; font-weight: bold">in</span> docs <span style="color: #008000; font-weight: bold">if</span> d <span style="color: #AA22FF; font-weight: bold">and</span> d<span style="color: #666666">.</span>strip())
    <span style="color: #008000; font-weight: bold">if</span> <span style="color: #AA22FF; font-weight: bold">not</span> text:
        <span style="color: #008000; font-weight: bold">return</span> []
    <span style="color: #008000; font-weight: bold">return</span> _split_text(text, max_tokens<span style="color: #666666">=</span>token_limit, max_chars<span style="color: #666666">=</span>token_limit <span style="color: #666666">*</span> <span style="color: #666666">3</span>)
</code></pre>
<h3 id="find_placeholders">find_placeholders(text: str) -&gt; Set[str]</h3>
<p>The function `find_placeholders` searches for placeholder tokens enclosed in double backticks followed by two square brackets, such as ``[[TOKEN]]``, within a given string `text`. It returns a set of these placeholder tokens found in the text. The placeholders are identified using a regular expression defined in `PLACEHOLDER_RE`.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">find_placeholders</span>(text: <span style="color: #008000">str</span>) <span style="color: #666666">-&gt;</span> Set[<span style="color: #008000">str</span>]:
<span style="color: #bbbbbb">    </span><span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;Return placeholder tokens of the form ``[[TOKEN]]`` found in ``text``.&quot;&quot;&quot;</span>
    <span style="color: #008000; font-weight: bold">return</span> <span style="color: #008000">set</span>(PLACEHOLDER_RE<span style="color: #666666">.</span>findall(text))
</code></pre>
<h3 id="_summarize_manual">_summarize_manual(client: LLMClient, cache: ResponseCache, text: str, chunking: str=&#x27;auto&#x27;, source: str=&#x27;combined&#x27;, post_chunk_hook: Callable[[list[str]], list[str]] | None=None) -&gt; str</h3>
<p>The function `_summarize_manual` generates a manual summary for the provided text using a specified chunking strategy. It interacts with an LLM client to perform summarization and utilizes a response cache to store previously generated summaries for efficiency. The function handles different chunking modes: &quot;manual&quot;, &quot;auto&quot; (with automatic chunking if text exceeds certain limits), and &quot;none&quot; (disabling chunking if text is too large). It also supports a post-chunk hook for additional processing of summarized parts. The function ensures that the final summary does not exceed token or character limits by performing hierarchical merges if necessary.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">_summarize_manual</span>(
    client: LLMClient,
    cache: ResponseCache,
    text: <span style="color: #008000">str</span>,
    chunking: <span style="color: #008000">str</span> <span style="color: #666666">=</span> <span style="color: #BA2121">&quot;auto&quot;</span>,
    source: <span style="color: #008000">str</span> <span style="color: #666666">=</span> <span style="color: #BA2121">&quot;combined&quot;</span>,
    post_chunk_hook: Callable[[<span style="color: #008000">list</span>[<span style="color: #008000">str</span>]], <span style="color: #008000">list</span>[<span style="color: #008000">str</span>]] <span style="color: #666666">|</span> <span style="color: #008000; font-weight: bold">None</span> <span style="color: #666666">=</span> <span style="color: #008000; font-weight: bold">None</span>,
) <span style="color: #666666">-&gt;</span> <span style="color: #008000">str</span>:
<span style="color: #bbbbbb">    </span><span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;Return a manual summary for ``text`` using ``chunking`` strategy.&quot;&quot;&quot;</span>
    <span style="color: #008000; font-weight: bold">if</span> <span style="color: #AA22FF; font-weight: bold">not</span> text:
        <span style="color: #008000; font-weight: bold">return</span> <span style="color: #BA2121">&quot;&quot;</span>

    <span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">explaincode</span> <span style="color: #008000; font-weight: bold">import</span> infer_sections  <span style="color: #3D7B7B; font-style: italic"># imported lazily to avoid circular dependency</span>

    within_limits <span style="color: #666666">=</span> _count_tokens(text) <span style="color: #666666">&lt;=</span> <span style="color: #666666">2000</span> <span style="color: #AA22FF; font-weight: bold">and</span> <span style="color: #008000">len</span>(text) <span style="color: #666666">&lt;=</span> <span style="color: #666666">6000</span>

    <span style="color: #008000; font-weight: bold">if</span> chunking <span style="color: #666666">==</span> <span style="color: #BA2121">&quot;manual&quot;</span> <span style="color: #AA22FF; font-weight: bold">or</span> (chunking <span style="color: #666666">==</span> <span style="color: #BA2121">&quot;auto&quot;</span> <span style="color: #AA22FF; font-weight: bold">and</span> <span style="color: #AA22FF; font-weight: bold">not</span> within_limits):
        <span style="color: #008000; font-weight: bold">try</span>:
            parts <span style="color: #666666">=</span> _split_text(text)
        <span style="color: #008000; font-weight: bold">except</span> <span style="color: #CB3F38; font-weight: bold">Exception</span> <span style="color: #008000; font-weight: bold">as</span> exc:  <span style="color: #3D7B7B; font-style: italic"># pragma: no cover - defensive</span>
            <span style="color: #008000">print</span>(<span style="color: #BA2121">f&quot;[WARN] Chunking failed: </span><span style="color: #A45A77; font-weight: bold">{</span>exc<span style="color: #A45A77; font-weight: bold">}</span><span style="color: #BA2121">&quot;</span>, file<span style="color: #666666">=</span>sys<span style="color: #666666">.</span>stderr)
            sections <span style="color: #666666">=</span> infer_sections(text)
            <span style="color: #008000; font-weight: bold">return</span> <span style="color: #BA2121">&quot;</span><span style="color: #AA5D1F; font-weight: bold">\n</span><span style="color: #BA2121">&quot;</span><span style="color: #666666">.</span>join(<span style="color: #BA2121">f&quot;</span><span style="color: #A45A77; font-weight: bold">{</span>k<span style="color: #A45A77; font-weight: bold">}</span><span style="color: #BA2121">: </span><span style="color: #A45A77; font-weight: bold">{</span>v<span style="color: #A45A77; font-weight: bold">}</span><span style="color: #BA2121">&quot;</span> <span style="color: #008000; font-weight: bold">for</span> k, v <span style="color: #AA22FF; font-weight: bold">in</span> sections<span style="color: #666666">.</span>items())

        total <span style="color: #666666">=</span> <span style="color: #008000">len</span>(parts)
        partials: <span style="color: #008000">dict</span>[<span style="color: #008000">int</span>, <span style="color: #008000">str</span>] <span style="color: #666666">=</span> {}
        work: <span style="color: #008000">list</span>[<span style="color: #008000">tuple</span>[<span style="color: #008000">int</span>, <span style="color: #008000">str</span>, <span style="color: #008000">str</span>]] <span style="color: #666666">=</span> []
        <span style="color: #008000; font-weight: bold">for</span> idx, part <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">enumerate</span>(parts, <span style="color: #666666">1</span>):
            logging<span style="color: #666666">.</span>debug(
                <span style="color: #BA2121">&quot;Chunk </span><span style="color: #A45A77; font-weight: bold">%s</span><span style="color: #BA2121">/</span><span style="color: #A45A77; font-weight: bold">%s</span><span style="color: #BA2121"> from </span><span style="color: #A45A77; font-weight: bold">%s</span><span style="color: #BA2121">: </span><span style="color: #A45A77; font-weight: bold">%s</span><span style="color: #BA2121"> tokens, </span><span style="color: #A45A77; font-weight: bold">%s</span><span style="color: #BA2121"> characters&quot;</span>,
                idx,
                total,
                source,
                _count_tokens(part),
                <span style="color: #008000">len</span>(part),
            )
            key <span style="color: #666666">=</span> ResponseCache<span style="color: #666666">.</span>make_key(<span style="color: #BA2121">f&quot;</span><span style="color: #A45A77; font-weight: bold">{</span>source<span style="color: #A45A77; font-weight: bold">}</span><span style="color: #BA2121">:chunk</span><span style="color: #A45A77; font-weight: bold">{</span>idx<span style="color: #A45A77; font-weight: bold">}</span><span style="color: #BA2121">&quot;</span>, part)
            cached <span style="color: #666666">=</span> cache<span style="color: #666666">.</span>get(key)
            <span style="color: #008000; font-weight: bold">if</span> cached <span style="color: #AA22FF; font-weight: bold">is</span> <span style="color: #AA22FF; font-weight: bold">not</span> <span style="color: #008000; font-weight: bold">None</span>:
                partials[idx] <span style="color: #666666">=</span> cached
                logging<span style="color: #666666">.</span>debug(
                    <span style="color: #BA2121">&quot;LLM response </span><span style="color: #A45A77; font-weight: bold">%s</span><span style="color: #BA2121">/</span><span style="color: #A45A77; font-weight: bold">%s</span><span style="color: #BA2121"> length: </span><span style="color: #A45A77; font-weight: bold">%s</span><span style="color: #BA2121"> characters&quot;</span>,
                    idx,
                    total,
                    <span style="color: #008000">len</span>(cached),
                )
            <span style="color: #008000; font-weight: bold">else</span>:
                work<span style="color: #666666">.</span>append((idx, part, key))

        <span style="color: #008000; font-weight: bold">if</span> work:
            <span style="color: #008000; font-weight: bold">with</span> ThreadPoolExecutor() <span style="color: #008000; font-weight: bold">as</span> executor:
                future_map <span style="color: #666666">=</span> {
                    executor<span style="color: #666666">.</span>submit(
                        client<span style="color: #666666">.</span>summarize,
                        part,
                        <span style="color: #BA2121">&quot;docstring&quot;</span>,
                        system_prompt<span style="color: #666666">=</span>CHUNK_SYSTEM_PROMPT,
                    ): (idx, key)
                    <span style="color: #008000; font-weight: bold">for</span> idx, part, key <span style="color: #AA22FF; font-weight: bold">in</span> work
                }
                <span style="color: #008000; font-weight: bold">for</span> future <span style="color: #AA22FF; font-weight: bold">in</span> as_completed(future_map):
                    idx, key <span style="color: #666666">=</span> future_map[future]
                    <span style="color: #008000; font-weight: bold">try</span>:
                        resp <span style="color: #666666">=</span> future<span style="color: #666666">.</span>result()
                    <span style="color: #008000; font-weight: bold">except</span> <span style="color: #CB3F38; font-weight: bold">Exception</span> <span style="color: #008000; font-weight: bold">as</span> exc:  <span style="color: #3D7B7B; font-style: italic"># pragma: no cover - network failure</span>
                        <span style="color: #008000">print</span>(
                            <span style="color: #BA2121">f&quot;[WARN] Summarization failed for chunk </span><span style="color: #A45A77; font-weight: bold">{</span>idx<span style="color: #A45A77; font-weight: bold">}</span><span style="color: #BA2121">/</span><span style="color: #A45A77; font-weight: bold">{</span>total<span style="color: #A45A77; font-weight: bold">}</span><span style="color: #BA2121">: </span><span style="color: #A45A77; font-weight: bold">{</span>exc<span style="color: #A45A77; font-weight: bold">}</span><span style="color: #BA2121">&quot;</span>,
                            file<span style="color: #666666">=</span>sys<span style="color: #666666">.</span>stderr,
                        )
                        <span style="color: #008000; font-weight: bold">continue</span>
                    cache<span style="color: #666666">.</span>set(key, resp)
                    logging<span style="color: #666666">.</span>debug(
                        <span style="color: #BA2121">&quot;LLM response </span><span style="color: #A45A77; font-weight: bold">%s</span><span style="color: #BA2121">/</span><span style="color: #A45A77; font-weight: bold">%s</span><span style="color: #BA2121"> length: </span><span style="color: #A45A77; font-weight: bold">%s</span><span style="color: #BA2121"> characters&quot;</span>,
                        idx,
                        total,
                        <span style="color: #008000">len</span>(resp),
                    )
                    partials[idx] <span style="color: #666666">=</span> resp

        <span style="color: #008000; font-weight: bold">if</span> <span style="color: #AA22FF; font-weight: bold">not</span> partials:
            sections <span style="color: #666666">=</span> infer_sections(text)
            <span style="color: #008000; font-weight: bold">return</span> <span style="color: #BA2121">&quot;</span><span style="color: #AA5D1F; font-weight: bold">\n</span><span style="color: #BA2121">&quot;</span><span style="color: #666666">.</span>join(<span style="color: #BA2121">f&quot;</span><span style="color: #A45A77; font-weight: bold">{</span>k<span style="color: #A45A77; font-weight: bold">}</span><span style="color: #BA2121">: </span><span style="color: #A45A77; font-weight: bold">{</span>v<span style="color: #A45A77; font-weight: bold">}</span><span style="color: #BA2121">&quot;</span> <span style="color: #008000; font-weight: bold">for</span> k, v <span style="color: #AA22FF; font-weight: bold">in</span> sections<span style="color: #666666">.</span>items())

        <span style="color: #008000; font-weight: bold">if</span> post_chunk_hook:
            <span style="color: #008000; font-weight: bold">try</span>:
                ordered <span style="color: #666666">=</span> [partials[i] <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">sorted</span>(partials)]
                ordered <span style="color: #666666">=</span> post_chunk_hook(ordered)
                partials <span style="color: #666666">=</span> {i <span style="color: #666666">+</span> <span style="color: #666666">1</span>: v <span style="color: #008000; font-weight: bold">for</span> i, v <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">enumerate</span>(ordered)}
            <span style="color: #008000; font-weight: bold">except</span> <span style="color: #CB3F38; font-weight: bold">Exception</span> <span style="color: #008000; font-weight: bold">as</span> exc:  <span style="color: #3D7B7B; font-style: italic"># pragma: no cover - defensive</span>
                logging<span style="color: #666666">.</span>debug(<span style="color: #BA2121">&quot;Chunk post-processing failed: </span><span style="color: #A45A77; font-weight: bold">%s</span><span style="color: #BA2121">&quot;</span>, exc)

        merge_input <span style="color: #666666">=</span> <span style="color: #BA2121">&quot;</span><span style="color: #AA5D1F; font-weight: bold">\n\n</span><span style="color: #BA2121">&quot;</span><span style="color: #666666">.</span>join(partials[i] <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">sorted</span>(partials))
        tokens <span style="color: #666666">=</span> _count_tokens(merge_input)
        chars <span style="color: #666666">=</span> <span style="color: #008000">len</span>(merge_input)
        iteration <span style="color: #666666">=</span> <span style="color: #666666">0</span>
        <span style="color: #008000; font-weight: bold">while</span> tokens <span style="color: #666666">&gt;</span> <span style="color: #666666">2000</span> <span style="color: #AA22FF; font-weight: bold">or</span> chars <span style="color: #666666">&gt;</span> <span style="color: #666666">6000</span>:
            iteration <span style="color: #666666">+=</span> <span style="color: #666666">1</span>
            logging<span style="color: #666666">.</span>info(
                <span style="color: #BA2121">&quot;Hierarchical merge pass </span><span style="color: #A45A77; font-weight: bold">%s</span><span style="color: #BA2121">: </span><span style="color: #A45A77; font-weight: bold">%s</span><span style="color: #BA2121"> tokens, </span><span style="color: #A45A77; font-weight: bold">%s</span><span style="color: #BA2121"> characters&quot;</span>,
                iteration,
                tokens,
                chars,
            )
            <span style="color: #008000; font-weight: bold">try</span>:
                sub_parts <span style="color: #666666">=</span> _split_text(merge_input)
            <span style="color: #008000; font-weight: bold">except</span> <span style="color: #CB3F38; font-weight: bold">Exception</span> <span style="color: #008000; font-weight: bold">as</span> exc:  <span style="color: #3D7B7B; font-style: italic"># pragma: no cover - defensive</span>
                <span style="color: #008000">print</span>(<span style="color: #BA2121">f&quot;[WARN] Hierarchical split failed: </span><span style="color: #A45A77; font-weight: bold">{</span>exc<span style="color: #A45A77; font-weight: bold">}</span><span style="color: #BA2121">&quot;</span>, file<span style="color: #666666">=</span>sys<span style="color: #666666">.</span>stderr)
                <span style="color: #008000; font-weight: bold">break</span>
            new_partials: <span style="color: #008000">list</span>[<span style="color: #008000">str</span>] <span style="color: #666666">=</span> []
            total <span style="color: #666666">=</span> <span style="color: #008000">len</span>(sub_parts)
            <span style="color: #008000; font-weight: bold">for</span> idx, piece <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">enumerate</span>(sub_parts, <span style="color: #666666">1</span>):
                logging<span style="color: #666666">.</span>debug(
                    <span style="color: #BA2121">&quot;Merge chunk </span><span style="color: #A45A77; font-weight: bold">%s</span><span style="color: #BA2121">/</span><span style="color: #A45A77; font-weight: bold">%s</span><span style="color: #BA2121">: </span><span style="color: #A45A77; font-weight: bold">%s</span><span style="color: #BA2121"> tokens, </span><span style="color: #A45A77; font-weight: bold">%s</span><span style="color: #BA2121"> characters&quot;</span>,
                    idx,
                    total,
                    _count_tokens(piece),
                    <span style="color: #008000">len</span>(piece),
                )
                key <span style="color: #666666">=</span> ResponseCache<span style="color: #666666">.</span>make_key(
                    <span style="color: #BA2121">f&quot;</span><span style="color: #A45A77; font-weight: bold">{</span>source<span style="color: #A45A77; font-weight: bold">}</span><span style="color: #BA2121">:merge</span><span style="color: #A45A77; font-weight: bold">{</span>iteration<span style="color: #A45A77; font-weight: bold">}</span><span style="color: #BA2121">:chunk</span><span style="color: #A45A77; font-weight: bold">{</span>idx<span style="color: #A45A77; font-weight: bold">}</span><span style="color: #BA2121">&quot;</span>, piece
                )
                cached <span style="color: #666666">=</span> cache<span style="color: #666666">.</span>get(key)
                <span style="color: #008000; font-weight: bold">if</span> cached <span style="color: #AA22FF; font-weight: bold">is</span> <span style="color: #AA22FF; font-weight: bold">not</span> <span style="color: #008000; font-weight: bold">None</span>:
                    resp <span style="color: #666666">=</span> cached
                <span style="color: #008000; font-weight: bold">else</span>:
                    <span style="color: #008000; font-weight: bold">try</span>:
                        resp <span style="color: #666666">=</span> client<span style="color: #666666">.</span>summarize(
                            piece, <span style="color: #BA2121">&quot;docstring&quot;</span>, system_prompt<span style="color: #666666">=</span>MERGE_SYSTEM_PROMPT
                        )
                    <span style="color: #008000; font-weight: bold">except</span> <span style="color: #CB3F38; font-weight: bold">Exception</span> <span style="color: #008000; font-weight: bold">as</span> exc:  <span style="color: #3D7B7B; font-style: italic"># pragma: no cover - network failure</span>
                        <span style="color: #008000">print</span>(
                            <span style="color: #BA2121">f&quot;[WARN] Hierarchical summarization failed for chunk </span><span style="color: #A45A77; font-weight: bold">{</span>idx<span style="color: #A45A77; font-weight: bold">}</span><span style="color: #BA2121">/</span><span style="color: #A45A77; font-weight: bold">{</span>total<span style="color: #A45A77; font-weight: bold">}</span><span style="color: #BA2121">: </span><span style="color: #A45A77; font-weight: bold">{</span>exc<span style="color: #A45A77; font-weight: bold">}</span><span style="color: #BA2121">&quot;</span>,
                            file<span style="color: #666666">=</span>sys<span style="color: #666666">.</span>stderr,
                        )
                        <span style="color: #008000; font-weight: bold">continue</span>
                    cache<span style="color: #666666">.</span>set(key, resp)
                new_partials<span style="color: #666666">.</span>append(resp)
            <span style="color: #008000; font-weight: bold">if</span> <span style="color: #AA22FF; font-weight: bold">not</span> new_partials:
                <span style="color: #008000; font-weight: bold">break</span>
            merge_input <span style="color: #666666">=</span> <span style="color: #BA2121">&quot;</span><span style="color: #AA5D1F; font-weight: bold">\n\n</span><span style="color: #BA2121">&quot;</span><span style="color: #666666">.</span>join(new_partials)
            tokens <span style="color: #666666">=</span> _count_tokens(merge_input)
            chars <span style="color: #666666">=</span> <span style="color: #008000">len</span>(merge_input)
        key <span style="color: #666666">=</span> ResponseCache<span style="color: #666666">.</span>make_key(<span style="color: #BA2121">f&quot;</span><span style="color: #A45A77; font-weight: bold">{</span>source<span style="color: #A45A77; font-weight: bold">}</span><span style="color: #BA2121">:final&quot;</span>, merge_input)
        cached <span style="color: #666666">=</span> cache<span style="color: #666666">.</span>get(key)
        <span style="color: #008000; font-weight: bold">if</span> cached <span style="color: #AA22FF; font-weight: bold">is</span> <span style="color: #AA22FF; font-weight: bold">not</span> <span style="color: #008000; font-weight: bold">None</span>:
            final_resp <span style="color: #666666">=</span> cached
        <span style="color: #008000; font-weight: bold">else</span>:
            <span style="color: #008000; font-weight: bold">try</span>:
                final_resp <span style="color: #666666">=</span> client<span style="color: #666666">.</span>summarize(
                    merge_input, <span style="color: #BA2121">&quot;docstring&quot;</span>, system_prompt<span style="color: #666666">=</span>MERGE_SYSTEM_PROMPT
                )
                cache<span style="color: #666666">.</span>set(key, final_resp)
            <span style="color: #008000; font-weight: bold">except</span> <span style="color: #CB3F38; font-weight: bold">Exception</span> <span style="color: #008000; font-weight: bold">as</span> exc:  <span style="color: #3D7B7B; font-style: italic"># pragma: no cover - network failure</span>
                <span style="color: #008000">print</span>(<span style="color: #BA2121">f&quot;[WARN] Merge failed: </span><span style="color: #A45A77; font-weight: bold">{</span>exc<span style="color: #A45A77; font-weight: bold">}</span><span style="color: #BA2121">&quot;</span>, file<span style="color: #666666">=</span>sys<span style="color: #666666">.</span>stderr)
                <span style="color: #008000; font-weight: bold">return</span> merge_input
        logging<span style="color: #666666">.</span>debug(<span style="color: #BA2121">&quot;Merged LLM response length: </span><span style="color: #A45A77; font-weight: bold">%s</span><span style="color: #BA2121"> characters&quot;</span>, <span style="color: #008000">len</span>(final_resp))
        <span style="color: #008000; font-weight: bold">return</span> final_resp

    <span style="color: #008000; font-weight: bold">if</span> chunking <span style="color: #666666">==</span> <span style="color: #BA2121">&quot;none&quot;</span> <span style="color: #AA22FF; font-weight: bold">and</span> <span style="color: #AA22FF; font-weight: bold">not</span> within_limits:
        <span style="color: #008000">print</span>(
            <span style="color: #BA2121">&quot;[WARN] Content exceeds token or character limits; chunking disabled.&quot;</span>,
            file<span style="color: #666666">=</span>sys<span style="color: #666666">.</span>stderr,
        )
    key <span style="color: #666666">=</span> ResponseCache<span style="color: #666666">.</span>make_key(<span style="color: #BA2121">f&quot;</span><span style="color: #A45A77; font-weight: bold">{</span>source<span style="color: #A45A77; font-weight: bold">}</span><span style="color: #BA2121">:full&quot;</span>, text)
    cached <span style="color: #666666">=</span> cache<span style="color: #666666">.</span>get(key)
    <span style="color: #008000; font-weight: bold">if</span> cached <span style="color: #AA22FF; font-weight: bold">is</span> <span style="color: #AA22FF; font-weight: bold">not</span> <span style="color: #008000; font-weight: bold">None</span>:
        <span style="color: #008000; font-weight: bold">return</span> cached
    resp <span style="color: #666666">=</span> client<span style="color: #666666">.</span>summarize(text, <span style="color: #BA2121">&quot;user_manual&quot;</span>, system_prompt<span style="color: #666666">=</span>MERGE_SYSTEM_PROMPT)
    cache<span style="color: #666666">.</span>set(key, resp)
    <span style="color: #008000; font-weight: bold">return</span> resp
</code></pre>
    </div>
    <script src="static/toggle.js"></script>
</body>
</html>
