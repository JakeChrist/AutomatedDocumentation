{
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\cache.py:2e37ab4b52e9489ed2b2dc8e686dc29df25416d04f5b423c47ba2cc9aecf698c:2e37ab4b52e9489ed2b2dc8e686dc29df25416d04f5b423c47ba2cc9aecf698c": "A simple on-disk cache for LLM responses. Implements methods to get and set values using a deterministic key based on file path and content. Persists the cache to disk as a JSON file.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\cache.py:ResponseCache:__init__:919483e1ff4b05cae685fcac27aa9458bc309d42dd717af59b0942962ccdf4e4:919483e1ff4b05cae685fcac27aa9458bc309d42dd717af59b0942962ccdf4e4": "Initializes an object with a file path. If the file exists, reads its content as JSON and stores it in `_data`. If the file does not exist or is not valid JSON, initializes `_data` as an empty dictionary.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\cache.py:ResponseCache:_save:d6c96e0258c810e9fec48856af580533cfc0aa8f13ea666bb1d396aa4abe5e41:d6c96e0258c810e9fec48856af580533cfc0aa8f13ea666bb1d396aa4abe5e41": "Writes the contents of `_data` to a file using JSON format with an indentation of 2 spaces and sorted keys. The file is encoded in UTF-8.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\cache.py:ResponseCache:a0717066449294e28695a1ab9d0dbfc8ea752cd613f6b4c6cc8a53e30ed7ff86:a0717066449294e28695a1ab9d0dbfc8ea752cd613f6b4c6cc8a53e30ed7ff86": "The `ResponseCache` class manages caching of responses in JSON format, using file paths and content hashes as keys. It provides methods for initializing with a file path, retrieving cached values, storing new values, and saving changes to disk.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\cache.py:ResponseCache:get:eeb84b4591575a8ed2767f4abac56f1f2dd0697e81322599734b8b31e94ddcce:eeb84b4591575a8ed2767f4abac56f1f2dd0697e81322599734b8b31e94ddcce": "Retrieves the cached value associated with a given key from an internal data structure. Returns the value if the key exists; otherwise, returns None.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\cache.py:ResponseCache:make_key:4f63c9f618b20a79035ed49cae07b9b800a46f352498e23dc8700f47c38fe96d:4f63c9f618b20a79035ed49cae07b9b800a46f352498e23dc8700f47c38fe96d": "Function `make_key` takes two parameters: `file_path` (a string) and `content` (a string). It returns a deterministic key by hashing the content using SHA-256 and appending the file path to the hash digest. The returned key is in the format \"file_path:digest\".",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\cache.py:ResponseCache:set:0bc8af7637662ae14e3eca8604a4d7155ff442d423955a243d6b586ffee8d8ba:0bc8af7637662ae14e3eca8604a4d7155ff442d423955a243d6b586ffee8d8ba": "Stores a `value` under a specified `key` in an internal data structure and saves the changes to disk.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\docgenerator.py:_build_function_prompt:31d471ba5c7dac83feee014fecd04733023c07d19e3b974244d3e4f849cc70e4:31d471ba5c7dac83feee014fecd04733023c07d19e3b974244d3e4f849cc70e4": "This function `_build_function_prompt` constructs a prompt for summarizing a given Python function's source code. It enriches the prompt with contextual information such as the class name, class summary, and project summary if provided. The prompt is designed to be used by a documentation generator to produce summaries that are accurate and relevant based on the input context and code.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\docgenerator.py:_chunk_module_by_structure:ac37d2fc61aaac5849c50407794c88050afb3d06c9794a02cb4990c81f1c8b4a:ac37d2fc61aaac5849c50407794c88050afb3d06c9794a02cb4990c81f1c8b4a": "This function `_chunk_module_by_structure` processes a module's parsed structure to create text chunks that do not exceed a specified token size. It starts by adding the module's docstring, then iterates through classes and functions within the module, appending their source code or signatures to blocks if they fit within the token limit. If a block exceeds the limit, it is further chunked using another function `chunk_text`. The resulting chunks are returned as a list.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\docgenerator.py:_get_tokenizer:204e4eef377a18f916763e0a67b4d166299c3a3ae485075ab2f5847e6597ef55:204e4eef377a18f916763e0a67b4d166299c3a3ae485075ab2f5847e6597ef55": "The `_get_tokenizer` function returns a tokenizer object used for estimating token counts. If the `tiktoken` library is installed, it attempts to use the \"cl100k_base\" encoding; if not, it falls back to using a simple tokenizer that splits text into words and joins them back together.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\docgenerator.py:_rewrite_docstring:039450bc821de677746790583236d6ca5e8e6b3f2efa9f3b461fa54875d271a7:039450bc821de677746790583236d6ca5e8e6b3f2efa9f3b461fa54875d271a7": "The `_rewrite_docstring` function rewrites the docstring of a code item using an optional context provided by a language model. It takes parameters including an `LLMClient`, a `ResponseCache`, file path, and item dictionary. The function checks if there is source or docstring data; if not, it prints a warning. If a docstring exists, it constructs a prompt based on the source code and optional context (class name, class summary, project summary). It then generates a key using the file path and item details. Using this key and prompt, it summarizes the chunked content and sanitizes the result before updating the item's docstring. If no summary is available, it sets the docstring to \"No summary available.\"",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\docgenerator.py:_summarize:e5a2e3a3e3563245f4bde014794610eff16062f1a564d91e41ec039be3f5d83a:e5a2e3a3e3563245f4bde014794610eff16062f1a564d91e41ec039be3f5d83a": "This function `_summarize` takes an `LLMClient`, a `ResponseCache`, a `key`, some `text`, and a `prompt_type`. It checks if the summary for the given key is already cached. If it is, it returns the cached summary. Otherwise, it uses the `client` to generate a summary of the `text` based on the `prompt_type`, caches this new summary under the given `key`, and then returns it.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\docgenerator.py:_summarize_chunked:cf2fc44fa1adb0e902d551b2d8004b3e2a4b2c4e84e84b374285667df4a8d307:cf2fc44fa1adb0e902d551b2d8004b3e2a4b2c4e84e84b374285667df4a8d307": "The `_summarize_chunked` function summarizes a given text by chunking it if necessary. It uses an `LLMClient` for summarization and a `ResponseCache` to store intermediate results. The function first calculates the available tokens based on the maximum context tokens and overhead from prompts. If the text fits within these available tokens, it is summarized directly. Otherwise, the text is chunked into smaller parts, each of which is summarized separately. These partial summaries are then merged into a single technical paragraph using another prompt. The final summary is sanitized before being returned.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\docgenerator.py:_summarize_class_recursive:12966c0a26d553c3483ed39115adc2f16e3f536a9144996b40e9b02d50afdb1a:12966c0a26d553c3483ed39115adc2f16e3f536a9144996b40e9b02d50afdb1a": "This function `_summarize_class_recursive` is designed to recursively summarize a class and its methods. It takes several parameters including `class_data`, which contains details about the class, `path`, `project_summary`, `tokenizer`, `client`, `cache`, `max_context_tokens`, and `chunk_token_budget`. The function performs the following tasks:\n\n1. Calls `_summarize_methods_recursive` to summarize all methods within the class.\n2. Constructs a prompt for summarizing the class using the `CLASS_PROMPT` format, which includes the class name, project summary, and method summaries.\n3. Generates a unique key for caching based on the path and class name.\n4. Summarizes the class using `_summarize_chunked`, sanitizes the summary, and updates the class data with the new summary.\n5. Rewrites the docstring of the class if it has changed.\n6. Recursively calls itself for each subclass within the current class.\n\nThe function ensures that all methods and subclasses are summarized recursively, maintaining a consistent structure in the documentation generation process.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\docgenerator.py:_summarize_methods_recursive:463414d03414a87990ab42ed0888f770dd4d62d45c4cbfa82759c939620b3370:463414d03414a87990ab42ed0888f770dd4d62d45c4cbfa82759c939620b3370": "The function `_summarize_methods_recursive` is designed to recursively summarize the methods of a given class and its subclasses. It takes several parameters including `class_data`, which contains information about the class, `path`, the directory path, `client`, an instance of `LLMClient` for language model interactions, `cache`, an instance of `ResponseCache` for caching responses, `tokenizer`, a tokenizer for text processing, and `max_context_tokens` and `chunk_token_budget` for managing token usage.\n\nThe function iterates over each method in the `class_data`. For each method, it constructs a key using the class name and method name to ensure uniqueness. It then calls `_summarize_chunked`, passing the language model client, cache, key, source code (or signature), type (\"function\"), tokenizer, maximum context tokens, and chunk token budget. The summary generated is stored in both the `summary` and `docstring` fields of the method dictionary.\n\nAfter processing all methods, the function recursively calls itself for each subclass listed in `class_data`, ensuring that all methods across the entire class hierarchy are summarized.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\docgenerator.py:_summarize_module_chunked:22091a1731ec2548cc3f5846354ea631a913489c831861fa742114c6a9182dfe:22091a1731ec2548cc3f5846354ea631a913489c831861fa742114c6a9182dfe": "This function `_summarize_module_chunked` is designed to summarize a module of code using a structure-aware chunking approach. It takes several parameters including an `LLMClient` instance for language model interactions, a `ResponseCache` object for caching summaries, a key prefix, the text of the module, a dictionary representing the module, a tokenizer, and token budget constraints.\n\nThe function first calculates the available tokens based on the maximum context tokens and overhead from the system prompt and template. If the encoded length of the module text is less than or equal to these available tokens, it generates a key for caching and calls `_summarize` directly to get the summary.\n\nIf the module text exceeds the available tokens, the function chunks the module based on its structure using `_chunk_module_by_structure`. It then iterates over each chunk, generates keys for caching, and calls `_summarize` to get summaries for each part. These partial summaries are combined into a single technical paragraph using a predefined merge prompt.\n\nFinally, it generates a key for caching the merged summary and calls `_summarize` again to combine these parts into a final summary. The resulting summary is sanitized before being returned.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\docgenerator.py:chunk_text:8ed78422f305238529fbadb0928188b2e60e75d2e0c9d50c331580ca5e43121c:8ed78422f305238529fbadb0928188b2e60e75d2e0c9d50c331580ca5e43121c": "The `chunk_text` function splits a given text into smaller chunks based on the specified token size. It uses a tokenizer to encode the text into tokens, then iterates through these tokens in chunks of the desired size, decoding each chunk back into text before appending it to the result list. This allows for efficient processing and handling of large texts by breaking them down into manageable parts.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\docgenerator.py:clean_output_dir:9ee5d2c01ec668db552d259eda84ed94c909bfe41463537b7909b90f52c916da:9ee5d2c01ec668db552d259eda84ed94c909bfe41463537b7909b90f52c916da": "The `clean_output_dir` function takes a string representing the path to an output directory and iterates through all files within that directory. If a file has a `.html` extension, it reads the first line of the file. If the first line contains the string \"Generated by DocGen-LM\", indicating that the file was generated by the DocGen-LM tool, it attempts to remove the file. If an error occurs during this process, it prints a warning message with the filename and the exception details.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\docgenerator.py:f07cc84ce87a4c016bfbb44a825b20fb75d63318b9728239f4d8ea58cd847279:merge:d481e86e6b71ec4a30053da60bc73294c041a0d116fa663975f540a7c5189b26": "This module implements a command-line interface for generating documentation using DocGen-LM. It scans a source tree for Python and MATLAB files, parses them, requests summaries from a running LLM, and writes HTML documentation. The module includes functions for cleaning the output directory, summarizing text, tokenizing, chunking text, summarizing modules, rewriting docstrings, and recursively summarizing classes and methods.\n\nThe `main` function generates HTML documentation using a local language model (LLM). It takes command-line arguments to specify the source directory, output directory, and various options like ignored paths, LLM URL, model name, and maximum context tokens. The function uses an argument parser to handle these inputs.\n\nIt initializes an LLM client and checks if the client is reachable. If not, it prints an error message and returns a non-zero exit code.\n\nThe function then sets up a tokenizer and calculates chunk token budgets based on the maximum context tokens. It creates the output directory and copies static files into it.\n\nUsing the `scan_directory` function, it processes each file in the source directory. For each file, it reads its content and parses it as Python or MATLAB code. If parsing fails due to syntax errors, it skips the file.\n\nFor each parsed module, it generates a summary using the LLM client and caches the results. It also handles classes and functions within the modules, summarizing them recursively and updating their docstrings with project context.\n\nFinally, it writes an index page and individual pages for each module in the output directory.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\docgenerator.py:f07cc84ce87a4c016bfbb44a825b20fb75d63318b9728239f4d8ea58cd847279:part0:9a9624ac0b3aef66f927c89a76613280cddcd9d13f2ffc2d88db997b40aae6cf": "This module implements a command-line interface for generating documentation using DocGen-LM. It scans a source tree for Python and MATLAB files, parses them, requests summaries from a running LLM, and writes HTML documentation. The module includes functions for cleaning the output directory, summarizing text, tokenizing, chunking text, summarizing modules, rewriting docstrings, and recursively summarizing classes and methods.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\docgenerator.py:f07cc84ce87a4c016bfbb44a825b20fb75d63318b9728239f4d8ea58cd847279:part1:35ba0b22b7776663315f3ac0915850edc1c34b61a8bcf152494e5010847178c8": "The code defines a `main` function that generates HTML documentation using a local language model (LLM). It takes command-line arguments to specify the source directory, output directory, and various options like ignored paths, LLM URL, model name, and maximum context tokens. The function uses an argument parser to handle these inputs.\n\nIt initializes an LLM client and checks if the client is reachable. If not, it prints an error message and returns a non-zero exit code.\n\nThe function then sets up a tokenizer and calculates chunk token budgets based on the maximum context tokens. It creates the output directory and copies static files into it.\n\nUsing the `scan_directory` function, it processes each file in the source directory. For each file, it reads its content and parses it as Python or MATLAB code. If parsing fails due to syntax errors, it skips the file.\n\nFor each parsed module, it generates a summary using the LLM client and caches the results. It also handles classes and functions within the modules, summarizing them recursively and updating their docstrings with project context.\n\nFinally, it writes an index page and individual pages for each module in the output directory.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\docgenerator.py:main:b8a22c48dd45bcff9dac85bd491cd8c542bbce48d880dad8cdfc66ab96dd0ca0:b8a22c48dd45bcff9dac85bd491cd8c542bbce48d880dad8cdfc66ab96dd0ca0": "The `main` function serves as the entry point for generating HTML documentation using a local Large Language Model (LLM). It accepts command-line arguments to specify the source directory, output location, and optional parameters such as LLM server URL, model name, and maximum context tokens. The function initializes an `LLMClient` instance to interact with the language model, sets up a tokenizer, and creates necessary directories for output.\n\nIt then scans the specified source directory for Python and MATLAB files, parses each file to extract classes and functions, and generates summaries using the LLM. The summaries are cached to avoid redundant requests. After processing all files, it constructs a project outline and summary, which is used to generate class and function summaries with context. Finally, it writes index and module pages to the output directory, presenting the documentation in an expandable section format.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\html_writer.py:9c67880c807b6c13cd855d095c53d4913d92121b20e917e7adb6a440a8708ca4:9c67880c807b6c13cd855d095c53d4913d92121b20e917e7adb6a440a8708ca4": "This module provides utilities for rendering documentation pages using simple template substitution. It includes functions to highlight code snippets in various programming languages and to render HTML content based on project summaries and page links. The module also supports generating documentation pages for individual modules, including classes and functions with nested subfunctions and subclasses.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\html_writer.py:_highlight:2bb9920a9b9b49c9199da16dd68c8e5d3e2518092984e47793f39c6c91f0b32d:2bb9920a9b9b49c9199da16dd68c8e5d3e2518092984e47793f39c6c91f0b32d": "The `_highlight` function takes a code string and a language identifier as input. It uses the `pygments` library to highlight the code based on the specified language. If the language is \"matlab\", it uses the `MatlabLexer`; if \"python\", it uses the `PythonLexer`; otherwise, it defaults to the `TextLexer`. The highlighted code is then formatted using an HTML formatter with no classes and nowrap enabled. The function returns the highlighted code wrapped in `<pre><code>` tags for proper rendering in HTML.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\html_writer.py:_render_class:cac29a31701f7a4c055e6b619f40f52bea0c6252b152b3d9a2c0eebd7159c2b2:cac29a31701f7a4c055e6b619f40f52bea0c6252b152b3d9a2c0eebd7159c2b2": "The `_render_class` function takes a dictionary representing a class (`cls`), a programming language (`language`), and an optional indentation level (`level`) as input. It returns a list of HTML strings that represent the class, its subclasses, and methods.\n\n- The function starts by creating a list to store HTML parts.\n- It determines the appropriate heading tag based on the `level`, ensuring it does not exceed `<h6>`.\n- It extracts the class name from the dictionary and appends an HTML header with the class name.\n- If the class has a docstring or summary, it appends a paragraph containing this documentation.\n- The function iterates over each method in the class, rendering them using another function `_render_function` and appending the results to the list.\n- For each subclass of the current class, it appends an HTML `<details>` element with a `<summary>` for the subclass name. It then recursively calls `_render_class` on the subclass to render its contents, increasing the indentation level by 1.\n- Finally, the function returns the complete list of HTML parts representing the class and its components.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\html_writer.py:_render_function:cebabe753ef8d4e17669c148c23028bdc282d220410b70abf5645c6843ea9e31:cebabe753ef8d4e17669c148c23028bdc282d220410b70abf5645c6843ea9e31": "The `_render_function` function generates HTML content for a given function and its nested subfunctions. It takes a dictionary representing the function, a programming language (either \"Python\" or \"MATLAB\"), an optional heading level (default is 3), and an optional prefix string. The function returns a list of HTML strings.\n\nThe function starts by creating a heading tag (`h1` to `h6`) based on the provided level, using the function's signature or name as the content. It then appends any summary or docstring associated with the function, escaping HTML characters for safety. If the function has source code, it calls `_highlight` to render the code in a highlighted format.\n\nFor each subfunction nested within the current function, the function creates a `<details>` element containing a `<summary>` tag with the subfunction's signature or name. It then recursively calls itself to generate HTML for the subfunction, incrementing the heading level by 1. Each subfunction's HTML is appended to the result list.\n\nFinally, the function returns the complete list of HTML parts representing the function and its subfunctions.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\html_writer.py:_render_html:497c45498e7036c6215f7f7eca6a124e80eaeccc76054f7f97b0843300b92e97:497c45498e7036c6215f7f7eca6a124e80eaeccc76054f7f97b0843300b92e97": "The `_render_html` function takes four parameters: `title`, `header`, `body`, and `nav_html`. It reads an HTML template from a file specified by `_TEMPLATE_PATH`. The function then formats this template using the provided parameters for title, header, body, and navigation HTML. Finally, it returns the formatted HTML content with a comment indicating that it was generated by DocGen-LM.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\html_writer.py:write_index:89eacd2b4947601296d3431e24d22ee66317b84db8cde5b893185697b8a72ee8:89eacd2b4947601296d3431e24d22ee66317b84db8cde5b893185697b8a72ee8": "The `write_index` function generates the HTML content for an index page in a project's documentation. It takes parameters for the output directory, project summary, navigation links, and optional module summaries. The function creates the destination directory if it doesn't exist, constructs the HTML body with the project summary and module links, and writes the rendered HTML to `index.html`.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\html_writer.py:write_module_page:9bd12da679933b7335771a618e7136aa9b5c5fbf8eebda8ecb2e5d60f00b205d:9bd12da679933b7335771a618e7136aa9b5c5fbf8eebda8ecb2e5d60f00b205d": "The `write_module_page` function generates an HTML documentation page for a module. It takes the output directory, module data, and page links as input. The function creates the destination directory if it doesn't exist. It constructs navigation items based on the provided page links. The body of the page includes a summary of the module, rendered classes, and functions. Each class and function is rendered using helper functions `_render_class` and `_render_function`. Finally, the HTML content is generated using `_render_html` and written to a file in the output directory.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\llm_client.py:8507043bc5e86fc826385a372aef087c5d4a12ac74a478e75c1ddc0ce048004a:8507043bc5e86fc826385a372aef087c5d4a12ac74a478e75c1ddc0ce048004a": "This module provides an interface to a local language model (LLM) backend using the LMStudio HTTP API. It includes:\n\n- A `SYSTEM_PROMPT` for the documentation engine.\n- `_COMMON_RULES` defining guidelines for generating summaries.\n- A `README_PROMPT` for enriching project documentation.\n- `PROMPT_TEMPLATES` for different types of code elements (module, class, function, README, project).\n- A `sanitize_summary` function to clean up generated summaries.\n- An `LLMClient` class with methods:\n- `ping`: Checks if the LMStudio API is reachable.\n- `summarize`: Generates a summary for given text using a specified prompt type.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\llm_client.py:LLMClient:__init__:700c23b8c0716a1aaf00c10fbc2e056bef4f6e1dca9c72b739185f920ef55cf8:700c23b8c0716a1aaf00c10fbc2e056bef4f6e1dca9c72b739185f920ef55cf8": "Initializes an object with a base URL and a model. The base URL is stored after removing any trailing slashes, and the endpoint for chat completions is constructed using this base URL. The model type is also set during initialization.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\llm_client.py:LLMClient:c116cc3ecf1838b02777408c04654cd7fcdad131536c8f9cd801f46136cbf413:c116cc3ecf1838b02777408c04654cd7fcdad131536c8f9cd801f46136cbf413": "The `LLMClient` class is designed for interacting with a language model to generate summaries. It provides methods for checking API reachability (`ping`) and for summarizing text using specified prompts, handling retries on failures.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\llm_client.py:LLMClient:ping:3fe5655e89accd067c6ddc9c1cc323c9dd9eac2dea9be6646ea4d470b3e0a436:3fe5655e89accd067c6ddc9c1cc323c9dd9eac2dea9be6646ea4d470b3e0a436": "Function `ping` checks if the API is reachable. It sends a GET request to the base URL with an optional timeout parameter. If the server responds successfully, it returns `True`. If there's a connection error or any other exception during the request, it raises a `ConnectionError` indicating that the server cannot be contacted.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\llm_client.py:LLMClient:summarize:b1a476007dba66e5510bf80c9aee0418d5bacde02f9b1185988415d3f5b7a4f3:b1a476007dba66e5510bf80c9aee0418d5bacde02f9b1185988415d3f5b7a4f3": "The function `summarize` takes a string `text` and a string `prompt_type`. It uses the specified `prompt_type` to generate a prompt from a template, constructs a payload with the model settings and the generated prompt, and sends this payload to an endpoint using HTTP POST. The response is parsed for content, which is then sanitized and returned as a summary. If the request fails due to HTTP errors or other exceptions, it retries up to three times before raising a `RuntimeError` with the last error message.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\llm_client.py:sanitize_summary:f75f156855e0a3815147bf887b1c4f24e2f85eab114e145e0e0ab70273f77e77:f75f156855e0a3815147bf887b1c4f24e2f85eab114e145e0e0ab70273f77e77": "The `sanitize_summary` function processes a given text by removing lines that start with specific phrases considered meta-commentary or redundant. It also filters out lines containing certain keywords related to summaries, outputs, and responses. The function returns the sanitized text after stripping leading and trailing whitespace.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\parser_matlab.py:15cf90e58e5b33528fe0fc6fa2e48fa77e43bd0fed902a29ea22b67a2f78ff68:15cf90e58e5b33528fe0fc6fa2e48fa77e43bd0fed902a29ea22b67a2f78ff68": "Parses MATLAB `.m` files to extract file header comments and function declarations. Returns a dictionary with the file header as a string and a list of dictionaries for each function, containing the function name and its arguments.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\parser_matlab.py:parse_matlab_file:5598ab15cd6a08bc7cbca585c2bc530d31f3db95f4f79fdae0f9bd53e292e331:5598ab15cd6a08bc7cbca585c2bc530d31f3db95f4f79fdae0f9bd53e292e331": "The `parse_matlab_file` function reads and parses a MATLAB `.m` file to extract its structure. It returns a dictionary containing the file's header comments and any function declarations found. Each function entry includes the function name and a list of arguments. The function uses regular expressions to identify and parse function declarations within the file content.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\parser_python.py:9b7a83be6356666450a5a1a457ffe2e114b6726c1c43053f6e27962b7ce8f0aa:9b7a83be6356666450a5a1a457ffe2e114b6726c1c43053f6e27962b7ce8f0aa": "This Python module provides a parser for Python files used by DocGen-LM. It uses the `ast` module to extract structured information from Python code according to the Software Requirements Specification (SRS). The module includes functions to format function signatures, parse classes and functions, and parse entire Python source files into structured dictionaries.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\parser_python.py:_format_arg:e0d9924943380385507391b9992c426c1d6219aa72f4442277568d536123fa39:e0d9924943380385507391b9992c426c1d6219aa72f4442277568d536123fa39": "Formats a function argument by appending its type annotation, if available.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\parser_python.py:_format_arguments:eb0ae4c81dbadfa661cc88660ed715a176c584ebbf70dd55cd60ea97ba3dbb99:eb0ae4c81dbadfa661cc88660ed715a176c584ebbf70dd55cd60ea97ba3dbb99": "The function `_format_arguments` takes an `ast.arguments` object as input and returns a string representation of the arguments it contains. It processes positional-only arguments, regular arguments, variable positional arguments, keyword-only arguments, and variable keyword arguments, formatting each according to its type and default value if provided.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\parser_python.py:_format_signature:905da678e4ccfed5b3ce0382e4fbf100b4e2d0fe623baae2fd33875fa3d4d91f:905da678e4ccfed5b3ce0382e4fbf100b4e2d0fe623baae2fd33875fa3d4d91f": "This function `_format_signature` takes an `ast.FunctionDef` or `ast.AsyncFunctionDef` object as input and returns a string representing the signature of the function. It formats the function's name, arguments, and return type using helper functions `_format_arguments` and `ast.unparse`. The resulting string includes the function name followed by its parameters in parentheses, and an arrow indicating the return type if specified.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\parser_python.py:_parse_classes:c101ce09e11b55c209b06e0b78c4909a12bfa338cb0e389403aae5a8d77fbe65:c101ce09e11b55c209b06e0b78c4909a12bfa338cb0e389403aae5a8d77fbe65": "The function `_parse_classes` recursively parses all `ClassDef` nodes within a given list of AST nodes. It iterates through each node, checking if it is an instance of `ClassDef`. If so, it calls the `parse_class` function to process the class and adds the result to the `classes` list. If the node is an instance of `FunctionDef` or `AsyncFunctionDef`, it recursively calls `_parse_classes` on the body of the function to search for nested classes. The function returns a list of dictionaries, each representing a parsed class.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\parser_python.py:parse_class:13a97c7933d2a27d1ebc4d1ad4f3f45ba7e17b41d59a822cbd5a043051af42e1:13a97c7933d2a27d1ebc4d1ad4f3f45ba7e17b41d59a822cbd5a043051af42e1": "The `parse_class` function takes an AST node representing a class and the source code as input. It returns a dictionary containing information about the class, including its name, docstring, methods, subclasses, and source code segment. The function iterates through the body of the class to identify and parse any nested functions (methods) using the `parse_function` function. It also recursively parses any nested classes using `_parse_classes`.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\parser_python.py:parse_classes:90065d9cf5b49d99410d23b5cdc778a556a8d0e87790134398c1738026f01a5b:90065d9cf5b49d99410d23b5cdc778a556a8d0e87790134398c1738026f01a5b": "This function, `parse_classes`, serves as a public interface for parsing classes from an abstract syntax tree (AST) node. It takes two parameters: `node`, which is an AST node, and `source`, a string representing the source code. The function retrieves the body of the node using `getattr` and passes it along with the source code to the private helper function `_parse_classes`. The result of `_parse_classes` is returned as a list of dictionaries, each containing information about a class parsed from the AST.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\parser_python.py:parse_function:f7f49041e461d3cb7edf716b0cbfc8823b0e306099d9ae1139432003802d1353:f7f49041e461d3cb7edf716b0cbfc8823b0e306099d9ae1139432003802d1353": "The `parse_function` function takes an AST node representing a function or async function and the source code as input. It returns a dictionary containing information about the function, including its name, signature, return type, docstring, source code segment, subfunctions, and subclasses. The function iterates through the body of the node to identify nested functions and classes, recursively parsing them and adding them to the `subfunctions` and `subclasses` lists in the returned dictionary.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\parser_python.py:parse_python_file:cf3e3bd7220b249ab45081416ce0cab661080776b9186cf5a5b3232df88e8cd9:cf3e3bd7220b249ab45081416ce0cab661080776b9186cf5a5b3232df88e8cd9": "The `parse_python_file` function reads a Python source file and extracts structured information. It takes the file path as input and returns a dictionary containing the module docstring, classes, and functions. The function uses the `ast` module to parse the source code and iterates through the nodes to identify and extract class and function definitions. Each class and function is parsed using helper functions (`parse_class` and `parse_function`).",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\reviewer.py:4f9d422499a1acff78c67b05122179a409cbacd25a4c242442e0aef707dbeb81:4f9d422499a1acff78c67b05122179a409cbacd25a4c242442e0aef707dbeb81": "This module provides a tool to review HTML documentation generated by DocGen-LM. It includes functions to check for assistant-like phrases, contradictions, and hallucinations in the HTML content. The `review_directory` function processes all `.html` files within a specified directory, applying these checks and optionally fixing issues by sanitizing paragraphs using `sanitize_summary`. The tool can be run from the command line with arguments specifying the directory path and an optional flag to enable autofixing of detected issues.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\reviewer.py:_extract_tags:a0b22b616fa87d5c415ec561519892f09216ec4ded32fb4aaaeade0cc15ec4f2:a0b22b616fa87d5c415ec561519892f09216ec4ded32fb4aaaeade0cc15ec4f2": "The function `_extract_tags` extracts all content within HTML tags of a specified type from a given HTML string. It uses a regular expression pattern to match the opening and closing tags, capturing the text between them. The function returns a list of strings, each representing the content within a matched tag.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\reviewer.py:_find_line_number:a7997783e605599073cb2a31ba5d3eb35e95192560d5eacce15c14358a2784cd:a7997783e605599073cb2a31ba5d3eb35e95192560d5eacce15c14358a2784cd": "The function `_find_line_number` searches for a specific phrase within an HTML string and returns the line number where the phrase is found. If the phrase is not present, it returns -1. The search is case-insensitive.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\reviewer.py:_is_generated_html:57ba312ae1db1478610fa37bf92e4f01379629818adfdd091baaa8f5e4d299d0:57ba312ae1db1478610fa37bf92e4f01379629818adfdd091baaa8f5e4d299d0": "This function checks whether a given string `text` appears to be generated by the DocGen-LM tool. It returns `True` if the text contains specific markers indicating it is documentation output, such as \"Generated by DocGen-LM\", an `<h1>` heading for project documentation, or headings for classes and methods in HTML format.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\reviewer.py:_review_file:429df077471cd6c1abadda25da99f6020bbdf5e43bfc231898d040e751eaba64:429df077471cd6c1abadda25da99f6020bbdf5e43bfc231898d040e751eaba64": "The `_review_file` function reads the content of a file at the specified `path`, checks for issues such as assistant phrasing, contradictions, and hallucinations in the HTML content, and appends messages to a list if any issues are found. If `autofix` is set to `True` and there are issues, it sanitizes the paragraphs in the HTML and writes the updated content back to the file. The function returns a list of issue messages.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\reviewer.py:_sanitize_paragraphs:89e8a38436e5dc518047151881c60997579098355a718eea0ac30e67f4e83fda:89e8a38436e5dc518047151881c60997579098355a718eea0ac30e67f4e83fda": "The function `_sanitize_paragraphs` processes an HTML string by sanitizing the content within `<p>` tags. It uses a regular expression to match the content of each paragraph and applies two transformations: it strips HTML from the matched content using `_strip_html`, and then sanitizes the summary using `sanitize_summary`. The sanitized content is then wrapped back in `<p>` tags.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\reviewer.py:_strip_html:7f798c74346ceee2e44463ab47f559f3d5beae9bd4729044ebddbe9c68a27199:7f798c74346ceee2e44463ab47f559f3d5beae9bd4729044ebddbe9c68a27199": "The `_strip_html` function takes a string `text` as input and returns a new string with all HTML tags removed. It uses the `re.sub` method from the `re` module to substitute any sequence of characters enclosed in angle brackets (`<...>`) with an empty string, effectively stripping away HTML markup.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\reviewer.py:check_assistant_phrasing:a637ef22e97a198c52fb8e35ebd15d1551a41186c42ca252bb5293bddc50c66a:a637ef22e97a198c52fb8e35ebd15d1551a41186c42ca252bb5293bddc50c66a": "This function `check_assistant_phrasing` analyzes HTML content to identify and list occurrences of phrases that resemble assistant-generated text. It extracts paragraph tags from the HTML, strips away any HTML formatting, converts the text to lowercase for case-insensitive comparison, and checks if any predefined assistant-like phrases are present. If a match is found, it records the phrase along with its line number in the original HTML. The function returns a list of these findings.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\reviewer.py:check_contradictions:5134c687763b2cecaac55f299ae74e5b5dfb922054ca17464b0c444a027569cd:5134c687763b2cecaac55f299ae74e5b5dfb922054ca17464b0c444a027569cd": "The `check_contradictions` function analyzes an HTML document to identify contradictions between the text content and the structure of the document. It returns a list of contradiction descriptions.\n\n- The function extracts paragraphs, summary text, method headers, function headers, and class headers from the HTML.\n- It checks if the summary text claims there are no methods, functions, or classes but finds corresponding headers in the document.\n- If such contradictions are found, they are added to the findings list, which is returned at the end of the function.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\reviewer.py:check_hallucinations:31aa479c66692233f6313fda5d816321f9aac85b3e9f4bed5af55adc4d98b431:31aa479c66692233f6313fda5d816321f9aac85b3e9f4bed5af55adc4d98b431": "This function `check_hallucinations` takes an HTML string as input and returns a list of hallucination phrases detected within the paragraph tags (`<p>`). It uses a helper function `_extract_tags` to extract all paragraph elements from the HTML, then processes each paragraph by stripping HTML tags and converting it to lowercase. It checks if any predefined hallucination terms are present in the text and appends them to the findings list if detected.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\reviewer.py:main:f48dd5211dce9826b30295bb0126e360751572cde59da309461b694bcd7bc8c6:f48dd5211dce9826b30295bb0126e360751572cde59da309461b694bcd7bc8c6": "The `main` function sets up an argument parser for a command-line interface. It accepts two arguments: the path to an HTML output directory and an optional flag (`--autofix`) to indicate whether files should be automatically rewritten to fix issues. The parsed arguments are then used to call the `review_directory` function, passing it the specified directory path and the autofix flag. The function returns 0 upon successful execution.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\reviewer.py:review_directory:f1b8d094453e478146c4938987afe1eed0c3dc83ba5f7b8c1c6e58b0f78d4217:f1b8d094453e478146c4938987afe1eed0c3dc83ba5f7b8c1c6e58b0f78d4217": "The `review_directory` function scans a directory and its subdirectories for HTML files. It iterates through each file, reviews it using the `_review_file` function with an optional autofix parameter, and prints any results or errors encountered during the review process.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\scanner.py:_is_subpath:7a1c62d5b8f2351f8d11e655e42fbe63cf202da573a68d65f8c1294b1c2c8270:7a1c62d5b8f2351f8d11e655e42fbe63cf202da573a68d65f8c1294b1c2c8270": "This function checks whether a given `path` is a subpath of another `parent` path. It returns `True` if the `path` is equal to or inside the `parent`, and `False` otherwise. The check is performed using the `relative_to` method, which raises a `ValueError` if the `path` is not related to the `parent`.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\scanner.py:fd7e0f952dd35ca841116789b2d99cfc36e1d26a7cf0ee616028fe9532c20347:fd7e0f952dd35ca841116789b2d99cfc36e1d26a7cf0ee616028fe9532c20347": "The module implements a function to recursively discover Python (``.py``) and Objective-C (``.m``) source files within a specified directory. It includes an ignore mechanism based on relative paths provided by the user. The function filters out directories named `.git` and any paths listed in the ignore list, ensuring that only relevant source files are returned as absolute paths.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\scanner.py:scan_directory:b3164bca9af1a968857ae96883083ad0c1a7fed37d05d5ec782b8c0c84d577cb:b3164bca9af1a968857ae96883083ad0c1a7fed37d05d5ec782b8c0c84d577cb": "The `scan_directory` function recursively discovers Python (``.py``) and MATLAB (``.m``) files under a specified base directory while ignoring certain subpaths. It returns a list of absolute paths to the discovered source files. The function uses `os.walk` to traverse the directory tree, filters out ignored directories and internal `.git` folders, and checks if each file has a valid extension before adding its absolute path to the results list.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_cache.py:97b2ae8f04e70da29a7fb5d7cb91652ea871818ccc183154b3320347b5835642:97b2ae8f04e70da29a7fb5d7cb91652ea871818ccc183154b3320347b5835642": "The module defines two functions for testing a response cache implementation. The first function, `test_cache_round_trip`, tests setting and retrieving an item from the cache. It creates a temporary cache file, sets a key-value pair in the cache, and then retrieves it to ensure the value is correct.\n\nThe second function, `test_cache_get_missing`, tests retrieving a non-existent item from the cache. It creates a new cache instance with a temporary file and attempts to retrieve an item using a non-existent key, expecting `None` as the result.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_cache.py:test_cache_get_missing:27e2e4b6efe5a38ba878bec1cb849e6b035970cfe36f44d1d9f50cbe37a644e4:27e2e4b6efe5a38ba878bec1cb849e6b035970cfe36f44d1d9f50cbe37a644e4": "This function tests the `get` method of the `ResponseCache` class. It creates a temporary directory and initializes a `ResponseCache` object with a path to a JSON file in that directory. The test asserts that calling the `get` method with a key that does not exist in the cache returns `None`.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_cache.py:test_cache_round_trip:0f91817a4ff7db12520fa3ffbd3f1d5c72b0e7feff803c15dafb369b2cde7b3c:0f91817a4ff7db12520fa3ffbd3f1d5c72b0e7feff803c15dafb369b2cde7b3c": "This function tests the round-trip functionality of a `ResponseCache` object. It creates a temporary file to store cache data, initializes a `ResponseCache` instance with this file path, sets a key-value pair in the cache, and then reads it back to verify that the value has been correctly stored and retrieved.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_docgenerator.py:f2ca5450559117c1a1532fb94c1afcd2a671f9748bd262e781e51a0a10c27633:f2ca5450559117c1a1532fb94c1afcd2a671f9748bd262e781e51a0a10c27633": "This module contains unit tests for a documentation generation tool. It uses the `unittest.mock` library to patch dependencies and the `pathlib` library to handle file paths. The tests cover various scenarios, including:\n\n1. Skipping invalid Python files due to syntax errors.\n2. Generating summaries for classes and functions with valid Python code.\n3. Handling non-UTF8 encoded files.\n4. Summarizing classes without docstrings.\n5. Sanitizing project summaries.\n6. Using README content as a summary.\n7. Cleaning the output directory before generating new documentation.\n8. Summarizing text in chunks to handle long inputs.\n9. Ensuring methods within classes are summarized individually.\n10. Handling subclasses and their methods.\n\nThe tests interact with an `LLMClient` mock object to simulate responses from a language model used for summarization, and they verify the correctness of the output by checking file existence and content.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_docgenerator.py:test_chunking_accounts_for_prompt_overhead:4eb42136ad689cff1bc8a026d8501443890494750a2bb3e9290f2941ce55d967:4eb42136ad689cff1bc8a026d8501443890494750a2bb3e9290f2941ce55d967": "This function `test_chunking_accounts_for_prompt_overhead` tests the `_summarize_chunked` function from the `docgenerator.py` module. It uses a temporary path for caching responses, sets up a tokenizer, and defines a template for summarizing modules. The function calculates the prompt overhead by encoding the system prompt and an empty template with the tokenizer. It then sets a maximum context token limit that includes this overhead plus 10 tokens. The test patches the `_summarize` function to return a fixed summary value. It calls `_summarize_chunked` with various parameters, including a mock client object, cache instance, key prefix, text, prompt type, tokenizer, and maximum context tokens. The assertion checks that the `_summarize` function was called more than once, indicating that the text was chunked to account for prompt overhead.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_docgenerator.py:test_clean_output_dir:5d3393002f0231387743cdb4c4f5674bbf8803d12b624740ba0f26e39b4c01a4:5d3393002f0231387743cdb4c4f5674bbf8803d12b624740ba0f26e39b4c01a4": "The `test_clean_output_dir` function tests the `clean_output_dir` function from the `docgenerator.py` module. It creates a temporary directory structure with files and subdirectories, simulating an output directory for documentation generation. The function then calls `clean_output_dir` to clean the directory, which should remove files that were generated by DocGen-LM while leaving other custom files intact. The test asserts that the generated file is deleted, but the custom and asset files remain.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_docgenerator.py:test_generates_class_and_function_summaries:f8d6d3ef50ab2b759f3f20b15a5cac313b180549bc96dd02b5d91ff6145c0d4d:f8d6d3ef50ab2b759f3f20b15a5cac313b180549bc96dd02b5d91ff6145c0d4d": "The function `test_generates_class_and_function_summaries` tests the generation of summaries for classes and functions within a Python project using the `docgenerator` module. It creates a temporary project directory with a single Python file containing a class (`Foo`) and a function (`bar`). The function then calls the main documentation generation process, mocking the `LLMClient` to return predefined summaries for various elements in the project. After running the main function, it asserts that the generated HTML files contain the expected summaries for the class and function, as well as the module summary.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_docgenerator.py:test_handles_class_without_docstring:4f15abe9d5016ea1ccf4b9167803c73c258f3a0298a28ad548ff4e5f379864ef:4f15abe9d5016ea1ccf4b9167803c73c258f3a0298a28ad548ff4e5f379864ef": "The function `test_handles_class_without_docstring` tests the handling of a Python class without a docstring by simulating the documentation generation process. It creates a temporary project directory with a single Python file containing an unannotated class, sets up a mock LLM client to return predefined summaries for module, project, and class, and then invokes the main function of the `docgenerator` module. The test asserts that the generated HTML output includes the summary for the class.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_docgenerator.py:test_project_summary_is_sanitized:4f304a65acf9277ea201c8103e7415c7052f93f875d368194888332e88d8e2b4:4f304a65acf9277ea201c8103e7415c7052f93f875d368194888332e88d8e2b4": "The function `test_project_summary_is_sanitized` tests the sanitization of project summaries generated by the `docgenerator.py` module. It creates a temporary project directory with a Python file, sets up mock interactions with an `LLMClient` to simulate language model responses, and runs the main documentation generation process. The test asserts that the output HTML does not contain specific phrases (\"You can run this\") while ensuring that the \"project summary\" was passed to the language model for processing.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_docgenerator.py:test_readme_summary_used:a0b784f365e8c48688facaa97bfdf6b260f1e86bc7dbd77f3c18d489d413d05d:a0b784f365e8c48688facaa97bfdf6b260f1e86bc7dbd77f3c18d489d413d05d": "This function, `test_readme_summary_used`, is a unit test for the documentation generation process using the DocGen-LM tool. It creates a temporary project directory with a Python module and a README file. The function then calls the main documentation generation function with this project directory and an output directory. During the execution, it mocks the `LLMClient` class to simulate interactions with a language model for summarization purposes. The test asserts that the README summary is included in the generated HTML documentation and that the language model was called with the correct parameters to generate the summary of the README content.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_docgenerator.py:test_skips_invalid_python_file:fc456ee485ea270b25e7572c5443230408762f4f8adc45b0047c99c4ee38161c:fc456ee485ea270b25e7572c5443230408762f4f8adc45b0047c99c4ee38161c": "The function `test_skips_invalid_python_file` tests the behavior of the documentation generation process when encountering a Python file with invalid syntax. It creates a temporary project directory containing a file named `bad.py` that has leading zeros in an integer literal, which is invalid Python syntax. The function then calls the main documentation generation function with this project directory and a specified output directory.\n\nThe test uses a mock `LLMClient` to simulate interactions with a language model, ensuring that the client's `ping` method returns `True` (indicating the client is available) and its `summarize` method returns a dummy summary. The main function is called with the project directory and output directory as arguments.\n\nAfter running the main function, the test asserts that the return value is `0`, indicating successful execution. It then checks that only an index page (`index.html`) is generated in the output directory, while no HTML file for the invalid Python file (`bad.html`) is created. This confirms that the documentation generation process correctly skips files with syntax errors.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_docgenerator.py:test_skips_non_utf8_file:0eda8a69fbbc037ee80cd91560c17ed6d5ed6f255f06c78c4ecc017eda060d47:0eda8a69fbbc037ee80cd91560c17ed6d5ed6f255f06c78c4ecc017eda060d47": "This function, `test_skips_non_utf8_file`, is a test case designed to verify that the documentation generation process skips files that are not encoded in UTF-8. It uses a temporary directory (`tmp_path`) to create a project directory with a non-UTF-8 file named \"bad.py\". The function then calls the main function of the `docgenerator` module, passing the project directory and output directory as arguments. It asserts that the return value of the main function is 0, indicating success. Additionally, it checks that an index.html file exists in the output directory but not a bad.html file, confirming that non-UTF-8 files are skipped during documentation generation.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_docgenerator.py:test_structured_chunker_keeps_functions_atomic:90d285d7957b01e598b5a8df5964a5764e602e64adb443d910ababce80baf605:90d285d7957b01e598b5a8df5964a5764e602e64adb443d910ababce80baf605": "This function tests the `structured_chunker` functionality by ensuring that functions are kept atomic during summarization. It uses a temporary directory to create a Python file with two functions, parses it, and then simulates an LLM client to summarize the module in chunks. The test checks if the number of chunks matches the number of functions and if each chunk corresponds to one of the parsed functions' source code.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_docgenerator.py:test_structured_chunker_splits_large_class_by_method:dd6431db041dc565f6df5c702455f34189bf9356a118849b3c83f194b6140f1b:dd6431db041dc565f6df5c702455f34189bf9356a118849b3c83f194b6140f1b": "This function, `test_structured_chunker_splits_large_class_by_method`, tests the functionality of splitting a large Python class into chunks based on its methods. It uses a temporary file to store the source code of a class with two methods. The function then parses this file and sets up a mock tokenizer and cache for summarization purposes. Using a patch, it mocks the `_summarize` function to return a fixed value. The function calculates the budget for token usage based on the length of the tokenizer's encoding of the class source and overhead from system prompts and module templates. It then calls `_summarize_module_chunked` with these parameters, expecting each method's source code to be passed as a chunk to the mock summarization function. Finally, it asserts that the number of chunks matches the number of methods and that the set of chunks contains all method sources.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_docgenerator.py:test_subclass_methods_are_summarized:80953c29703ecfd84e5a3dfe5da18e44f8e28789e8261466bd8c7db815fba469:80953c29703ecfd84e5a3dfe5da18e44f8e28789e8261466bd8c7db815fba469": "This function, `test_subclass_methods_are_summarized`, is a test case designed to verify that methods within subclasses are correctly summarized when generating documentation. It uses the `tmp_path` fixture to create a temporary project directory and writes a Python file containing a class with a nested subclass and a method. The function then calls the main documentation generation process using a mock `LLMClient` and a mock `_summarize` function, which returns a fixed summary string. After running the test, it checks if the method name \"B:m\" is present in any of the arguments passed to the `_summarize` function, indicating that subclass methods were successfully summarized during the documentation process.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_docgenerator.py:test_summarize_chunked_splits_long_text:9a1c1eb2fc7cd567c656228528556183365a725c7bdfa71dc1790f0fcbd54fb5:9a1c1eb2fc7cd567c656228528556183365a725c7bdfa71dc1790f0fcbd54fb5": "This function tests the `_summarize_chunked` method from the `docgenerator` module. It sets up a temporary cache directory, creates a tokenizer, and defines a long text string to be summarized. The function uses the `patch` decorator to mock the `_summarize` method, which is called within `_summarize_chunked`. The test asserts that the mocked `_summarize` method was called more than once, indicating that the input text was chunked and processed in multiple calls.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_docgenerator_subclasses.py:0fe483931aa675c30839a1cb49e71a4b7aaf03932ad088e2784291adc1ede8f0:0fe483931aa675c30839a1cb49e71a4b7aaf03932ad088e2784291adc1ede8f0": "This module defines a test function `test_subclass_docs_and_method_summary` that uses the `unittest.mock.patch` decorator to mock an `LLMClient`. The function creates a temporary project directory with a Python module containing a nested class and a method. It then calls the `main` function from the `docgenerator` module, passing the path to the project directory and specifying an output directory for documentation. The test asserts that the return value of `main` is 0, indicating success. Additionally, it checks that the generated HTML documentation contains summaries for the nested class and its method.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_docgenerator_subclasses.py:test_subclass_docs_and_method_summary:8c3cdebd8490a473a1298a23ec222fd4101874c187087598b1dd2affd26fe179:8c3cdebd8490a473a1298a23ec222fd4101874c187087598b1dd2affd26fe179": "The function `test_subclass_docs_and_method_summary` tests the documentation generation process for a Python project containing a subclass with a method. It sets up a temporary project directory, creates a Python file with a nested class and method, and configures an mock LLM client to return summaries for classes and methods. The function then runs the main documentation generation process and checks if the generated HTML contains the expected summary elements for both the class and the method.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_html_writer.py:a1aeaba6fec7461888e75a51cdc213dbeb5d81eaf06741979e1d495b15314fc9:a1aeaba6fec7461888e75a51cdc213dbeb5d81eaf06741979e1d495b15314fc9": "This module contains tests for functions `write_index` and `write_module_page` from the `html_writer.py` file. The tests use `tmp_path` to create temporary files and verify that the output HTML is correctly generated based on the input data. The tests check for specific HTML elements, attributes, and content to ensure that the documentation is rendered as expected.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_html_writer.py:test_subclass_rendering:4a1da1f77441a98a6a8dadf967fbfa93a82560ceb9d9b2e14882a345e506d48e:4a1da1f77441a98a6a8dadf967fbfa93a82560ceb9d9b2e14882a345e506d48e": "The function `test_subclass_rendering` tests the rendering of subclass information in HTML documentation. It creates a mock module data structure with a class `A` that has a subclass `B`. The function writes this module data to an HTML file using the `write_module_page` function and then reads the generated HTML content. It asserts that the HTML contains details tags, mentions \"Class: B\", includes the method signature \"def m(self)\", and highlights one code snippet.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_html_writer.py:test_subfunction_rendering:3bf56d99891284d48b8e7978cb3b2555e33caf4bdb51c2b28b7afa25caa2808b:3bf56d99891284d48b8e7978cb3b2555e33caf4bdb51c2b28b7afa25caa2808b": "The function `test_subfunction_rendering` tests the rendering of subfunctions in HTML documentation. It creates a mock module data structure with an outer function containing a nested inner function. The function then writes this module page to a temporary directory using the `write_module_page` function and reads the generated HTML file. It asserts that the HTML contains details tags, references to the inner subfunction, and that both the outer and inner functions' source code are highlighted in `<pre><code>` blocks.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_html_writer.py:test_write_index:c6cb96b081ff7530699d98efc86d7c4d43e4b94c8c3f373759459f3ea652e65e:c6cb96b081ff7530699d98efc86d7c4d43e4b94c8c3f373759459f3ea652e65e": "The `test_write_index` function tests the `write_index` function from the `html_writer.py` module. It creates a temporary directory, defines links and summaries for modules, and calls `write_index` to generate an HTML index file. The test checks that the generated HTML contains expected elements such as the generation comment, project summary, module links, and summaries. It ensures that special characters in module names are correctly escaped and that only one summary is rendered.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_html_writer.py:test_write_module_page:5a5ea8c862256be0eedd7f8a177bea8ffbae4282de37350d5b60523b9bb59e0e:5a5ea8c862256be0eedd7f8a177bea8ffbae4282de37350d5b60523b9bb59e0e": "The `test_write_module_page` function tests the `write_module_page` function from the `html_writer.py` module. It creates a temporary directory, simulates module data including classes and functions, and writes an HTML module page using this data. The test checks that the generated HTML contains expected elements such as project overview link, module summary, class details, method signatures, and function definitions. It also verifies that code snippets are correctly highlighted in `<pre><code>` tags.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_integration.py:e977cba7f0b91bc157a456c9b49e68be4ca45d263b578fcfe7b372ef54d38deb:e977cba7f0b91bc157a456c9b49e68be4ca45d263b578fcfe7b372ef54d38deb": "This module contains two tests for a documentation generator. The first test, `test_docgenerator_generates_html`, verifies that the generator can process Python and MATLAB files, create HTML output, and include summaries generated by an LLMClient mock. The second test, `test_static_copied_from_any_cwd`, checks if static files are correctly copied to the output directory regardless of the current working directory.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_integration.py:test_docgenerator_generates_html:a0d9d9da446675eadb6249b97685b0159af6b1b4c46f3ea7cc346e5534f9f484:a0d9d9da446675eadb6249b97685b0159af6b1b4c46f3ea7cc346e5534f9f484": "The function `test_docgenerator_generates_html` tests the documentation generation process using a mock LLMClient. It creates a temporary project directory with simple Python and MATLAB files, then calls the main function to generate HTML documentation. The test asserts that the output directory contains index and module-specific HTML files, and that the generated HTML includes a summary provided by the mock client.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_integration.py:test_static_copied_from_any_cwd:13790fd7f76945482466f7643cdda89a30832cffc4cab3c33cd18990277ae6b9:13790fd7f76945482466f7643cdda89a30832cffc4cab3c33cd18990277ae6b9": "This function, `test_static_copied_from_any_cwd`, tests the functionality of copying static files during documentation generation. It creates a temporary project directory with a Python module and an output directory for documentation. Using a mock LLMClient to simulate successful ping and summary responses, it runs the main documentation generation process from any working directory. The test asserts that after running, a `style.css` file is copied to the static directory of the output location.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_llm_client.py:ff8a0c5e5d3895b53e3efd3ac0badb2dca6ba723a90e55d61bc0a3a56cb89180:ff8a0c5e5d3895b53e3efd3ac0badb2dca6ba723a90e55d61bc0a3a56cb89180": "The module defines a test suite for an `LLMClient` class, which interacts with a language model. It includes tests for the client's ability to ping the server, summarize text based on different types (class, function, readme), and handle exceptions during requests. The tests use mocking to simulate HTTP responses and assert the behavior of the client methods under various conditions.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_llm_client.py:test_ping_failure:19eb50c0f90cc7b95070f705ac1da2354b6f9ca1e22d0ef8e33300a139582f68:19eb50c0f90cc7b95070f705ac1da2354b6f9ca1e22d0ef8e33300a139582f68": "This function tests the `ping` method of the `LLMClient` class when a connection failure occurs. It creates an instance of `LLMClient` with a fake server URL and uses the `patch` decorator from the `unittest.mock` module to simulate a request exception during the ping operation. The test asserts that a `ConnectionError` is raised as expected when attempting to connect to the fake server.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_llm_client.py:test_ping_success:9c46ea1985c73462f3542e55b19e292985d90dd3554059a66f07251a27e5da30:9c46ea1985c73462f3542e55b19e292985d90dd3554059a66f07251a27e5da30": "The function `test_ping_success` tests the `ping` method of the `LLMClient` class. It creates an instance of `LLMClient` with a fake URL, sets up a mock response that does not raise any exceptions when calling `raise_for_status`, and uses the `patch` decorator from the `unittest.mock` module to mock the `requests.get` function. The test asserts that the `ping` method returns `True`, indicating a successful ping, and verifies that the `get` function was called once with the specified URL and timeout, as well as that `raise_for_status` was called on the mock response object.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_llm_client.py:test_prompt_varies_by_type:9b663f253bb94b9eec36183f0ce23d3d26c229a09af47c22707bf989cea2268b:9b663f253bb94b9eec36183f0ce23d3d26c229a09af47c22707bf989cea2268b": "This function tests the `summarize` method of the `LLMClient` class to ensure that it generates different prompts based on the type of code being summarized. It uses a mock response from an HTTP POST request and patches the `requests.post` method to return this mock response. The function then calls the `summarize` method twice, once with \"class\" as the type and once with \"function\". It asserts that the prompts generated for classes and functions are different and match the expected prompt templates.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_llm_client.py:test_readme_prompt_template_used:692e70820cc3c34f253cdc466cf04a5563db4b0e09302c83c446808ebfe2898f:692e70820cc3c34f253cdc466cf04a5563db4b0e09302c83c446808ebfe2898f": "The function `test_readme_prompt_template_used` tests the `summarize` method of the `LLMClient` class. It creates a mock response from an HTTP POST request, which simulates the language model's response to a summary prompt. The test checks if the constructed prompt matches the expected format for README documentation using the `PROMPT_TEMPLATES[\"readme\"]`.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_llm_client.py:test_sanitize_summary_filters_phrases:f802cfe16e09719343521dcf55a5993163922e6eb154b46b1d0392c3b05578fd:f802cfe16e09719343521dcf55a5993163922e6eb154b46b1d0392c3b05578fd": "The function `test_sanitize_summary_filters_phrases` tests the `sanitize_summary` function to ensure it filters out unwanted phrases from the input text. It asserts that after sanitization, the remaining text contains only relevant information without disclaimers or introductory phrases.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_llm_client.py:test_summarize_raises_runtime_error_with_message:cdb8cf44e5932eb977c53891b40cfb9a9106d5ff07dcb64343c0df2635994c1a:cdb8cf44e5932eb977c53891b40cfb9a9106d5ff07dcb64343c0df2635994c1a": "The function `test_summarize_raises_runtime_error_with_message` tests the `summarize` method of the `LLMClient` class. It sets up a mock response that raises an HTTP error and a JSON decoding error, with the text \"server exploded\". The function then patches the `requests.post` call to return this mock response and uses `pytest.raises` to assert that calling `client.summarize(\"text\", \"module\")` raises a `RuntimeError` with the message \"server exploded\".",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_llm_client.py:test_summarize_retries_and_returns_summary:ee663393596944a003f820439ba695bc6fa96cd1a4a5029e70230dc9a9606844:ee663393596944a003f820439ba695bc6fa96cd1a4a5029e70230dc9a9606844": "This function tests the `summarize` method of the `LLMClient` class. It sets up a mock response that simulates a request failure followed by a successful response from a language model. The test asserts that the method retries on failure, calls the sleep function once with a delay of 1 second, and correctly formats the prompt using a template for module summaries.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_parser_matlab.py:d371df41f01bfadecc63c5f1bddb7b77eb2309a17405bffe247ca4a3e17973bd:d371df41f01bfadecc63c5f1bddb7b77eb2309a17405bffe247ca4a3e17973bd": "The module defines two test functions to verify the functionality of a MATLAB file parser. The `test_parse_simple_matlab` function checks if the parser correctly extracts the header and a single function from a simple MATLAB file. The `test_parse_multiple_functions` function tests the parser's ability to handle multiple functions within a single MATLAB file, ensuring that each function is correctly identified and its arguments are accurately parsed.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_parser_matlab.py:test_parse_multiple_functions:fd184fa847e203a5f4b38222c2276c3f0be060556e9e756799cc3d8e84738420:fd184fa847e203a5f4b38222c2276c3f0be060556e9e756799cc3d8e84738420": "The function `test_parse_multiple_functions` tests the parsing of multiple MATLAB functions from a file. It creates a temporary file with two MATLAB functions, `compute` and `square`, and then uses the `parse_matlab_file` function to parse the file. The test asserts that the parsed result contains no header, two functions named \"compute\" and \"square\", and correct argument lists for each function.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_parser_matlab.py:test_parse_simple_matlab:38abb857a526f63dd6e17a9f789f008dc317178541ba5120065339abdc069caa:38abb857a526f63dd6e17a9f789f008dc317178541ba5120065339abdc069caa": "The function `test_parse_simple_matlab` is a test case that verifies the functionality of parsing a simple MATLAB file. It creates a temporary MATLAB file with a header and a single function named `add`. The function takes two arguments, `x` and `y`, and returns their sum.\n\nThe test case then calls the `parse_matlab_file` function with the path to the temporary file as an argument. The result is a dictionary containing the parsed content of the MATLAB file.\n\nThe assertions check that the header of the MATLAB file is correctly extracted and that there is one function defined in the file. It further verifies that the name of the function is `add`, and that it has two arguments, `x` and `y`.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_parser_python.py:0656a74b22ae45e63880587901e7b10ae787467de6bd22083f6803af85bd3957:0656a74b22ae45e63880587901e7b10ae787467de6bd22083f6803af85bd3957": "The module defines several test functions to verify the functionality of a `parse_python_file` function from the `parser_python` module. Each test function creates a Python source file with different structures (simple module, complex signature, nested classes, deeply nested classes, and class inside method) using `textwrap.dedent`. It then parses the source file using `parse_python_file` and asserts that the parsed result matches the expected structure and content of the source code.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_parser_python.py:test_class_inside_method:53292a19592580c347dac5038a817adc65eec2c15788cac61880feeb795250e8:53292a19592580c347dac5038a817adc65eec2c15788cac61880feeb795250e8": "This function, `test_class_inside_method`, is designed to test the parsing of Python code that contains a class defined inside another method. It uses a temporary file path provided by `tmp_path` and writes a Python script with a nested class structure to this file. The function then calls `parse_python_file` to parse the content of the file.\n\nThe test asserts that:\n1. There is one top-level class named \"A\" in the parsed result.\n2. Class \"A\" has one subclass named \"B\".\n3. Subclass \"B\" contains one method named \"m\".\n\nThis ensures that the parser correctly identifies and categorizes nested classes within methods, verifying the functionality of the `parse_python_file` function for handling complex Python code structures.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_parser_python.py:test_deeply_nested_classes:28c3fb76618dc6dee098ddd7746192b88bc7d3c7500a2c2713a2c4dac5d91a1e:28c3fb76618dc6dee098ddd7746192b88bc7d3c7500a2c2713a2c4dac5d91a1e": "The function `test_deeply_nested_classes` tests the parsing of Python files containing deeply nested classes. It creates a temporary file with nested class definitions and uses the `parse_python_file` function to parse it. The test asserts that the nested classes are correctly identified and their methods are properly extracted.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_parser_python.py:test_parse_complex_signature:537607fcb72751780d7f76e56602a3f95305bb6faa3becca5f3f179fa09ca612:537607fcb72751780d7f76e56602a3f95305bb6faa3becca5f3f179fa09ca612": "This function tests the parsing of a complex Python function signature. It creates a temporary Python file with a function having positional-only parameters, keyword-only parameters, and default values. The function then parses this file using `parse_python_file` and asserts that the extracted signature matches the expected format. Additionally, it checks that the docstring and source code content are correctly captured.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_parser_python.py:test_parse_nested_structures:b78472d9c58d872720bba873dcd0dda916885bb8b56e988cbff7085833077f80:b78472d9c58d872720bba873dcd0dda916885bb8b56e988cbff7085833077f80": "The function `test_parse_nested_structures` tests the parsing of nested structures in Python files using the `parse_python_file` function. It creates a temporary file with nested functions and classes, parses it, and asserts that the parsed results correctly identify the names and relationships between the outer function, inner function, class, and method.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_parser_python.py:test_parse_simple_module:0f30508d5854d2a17e2ba5e4d47ba74b93e1ae75d895e0522108dcf2d5a962ee:0f30508d5854d2a17e2ba5e4d47ba74b93e1ae75d895e0522108dcf2d5a962ee": "This function `test_parse_simple_module` tests the parsing of a Python file containing a simple module with a class and a function. It uses a temporary directory to create a sample Python file, then parses it using the `parse_python_file` function from the `parser_python.py` module. The test checks that the parsed result contains the correct module docstring, class name, class docstring, method signature, method docstring, and source code. Additionally, it verifies that the parsed result includes a function with the correct name, signature, return type, docstring, and source code.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_reviewer.py:83233473a3bb44ee0c5e26502caa85ad29205c84af0e40280e3fd12a3f730505:83233473a3bb44ee0c5e26502caa85ad29205c84af0e40280e3fd12a3f730505": "This module defines functions to test the detection of assistant phrasing, contradictions, and hallucinations in Python modules. It uses a temporary directory to create mock module pages and then runs a `main` function from the `reviewer` module on these pages. The tests check for specific phrases like \"[ASSISTANT]\", \"[CONTRADICTION]\", and \"[HALLUCINATION]\" in the output, as well as verify that autofix removes certain phrasing from the HTML files.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_reviewer.py:_make_module:9a68726ad9d90dbac9bb8f276814962925c89500763e1fc0a747e2b474ed86fc:9a68726ad9d90dbac9bb8f276814962925c89500763e1fc0a747e2b474ed86fc": "The function `_make_module` creates a mock module page for testing purposes. It takes three parameters: `tmp_path`, which is the temporary directory where the module page will be created; `summary`, which is a string summarizing the module; and `methods`, an optional list of methods to include in a class named \"Foo\". The function returns the path to the generated module HTML file.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_reviewer.py:test_assistant_phrasing_detected:ac160dc47ae7dc91a25ed7604b83109e7b5617495db7f5296da8c1b05fc64235:ac160dc47ae7dc91a25ed7604b83109e7b5617495db7f5296da8c1b05fc64235": "This function tests if assistant phrasing is detected and logged during the documentation generation process. It creates a temporary module with assistant phrasing, runs the main documentation generator function on it, captures the output, and asserts that both \"[ASSISTANT]\" and \"mod.html\" are present in the output.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_reviewer.py:test_autofix_removes_phrasing:1b036ca82dcbc3cfe03f051900b69315b1369abacaa9208e7dc150caaabe1085:1b036ca82dcbc3cfe03f051900b69315b1369abacaa9208e7dc150caaabe1085": "The function `test_autofix_removes_phrasing` is a test function designed to verify the functionality of an autofix feature within a documentation generation tool. It takes a temporary directory path as input and creates a module file with specific content. The function then runs the main documentation generation process with the `--autofix` option on this temporary directory. After processing, it reads the generated HTML file and asserts that certain phrases (in this case, \"You can\") have been removed from the output, indicating that the autofix feature is working as expected by cleaning up phrasing in the generated documentation.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_reviewer.py:test_contradiction_detected:cb91ab1b99a15bc4a9c72d4e450f93d09a5f540e29f627edb9b49a0252159a91:cb91ab1b99a15bc4a9c72d4e450f93d09a5f540e29f627edb9b49a0252159a91": "This function `test_contradiction_detected` is designed to test the detection of contradictions within generated documentation. It creates a temporary module with specified methods, including their names, signatures, docstrings, and source code. The function then calls the main documentation generation process using the path to this temporary module as an argument. After execution, it captures the output from standard out (stdout) using `capsys`. Finally, it asserts that the string \"[CONTRADICTION]\" is present in the captured output, indicating that a contradiction was detected during the documentation generation process.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_reviewer.py:test_hallucination_detected:abe1c2332c1f7478d39af4bb58f35bead37a2cf249d914514ede76925dcad8eb:abe1c2332c1f7478d39af4bb58f35bead37a2cf249d914514ede76925dcad8eb": "The function `test_hallucination_detected` is a test function designed to verify the detection of hallucinations during documentation generation. It creates a temporary module with a specified description, runs the main documentation generation process on this module using the provided path, and then checks if the output contains the marker \"[HALLUCINATION]\".",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_scanner.py:3ec32c624e4312ae44349511245ebc4be1d33ae9233f8c4ba760f4c5f65f37f1:3ec32c624e4312ae44349511245ebc4be1d33ae9233f8c4ba760f4c5f65f37f1": "The module defines a test suite for the `scan_directory` function from the `scanner` module. It includes three tests:\n\n1. `test_scan_directory_ignore_folder`: Verifies that directories specified in the ignore list are excluded from the scan results.\n2. `test_scan_directory_mixed_file_types`: Ensures that files of various types (Python, Objective-C, text) are included in the scan results when no specific filters are applied.\n3. `test_scan_directory_skips_git_folder`: Confirms that the `.git` directory and its contents are not included in the scan results.\n\nEach test creates a temporary directory with predefined files and directories, calls `scan_directory`, and asserts that the returned set of file paths matches the expected outcome based on the test case.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_scanner.py:create_files:b322148f6c53fda1b1a7de45b17636f821ed197ad73e21ae614bba3c0e9cb634:b322148f6c53fda1b1a7de45b17636f821ed197ad73e21ae614bba3c0e9cb634": "The `create_files` function takes a base directory and a list of relative file paths as input. It iterates over each relative path, constructs the full path by appending it to the base directory, creates any necessary parent directories (if they don't already exist), and then writes an empty string to the file at that path.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_scanner.py:test_scan_directory_ignore_folder:1136cb074f1113bf9686b4afbc9efb05e184210417f9c05f1ac9087cd832a6a0:1136cb074f1113bf9686b4afbc9efb05e184210417f9c05f1ac9087cd832a6a0": "The function `test_scan_directory_ignore_folder` tests the `scan_directory` function to ensure it correctly ignores specified subpaths when scanning directories for code files. It creates a temporary directory with various files and subdirectories, including one that should be ignored. The function then calls `scan_directory` with the path of the temporary directory and a list containing the name of the directory to ignore. The result is compared to an expected set of file paths, which excludes the ignored subdirectory.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_scanner.py:test_scan_directory_mixed_file_types:d348f9059abd990c494e9fbfe5ff4bb7f525fc651593419bca39a6a657e61948:d348f9059abd990c494e9fbfe5ff4bb7f525fc651593419bca39a6a657e61948": "The function `test_scan_directory_mixed_file_types` tests the `scan_directory` function with a directory containing files of mixed types. It creates a temporary directory with various file types, including Python (`one.py`, `four.py`), MATLAB (`two.m`, `six.m`), and text (`three.txt`) files, as well as nested directories with additional files. The function then calls `scan_directory` on the temporary path and asserts that the result matches the expected set of file paths, excluding Markdown files (`five.md`).",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_scanner.py:test_scan_directory_skips_git_folder:5db78c526074e5ae2f058b9c38ce2e482d6d2bf3d1f670d4940e9f36ce3a4fbe:5db78c526074e5ae2f058b9c38ce2e482d6d2bf3d1f670d4940e9f36ce3a4fbe": "",
  "PROJECT:cce500a3de68967a7a947d04873522ed03b4ab20dc39bdb323df7da26685d2e0:cce500a3de68967a7a947d04873522ed03b4ab20dc39bdb323df7da26685d2e0": "This project consists of several modules and classes designed to process and summarize code files. The `cache.py` module defines a `ResponseCache` class for caching responses. The `docgenerator.py` module includes functions for cleaning output directories, summarizing text, and generating documentation from Python and MATLAB files. It also contains a main function for orchestrating the documentation generation process.\n\nThe `html_writer.py` module provides functions for rendering HTML content, including highlighting code snippets and writing index and module pages. The `llm_client.py` class, `LLMClient`, handles interactions with a language model to generate summaries, with a method for sanitizing summaries.\n\nThe `parser_matlab.py` and `parser_python.py` modules contain functions for parsing MATLAB and Python files, respectively, extracting classes and functions, and formatting their signatures and arguments. The `reviewer.py` module includes functions for reviewing generated documentation, checking for issues like assistant phrasing, contradictions, and hallucinations.\n\nThe `scanner.py` module defines a function to scan directories for code files, ignoring certain subpaths. Test modules (`test_cache.py`, `test_docgenerator.py`, etc.) contain numerous test functions to ensure the correctness of each component's functionality.",
  "README:e4c6be0d9ef4e33e98b4b6858d5b88aef6f78e8625e22967371440690fd23324:e4c6be0d9ef4e33e98b4b6858d5b88aef6f78e8625e22967371440690fd23324": "DocGen-LM is a tool for generating static HTML documentation for Python and MATLAB projects by analyzing source files with a local Large Language Model (LLM). It supports capturing and rendering nested functions and subclasses, presenting complex structures as expandable sections in the output. The tool can be used via a command-line interface, which allows specifying the project directory, output location, and optional parameters such as LLM server URL and model name.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\cache.py:ResponseCache:4bf39f0ddf33468e133fc0de74e4b5ffcc04454990de01f6d9556f317e81e88f:bb8c5e04ff12539d13e7ca41ecbd56f704e29527621cb046143ffeb35745f4a7": "The `ResponseCache` class is designed to persist mappings from stable keys to language model (LLM) responses. It initializes by loading data from a specified file path, creating an empty dictionary if the file does not exist or if the file content is invalid JSON. The class provides methods to generate deterministic keys from file paths and content, retrieve cached values by key, store new key-value pairs, and save the current cache state to disk in a formatted JSON structure.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\cache.py:__init__:510b9c2b56f9dc32af9a63b50be7a88e39781c61e5d22b935cd48468ad32cf9d:c0be92d5e60dff94f9ed7283b0ca40e7ff2cd68e9d19cb4fff921f5eb598c115": "Initializes a `ResponseCache` instance with a file path. If the file exists, it reads and parses its content as JSON into a dictionary; otherwise, it initializes an empty dictionary.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\cache.py:_save:b3d0bd0a94728b12969b643e3f4e6e3e7948618a989dbbf00e59390ec9770933:57397adc432be2d878922b70fa9266411c54c977605706b813c168814312c1af": "This function `ResponseCache._save` writes the current state of the cache to a file. It converts the internal `_data` dictionary to a JSON string with an indentation of 2 spaces and sorted keys for readability. The JSON string is then written to the file specified by `self.file`, using UTF-8 encoding.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\cache.py:get:0eacf0323690ef9c7abe05c0635de4c444484a7e432ebcd4727d184b87e00ef2:85ad7041fa366b5bfa1c8c126b05d84aad85cede5d8f7ee3b8893c60613aab24": "The `get` method of the `ResponseCache` class retrieves the cached value associated with a given key. If the key exists in the cache, it returns the corresponding value; otherwise, it returns `None`.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\cache.py:make_key:ee2030dcd1e9792b2dbd071a63c2a93bcde71c2de582501bd95b6669b0f16385:fd9ae4ec01fd5b3e948420b282fbb6e8e72275418bbc2d549e47da440afffd30": "The `make_key` function generates a unique key for caching responses based on a file path and its content. It uses the SHA-256 hash algorithm to create a deterministic digest of the content, then combines this digest with the file path using a colon as a separator. This key can be used as a lookup in a cache to store or retrieve responses associated with specific files and their contents.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\cache.py:set:c7cc49e392056509be85c848604b4967e9750ce5590f565618b6f2acdb083ad6:811c849682dc9c72014853d82ed7b32e911b18603cbb735aed79eab7dfc6534e": "This method stores a value in the cache using a specified key and persists the changes to disk. It takes two parameters: `key` (a string representing the unique identifier for the cached value) and `value` (the data to be stored). After storing the value, it calls `_save()` to ensure that the updated cache is written back to the file system.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\docgenerator.py:_build_function_prompt:8d1d0c517e996cfbfef719c935ecc657e52d264d30bec3094f4e6e2499dcf6d4:31d471ba5c7dac83feee014fecd04733023c07d19e3b974244d3e4f849cc70e4": "This function `_build_function_prompt` constructs a prompt for summarizing a Python function's source code. It takes four parameters: `source`, which is the function's source code; and three optional parameters: `class_name`, `class_summary`, and `project_summary`. The function returns a string that includes these parameters to provide context for the summary, followed by instructions on how to summarize the function based solely on its source code.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\docgenerator.py:_chunk_module_by_structure:2dc5dffe7a6e0f13c301a936ff594031659721e62647a1a315e3b2da52fefb9e:ac37d2fc61aaac5849c50407794c88050afb3d06c9794a02cb4990c81f1c8b4a": "This function `_chunk_module_by_structure` processes a parsed module dictionary to create text chunks suitable for tokenization. It starts by appending the module's docstring, then iterates through classes and their methods, as well as standalone functions. Each block of code (class source, method source, or function signature) is checked against a specified chunk size in tokens. If a block exceeds the chunk size, it is further split using another function `chunk_text`. The function ensures that blocks are separated by double newlines and does not exceed the token limit for each chunk. Finally, any remaining blocks are added to the list of chunks.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\docgenerator.py:_get_tokenizer:a76e2015f6c5b2841180fae77a8670b61015d3d94799138339ce7db93ea9754a:204e4eef377a18f916763e0a67b4d166299c3a3ae485075ab2f5847e6597ef55": "Returns a tokenizer object for estimating token counts. If the `tiktoken` library is installed, it uses the `cl100k_base` encoding. If not, it falls back to a simple tokenizer that splits text into words and joins them back together.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\docgenerator.py:_rewrite_docstring:a53b316cb3e3f170f2e365e5916ffc5a3d75bdd1f263ef26c02abf2ed0612287:039450bc821de677746790583236d6ca5e8e6b3f2efa9f3b461fa54875d271a7": "The `_rewrite_docstring` function rewrites the docstring of a code item using an LLM client and a response cache. It takes parameters including the client, cache, file path, and item dictionary. The function checks if there is source or docstring data; if not, it prints a warning and returns. If a docstring exists, it constructs a prompt based on optional context such as class name, summary, and project summary. A key is generated using the file path, item name, and content. The function then summarizes the chunked input using the client and updates the item's docstring with the sanitized result or a default message if no summary is available.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\docgenerator.py:_summarize_chunked:16cb5b83ce6bc4fd0bb78a645ef7361c7a85f25979b94a3623ed263f96771376:cf2fc44fa1adb0e902d551b2d8004b3e2a4b2c4e84e84b374285667df4a8d307": "The function `_summarize_chunked` is designed to summarize a given text by breaking it into smaller chunks if necessary. It uses an `LLMClient` for generating summaries and a `ResponseCache` for caching results. The function takes parameters such as the client, cache, key prefix, text, prompt type, tokenizer, maximum context tokens, and chunk token budget.\n\nThe function first determines the available tokens based on the overhead of the system prompt and template. If the text can be summarized within these available tokens, it proceeds to summarize the text using the `_summarize` function. If not, it chunks the text into smaller parts based on the available tokens and a chunk token budget. Each part is then summarized individually.\n\nAfter summarizing all parts, the function combines them into a single technical paragraph by listing each summary. It constructs a merge prompt to instruct the language model to combine these summaries into a cohesive final summary. This merge prompt is also cached, and the final summary is sanitized before being returned.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\docgenerator.py:_summarize_class_recursive:c07c95cd346f0f9f506b70dec35d1cbc94027f03b51f5179ed7e440e60fe1b6a:12966c0a26d553c3483ed39115adc2f16e3f536a9144996b40e9b02d50afdb1a": "This function, `_summarize_class_recursive`, is designed to recursively summarize a class and its methods. It takes several parameters including `class_data` (a dictionary containing the class information), `path` (the directory path of the file), `project_summary` (a summary of the project), `tokenizer`, `client` (an instance of `LLMClient` for language model interactions), `cache` (an instance of `ResponseCache` for caching responses), and token budget parameters.\n\nThe function first summarizes the methods within the class using `_summarize_methods_recursive`. It then constructs a prompt with the class name, project summary, and method summaries. Using this prompt, it generates a summary for the class itself and sanitizes it. If the original docstring exists, it rewrites the docstring by summarizing it again.\n\nThe function updates the `class_data` dictionary with the new summary and docstring. It then recursively calls itself to summarize any subclasses of the current class.\n\nOverall, this function is responsible for generating summaries and updating the documentation for classes in a project, ensuring that all relevant information is captured and presented clearly.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\docgenerator.py:_summarize_methods_recursive:3edcf3ab96f6236395b3d6493a3af97a1dda029e9621fa8cea9c596012aaf432:463414d03414a87990ab42ed0888f770dd4d62d45c4cbfa82759c939620b3370": "This function, `_summarize_methods_recursive`, is designed to recursively summarize methods of a class and its subclasses. It takes several parameters including `class_data` (a dictionary containing class information), `path` (the directory path of the file), `client` (an instance of `LLMClient` for interacting with a language model), `cache` (an instance of `ResponseCache` for caching responses), `tokenizer`, `max_context_tokens`, and `chunk_token_budget`. The function iterates over each method in the class, constructs a unique key using the path, class name, and method name, and then summarizes the method's source code using the `_summarize_chunked` function. The summary is stored back in the method dictionary under both \"summary\" and \"docstring\". If the class has subclasses, the function calls itself recursively to process each subclass.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\docgenerator.py:_summarize_module_chunked:b52d2751aa40ceee7e2643dc73b0567eb8a90d2d26fddb2752c66639eb2fbb3e:22091a1731ec2548cc3f5846354ea631a913489c831861fa742114c6a9182dfe": "This function `_summarize_module_chunked` is designed to summarize a Python or MATLAB module using a language model. It employs structure-aware chunking to handle large modules that exceed the token budget for a single request. The function uses an `LLMClient` to interact with a language model and a `ResponseCache` to store intermediate summaries. It first checks if the entire module text fits within the available tokens; if so, it summarizes the module directly. If not, it chunks the module based on its structure and summarizes each chunk separately. Finally, it combines these partial summaries into a single technical paragraph using another prompt. The resulting summary is sanitized before being returned.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\docgenerator.py:chunk_text:031e311d07276fad03890b4f5802cdf274bdcd2175632741e18fe1b078e7094c:8ed78422f305238529fbadb0928188b2e60e75d2e0c9d50c331580ca5e43121c": "The `chunk_text` function splits a given text into smaller chunks based on the specified token size. It takes three parameters: `text`, which is the input string to be split; `tokenizer`, an object used for encoding and decoding text into tokens; and `chunk_size_tokens`, an integer specifying the approximate number of tokens per chunk. The function encodes the entire text into tokens, then iterates through these tokens in steps of `chunk_size_tokens`, decoding each chunk back into a string before appending it to the result list. This allows for efficient processing of large texts by breaking them into manageable parts.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\html_writer.py:_highlight:69ac2dba90731c316a2af61240e3807ebbb0e83590e137b39949e125f79358a5:2bb9920a9b9b49c9199da16dd68c8e5d3e2518092984e47793f39c6c91f0b32d": "The `_highlight` function takes a string `code` and a string `language`, and returns the code highlighted for the specified language using Pygments. If the language is \"matlab\", it uses the MatlabLexer; if \"python\", it uses the PythonLexer; otherwise, it uses the TextLexer. The HtmlFormatter is configured to produce HTML without classes and without wrapping long lines. The function wraps the highlighted code in `<pre><code>` tags for proper rendering in HTML documents.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\html_writer.py:_render_class:ebaa9ded0efc012d5400f86b0ccac8aa996183b43a41c35d24f7586575d7834e:cac29a31701f7a4c055e6b619f40f52bea0c6252b152b3d9a2c0eebd7159c2b2": "This function `_render_class` generates HTML content for a class and its subclasses. It takes a dictionary representing the class, a string indicating the programming language, and an optional integer for the heading level. The function returns a list of HTML strings.\n\nThe function starts by creating an HTML heading tag based on the provided level, using the class name as the text. If the class has a docstring or summary, it adds a paragraph with that content. It then iterates over any methods in the class, rendering each method using another function `_render_function`. For each subclass, it creates a details element containing a summary and recursively renders the subclass using `_render_class`.\n\nThe resulting HTML parts are collected in a list and returned.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\html_writer.py:_render_function:936cfd27a5390070061fe37a56aa6e08ecc003392600d9bd9c27da09cbb52c03:cebabe753ef8d4e17669c148c23028bdc282d220410b70abf5645c6843ea9e31": "The `_render_function` function generates HTML parts for a given function and its nested subfunctions. It takes a dictionary representing the function, a programming language, an optional heading level, and an optional prefix string as input. The function returns a list of HTML strings.\n\n- It starts by creating a header tag (`<h1>` to `<h6>`) based on the provided level, defaulting to level 3.\n- It extracts the function's signature or name and escapes it for HTML output, appending it within the header tag.\n- If available, it appends a paragraph containing the function's summary or docstring, also escaped for HTML.\n- If the function has source code, it calls `_highlight` to generate HTML with syntax highlighting for the given language.\n- For each nested subfunction, it creates a `<details>` element with a `<summary>` tag displaying the subfunction's signature or name. It then recursively renders the subfunction using `_render_function`, increasing the heading level by 1.\n- The function returns a list of HTML strings representing the rendered function and its subfunctions.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\html_writer.py:write_index:54bc13ba709d6ba89e6213a9c3675b5046111f84236bef2afd878957d716f80b:89eacd2b4947601296d3431e24d22ee66317b84db8cde5b893185697b8a72ee8": "The `write_index` function generates the HTML content for the index page of a project documentation. It takes parameters for the output directory, project summary, navigation links, and optional module summaries. The function creates the destination directory if it doesn't exist. It constructs the HTML body by combining the project summary, navigation links, and module summaries into an unordered list. Each item in the list includes a link to a page and an optional summary. The function then renders the HTML using a template and writes the output to `index.html` in the destination directory.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\html_writer.py:write_module_page:aa33b544a6c6699aab55ce2c61a6266853cda40b6decdb461bc10d3cd74ec778:9bd12da679933b7335771a618e7136aa9b5c5fbf8eebda8ecb2e5d60f00b205d": "This function `write_module_page` generates an HTML documentation page for a module. It takes three parameters: `output_dir`, which is the directory where the output HTML file will be saved; `module_data`, a dictionary containing information about the module such as its name, summary, classes, and functions; and `page_links`, an iterable of tuples representing links to other pages.\n\nThe function first constructs the destination directory for the output file. It then extracts relevant data from `module_data` such as the module's name and language. Navigation items are created based on `page_links`.\n\nThe body of the HTML page is built by concatenating parts that include a summary paragraph, sections for classes, and sections for functions. Each class and function is rendered using helper functions `_render_class` and `_render_function`, respectively.\n\nFinally, the complete HTML content is generated using `_render_html`, which takes parameters such as the module name, title, body content, and navigation menu. The resulting HTML string is written to a file named after the module in the output directory.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\llm_client.py:LLMClient:72838e8fd0709fe551641fc0c9f76a75b2b5ff0bb539cfd53f50e846550367c6:fdf099ba724bc01344e966795e4427c8ab6efc0dcfe3b2d08b172973cfc85536": "The `LLMClient` class provides a thin wrapper around the LMStudio HTTP API. It includes methods for checking connectivity with the API (`ping`) and generating summaries of text using specified prompt types (`summarize`). The `summarize` method uses a template to format the input text, sends a POST request to the API endpoint, and handles potential errors by retrying up to three times before raising a runtime error.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\llm_client.py:__init__:95a56a7bd0cf62a290f73a7e01077a76bcdaf38005b904b54c99a8c5bb3c0767:a3d5bd17c31ab59e4874dc3ddf111431917684e48bbd3277b0517921ea20f4f9": "The `__init__` method initializes an instance of the `LLMClient` class. It accepts two parameters: `base_url` and `model`. The `base_url` parameter specifies the URL of the LLM server, defaulting to \"http://localhost:1234\". The `model` parameter specifies the name of the model to be used, defaulting to \"local\". The method sets these parameters as instance variables after stripping any trailing slashes from the `base_url`. It also constructs an `endpoint` attribute by appending \"/v1/chat/completions\" to the `base_url`.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\llm_client.py:ping:36c8a8fa64e8df09afd04272abd8362b7d048a0da71bfe0b2697b79c0b4aa4c9:2118b24ff7b86254d9b478b959f6c5a08b86fccceb6370681049573ee5d9aa55": "The `ping` method of the `LLMClient` class checks if the language model API is reachable. It sends a GET request to the base URL with an optional timeout parameter. If the server responds successfully, it returns `True`. If there is any issue in connecting to the server, such as a network problem or incorrect URL, it raises a `ConnectionError` with a descriptive message indicating that the LMStudio server cannot be reached.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\llm_client.py:sanitize_summary:3bfdf28f11b93635565f7d083f79158730a3773e6852fc119a4a970bfcc9082f:f75f156855e0a3815147bf887b1c4f24e2f85eab114e145e0e0ab70273f77e77": "",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\llm_client.py:summarize:7c22f6920eb5bc43053242c09d0395701d3ef9f2f095526072c65e46c99ba596:815d331eaab3058d5e0fd8e3f949bae92160f9d565ebdfd3ac8e8231547fba89": "The `summarize` method in the `LLMClient` class generates a summary for a given text using a specified prompt template. It uses a language model to process the input text and returns a sanitized summary. The method handles retries up to three times if the initial request fails, with exponential backoff between attempts.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\parser_matlab.py:parse_matlab_file:2d9f4f5255f733ebd80ea0eba0731451005bbfa1f6edef6094a66b86e46ec75d:5598ab15cd6a08bc7cbca585c2bc530d31f3db95f4f79fdae0f9bd53e292e331": "This function `parse_matlab_file` reads and parses a MATLAB `.m` file to extract its structure. It returns a dictionary containing the file's header comments and any function declarations found within the file. Each function entry includes the function name and a list of arguments, with support for both comma-separated and semicolon-separated argument lists. The function uses regular expressions to identify and parse function declarations from the file's lines.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\parser_python.py:_format_arg:d289d84932d920d7670c7bbf2974583baba9cddb5de2b01cf58ae55faa5e740a:e0d9924943380385507391b9992c426c1d6219aa72f4442277568d536123fa39": "The function `_format_arg` takes an `ast.arg` object as input and returns a string representation of the argument. If the argument has an annotation, it appends the annotation to the argument name in the format `arg: annotation`. Otherwise, it simply returns the argument name.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\parser_python.py:_format_arguments:e2d8f0971a15981b6e96210b75da89dab53d4cb40288868709686691cec8ca40:eb0ae4c81dbadfa661cc88660ed715a176c584ebbf70dd55cd60ea97ba3dbb99": "The function `_format_arguments` takes an `ast.arguments` object as input and returns a string representation of the arguments. It processes positional-only, regular, variable-positional, keyword-only, and variable-keyword arguments, including their default values if provided. The function uses helper functions like `_format_arg` to format individual arguments and constructs the final string by joining these parts with commas.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\parser_python.py:_format_signature:be22a390f3fa823b52e1180961872eb07e078c63a6e6fa31ef2f27e25880da29:905da678e4ccfed5b3ce0382e4fbf100b4e2d0fe623baae2fd33875fa3d4d91f": "This function `_format_signature` takes an AST node representing a function definition (`ast.FunctionDef`) or an asynchronous function definition (`ast.AsyncFunctionDef`) and returns a string that represents the signature of the function. The signature includes the function name, its parameters as formatted by `_format_arguments`, and the return type if specified.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\parser_python.py:_parse_classes:b422cc9b3eba63314e6c8a9b4103320737193610f650798bb37048b306ab4b54:c101ce09e11b55c209b06e0b78c4909a12bfa338cb0e389403aae5a8d77fbe65": "The function `_parse_classes` recursively parses all `ClassDef` nodes within a given list of AST nodes. It iterates through each node, checks if it is a `ClassDef`, and if so, appends the result of parsing that class to a list. If the node is a function or async function, it recursively calls itself with the body of that function, continuing the search for classes within nested structures. The function returns a list of dictionaries representing all parsed classes.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\parser_python.py:parse_class:3dab8a42c9d111d8a90caa74a6391d9e31043fe921ea3fc67f9990d94b7ca844:13a97c7933d2a27d1ebc4d1ad4f3f45ba7e17b41d59a822cbd5a043051af42e1": "The `parse_class` function processes an AST node representing a class definition and extracts relevant information. It returns a dictionary containing the class's name, docstring, methods, subclasses, and source code segment. The function iterates through the body of the class to identify nested functions (methods) and recursively parses any nested classes.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\parser_python.py:parse_classes:2a0d9e9fdd1113c5ff1bae7ceb2e7cfca57f691dc09999409c5cf7e46ffc0282:90065d9cf5b49d99410d23b5cdc778a556a8d0e87790134398c1738026f01a5b": "This function `parse_classes` serves as a public interface to extract class information from an abstract syntax tree (AST) node. It takes two parameters: `node`, which is an AST node, and `source`, a string representing the source code. The function returns a list of dictionaries, each containing details about a class found in the AST.\n\nThe actual parsing logic is delegated to a private helper function `_parse_classes`, which processes the body of the given AST node (or an empty list if the node has no body) and extracts class information from it.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\parser_python.py:parse_function:6149dcb0f56b2a2a9f6170959a6193c0eb086721b376d971e8ce84a6259c1522:f7f49041e461d3cb7edf716b0cbfc8823b0e306099d9ae1139432003802d1353": "The `parse_function` function takes an abstract syntax tree (AST) node representing a function or async function and the source code as input. It returns a dictionary containing information about the function, including its name, signature, return type, docstring, source code snippet, subfunctions, and subclasses.\n\n- The function initializes a dictionary `func_info` with keys for the function's name, signature, return type, docstring, source code, subfunctions, and subclasses.\n- It sets the function's name, signature (formatted using `_format_signature`), return type (if present), and docstring from the AST node.\n- The function retrieves the source code snippet corresponding to the function using `ast.get_source_segment`.\n- It iterates through the body of the function to find nested functions or async functions, recursively calling `parse_function` on each one and appending the results to the `subfunctions` list in `func_info`.\n- The function calls `_parse_classes` to extract any subclasses defined within the function's body and appends them to the `subclasses` list in `func_info`.\n- Finally, it returns the populated `func_info` dictionary.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\parser_python.py:parse_python_file:dd36e7f9db386a1510466a1654b2cdc14bb9fd0d50dcce696d486f7c73880a6c:cf3e3bd7220b249ab45081416ce0cab661080776b9186cf5a5b3232df88e8cd9": "The `parse_python_file` function reads a Python source file and extracts structured information. It takes the file path as input and returns a dictionary containing the module docstring, classes, and functions. The function uses the `ast` module to parse the source code and iterates through its body to identify class definitions and function definitions. Each identified class and function is parsed further using helper functions (`parse_class` and `parse_function`).",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\reviewer.py:_is_generated_html:c610067e86bead8fd202f8f29c1befc4c0568a8439b142cf19c4b87b18bf7a0c:57ba312ae1db1478610fa37bf92e4f01379629818adfdd091baaa8f5e4d299d0": "The function `_is_generated_html` checks if a given string `text` appears to be output from the DocGen-LM tool. It returns `True` if the text contains specific markers indicating it is documentation generated by DocGen-LM, such as \"Generated by DocGen-LM\", an `<h1>` heading for project documentation, or headings for classes and methods in HTML format.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\reviewer.py:check_assistant_phrasing:063819eb192e4b7280e0dd2991567f6c48dbd54eca536970a19a3620975dda81:a637ef22e97a198c52fb8e35ebd15d1551a41186c42ca252bb5293bddc50c66a": "The `check_assistant_phrasing` function takes an HTML string as input and returns a list of phrases that resemble assistant-like language found within paragraph tags. It extracts all paragraph content, strips HTML tags, converts text to lowercase for case-insensitive comparison, and checks each against a predefined list of assistant phrases. If a match is found, it records the phrase along with its line number in the original HTML.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\reviewer.py:check_contradictions:4e2a25a658e102b407ea82329be874b0d1abc7d09d99b535708baf7f9fc939c4:5134c687763b2cecaac55f299ae74e5b5dfb922054ca17464b0c444a027569cd": "The `check_contradictions` function analyzes HTML content to identify contradictions based on the presence of specific phrases and corresponding elements. It returns a list of contradiction descriptions. The function extracts paragraphs, summary text, method headers, function headers, and class headers from the HTML. It then checks for contradictions by comparing the presence of certain phrases in the summary text with the actual presence of method, function, and class headers. If a contradiction is found, it appends a description to the findings list.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\reviewer.py:check_hallucinations:1424a663d73f8876587f8765d56859bcd68eae9d6de895a8e3d2184fcabd900f:31aa479c66692233f6313fda5d816321f9aac85b3e9f4bed5af55adc4d98b431": "This function `check_hallucinations` takes a string `html` as input and returns a list of hallucination phrases detected within the HTML content. It uses helper functions `_extract_tags` to extract paragraph tags (`<p>`) from the HTML, and `_strip_html` to remove HTML tags from the extracted text. The function then checks each stripped text for the presence of any terms listed in `HALLUCINATION_TERMS`. If a term is found, it is added to the list of findings, which is returned at the end of the function.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\scanner.py:_is_subpath:791355268b51ffac298483ceb25694b440f52df3842a9bce8a4cbfa524b94294:7a1c62d5b8f2351f8d11e655e42fbe63cf202da573a68d65f8c1294b1c2c8270": "This function checks if a given `path` is either equal to or located within a specified `parent` directory. It uses the `relative_to` method of the `Path` class to determine if the `path` can be made relative to the `parent`. If successful, it returns `True`, indicating that `path` is a subpath of `parent`. If a `ValueError` is raised during this process, it means that `path` is not related to `parent` as a subpath, and the function returns `False`.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\scanner.py:scan_directory:3dea3748079d486764a28c736df444ee10046a46344124b73c3a22888a2f37b6:b3164bca9af1a968857ae96883083ad0c1a7fed37d05d5ec782b8c0c84d577cb": "The `scan_directory` function recursively discovers Python (``.py``) and MATLAB (``.m``) files under a specified base directory while ignoring certain subpaths. It returns a list of absolute paths to the discovered source files. The function uses `os.walk` to traverse the directory tree, filters out ignored directories and files, and collects the paths of relevant files."
}