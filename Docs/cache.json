{
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\cache.py:2e37ab4b52e9489ed2b2dc8e686dc29df25416d04f5b423c47ba2cc9aecf698c:2e37ab4b52e9489ed2b2dc8e686dc29df25416d04f5b423c47ba2cc9aecf698c": "A simple on-disk cache for LLM responses. Implements methods to initialize the cache from a file, generate deterministic keys based on file paths and content, retrieve cached values by key, store new values with their keys, and persist the cache data to disk in JSON format.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\cache.py:ResponseCache:__init__:919483e1ff4b05cae685fcac27aa9458bc309d42dd717af59b0942962ccdf4e4:919483e1ff4b05cae685fcac27aa9458bc309d42dd717af59b0942962ccdf4e4": "Initializes an object with a file path. If the file exists, reads its content as JSON and stores it in `_data`. If the file does not exist or is not valid JSON, initializes `_data` as an empty dictionary.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\cache.py:ResponseCache:_save:d6c96e0258c810e9fec48856af580533cfc0aa8f13ea666bb1d396aa4abe5e41:d6c96e0258c810e9fec48856af580533cfc0aa8f13ea666bb1d396aa4abe5e41": "The function `_save` writes the data stored in `self._data` to a file using the `write_text` method of `self.file`. The data is formatted as a JSON string with an indentation of 2 spaces and sorted keys. The encoding used for writing is \"utf-8\".",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\cache.py:ResponseCache:bb3037ac24d97dc868b3e947cc4e40c7983bb6e44ca10e59814e38a257fb23e6:bb3037ac24d97dc868b3e947cc4e40c7983bb6e44ca10e59814e38a257fb23e6": "The `ResponseCache` class manages caching mechanisms for responses in JSON format, providing methods to initialize, retrieve, store, and save cached data. It uses a SHA-256 hash of the content combined with the file path as a unique key to ensure deterministic caching.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\cache.py:ResponseCache:get:eeb84b4591575a8ed2767f4abac56f1f2dd0697e81322599734b8b31e94ddcce:eeb84b4591575a8ed2767f4abac56f1f2dd0697e81322599734b8b31e94ddcce": "Returns the cached value associated with a given key if it exists in the cache. If the key is not found, returns `None`.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\cache.py:ResponseCache:make_key:4f63c9f618b20a79035ed49cae07b9b800a46f352498e23dc8700f47c38fe96d:4f63c9f618b20a79035ed49cae07b9b800a46f352498e23dc8700f47c38fe96d": "Function `make_key` takes two parameters: `file_path` (a string) and `content` (a string). It returns a deterministic key by hashing the content using SHA-256 and appending the file path to the hash digest. The key format is \"file_path:digest\".",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\cache.py:ResponseCache:set:0bc8af7637662ae14e3eca8604a4d7155ff442d423955a243d6b586ffee8d8ba:0bc8af7637662ae14e3eca8604a4d7155ff442d423955a243d6b586ffee8d8ba": "Stores a value under a specified key in an internal data structure and persists the change to disk.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\chunk_utils.py:6c5fb52965b9c830534a1a0e867741ffe867c9e43e8bfc85e5073585b38f3c88:6c5fb52965b9c830534a1a0e867741ffe867c9e43e8bfc85e5073585b38f3c88": "This module provides utility functions for tokenization and text chunking. It includes:\n\n1. `get_tokenizer()`: Returns a tokenizer object for estimating token counts, using the `tiktoken` library if available.\n2. `_split_blocks(text: str) -> List[str]`: Splits Markdown text into paragraphs, headings, and fenced code blocks.\n3. `_split_long_block(block: str, tokenizer, chunk_size_tokens: int) -> List[str]`: Fallback function to split long blocks by approximate character length if they exceed the specified token size.\n4. `chunk_text(text: str, tokenizer, chunk_size_tokens: int) -> List[str]`: Splits text into chunks roughly of the specified token size, honoring natural break points like blank lines and Markdown headings. If a block exceeds the token size, it falls back to splitting by character length.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\chunk_utils.py:_split_blocks:49589ae413dbc61ce014dd1fa102aa41554bebe18b8b9d38538e5cdbde2b92fb:49589ae413dbc61ce014dd1fa102aa41554bebe18b8b9d38538e5cdbde2b92fb": "The function `_split_blocks` takes a string `text` as input and returns a list of Markdown blocks, which are separated into paragraphs, headings, and code fences. It processes the text line by line, identifying and grouping lines based on their content. Paragraphs are sequences of non-empty lines that do not start with a heading or a code fence. Headings are lines that start with one or more hash symbols (`#`). Code blocks are enclosed within triple backticks (```). The function strips leading and trailing whitespace from each block before returning the list of blocks.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\chunk_utils.py:_split_long_block:9e9b69ff96cf6833b6161605130c8f492d3e11f78da7d8d101fa7829b0678a31:9e9b69ff96cf6833b6161605130c8f492d3e11f78da7d8d101fa7829b0678a31": "This function `_split_long_block` takes a string `block`, a tokenizer, and an integer `chunk_size_tokens`. It encodes the block into tokens using the provided tokenizer. If the number of tokens is less than or equal to `chunk_size_tokens`, it returns the original block as a single element list. Otherwise, it calculates an average character length per token and determines a maximum chunk size in characters based on this average. The function then splits the block into chunks of up to `max_chars` characters and returns these chunks as a list.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\chunk_utils.py:chunk_text:01b8f6fdb832b980969c3a7c4a22204d35b38b59a0c25db95ac28515e0ae17d9:01b8f6fdb832b980969c3a7c4a22204d35b38b59a0c25db95ac28515e0ae17d9": "The function `chunk_text` splits a given text into chunks of approximately specified token size. It uses a tokenizer to count tokens and ensures that natural break points like blank lines, Markdown headings, and fenced code blocks are respected. If a single block exceeds the token limit, it falls back to splitting by character length. The function returns a list of chunked text strings.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\chunk_utils.py:get_tokenizer:2b3f1ce6b7d43f80923d6ca3b06fffc6a04a68f2856c69865b5d7ec54a429f8e:2b3f1ce6b7d43f80923d6ca3b06fffc6a04a68f2856c69865b5d7ec54a429f8e": "The function `get_tokenizer` returns a tokenizer object used for estimating token counts. It first attempts to import and use the `tiktoken` library with the \"cl100k_base\" encoding. If successful, it returns this tokenizer. If `tiktoken` is not available or fails, it falls back to using a simple tokenizer that splits text into words by spaces for encoding and joins them back together for decoding. If both attempts fail, it prints a warning message indicating that token counts will be approximate and returns a simple tokenizer as a fallback.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\docgenerator.py:3bbd942ca83c7c49d3ac35629b433c86a310c968939f45fc9029090749c3e7af:merge0:3bacd1fb927d6b09292651d64559cbdeffcd475b262554efff1e1255a916e9db": "This module provides a command-line interface for generating documentation using DocGen-LM. It scans a source tree for Python and MATLAB files, parses them, requests summaries from a running LLM, and writes HTML documentation. The script includes functions for cleaning the output directory, summarizing text chunks, handling module structure, and recursively summarizing classes and methods. This Python script generates HTML documentation using a local Large Language Model (LLM). It accepts command-line arguments to specify the source directory, output directory, and various options such as ignored paths, LLM URL, model name, and maximum context tokens. The script processes files in the source directory, parses them based on their extensions (Python or MATLAB), and generates summaries using the LLM. It handles exceptions for file encoding issues and syntax errors. The script also collects markdown documentation from README.md and any .md files within a 'docs' subdirectory. After summarizing modules, classes, and functions, it writes HTML index and module pages to the output directory.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\docgenerator.py:3bbd942ca83c7c49d3ac35629b433c86a310c968939f45fc9029090749c3e7af:part0:8d5fa3017655aa21bfec429fe81d8bb373ed9e57fdd687c6c47815484389e168": "This module provides a command-line interface for generating documentation using DocGen-LM. It scans a source tree for Python and MATLAB files, parses them, requests summaries from a running LLM, and writes HTML documentation. The script includes functions for cleaning the output directory, summarizing text chunks, handling module structure, and recursively summarizing classes and methods.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\docgenerator.py:3bbd942ca83c7c49d3ac35629b433c86a310c968939f45fc9029090749c3e7af:part1:04b963117c836b259d6d1e5139f32dbc2024588b2d93581173210710e7bfa9d9": "This Python script generates HTML documentation using a local Large Language Model (LLM). It accepts command-line arguments to specify the source directory, output directory, and various options such as ignored paths, LLM URL, model name, and maximum context tokens. The script processes files in the source directory, parses them based on their extensions (Python or MATLAB), and generates summaries using the LLM. It handles exceptions for file encoding issues and syntax errors. The script also collects markdown documentation from README.md and any .md files within a 'docs' subdirectory. After summarizing modules, classes, and functions, it writes HTML index and module pages to the output directory.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\docgenerator.py:_build_function_prompt:8e91dfaf6d96fbb473557d11e827e711f652882acd2ea2ecc14a6745f00c214d:8e91dfaf6d96fbb473557d11e827e711f652882acd2ea2ecc14a6745f00c214d": "This function `_build_function_prompt` constructs a context-enriched prompt for summarizing Python functions. It takes four parameters: `source`, `class_name`, `class_summary`, and `project_summary`. The function returns a string that includes the following:\n\n1. A brief introduction as a documentation generator.\n2. Information about the class to which the function belongs, if provided.\n3. A summary of the class, if provided.\n4. A summary of the project, if provided.\n5. Instructions on how to summarize the function based on its source code.\n6. The actual source code of the function enclosed in a code block.\n\nThis prompt is designed to provide sufficient context for a language model to generate an accurate and relevant summary of the function.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\docgenerator.py:_chunk_module_by_structure:a72ca18613eb564886dca50e91cb8bda4990ca88f637ed1eb14a4a5238490482:a72ca18613eb564886dca50e91cb8bda4990ca88f637ed1eb14a4a5238490482": "This function `_chunk_module_by_structure` processes a Python module's parsed structure to create text chunks of a specified size. It first extracts the module's docstring and adds it to the blocks list if present. Then, it iterates through classes, methods, and functions within the module, adding their source code to the blocks list. The function then processes these blocks into chunks that do not exceed the specified token limit. If a block exceeds the token limit, it is further chunked using another function `chunk_text`. Finally, any remaining blocks are added to the chunks list, which is returned as the result.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\docgenerator.py:_rewrite_docstring:2b568b3bd955c3706aab61b1274e9ce067608bc3b83567d6c2010d0bb6179922:2b568b3bd955c3706aab61b1274e9ce067608bc3b83567d6c2010d0bb6179922": "This function `_rewrite_docstring` is designed to rewrite the docstring of a code item using an optional context. It takes several parameters including an LLM client, a response cache, file path, and item details. The function checks if there is source code or a docstring for the given item; if not, it prints a warning and returns. If a docstring exists, it constructs a prompt based on whether class or project summaries are provided. It then generates a key using the file path, item name, and relevant content. Using this key, it calls `_summarize_chunked` to generate a new docstring by summarizing the source code and optional context. The resulting summary is sanitized and assigned back to the item's docstring field. If no summary can be generated, it defaults to \"No summary available.\"",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\docgenerator.py:_summarize:b61452961000df846fa6438be081783745d9d9164fd97eb8f529e9242fb89630:b61452961000df846fa6438be081783745d9d9164fd97eb8f529e9242fb89630": "The function `_summarize` takes an `LLMClient`, a `ResponseCache`, a `key`, a `text`, and a `prompt_type` as parameters. It checks if the summary for the given key is already cached. If it is, it returns the cached summary. Otherwise, it uses the `LLMClient` to generate a summary of the provided text based on the prompt type, caches this new summary using the provided key, and then returns the generated summary.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\docgenerator.py:_summarize_class_recursive:05545fc49af89e2e2030f527899efe335ca383251f9b657dee4e082617c3c316:05545fc49af89e2e2030f527899efe335ca383251f9b657dee4e082617c3c316": "This function `_summarize_class_recursive` is designed to recursively summarize a class and its methods within a Python project. It takes several parameters including `class_data`, which contains the class information; `path`, the file path of the class; `project_summary`, a summary of the entire project; `tokenizer`, a tokenizer for text processing; `client`, an instance of `LLMClient` for interacting with a language model; `cache`, an instance of `ResponseCache` for caching responses; and `max_context_tokens` and `chunk_token_budget` for managing token usage.\n\nThe function performs the following tasks:\n1. It recursively summarizes all methods within the class using `_summarize_methods_recursive`.\n2. It constructs a prompt (`class_prompt`) that includes the class name, project summary, and summaries of its methods.\n3. It generates a key (`cls_key`) for caching based on the path and class name.\n4. It uses `_summarize_chunked` to generate a summary for the class's docstring, ensuring it does not exceed the specified token budget.\n5. It sanitizes the generated summary and updates the `class_data` with both the new summary and docstring.\n6. If an original docstring exists, it rewrites the docstring using `_rewrite_docstring`.\n7. It recursively calls itself for each subclass of the current class.\n\nThis function is part of a larger system that processes Python files to generate summaries and documentation, utilizing caching and language model interactions to efficiently handle large codebases.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\docgenerator.py:_summarize_methods_recursive:511294f5d054840f766102a58f33cdd6510c09ae9bed46f8f6c32c7cf57c39ea:511294f5d054840f766102a58f33cdd6510c09ae9bed46f8f6c32c7cf57c39ea": "This function recursively summarizes methods within a given class and its subclasses. It iterates through each method in the class, constructs a unique key for caching purposes, and then uses a language model client to generate a summary of the method's source code or signature. The summary is stored back into the method dictionary under the keys \"summary\" and \"docstring\". For each subclass of the current class, the function calls itself recursively to ensure all methods in the entire inheritance hierarchy are summarized.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\docgenerator.py:_summarize_module_chunked:12164ebc467de30417d75aa6bce2048107d749aa05d1a0adb5419fcaf2a88a24:12164ebc467de30417d75aa6bce2048107d749aa05d1a0adb5419fcaf2a88a24": "This function `_summarize_module_chunked` is designed to summarize a Python module using a structure-aware chunking approach. It utilizes an LLMClient for generating summaries and a ResponseCache for caching results. The function first checks if the entire module text can be summarized within the available token budget. If not, it chunks the module based on its structure into smaller parts that fit within the budget. Each part is then summarized individually. After summarizing all parts, the function combines these summaries into a single technical paragraph using a recursive merging process. The merging ensures that the combined summary fits within the maximum context tokens allowed by the tokenizer. If any step fails due to exceptions (e.g., network issues), it falls back to summarizing the entire module or individual parts as a last resort. The function returns the sanitized final summary of the module.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\docgenerator.py:clean_output_dir:2b4694f1530f9047e80d614912ac2e053766e36467d11f112ab5c613756cd6f1:2b4694f1530f9047e80d614912ac2e053766e36467d11f112ab5c613756cd6f1": "The function `clean_output_dir` takes a string representing the path to an output directory and iterates through all files within that directory. If a file has a `.html` extension, it reads the first line of the file. If the first line contains the string \"Generated by DocGen-LM\", the file is deleted. If any errors occur during this process, a warning message is printed to the console.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\docgenerator.py:main:7a4d92691db9aa8560e5d5463451892eebf90252117c90c7dfc201e88f0d4e5e:7a4d92691db9aa8560e5d5463451892eebf90252117c90c7dfc201e88f0d4e5e": "The `main` function serves as the entry point for generating HTML documentation using a local language model (LLM). It parses command-line arguments to configure the source directory, output directory, and various options such as ignoring certain paths, specifying the LLM URL, and setting the maximum context tokens. The function initializes an LLM client, sets up tokenization, and prepares the output directory.\n\nIt then scans the source directory for Python and MATLAB files, parsing each file to extract classes and functions. For each module, it generates a summary using the LLM client, handling exceptions for invalid encoding or malformed files. It also processes methods and standalone functions within the modules, summarizing them recursively and updating their docstrings with context.\n\nThe function constructs a project outline and gathers markdown documentation from README files and 'docs' directories within the source. It then summarizes the project and its components using the LLM client. Finally, it writes the index page and individual module pages to the output directory, ensuring that all summaries are properly formatted and linked.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:Config:13258c4a74337d8a14ffde33320f3e66831ceb5e80b47ddf5fa5ffce129b53a0:13258c4a74337d8a14ffde33320f3e66831ceb5e80b47ddf5fa5ffce129b53a0": "The `Config` class is part of a project that generates static HTML documentation for Python and MATLAB projects using local language models. It supports nested functions and subclasses, rendering complex structures as expandable sections in the output, and includes both CLI and GUI interfaces for specifying project directories, output paths, and LLM server details.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:_edit_chunks_in_editor:7ccb7e4d990ab112a8bb022b43e2daa15a97ccc3f0cfb59fe5e4cdcbc61055ed:7ccb7e4d990ab112a8bb022b43e2daa15a97ccc3f0cfb59fe5e4cdcbc61055ed": "This function `_edit_chunks_in_editor` takes a list of string chunks, each separated by lines containing `---`. It opens these chunks in the user's default editor (determined by environment variables `EDITOR` or `VISUAL`, with a fallback to \"vi\") for optional modification. After editing, it reads back the modified content, splits it into parts based on the separator, and returns a list of non-empty, stripped parts.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:aad69518442045a27cc350ff4925b9ffaefe81eac25d25847a93bf6c19bb5d90:merge0:e02144e25a42c5965b8037caa72ff9ed9e133206855c1c4a630c83ad12b1d827": "This module provides comprehensive functionality for generating project summaries from existing documentation and sample files. It includes classes, functions, and utilities for parsing configuration, collecting relevant files, slugifying text, inserting links into an index file, extracting text from various file types, detecting placeholders, mapping evidence to sections, ranking code files, and more. The module also defines functions to extract relevant code snippets from files, scan code for specific sections, generate a manual using an LLM, and fill placeholders in the manual with code snippets. It includes utilities for logging, time tracking, file size checks, and text extraction, designed to handle large numbers of files efficiently. Additionally, it provides functions to render HTML from structured sections of a manual, parse plain text into structured sections, validate references within sections, infer missing sections, and convert HTML to PDF. The module also interacts with an LLMClient for inferring missing sections based on provided text. Finally, the Python script defines a `main` function that sets up command-line arguments using the `argparse` module, processes these arguments to create a configuration object, collects document files, reads text from collected documents, initializes logging, generates an initial manual summary using an LLM client, detects missing sections, optionally scans project code to fill in missing sections, validates manual references and evidence map, renders the final HTML or PDF output based on the configured format, inserts a link to the generated manual into `index.html` if specified, saves the evidence map as a JSON file, and handles exceptions gracefully with fallbacks for LLM summarization failures.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:aad69518442045a27cc350ff4925b9ffaefe81eac25d25847a93bf6c19bb5d90:part0:8e0aa5cc5130e20eb0fb2d8a0c1a22484128117919a628d4585c5548c48a1959": "This module provides functionality to generate a project summary from existing documentation and sample files. It includes classes, functions, and utilities for parsing configuration, collecting relevant files, slugifying text, inserting links into an index file, extracting text from various file types, detecting placeholders, mapping evidence to sections, ranking code files, and more.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:aad69518442045a27cc350ff4925b9ffaefe81eac25d25847a93bf6c19bb5d90:part1:8f10a64afd7e2fd32e707110d894fffc2905f5f7961dc4bce28b5eeab79d573d": "The module defines functions to extract relevant code snippets from files, scan code for specific sections, generate a manual using an LLM, and fill placeholders in the manual with code snippets. It includes utilities for logging, time tracking, file size checks, and text extraction. The functions are designed to handle large numbers of files efficiently by limiting the number of files processed and the amount of data read from each file.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:aad69518442045a27cc350ff4925b9ffaefe81eac25d25847a93bf6c19bb5d90:part2:728ef003d9b9cf619f2797bd3f130e29e504e38c3a5e8a9633d300640b8df8a4": "This module provides functions to render HTML from structured sections of a manual, parse plain text into structured sections, validate references within sections, infer missing sections, and convert HTML to PDF. It includes utilities for slugifying text, escaping HTML, and handling Markdown rendering. The module also interacts with an LLMClient for inferring missing sections based on provided text.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:aad69518442045a27cc350ff4925b9ffaefe81eac25d25847a93bf6c19bb5d90:part3:a9277aadc6312b031707b1eddb8a882d73e638ba5c39005838093b1f6829288b": "This Python script defines a `main` function that sets up command-line arguments using the `argparse` module to configure various options for summarizing project documentation. It then processes these arguments to create a configuration object and performs several steps:\n\n1. Collects document files from the specified path.\n2. Reads text from collected documents.\n3. Initializes logging based on chunking mode.\n4. Generates an initial manual summary using an LLM client.\n5. Detects missing sections in the generated summary.\n6. Optionally scans project code to fill in missing sections if needed.\n7. Validates manual references and evidence map.\n8. Renders the final HTML or PDF output based on the configured format.\n9. Inserts a link to the generated manual into `index.html` if specified.\n10. Saves the evidence map as a JSON file.\n\nThe script handles exceptions gracefully, providing fallbacks for LLM summarization failures and ensuring that the output is saved in the correct format.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:collect_docs:e240a53f873f1b6e9dd7e671f89590e96edd981c74438739a81adc6ce8f0271a:e240a53f873f1b6e9dd7e671f89590e96edd981c74438739a81adc6ce8f0271a": "The function `collect_docs` takes a directory path as input and returns a list of documentation file paths. It searches for specific types of files, including Markdown, HTML, TXT, DOCX, and README files in the given directory and its subdirectories. The function uses glob patterns to find matching files and ensures that only unique files are returned by maintaining a set of seen files.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:collect_files:eae31f02a5b22b8ae8a67970756c848cdf2be9209440bd6a7c1437eab3094d76:eae31f02a5b22b8ae8a67970756c848cdf2be9209440bd6a7c1437eab3094d76": "The `collect_files` function returns a list of file paths from the specified base directory that are relevant for summarization. It starts with a default set of patterns including README files, text documents, HTML files, and various data formats like CSV and JSON. If additional patterns are provided through the `extra_patterns` parameter, these are also included in the search. The function uses `rglob` to recursively find all matching files within the base directory. To ensure uniqueness, it filters out duplicate files based on their paths, storing only unique files in the final list which is then returned.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:detect_placeholders:c802c7411466b96c4d60fc18c1f342cc75b03efd1043be2a31cc99173af5a987:c802c7411466b96c4d60fc18c1f342cc75b03efd1043be2a31cc99173af5a987": "The function `detect_placeholders` takes a string `text` as input and returns a list of section names that are still marked by placeholder tokens. It uses the helper function `find_placeholders` to identify all placeholder tokens in the text. Then, it filters these tokens against a dictionary `SECTION_PLACEHOLDERS`, which maps section names to their corresponding placeholder tokens. The function collects and returns the names of sections whose placeholders are found in the input text.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:extract_snippets:8cd55f9fb6ba32dce8b373a979ad3589d0154892de0084f98f05265c80f569da:8cd55f9fb6ba32dce8b373a979ad3589d0154892de0084f98f05265c80f569da": "The `extract_snippets` function processes a list of Python and MATLAB files to extract relevant code snippets. It filters files based on the number of files processed (`max_files`), time spent processing (`time_budget`), and file size (`max_bytes`). For each file, it reads the text and extracts module docstrings, class and function docstrings, I/O signatures (if any arguments match \"path\", \"file\", \"config\", or \"io\"), CLI parser code, and the `__main__` block. The extracted snippets are stored in a dictionary with file paths as keys.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:extract_text:8d37c86ac5e2fdead89b76eb732ef8b50aa8a52b4918057dd2ce1c4f513aacbb:8d37c86ac5e2fdead89b76eb732ef8b50aa8a52b4918057dd2ce1c4f513aacbb": "The `extract_text` function reads and processes the content of a file located at the specified `path`. It determines the file type based on its suffix (extension) and applies specific processing rules accordingly:\n\n1. **HTML Files**: The function uses BeautifulSoup to parse the HTML content. It converts all headings (`<h1>` to `<h6>`) into Markdown-style headers, wraps code blocks in triple backticks, and removes any leading or trailing whitespace from lines.\n\n2. **Markdown Files**: For `.md` files, it simply reads the text as is.\n\n3. **DOCX Files**: If the file is a DOCX document and the `Document` class (from the `python-docx` library) is available, it extracts text from paragraphs. It identifies headings based on their style names and converts them into Markdown-style headers. Non-heading text is left unchanged.\n\n4. **Other File Types**: For any other file type, it reads the text as plain text without any modifications.\n\nThe function returns the processed text content or an empty string if an exception occurs during processing.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:infer_sections:6ea28a067a36526477314595794cef33e8f6d5cb58c8be1d891aeca9674ed1c9:6ea28a067a36526477314595794cef33e8f6d5cb58c8be1d891aeca9674ed1c9": "This function `infer_sections` takes a string `text` as input and returns a dictionary of manual sections. It attempts to infer the content of these sections based on the input text. If the input text is non-empty, it places the entire text under an \"Overview\" section and generates placeholder content for other required sections labeled \"(inferred)\". If the input text is empty, it initializes all required sections with a default message indicating no information is available. The function uses `REQUIRED_SECTIONS` to define which sections are expected.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:inject_user_manual:3acdf3101f2ae84579377644317b7c324d18ba1556fddbe3fedd84ea39d61c8c:3acdf3101f2ae84579377644317b7c324d18ba1556fddbe3fedd84ea39d61c8c": "Inserts a top-level link to a user manual into an HTML file specified by `index_path`. The link is added to the first `<nav>` or `<ul>` element if present; otherwise, it is inserted at the start of the first element in `<body>` or the document root.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:insert_into_index:5dda1cddc9f32b54af0d03577a2e3d2705d108b0d1bae3d240f5f5dd539cea8d:5dda1cddc9f32b54af0d03577a2e3d2705d108b0d1bae3d240f5f5dd539cea8d": "This function `insert_into_index` appends a navigation entry linking to a specified file into an HTML index file. It takes three parameters: the path to the index file (`index_path`), the title of the link (`title`), and the filename to link to (`filename`). The function reads the existing content of the index file using BeautifulSoup, which parses HTML. It then searches for either a `<ul>` or `<nav>` element within the parsed HTML. If such an element is found, it checks if an anchor tag with the same `href` attribute as the filename already exists to avoid duplicates. If not, it creates a new anchor tag with the provided title and appends it to the appropriate container (either inside an `<li>` tag if it's a `<ul>`, or directly if it's a `<nav>`). Finally, it writes the modified HTML back to the index file.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:llm_fill_placeholders:fb997728898771a421ac89c061b2a95eccd16bfc4276ef06e5224e93cdc4282a:fb997728898771a421ac89c061b2a95eccd16bfc4276ef06e5224e93cdc4282a": "The function `llm_fill_placeholders` processes a user manual text and integrates relevant code snippets into it. It uses an LLM client to generate updated sections of the manual based on provided code snippets. The function handles chunking large code snippets to ensure they fit within the model's context window. It logs the progress of filling each section with code information.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:llm_generate_manual:359d02b4df2083dcaf25d9e5fb7791792384511fe6a5f088ef2e8c5b329749ea:359d02b4df2083dcaf25d9e5fb7791792384511fe6a5f088ef2e8c5b329749ea": "The `llm_generate_manual` function takes a dictionary of documentation snippets, an LLM client, a response cache, and an optional chunking strategy as input. It maps the documentation snippets to manual sections, performs an LLM call per section, and assembles the final manual text. The function returns the manual text, a mapping of source files to the sections they contributed, and an evidence map capturing the snippets used for each section.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:main:6f22c30ee8405fbe5894581ea0bf1a8ca579904928aa46169b047fa41b5bf0de:6f22c30ee8405fbe5894581ea0bf1a8ca579904928aa46169b047fa41b5bf0de": "The `main` function serves as the entry point for the `explaincode.py` utility. It parses command-line arguments to configure settings for summarizing project documentation. The function initializes a configuration object based on user input, collects documentation files from the specified path, and processes them using an LLM client. It handles both HTML and PDF output formats, optionally inserting links into an index file, and manages code scanning based on specified flags. The function logs progress and any issues encountered during the summarization process, ensuring that the generated documentation is complete and accurate.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:map_evidence_to_sections:4093fa6ba6b1277dfbe92aff87c501b63aed2afa1030bcd032cdafddca0081df:4093fa6ba6b1277dfbe92aff87c501b63aed2afa1030bcd032cdafddca0081df": "The function `map_evidence_to_sections` takes a dictionary of paths and their corresponding documentation snippets as input. It returns a tuple containing two dictionaries: `section_map` and `file_map`.\n\n- `section_map` maps section names to a list of tuples, where each tuple contains the source path and a snippet of documentation.\n- `file_map` maps each source path to the set of sections it contributed to.\n\nThe function processes each documentation snippet by checking if it contains any keywords associated with specific sections. If a keyword is found, the function extracts up to 10 lines of code following the keyword (or fewer if they are empty or start with a comment). The extracted snippets are then added to the corresponding section in `section_map`, and the source path is recorded in `file_map`.\n\nFor the \"Overview\" section, there is additional logic to prioritize snippets from README files and directories named \"docs\". Snippets are sorted based on their length and priority, ensuring that only the most relevant snippets are kept per section.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:parse_manual:412b7051640c77f528c30db5741f54e4404be1317f32112fb26246fa8906fde6:412b7051640c77f528c30db5741f54e4404be1317f32112fb26246fa8906fde6": "The `parse_manual` function takes a string of text and an optional LLMClient instance, along with a boolean flag to infer missing sections. It parses the input text into structured sections based on lines containing a colon. If the `infer_missing` flag is set to True and any required sections are absent, it uses the provided LLMClient to generate summaries for these sections and marks them as inferred. The function returns a dictionary where keys are section titles and values are the corresponding content.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:rank_code_files:c480caff561416eb4f94e7de4a12a1cb26ea3e96ce8fc77d1d77eb3a7991ce72:c480caff561416eb4f94e7de4a12a1cb26ea3e96ce8fc77d1d77eb3a7991ce72": "The function `rank_code_files` ranks Python, MATLAB, and Jupyter Notebook files under a specified root directory based on a set of heuristics. It skips directories like virtual environments, version control systems, and test suites. The ranking considers file extensions, relative paths containing certain keywords, and references to documentation patterns provided by the user. The function returns a list of file paths sorted by their scores in descending order.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:render_html:676dbd3001d95be9bfc6cbffe4e84637613c3167952b927a3c5d9a86f8a11a25:676dbd3001d95be9bfc6cbffe4e84637613c3167952b927a3c5d9a86f8a11a25": "The `render_html` function generates HTML content from a dictionary of sections, a title, and an optional evidence map. It processes each section to create anchor links for navigation and renders the content as HTML, using Markdown for formatting if available. If a section is empty or lacks information, it substitutes it with snippets from the evidence map. The function includes styling for the generated HTML and outputs a complete HTML document.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:scan_code:d9e82d404cb4ae5576904d982666a9df39a5111a8f38668f57f448b214503891:d9e82d404cb4ae5576904d982666a9df39a5111a8f38668f57f448b214503891": "The `scan_code` function collects source code snippets from a specified base directory, grouped by manual sections. It searches through files for keywords associated with the given sections (or all known sections if none are provided) and returns a dictionary mapping section names to dictionaries of relative file paths and their corresponding snippet text. The function uses regular expressions to identify relevant patterns in the text, ranks code files based on these patterns, extracts snippets from the top-ranked files within specified limits, and categorizes them according to the desired sections.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:slugify:c3681857bab75151bf60941f40c7d883848af1cd02c174eaa3eda935e589bcaa:c3681857bab75151bf60941f40c7d883848af1cd02c174eaa3eda935e589bcaa": "Converts a given string into a filesystem-friendly slug by replacing non-alphanumeric characters with underscores and ensuring the result is lowercase. If the resulting slug is empty, it defaults to \"user_manual\".",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:validate_manual_references:557b850bf3d8df1d0bff6fdfc241d6cbe97090de97ee5cb9935d2a95f8958c00:557b850bf3d8df1d0bff6fdfc241d6cbe97090de97ee5cb9935d2a95f8958c00": "The `validate_manual_references` function checks for missing file references in documentation sections. It scans the text of each section for substrings that resemble file paths or module names using a regular expression pattern. If a referenced file is not found under the specified project root, it appends \"[missing]\" to the reference in the section text. The function modifies the `sections` dictionary in place. Additionally, if an `evidence_map` is provided, it records missing references under the corresponding section in a list called `missing_references`.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:write_pdf:0def29af197aef8f497e05526eadedcfecb59afc02d3bfc836ec3584686fb922:0def29af197aef8f497e05526eadedcfecb59afc02d3bfc836ec3584686fb922": "This function `write_pdf` takes an HTML string and a file path as input. It attempts to write the HTML content as a PDF file at the specified path. If successful, it returns `True`; otherwise, it returns `False`. The function uses the `canvas` module from the `reportlab` library to create the PDF. It first checks if the `canvas` module is available; if not, it returns `False`. Then, it extracts text from the HTML using `BeautifulSoup`, creates a canvas object with specified page size, and writes each line of text to the PDF. Finally, it saves the PDF file and returns `True` on success.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:5d50ba49c5671a2e830adf7defdabc64df1f3c27570cab0f7f0e39e9d50edbfe:5d50ba49c5671a2e830adf7defdabc64df1f3c27570cab0f7f0e39e9d50edbfe": "A PyQt5 application for generating documentation and running ExplainCode. Features include:\n\n- A dark-themed GUI with a header, project/output directory selectors, DocGen/ExplainCode options, and a log area.\n- Drag-and-drop functionality for selecting directories/files in the GUI.\n- Collapsible boxes to organize settings.\n- Asynchronous command execution using `QThread` to handle long-running processes without blocking the main thread.\n- Support for running DocGen and ExplainCode with customizable options.\n- Logging of command output and process status.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:CollapsibleBox:9aa3545942e17e1531d816d2688851148ce5029d70bb730110b15ef8bad69ce7:9aa3545942e17e1531d816d2688851148ce5029d70bb730110b15ef8bad69ce7": "The `CollapsibleBox` class defines a user interface component with a toggle button and a content widget, allowing for the expansion and collapse of content sections. It includes methods for initializing the component, handling toggling events to show or hide content, and setting the layout of the content widget.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:CollapsibleBox:__init__:3872795cd50f67882abd634cee89722f78baef841dae8e915249543f655adece:3872795cd50f67882abd634cee89722f78baef841dae8e915249543f655adece": "A class with an `__init__` method that initializes a toggle button and a content widget. The toggle button is styled to have no border, light gray text, and bold font weight. It has a right arrow icon and can be toggled on or off. When the toggle button is clicked, it calls the `on_toggled` method. The content widget is initially hidden. A vertical layout is created with no margins, containing both the toggle button and the content widget.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:CollapsibleBox:on_toggled:f90ec87aaa91989724254207a4e933efac34041b0616a24b2d270248eb906904:f90ec87aaa91989724254207a4e933efac34041b0616a24b2d270248eb906904": "Toggles the state of a button and updates its appearance and visibility based on whether it is checked or not. When the button is checked, it displays a down arrow; when unchecked, it shows a right arrow. Additionally, it controls the visibility of associated content, making it visible when the button is checked and hiding it otherwise.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:CollapsibleBox:setContentLayout:ac9bfe1723225a787e6fed8f56df1803aac7bf21a8460cdab57bb446c2364b27:ac9bfe1723225a787e6fed8f56df1803aac7bf21a8460cdab57bb446c2364b27": "Sets the content layout of an object.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:CommandRunner:0236faf5f07777ff3c7a48fd3fa9fc5ae3b8f4f106a98a64316fc76f1f57f063:0236faf5f07777ff3c7a48fd3fa9fc5ae3b8f4f106a98a64316fc76f1f57f063": "The `CommandRunner` class manages the execution of a list of commands, capturing their output in real-time and handling both standard output and standard error streams. It uses threads for efficient reading from these streams and emits the results as they become available, ensuring that any errors are promptly reported.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:CommandRunner:__init__:e101f462c35c5d2aea35db85e4ee5dd50b4513aa99b522541dc82c8e27a017f4:e101f462c35c5d2aea35db85e4ee5dd50b4513aa99b522541dc82c8e27a017f4": "Initializes an object with a list of commands.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:CommandRunner:_reader:8cbfd3ce114ed1c88228963326a3e4e5c43e87fbd062a6965099f60e48b826d6:8cbfd3ce114ed1c88228963326a3e4e5c43e87fbd062a6965099f60e48b826d6": "The function `_reader` reads characters from a stream one by one and emits chunks of text. It handles carriage returns (`\\r`) to update progress bars in the GUI, flushing any buffered text when the stream ends. It also ensures that newlines (`\\n`) are properly emitted with the accumulated buffer.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:CommandRunner:run:c94857cc54e41729c04041a0a02b8ef637ddeb94d917c5048d30a4c9036c500a:c94857cc54e41729c04041a0a02b8ef637ddeb94d917c5048d30a4c9036c500a": "The function `run` executes a list of commands (`self.cmds`). For each command, it emits the command string followed by output from both standard output and standard error. It uses threads to read from these streams in real-time. The function captures the return code of the last executed command and emits this code when all commands have been processed or an exception occurs. If any command fails (non-zero return code), the loop breaks, and the function emits a failure status.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:MainWindow:__init__:1da23725535c31140c4fdd3e8bd0a1c242da37272b89cb4d53c5aa803892f18f:1da23725535c31140c4fdd3e8bd0a1c242da37272b89cb4d53c5aa803892f18f": "This code defines a class that initializes a graphical user interface (GUI) for a documentation tool. The GUI includes sections for setting the project and output directories, configuring DocGen options such as including private functions and supported languages, and selecting an output format for ExplainCode. It also provides checkboxes to include input data analysis and a log area for displaying messages. The GUI contains buttons to run DocGen, ExplainCode, or both.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:MainWindow:append_log:479035b003afdc113e4797fee7c099619ef8d0c73b903f780a2ffa361feaaf55:479035b003afdc113e4797fee7c099619ef8d0c73b903f780a2ffa361feaaf55": "Appends text to a log widget, handling carriage returns by clearing the current line before inserting new text. Automatically scrolls the log view to the bottom after appending.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:MainWindow:build_docgen_cmd:aa405669828c941197e5ebc761b74680661f1d13446b43d905554dd073085192:aa405669828c941197e5ebc761b74680661f1d13446b43d905554dd073085192": "Constructs a command to run a documentation generator script with specified parameters based on user input. The command includes the Python interpreter, the script name, project and output directories, an optional flag for including private members, and selected programming languages.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:MainWindow:build_explain_cmd:7b8696f7337008622c6bc5488b4fc92413596481c1750330bdc72564631f2cb5:7b8696f7337008622c6bc5488b4fc92413596481c1750330bdc72564631f2cb5": "This function constructs a command to run `explaincode.py` with specified parameters. It includes the project path, output file, and output format. Optionally, it can include additional data if a checkbox is checked and text is provided in an edit field. The constructed command is returned as a list of strings.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:MainWindow:dark_style:024d23387b641216e7d149e6c045b026f1a451318d781be0d3d84d51867f51ef:024d23387b641216e7d149e6c045b026f1a451318d781be0d3d84d51867f51ef": "This function returns a string containing CSS styles for various Qt widgets, including QWidget, QLineEdit, QPlainTextEdit, QComboBox, QPushButton, and QLabel. The styles define colors, fonts, borders, padding, and hover effects to give the interface a dark theme appearance.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:MainWindow:f42ccd06203cb53e12b4c9c6ac942bf0964022448a26efb0eb944abc02542698:f42ccd06203cb53e12b4c9c6ac942bf0964022448a26efb0eb944abc02542698": "This class defines a graphical user interface for a documentation tool that allows users to set project and output directories, configure options such as including private functions and supported languages, and select an output format for ExplainCode. It provides functionality to run commands for generating documentation and explanations, handle logging, and manage the state of running processes.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:MainWindow:on_finished:c98dd27bd106b89d8d5059a01d5a7c208db9c09ee3836ee9d932c0f5bdb99f8b:c98dd27bd106b89d8d5059a01d5a7c208db9c09ee3836ee9d932c0f5bdb99f8b": "Function `on_finished` logs the exit code of a process and sets the running status to False.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:MainWindow:run_both:123251ea533aa28d4fb511b62f853998d3769fcced0962a00cdc1cb16c3cfef0:123251ea533aa28d4fb511b62f853998d3769fcced0962a00cdc1cb16c3cfef0": "Clears the log and runs both the document generation command and the explanation command.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:MainWindow:run_commands:259d9e78ac20ac9cd282474591a8079c54a2e042ef9670b77335a47dad9adaff:259d9e78ac20ac9cd282474591a8079c54a2e042ef9670b77335a47dad9adaff": "The function `run_commands` takes a list of commands as input. It checks if project and output directories are set; if not, it logs an error message. If directories are set, it sets the running state to true, initializes a `CommandRunner` with the provided commands, connects its output signal to a log appending method, connects its finished signal to a handler method, and starts the command execution.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:MainWindow:run_docgen:0249c14aca7d5d21ff6d3b7929c59f2dbc05b970b05e9329f97566991188ecf6:0249c14aca7d5d21ff6d3b7929c59f2dbc05b970b05e9329f97566991188ecf6": "Clears the log and runs a command to build documentation.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:MainWindow:run_explain:aaae3953f6dfd026db21ab5cd9b5c637f7a8e0fee01ae706e4db035bf9a67663:aaae3953f6dfd026db21ab5cd9b5c637f7a8e0fee01ae706e4db035bf9a67663": "Clears the log and runs a command to explain something.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:MainWindow:select_dir:2a0195f8b02fa1d0340ed30e33775539f64b5ddf0498a2fae1d7426f16c229f5:2a0195f8b02fa1d0340ed30e33775539f64b5ddf0498a2fae1d7426f16c229f5": "Function `select_dir` takes a `line_edit` widget as an argument. It opens a file dialog to allow the user to select an existing directory. If a directory is selected, it sets the text of the `line_edit` widget to the path of the selected directory.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:MainWindow:select_file:eefcbb0d572a55989ebf1a954aae8e90553ec7f2c5c165ee8e6029c3df4770d3:eefcbb0d572a55989ebf1a954aae8e90553ec7f2c5c165ee8e6029c3df4770d3": "Function `select_file` opens a file dialog for selecting data files with extensions `.json`, `.csv`, or `.txt`. If a file is selected, it sets the text of the provided `QLineEdit` widget to the selected file's path.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:MainWindow:set_running:d3acbd2de6100d567839296867ec1053032418777abacda408081e46f5c8e826:d3acbd2de6100d567839296867ec1053032418777abacda408081e46f5c8e826": "The function `set_running` takes a boolean parameter `running`. It iterates over three button objects (`docgen_btn`, `explain_btn`, and `both_btn`) and sets their enabled state to the opposite of the `running` parameter. If `running` is `True`, buttons are disabled; if `False`, they are enabled.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:PathLineEdit:848b3e6c2c6d95b226157fefac19b4794a344eb702c21b0a5841c3771d7b61d0:848b3e6c2c6d95b226157fefac19b4794a344eb702c21b0a5841c3771d7b61d0": "The `PathLineEdit` class is designed for handling file path inputs with drag-and-drop functionality. It initializes with an optional parent object, accepts drops, and processes drop events by extracting URLs from the dropped data to set the object's text to the local file path of the first URL.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:PathLineEdit:__init__:c9e8a7be9ec3c7638ba891fb56438f32b028d50d553e3cf05183fab3aa0b6309:c9e8a7be9ec3c7638ba891fb56438f32b028d50d553e3cf05183fab3aa0b6309": "Initializes an object with optional parent. Sets the object to accept drops.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:PathLineEdit:dragEnterEvent:362f23d15259d38f2384b97d4fe0df74d022e537eb20da5aa442f957d48d0d35:362f23d15259d38f2384b97d4fe0df74d022e537eb20da5aa442f957d48d0d35": "The function `dragEnterEvent` checks if the event contains URLs. If it does, it accepts the proposed action for the event.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:PathLineEdit:dropEvent:2bae52494ea3b00064a9fc268f5338cc663c0b954be820963c807172bd13b7cf:2bae52494ea3b00064a9fc268f5338cc663c0b954be820963c807172bd13b7cf": "The function `dropEvent` handles a drop event by extracting URLs from the dropped data and setting the text of the object to the local file path of the first URL.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\html_writer.py:9c67880c807b6c13cd855d095c53d4913d92121b20e917e7adb6a440a8708ca4:9c67880c807b6c13cd855d095c53d4913d92121b20e917e7adb6a440a8708ca4": "This module provides HTML rendering utilities for generating documentation pages using simple template substitution. It includes functions for highlighting code snippets with Pygments and rendering HTML content based on templates. The module also defines functions to write index and module-specific documentation pages, handling project summaries, page links, and nested structures like classes and methods.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\html_writer.py:_highlight:765a9266ca9e39dd74b6bce47ff90e52bacc88c90749e1875aa2bbaf8784bcf2:765a9266ca9e39dd74b6bce47ff90e52bacc88c90749e1875aa2bbaf8784bcf2": "The function `_highlight` takes a string `code` and a string `language`, and returns the code highlighted for syntax in HTML using Pygments. It selects a lexer based on the language (MATLAB or Python), uses an HTML formatter to format the code, and wraps the result in `<pre><code>` tags. If the language is neither MATLAB nor Python, it defaults to using a `TextLexer`.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\html_writer.py:_render_class:9ebd3d8c1d06ad207ad70c899b564f8ff0beb63d73a4331a9ce72f57bd962562:9ebd3d8c1d06ad207ad70c899b564f8ff0beb63d73a4331a9ce72f57bd962562": "This function `_render_class` takes a dictionary representing a class, a programming language, and an optional level parameter. It returns a list of HTML strings that represent the class and its subclasses in a structured format. The function uses recursion to handle nested classes. It generates HTML tags based on the provided level, escapes special characters using `html.escape`, and constructs a hierarchical representation of the class structure with expandable sections for subclasses.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\html_writer.py:_render_function:699fe285151db344f9a0e01c9cb45c472da3164ac702b8c706df1fb09a3cfc61:699fe285151db344f9a0e01c9cb45c472da3164ac702b8c706df1fb09a3cfc61": "The function `_render_function` takes a dictionary representing a function (`func`), a programming language (`language`), an optional heading level (`level`), and an optional prefix string. It returns a list of HTML strings that represent the function, including its signature, summary, source code, and any nested subfunctions.\n\n- The function starts by creating an empty list `parts` to store HTML parts.\n- It determines the appropriate HTML tag based on the provided level, ensuring it does not exceed 6 (the maximum valid heading level in HTML).\n- It retrieves the function's signature or name from the dictionary and escapes it for use in HTML. This signature is then wrapped in the determined HTML tag with an `id` attribute set to the function's name.\n- If a summary or docstring is available, it is escaped and wrapped in a paragraph tag.\n- If source code is present, it calls another function `_highlight` (not shown) to highlight the code based on the specified language and appends the result to `parts`.\n- The function then iterates over any nested subfunctions. For each subfunction, it creates a details element with a summary section containing the subfunction's signature. It recursively calls itself to render the subfunction, increasing the level by 1.\n- Finally, the function returns the list of HTML parts.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\html_writer.py:_render_html:8094b51a42b4b57ddef46489742669515455b89184822473cd902acbfe4e5b3d:8094b51a42b4b57ddef46489742669515455b89184822473cd902acbfe4e5b3d": "The function `_render_html` takes four parameters: `title`, `header`, `body`, and `nav_html`. It reads an HTML template from a file specified by `_TEMPLATE_PATH`, formats the template with the provided title, header, body, and navigation HTML, and returns the formatted HTML content. The returned HTML includes a comment indicating it was generated by DocGen-LM.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\html_writer.py:write_index:54e2e9bbbdcf8cfb6d68d31ca8aa5c406b049fa71d3db337fa5ecc87f3b8442a:54e2e9bbbdcf8cfb6d68d31ca8aa5c406b049fa71d3db337fa5ecc87f3b8442a": "This function `write_index` generates the content for an `index.html` file. It takes parameters for the output directory, a project summary, and navigation links. Optionally, it can also take summaries for individual modules. The function creates the destination directory if it doesn't exist. It constructs HTML for the project summary and navigation links, optionally including module summaries. The final HTML is rendered using a helper function `_render_html` and written to `index.html` in the output directory.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\html_writer.py:write_module_page:0a66a974a1343daf827a0970a93a48023a5db8668f764191544084d46c6536ec:0a66a974a1343daf827a0970a93a48023a5db8668f764191544084d46c6536ec": "This function `write_module_page` generates an HTML documentation page for a module based on provided data. It takes three parameters: `output_dir`, `module_data`, and `page_links`. The function creates the output directory if it doesn't exist. It constructs navigation items using links from `page_links`. The body of the page includes a summary of the module, detailed descriptions of its classes and functions, and is rendered into HTML using `_render_html` function. The resulting HTML file is saved in the output directory with the name corresponding to the module's name.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\llm_client.py:8f5b5f0b0df904ebe69c30d4e90b99dac958762ddee3adcb12e8b64107e13bf6:8f5b5f0b0df904ebe69c30d4e90b99dac958762ddee3adcb12e8b64107e13bf6": "This module provides an interface to a local Large Language Model (LLM) backend called LMStudio. It includes:\n\n- A `SYSTEM_PROMPT` for the documentation model.\n- Common rules for prompt templates.\n- A `README_PROMPT` for enriching project summaries from README files.\n- A dictionary `PROMPT_TEMPLATES` containing different prompt templates for summarizing modules, classes, functions, READMEs, projects, docstrings, and user manuals.\n- A `sanitize_summary` function to remove unwanted commentary from summaries.\n- An `LLMClient` class that:\n- Initializes with a base URL and model name.\n- Includes a `ping` method to check if the API is reachable.\n- Implements a `summarize` method to generate summaries using the LLM, handling retries on failures.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\llm_client.py:LLMClient:475c492e61984540cddd2c7189875148b29cfa4dbada2eb3e08dac57e3bc6d4a:475c492e61984540cddd2c7189875148b29cfa4dbada2eb3e08dac57e3bc6d4a": "The `LLMClient` class is designed to interact with a language model for generating summaries. It includes methods for initializing the client with a base URL and model type, checking API reachability with the `ping` method, and summarizing text using the `summarize` method. The `summarize` method attempts up to three times to send a request to an endpoint and processes the response to extract a sanitized summary.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\llm_client.py:LLMClient:__init__:700c23b8c0716a1aaf00c10fbc2e056bef4f6e1dca9c72b739185f920ef55cf8:700c23b8c0716a1aaf00c10fbc2e056bef4f6e1dca9c72b739185f920ef55cf8": "Initializes an object with a base URL and a model. The base URL is stripped of any trailing slashes, and the endpoint for chat completions is constructed using this base URL. The model type is also set during initialization.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\llm_client.py:LLMClient:ping:3fe5655e89accd067c6ddc9c1cc323c9dd9eac2dea9be6646ea4d470b3e0a436:3fe5655e89accd067c6ddc9c1cc323c9dd9eac2dea9be6646ea4d470b3e0a436": "Function `ping` checks if an API is reachable by sending a GET request. It takes an optional `timeout` parameter with a default value of 2.0 seconds. If the server responds successfully, it returns `True`. If there's an error during the request or the server cannot be contacted, it raises a `ConnectionError` with a message indicating that LMStudio is not reachable at the specified URL.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\llm_client.py:LLMClient:summarize:340953c686eb58c465b342c01876eeee10acc4d018b2970e5b107bcfedab0633:340953c686eb58c465b342c01876eeee10acc4d018b2970e5b107bcfedab0633": "The function `summarize` takes three parameters: a string `text`, a string `prompt_type`, and an optional string `system_prompt`. It returns a summary of the input text using a specified prompt template. The function uses a loop to attempt up to three times to send a request to an endpoint with a payload containing the model, temperature, system prompt, and user prompt. If successful, it processes the response to extract and sanitize the summary content. If all attempts fail, it raises a `RuntimeError` with an error message.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\llm_client.py:sanitize_summary:bfb4c059f28a5c9c407b6a6bf00c41165190b320148b93f6ad99219013612bc7:bfb4c059f28a5c9c407b6a6bf00c41165190b320148b93f6ad99219013612bc7": "",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\manual_utils.py:_count_tokens:46779fe3de6033090e661845b5628851df4a86e42eb6c5884c573a9c848b8135:46779fe3de6033090e661845b5628851df4a86e42eb6c5884c573a9c848b8135": "This function `_count_tokens` calculates the approximate number of tokens in a given text string. It uses a tokenizer to encode the text and then returns the length of the encoded list, which represents the token count.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\manual_utils.py:_split_text:fbe13d4b92a9d36cf3c61727cf0cd7f93d9e457cddf22f21d0690477c0b10f62:fbe13d4b92a9d36cf3c61727cf0cd7f93d9e457cddf22f21d0690477c0b10f62": "The function `_split_text` splits a given text into chunks while respecting specified maximum token and character limits. It first divides the text into paragraphs, then iterates through each paragraph to check if it exceeds the token or character limit. If a paragraph does not exceed the limits, it is added to the current chunk. If adding a paragraph would exceed the limits, the current chunk is finalized and a new one starts with the current paragraph. The function uses regular expressions to split text into paragraphs and utility functions `_count_tokens` and `chunk_text` for token counting and further splitting if necessary.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\manual_utils.py:_summarize_manual:e26449d6c713c529d587b4ead05aa71dc02c25673e4915bc3e69e65f2f34e74b:e26449d6c713c529d587b4ead05aa71dc02c25673e4915bc3e69e65f2f34e74b": "This function `_summarize_manual` generates a summary for a given text using an LLM client and caching mechanism. It supports different chunking strategies: manual, automatic with limits, or none. The function handles text splitting, caching of responses, and merging of summaries to ensure the output does not exceed token or character limits. If chunking is enabled, it processes the text in chunks, summarizes each part, and then merges them. If chunking is disabled but the content exceeds limits, it logs a warning and proceeds with summarization without chunking. The function uses caching to avoid redundant requests to the LLM client for previously summarized parts of the text.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\manual_utils.py:ca45f47ddbb3006a8bf59dd1857385df96e5bfaf41681af7c2da178cba05f5ca:ca45f47ddbb3006a8bf59dd1857385df96e5bfaf41681af7c2da178cba05f5ca": "This module provides functions for splitting text into chunks and generating summaries using a language model. It includes utilities for token counting, text chunking, placeholder detection, and summarization with caching to improve performance. The module uses concurrent processing to handle large texts efficiently.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\manual_utils.py:chunk_docs:4114487c1179e00d9690e7fd33305cc095fc24e0956ba5cc893378702cba67c4:4114487c1179e00d9690e7fd33305cc095fc24e0956ba5cc893378702cba67c4": "Splits a list of documentation strings into chunks based on a token limit.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\manual_utils.py:find_placeholders:dafc004f2d1ef7f651fa4698ea182a553c7962c451d1d432e2a1c8aca8816a57:dafc004f2d1ef7f651fa4698ea182a553c7962c451d1d432e2a1c8aca8816a57": "The function `find_placeholders` takes a string `text` as input and returns a set of placeholder tokens found within the text. Placeholder tokens are identified using a regular expression defined by `PLACEHOLDER_RE`, which matches strings enclosed in double backticks followed by any characters until another pair of double backticks is encountered. The function extracts these tokens and returns them as a set, ensuring uniqueness.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\parser_matlab.py:15cf90e58e5b33528fe0fc6fa2e48fa77e43bd0fed902a29ea22b67a2f78ff68:15cf90e58e5b33528fe0fc6fa2e48fa77e43bd0fed902a29ea22b67a2f78ff68": "This module defines a function `parse_matlab_file` that takes the path to a MATLAB `.m` file and returns a dictionary containing the file's header comments and any function declarations found. The function extracts leading comment lines as the file header and uses a regular expression to identify and parse function declarations, extracting their names and arguments.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\parser_matlab.py:parse_matlab_file:f64c5b3aebe4abf1933ab91475915ca7475338cb202cd2ba3b5e35483d072224:f64c5b3aebe4abf1933ab91475915ca7475338cb202cd2ba3b5e35483d072224": "The function `parse_matlab_file` reads a MATLAB `.m` file and extracts its structure. It returns a dictionary containing the file's header comments and any function declarations found. The function identifies the start of the body by looking for non-comment lines or blank lines following header comments. It uses a regular expression to parse function declarations, extracting the function name and arguments. The result includes both the header text and a list of functions with their names and argument lists.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\parser_python.py:9b7a83be6356666450a5a1a457ffe2e114b6726c1c43053f6e27962b7ce8f0aa:9b7a83be6356666450a5a1a457ffe2e114b6726c1c43053f6e27962b7ce8f0aa": "This module provides a parser for Python files using the `ast` module. It extracts structured information according to the Software Requirements Specification (SRS). The parser can handle classes and functions, including their signatures, docstrings, and nested definitions. It also supports asynchronous functions and includes methods to parse entire Python source files into a structured dictionary format.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\parser_python.py:_format_arg:aaaf7755589aad4f1ddb50cc983ddcc47166ff5b5eb615a0d43f7cdd3660124b:aaaf7755589aad4f1ddb50cc983ddcc47166ff5b5eb615a0d43f7cdd3660124b": "The function `_format_arg` takes an `ast.arg` object as input and returns a string representation of the argument. If the argument has an annotation, it appends the annotation to the argument name in the format `arg: annotation`.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\parser_python.py:_format_arguments:294463138e1b6e286049e61181dcabf62351a126414a5a5eb4205b69b966ef57:294463138e1b6e286049e61181dcabf62351a126414a5a5eb4205b69b966ef57": "This function `_format_arguments` takes an `ast.arguments` object as input and returns a string representation of the arguments. It handles positional-only, regular, variable positional, keyword-only, and variable keyword arguments, formatting them according to Python syntax rules. The function uses helper functions like `_format_arg` and `ast.unparse` to construct the argument strings.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\parser_python.py:_format_signature:fbf8dc659e1ae8c3e99401a0e2545dd7b28f66c357a0bc4ee5892aa85fdbaba2:fbf8dc659e1ae8c3e99401a0e2545dd7b28f66c357a0bc4ee5892aa85fdbaba2": "This function `_format_signature` takes an `ast.FunctionDef` or `ast.AsyncFunctionDef` object as input and returns a string representing the signature of the function. The signature includes the function name, its parameters formatted by `_format_arguments`, and the return type if specified.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\parser_python.py:_parse_classes:8e2e1d387badb5f06d03f9e20a2ceae079f4f26215b88a57451b4033dfc3f639:8e2e1d387badb5f06d03f9e20a2ceae079f4f26215b88a57451b4033dfc3f639": "This function recursively parses all `ClassDef` nodes within a list of AST nodes. It iterates through each node, checks if it is an instance of `ClassDef`, and if so, appends the parsed class to a list. If the node is an instance of `FunctionDef` or `AsyncFunctionDef`, it calls itself recursively on the body of that function to parse any nested classes. The function returns a list of dictionaries representing all parsed classes.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\parser_python.py:parse_class:88d84b0c3fce8b77779d4f8131d9d5dfdfb997d05c8166f3987a4c6af3604aa4:88d84b0c3fce8b77779d4f8131d9d5dfdfb997d05c8166f3987a4c6af3604aa4": "This function `parse_class` takes an AST node representing a class definition and the source code as input. It returns a dictionary containing information about the class, including its name, docstring, methods, subclasses, and source code segment.\n\n- The function initializes a dictionary `cls_info` with keys for the class's name, docstring, methods, subclasses, and source code.\n- It extracts the class's name and docstring using `ast.get_docstring(node)`.\n- It iterates through the body of the class node to find nested functions (methods) and calls another function `parse_function` to parse each method, appending the result to the \"methods\" list in `cls_info`.\n- The function also calls `_parse_classes` to recursively parse any subclasses within the current class and appends them to the \"subclasses\" list in `cls_info`.\n- Finally, it returns the populated `cls_info` dictionary.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\parser_python.py:parse_classes:0b9860838a1c87f40fcaa671a7100b2515b12707c6d202a9dee98bf0961742cd:0b9860838a1c87f40fcaa671a7100b2515b12707c6d202a9dee98bf0961742cd": "This function `parse_classes` serves as a public interface for parsing classes within a Python abstract syntax tree (AST). It takes two parameters: `node`, which is an AST node, and `source`, a string representing the source code. The function calls a private helper function `_parse_classes`, passing it the body of the `node` (or an empty list if `node.body` does not exist) and the `source` code. The result from `_parse_classes` is returned as a list of dictionaries, each containing details about a class found in the source code.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\parser_python.py:parse_function:09f0616a0c293d6fabc56ed2b781346cc87a31b5590cefeecc293231f143653a:09f0616a0c293d6fabc56ed2b781346cc87a31b5590cefeecc293231f143653a": "This function `parse_function` takes an AST node representing a function or async function and the source code as input. It returns a dictionary containing information about the function, including its name, signature, return type, docstring, source code segment, subfunctions, and subclasses. The function iterates through the body of the given node to find nested functions and classes, recursively parsing them and adding their information to the result dictionary.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\parser_python.py:parse_python_file:fb795e86bd205e89cd26315ab4d8a3bc381e81440fef037935979e7da0193421:fb795e86bd205e89cd26315ab4d8a3bc381e81440fef037935979e7da0193421": "The `parse_python_file` function reads a Python source file and returns structured information about its contents. It takes the file path as input and uses the `ast` module to parse the source code. The function extracts the module docstring and iterates through the body of the module, identifying classes and functions. For each class, it calls `parse_class`, and for each function (whether synchronous or asynchronous), it calls `parse_function`. The results are stored in a dictionary containing the module docstring, a list of parsed classes, and a list of parsed functions.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\reviewer.py:4f9d422499a1acff78c67b05122179a409cbacd25a4c242442e0aef707dbeb81:4f9d422499a1acff78c67b05122179a409cbacd25a4c242442e0aef707dbeb81": "This module provides a tool for reviewing HTML documentation generated by DocGen-LM. It includes functions to check for assistant-like phrases, contradictions, and hallucinations in the HTML content. The `review_directory` function processes all `.html` files in a specified directory, applying checks and optionally fixing issues using an autofix feature. The main entry point is the `main` function, which parses command-line arguments to specify the directory to review and whether to enable autofix.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\reviewer.py:_extract_tags:71be4dd8a38016e2f4d4d6d6ac2c96ac1d64a84a6861334dc6c7c61acb4352c2:71be4dd8a38016e2f4d4d6d6ac2c96ac1d64a84a6861334dc6c7c61acb4352c2": "The function `_extract_tags` extracts all occurrences of a specified HTML tag and its content from a given HTML string. It uses a regular expression pattern to match the opening and closing tags along with their contents. The function returns a list of strings, each representing the content within an instance of the specified tag.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\reviewer.py:_find_line_number:5cea16d12562646078ae69fb1a1b65e1e5137e30f9bf3ea946cffb04b872b659:5cea16d12562646078ae69fb1a1b65e1e5137e30f9bf3ea946cffb04b872b659": "The function `_find_line_number` searches for a specific phrase within an HTML string and returns the line number where the phrase is found. If the phrase is not present, it returns -1. The search is case-insensitive.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\reviewer.py:_is_generated_html:0b9315cb9a876ec6454bc9ed604e8646efbaf5d241711cae032e996c9b26fd3a:0b9315cb9a876ec6454bc9ed604e8646efbaf5d241711cae032e996c9b26fd3a": "The function `_is_generated_html` checks if a given string `text` appears to be output from the DocGen-LM tool. It returns `True` if the text contains specific markers indicating it was generated by DocGen-LM, such as \"Generated by DocGen-LM\", an HTML header for project documentation, or headings for classes and methods. If none of these markers are found, it returns `False`.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\reviewer.py:_review_file:2ce849784a463d543998c6243d6b5097142cc30e3825267270c56b8ac83690c1:2ce849784a463d543998c6243d6b5097142cc30e3825267270c56b8ac83690c1": "The function `_review_file` takes a file path and an optional boolean flag `autofix`. It reads the HTML content of the specified file. If the HTML is not generated by the tool, it returns an empty list. Otherwise, it checks for assistant phrasing, contradictions, and hallucinations in the HTML content. For each issue found, it appends a formatted string to the results list indicating the type of issue and the file name. If `autofix` is True and there are issues, it sanitizes the paragraphs in the HTML and writes the updated content back to the file. Finally, it returns the list of issues.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\reviewer.py:_sanitize_paragraphs:fbd9ec328359c647486a7f320d7f8412261e7acbd460acca22f8529a034b9a55:fbd9ec328359c647486a7f320d7f8412261e7acbd460acca22f8529a034b9a55": "The function `_sanitize_paragraphs` processes an HTML string by sanitizing and cleaning the content within paragraph tags. It uses a regular expression to identify all `<p>` tags and applies a replacement function `repl` to each match. The replacement function `repl` strips any HTML from the text inside the paragraph, sanitizes it using another function `sanitize_summary`, and then wraps the sanitized text back in `<p>` tags. This ensures that the HTML content is clean and properly formatted as paragraphs.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\reviewer.py:_strip_html:eb1719796587f9bda0e07c88e9fe5fac31290b71990740314752fb58670fe55d:eb1719796587f9bda0e07c88e9fe5fac31290b71990740314752fb58670fe55d": "The function `_strip_html` takes a string `text` as input and returns a new string with all HTML tags removed. It uses the `re.sub` function from the `re` module to substitute any sequence of characters enclosed in angle brackets (`<...>`) with an empty string, effectively removing them.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\reviewer.py:check_assistant_phrasing:173dff68a0a88e2e3670c84e9b27c0e3eff30b8384a9555c96bcb218bcf5fcfb:173dff68a0a88e2e3670c84e9b27c0e3eff30b8384a9555c96bcb218bcf5fcfb": "The function `check_assistant_phrasing` analyzes an HTML string to identify and list occurrences of assistant-like phrases. It extracts paragraph tags from the HTML, strips away any HTML tags within those paragraphs, converts the text to lowercase for case-insensitive comparison, and checks if any predefined assistant phrases are present in the text. If a phrase is found, it records the exact text along with its line number in the original HTML. The function returns a list of these findings.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\reviewer.py:check_contradictions:dbae9d538b4b0b2aeef860bb3e6959bcfea20a667e05227ecada1cd6e04e8821:dbae9d538b4b0b2aeef860bb3e6959bcfea20a667e05227ecada1cd6e04e8821": "Function `check_contradictions` analyzes HTML content to identify contradictions based on the presence of specific tags and text. It returns a list of contradiction descriptions. The function extracts paragraphs, methods, functions, and classes from the HTML. If the summary states there are no methods but methods are found, it appends a description to the findings list. Similarly, it checks for contradictions regarding functions and classes.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\reviewer.py:check_hallucinations:96f7853b7e19d90d9a9910a0091656f13c92bb18a55b80ff94be281abbbcecf2:96f7853b7e19d90d9a9910a0091656f13c92bb18a55b80ff94be281abbbcecf2": "The function `check_hallucinations` analyzes HTML content to detect the presence of hallucination phrases. It extracts all paragraph tags from the HTML, strips out any HTML tags, converts the text to lowercase, and then checks if any predefined hallucination terms are present in the text. If a term is found, it is added to a list of findings, which is returned at the end of the function.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\reviewer.py:main:76a154bc7323a0f0247fa484d701a1c8b5765daf5f5c3176cf743093b74a5ccc:76a154bc7323a0f0247fa484d701a1c8b5765daf5f5c3176cf743093b74a5ccc": "The `main` function sets up an argument parser for a command-line interface. It accepts two arguments: the path to an HTML output directory and an optional flag (`--autofix`) to indicate whether files should be automatically rewritten to fix issues. The function then calls `review_directory` with the provided directory path and autofix setting, returning 0 upon completion.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\reviewer.py:review_directory:1e191bb0955fba717673a9eace516d2f57e2b11fd8b28f58519f42fd12fea26b:1e191bb0955fba717673a9eace516d2f57e2b11fd8b28f58519f42fd12fea26b": "The function `review_directory` takes a directory path and an optional autofix flag as input. It recursively iterates over all HTML files within the specified directory using `rglob`. For each file, it attempts to review the content by calling `_review_file` with the file path and autofix flag. If successful, it prints each line of the results. If an exception occurs during the review process, it catches the exception, prints an error message indicating the file that caused the issue, and continues processing the remaining files.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\scanner.py:_is_subpath:c407d832452318a30c2aab115e0b9898899c42124aa3d4f643ea0a352bb9a6ce:c407d832452318a30c2aab115e0b9898899c42124aa3d4f643ea0a352bb9a6ce": "This function checks if one directory (`path`) is a subdirectory of another directory (`parent`). It returns `True` if `path` is either equal to or inside `parent`, and `False` otherwise. The check is performed using the `relative_to` method, which raises a `ValueError` if `path` is not a subdirectory of `parent`.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\scanner.py:fd7e0f952dd35ca841116789b2d99cfc36e1d26a7cf0ee616028fe9532c20347:fd7e0f952dd35ca841116789b2d99cfc36e1d26a7cf0ee616028fe9532c20347": "The module implements a function to recursively discover Python and Objective-C source files within a directory structure. It includes an internal helper function `_is_subpath` to check if one path is a subpath of another. The `scan_directory` function takes a base path and a list of ignore paths, then returns a sorted list of absolute paths to discovered source files, excluding those listed in the ignore list.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\scanner.py:scan_directory:7930f99bfd43670875fc162607cd489dc4c214a8d76384a10a2b494ad6f7f0ff:7930f99bfd43670875fc162607cd489dc4c214a8d76384a10a2b494ad6f7f0ff": "The `scan_directory` function recursively discovers Python (``.py``) and MATLAB (``.m``) files under a specified base directory while ignoring certain paths. It returns a list of absolute paths to the discovered source files, excluding those listed in the ignore parameter. The function uses `os.walk` to traverse the directory tree, filters out ignored directories and files, and collects the paths of valid source files.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\setup.py:ef7b23c3468c8130483cd7578c14e977b39b372fd088f0e163b47be196d1291e:ef7b23c3468c8130483cd7578c14e977b39b372fd088f0e163b47be196d1291e": "A Python script that uses `setuptools` to set up and configure a package. When executed, it runs the `setup()` function from `setuptools`, which typically handles tasks like installing dependencies, creating distribution packages, and managing project metadata.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\summarize_utils.py:_summarize:9ad26145b6b791d6eab2c6a049da68bb08a79607b6b313ad8a30b0a3566f20c0:9ad26145b6b791d6eab2c6a049da68bb08a79607b6b313ad8a30b0a3566f20c0": "The function `_summarize` interacts with a language model to generate summaries of text. It uses an `LLMClient` to perform the summarization and a `ResponseCache` to store previously generated summaries for reuse. The function takes several parameters including a cache key, the text to summarize, a prompt type, and a system prompt. If a summary is already cached under the given key, it returns the cached summary; otherwise, it generates a new summary using the language model, caches it, and then returns the generated summary.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\summarize_utils.py:dfc94899d582f733d44e86f9d4150162786fe35452be561882e6039626bba1de:dfc94899d582f733d44e86f9d4150162786fe35452be561882e6039626bba1de": "This module provides functions for summarizing text using a language model client and caching responses. It includes:\n\n1. `_summarize`: Summarizes text directly if it fits within the context token limit, otherwise returns cached summary.\n2. `summarize_chunked`: Splits large texts into chunks to fit within context limits, summarizes each chunk, combines them, and caches the result.\n\nThe module uses a tokenizer for text processing, prompt templates, and system prompts. It handles exceptions during chunking and summarization processes, providing fallbacks and logging warnings.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\summarize_utils.py:summarize_chunked:cccb7382406a64b8f2f135645006dcd166e9b53fbf388fb2a184576e92f87acc:cccb7382406a64b8f2f135645006dcd166e9b53fbf388fb2a184576e92f87acc": "This function `summarize_chunked` is designed to summarize a given text by chunking it if necessary. It uses an LLMClient for summarization and a ResponseCache for caching responses. The function first checks if the input text can be summarized in one go without exceeding the available token budget. If not, it chunks the text into manageable parts. Each part is then summarized individually. After all parts are summarized, they are combined into a single technical paragraph using another recursive merge process. The function handles exceptions during chunking and summarization, printing warnings and returning sanitized summaries in case of failures.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_cache.py:97b2ae8f04e70da29a7fb5d7cb91652ea871818ccc183154b3320347b5835642:97b2ae8f04e70da29a7fb5d7cb91652ea871818ccc183154b3320347b5835642": "The module defines two functions for testing a `ResponseCache` class. The first function, `test_cache_round_trip`, tests setting and retrieving a value from the cache. It creates a temporary file, initializes a `ResponseCache` instance with that file, sets a key-value pair in the cache, and then verifies that the value can be retrieved correctly.\n\nThe second function, `test_cache_get_missing`, tests retrieving a non-existent key from the cache. It initializes a `ResponseCache` instance with a new temporary file and attempts to retrieve a value for an unknown key, expecting `None` as the result.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_cache.py:test_cache_get_missing:97ab584595905de4fa884acaf98a17de7691dd04cbefad6af2ef27b815ca5b6d:97ab584595905de4fa884acaf98a17de7691dd04cbefad6af2ef27b815ca5b6d": "This function tests the `get` method of a `ResponseCache` object. It creates a temporary directory, initializes a `ResponseCache` instance with a path to a JSON file in that directory, and asserts that calling `get` with a key (\"unknown\") returns `None`, indicating that the cache does not contain an entry for that key.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_cache.py:test_cache_round_trip:12d0ee59b7ef04fdee338b0e3a82aac046ab2487211e88ca0af97f526930b393:12d0ee59b7ef04fdee338b0e3a82aac046ab2487211e88ca0af97f526930b393": "This function tests the round-trip functionality of a caching mechanism for responses. It creates a temporary file to store the cache, initializes a `ResponseCache` object with this file path, and sets a key-value pair in the cache. Then, it reloads the cache from the same file and asserts that the value retrieved matches the original value.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_chunk_utils.py:d2a16b3c3609200d2d6d0ef21f64bf5274294b26300f2f0821797948f0587063:d2a16b3c3609200d2d6d0ef21f64bf5274294b26300f2f0821797948f0587063": "The module contains tests for two functions: `get_tokenizer` and `chunk_text`. It verifies that the tokenizer encodes and decodes text correctly, reconstructs content when chunked, splits markdown headings appropriately, and preserves code blocks within chunks.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_chunk_utils.py:test_chunk_text_preserves_code_blocks:15a3da5f9b8e8b2bfa42f423626ee632340cb0a212f5ac4e040c326a7bdb2900:15a3da5f9b8e8b2bfa42f423626ee632340cb0a212f5ac4e040c326a7bdb2900": "The function `test_chunk_text_preserves_code_blocks` tests the `chunk_text` function to ensure that code blocks are preserved when splitting text into chunks. It uses a tokenizer obtained from `get_tokenizer()` and splits the input text into chunks with a maximum length of 4 tokens. The test asserts that at least one chunk contains the entire code block \"```python\\nprint('hi')\\n```\". Additionally, it checks that each chunk has either zero or two triple backticks, indicating the presence or absence of code blocks.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_chunk_utils.py:test_chunk_text_reconstructs_content:5fa33e9b993320b1958a76c559822b8baac4f1f75a4a635d0ec67ff8942416c7:5fa33e9b993320b1958a76c559822b8baac4f1f75a4a635d0ec67ff8942416c7": "The function `test_chunk_text_reconstructs_content` tests the functionality of splitting and then reconstructing text into chunks. It uses a tokenizer to split the input text into chunks of a specified size (10 in this case). The test asserts that concatenating the chunks reconstructs the original text exactly, ensuring no data is lost during the chunking process. Additionally, it verifies that the number of chunks is greater than one, indicating successful splitting.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_chunk_utils.py:test_chunk_text_splits_markdown_headings:c6764c89a483614e52b109b5dfcb592fe66e2242d8bd9b5e20d6d428fdbb1782:c6764c89a483614e52b109b5dfcb592fe66e2242d8bd9b5e20d6d428fdbb1782": "The function `test_chunk_text_splits_markdown_headings` tests the functionality of splitting text into manageable parts using a tokenizer, specifically focusing on how markdown headings are handled. It asserts that the text is split into two chunks and verifies that each chunk starts with a markdown heading (`# H1` and `# H2`).",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_chunk_utils.py:test_get_tokenizer_roundtrip:20a6413a0dfb483519f8da9b87e6526c873ffb287e4eaeb13a13de21099c2069:20a6413a0dfb483519f8da9b87e6526c873ffb287e4eaeb13a13de21099c2069": "The function `test_get_tokenizer_roundtrip` tests the round-trip encoding and decoding functionality of a tokenizer. It retrieves a tokenizer instance using the `get_tokenizer` function, encodes a sample text string into tokens, asserts that the result is a list, decodes the tokens back to text, and finally asserts that the decoded text matches the original input after stripping any leading or trailing whitespace.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_docgenerator.py:4747c471351680c3f05795d65a616b0dac6b8c1564d9af3bb5af468dd7379569:4747c471351680c3f05795d65a616b0dac6b8c1564d9af3bb5af468dd7379569": "The module contains unit tests for a code documentation generator. It uses the `unittest.mock` library to patch dependencies and the `pathlib` library for file operations. The tests cover various scenarios such as skipping invalid Python files, generating summaries for classes and functions, handling non-UTF8 files, and ensuring project summaries are sanitized. Additionally, it includes tests for summarizing text in chunks, merging summaries recursively, and structuring chunkers to keep functions atomic or split large classes by methods.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_docgenerator.py:test_chunking_accounts_for_prompt_overhead:63413e9f5aa081361147f2ad635342aa1bd895a2449193db9a3aa4c0ce55824b:63413e9f5aa081361147f2ad635342aa1bd895a2449193db9a3aa4c0ce55824b": "This function tests the `summarize_chunked` function from the `summarize_utils` module. It sets up a tokenizer, cache, and prompt template, calculates the overhead for the system prompt and template, and then calls `summarize_chunked` with a mock summarization client. The test asserts that the mock summarization function was called more than once, indicating that the text was chunked and summarized accordingly.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_docgenerator.py:test_clean_output_dir:517050b6c98b4ac672e17d31f75a791f29998bf69c930e1d4fe7d2542f4cfa59:517050b6c98b4ac672e17d31f75a791f29998bf69c930e1d4fe7d2542f4cfa59": "The function `test_clean_output_dir` tests the `clean_output_dir` function from the `docgenerator` module. It creates a temporary directory, simulates files and directories within it, and then calls `clean_output_dir` to clean up the output directory. The test asserts that only the custom HTML file remains after cleaning, while other generated files are removed.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_docgenerator.py:test_generates_class_and_function_summaries:611af8bc18d29c2d431274d01ccac208a73385e3998baa0aab5b503fe037273a:611af8bc18d29c2d431274d01ccac208a73385e3998baa0aab5b503fe037273a": "The function `test_generates_class_and_function_summaries` tests the generation of class and function summaries using a mock LLM client. It creates a temporary project directory with a Python module containing a class and a function, then calls the main function to generate documentation. The mock client returns predefined summaries for different elements, and the test asserts that the generated HTML files contain the expected summaries.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_docgenerator.py:test_handles_class_without_docstring:aee63eca9f748e4ee78da181aa58e61d506922946b1a45678896b96bce79fff2:aee63eca9f748e4ee78da181aa58e61d506922946b1a45678896b96bce79fff2": "The function `test_handles_class_without_docstring` tests the handling of a Python class without a docstring by creating a temporary project directory, writing a Python file with an unannotated class, and then running the main documentation generation process. It uses a mock LLM client to simulate responses for module, project, and class summaries. The test asserts that the class summary is included in the generated HTML output.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_docgenerator.py:test_merge_recurses_when_prompt_too_long:43cf9e6030980b9f28fffe8d3e02591356e3cf3a01d28bf74ff023b8f3b81e4f:43cf9e6030980b9f28fffe8d3e02591356e3cf3a01d28bf74ff023b8f3b81e4f": "This function tests the merging of recursive calls when a prompt is too long. It uses a fake summary function to simulate responses from an LLM client, ensuring that the text does not exceed the maximum context tokens allowed. The test checks if the `summarize_chunked` function correctly merges multiple calls when necessary.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_docgenerator.py:test_project_summary_is_sanitized:aae79b012fc8115545e185f3310992a7d6e728852fb9818cc05f5dd7eccf31ce:aae79b012fc8115545e185f3310992a7d6e728852fb9818cc05f5dd7eccf31ce": "This function `test_project_summary_is_sanitized` tests the generation of a project summary using the `docgenerator` module. It creates a temporary project directory with a Python file containing a simple function. The function then calls the main entry point of the `docgenerator` module, passing the path to the project and an output directory for the generated documentation.\n\nThe test uses a mock client for the language model (`LLMClient`) to simulate responses during the summarization process. It asserts that the return value of the main function is 0, indicating success. The function also checks that the generated HTML file does not contain certain strings (\"You can run this\" and \"It prints.\") and verifies that the project summary was requested by checking the calls made to the mock client's `summarize` method.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_docgenerator.py:test_readme_summary_used:bbee058a9bacbc9c586f59bfa30e8eda1f216564061606b24f681efd9b44ae16:bbee058a9bacbc9c586f59bfa30e8eda1f216564061606b24f681efd9b44ae16": "This function tests the generation of a README summary using the `docgenerator` module. It creates a temporary project directory with a Python file and a README.md file, then calls the `main` function to generate documentation. The test uses a mock LLM client to simulate the summarization process, ensuring that the README is correctly summarized and included in the output HTML.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_docgenerator.py:test_single_long_partial_is_recursively_chunked:b77d0a7a8a1a6054953ffbe3b85992864c69d950f7945382396cbc135133530b:b77d0a7a8a1a6054953ffbe3b85992864c69d950f7945382396cbc135133530b": "This function tests the recursive chunking of a long text into manageable parts using a language model. It sets up a mock summarization function to simulate responses from the language model and verifies that the text is correctly split into chunks. The test uses a temporary path for caching responses and checks if the number of calls made to the mock summarization function for docstrings exceeds one, ensuring that the text is being chunked appropriately.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_docgenerator.py:test_skips_invalid_python_file:6e4262e866bdadf37c454dd8665621fbedeaaa1a5986f05aa23bcbad854551c6:6e4262e866bdadf37c454dd8665621fbedeaaa1a5986f05aa23bcbad854551c6": "This function `test_skips_invalid_python_file` tests the behavior of the `main` function from the `docgenerator.py` module when encountering an invalid Python file. It sets up a temporary project directory with an invalid Python file (`bad.py`) that contains syntax errors due to leading zeros in numeric literals. The function then calls the `main` function with this project directory and specifies an output directory for the documentation.\n\nThe test uses a mock object for the `LLMClient` class to simulate interactions with a language model, ensuring that it responds as expected without actually making network requests. The `ping` method is mocked to return `True`, indicating that the client is available, and the `summarize` method is also mocked to return a dummy summary string.\n\nAfter calling the `main` function, the test asserts that the return value is `0`, indicating successful execution. It then checks that only an index page (`index.html`) is generated in the output directory, while no documentation file for the invalid Python file (`bad.html`) is created. This confirms that the system correctly skips files with syntax errors during documentation generation.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_docgenerator.py:test_skips_non_utf8_file:9e1840012ec79894a39d0189c0afc4a648a0fa4d29964c36b6594c3cd73cb341:9e1840012ec79894a39d0189c0afc4a648a0fa4d29964c36b6594c3cd73cb341": "The function `test_skips_non_utf8_file` is a unit test for the `main` function in the `docgenerator.py` module. It verifies that non-UTF-8 encoded files are skipped during documentation generation.\n\nHere's what the function does:\n\n1. Creates a temporary project directory with a non-UTF-8 file named `bad.py`.\n2. Sets up a mock LLM client using the `patch` decorator to simulate successful pinging and summarization.\n3. Calls the `main` function with the project directory and output directory as arguments.\n4. Asserts that the return value of `main` is 0, indicating success.\n5. Verifies that an index HTML file exists in the output directory.\n6. Ensures that a non-UTF-8 encoded file (`bad.py`) does not have a corresponding HTML file in the output directory.\n\nThis test ensures that the `main` function correctly handles and skips files with encoding issues during documentation generation.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_docgenerator.py:test_structured_chunker_keeps_functions_atomic:c7a9b6ba064a9a16044ae13e6bbb8038dd1c118124913611426d028496e15c6b:c7a9b6ba064a9a16044ae13e6bbb8038dd1c118124913611426d028496e15c6b": "This function tests the `chunk_utils` module's ability to keep functions atomic when chunking text. It creates a Python file with two functions, each containing multiple lines of code. The test uses a mock object for the language model client and a response cache. It then calls the `_summarize_module_chunked` function from the `docgenerator` module, passing in the parsed Python file and other necessary parameters. The function is expected to chunk the text into two parts, each containing one of the functions. The test asserts that the number of chunks is equal to the number of functions and that the source code of the functions is correctly preserved in the chunks.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_docgenerator.py:test_structured_chunker_splits_large_class_by_method:dc0a661f1a1f2aff34d77e1031d46ea8fd9f0b735c6ec89d9dc2faacbb3feec8:dc0a661f1a1f2aff34d77e1031d46ea8fd9f0b735c6ec89d9dc2faacbb3feec8": "This function tests the `chunk_utils` module's ability to split a large Python class into smaller chunks based on its methods. It uses a mock language model client and a response cache to simulate the summarization process. The test ensures that each method's source code is chunked separately and passed to the summarization function.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_docgenerator.py:test_subclass_methods_are_summarized:a27804ffba66a1c2f05e58c3d586b5a3f68ca1479f655ad042b87e80c923de49:a27804ffba66a1c2f05e58c3d586b5a3f68ca1479f655ad042b87e80c923de49": "This function, `test_subclass_methods_are_summarized`, tests the functionality of summarizing methods within subclasses using a mock LLM client. It creates a temporary project directory with a Python file containing a subclass method and sets up an output directory for documentation. The function uses patches to mock the LLM client and the summary generation process, ensuring that the subclass method is included in the summaries. It asserts that the method name \"B:m\" is called during the summary generation process.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_docgenerator.py:test_summarize_chunked_splits_long_text:1dfe8b171a1a651a9c5ed03d442793d875ad341b8e5277bcdb15a4f6ea51b703:1dfe8b171a1a651a9c5ed03d442793d875ad341b8e5277bcdb15a4f6ea51b703": "This function tests the `summarize_chunked` function from the `summarize_utils` module. It sets up a tokenizer, creates a cache object, and mocks the `_summarize` function to return \"summary\". The function is then called with various parameters, including a client object, cache, key prefix, text, prompt type, maximum context tokens, and chunk token budget. The test asserts that the `_summarize` function was called more than once during the execution of `summarize_chunked`.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_docgenerator_subclasses.py:0fe483931aa675c30839a1cb49e71a4b7aaf03932ad088e2784291adc1ede8f0:0fe483931aa675c30839a1cb49e71a4b7aaf03932ad088e2784291adc1ede8f0": "This module defines a test function `test_subclass_docs_and_method_summary` that uses the `unittest.mock.patch` decorator to mock an `LLMClient` class from the `docgenerator` module. The test creates a temporary project directory with a Python file containing a nested class and method, then calls the `main` function from `docgenerator` with the path to the project directory and an output directory for documentation. It asserts that the return value of `main` is 0 and checks that the generated HTML documentation contains summaries for the subclass and method.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_docgenerator_subclasses.py:test_subclass_docs_and_method_summary:2dda1034e81537f776d8d409f8fda6d75eb716d9f682091977c168d5b77769aa:2dda1034e81537f776d8d409f8fda6d75eb716d9f682091977c168d5b77769aa": "The function `test_subclass_docs_and_method_summary` tests the generation of documentation for a Python project containing a subclass with a method. It sets up a temporary project directory, writes a Python file defining a class `A` with a nested class `B` and a method `m`, and specifies an output directory for the generated documentation.\n\nThe function uses a mock LLM client to simulate responses during the summarization process. It asserts that the main function returns 0, indicating successful execution. The test then reads the generated HTML file and checks for the presence of specific summary sections for the subclass `B` and its method `m`, ensuring that the documentation is correctly formatted and includes summaries as expected.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:9f0d37bcbc57a013c11fd908528d6ce6ecd27c9db6d5f4746e019d3fcdaf8461:merge0:3b438ddf50e4da4991134fd1275101d4e90a6ce9aa6be9a27f9203fa3ee5d557": "The module defines functions for creating documentation summaries, extracting text from files, rendering HTML, and handling various file formats. It includes a mock LLM client for summarization tasks, tests for different file types (Markdown, HTML, DOCX), and functionality to collect, map evidence, detect placeholders, parse manuals, validate references, infer sections, extract snippets, and scan code directories. The module also contains several test functions for a code documentation tool, covering aspects such as categorizing code snippets, filling placeholders using LLM responses, generating full documentation without scanning code, handling missing \"How to Run\" sections, skipping or forcing code fallback based on flags, customizing titles and filenames, inserting generated documentation into index files, and testing default and injected documentation into existing docs directories. Additionally, it includes tests for a summarization process, including chunking triggers, applying edit hooks, parallel summarization, hierarchical merge logging, cached chunks reuse, and avoiding LLM calls when chunking is set to none.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:9f0d37bcbc57a013c11fd908528d6ce6ecd27c9db6d5f4746e019d3fcdaf8461:part0:5516db775b429103a40dd2a03a766cbe0e39e0bdb1b12007edef2db075c1950b": "The module defines several functions and tests for creating documentation summaries, extracting text from files, rendering HTML, and handling various file formats. It includes a mock LLM client for summarization tasks, tests for different file types (Markdown, HTML, DOCX), and functionality to collect, map evidence, detect placeholders, parse manuals, validate references, infer sections, extract snippets, and scan code directories.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:9f0d37bcbc57a013c11fd908528d6ce6ecd27c9db6d5f4746e019d3fcdaf8461:part1:48d5e534383e6abde583f21f176a27405bece94f1b5b81cf84364e3c67b29752": "The module contains several test functions for a code documentation tool. Each function tests different aspects of the tool's functionality, including:\n\n1. `test_scan_code_categorizes_snippets`: Tests the categorization of code snippets based on their content.\n2. `test_llm_fill_placeholders_per_section_logging`: Tests the filling of placeholders in a manual using LLM (Large Language Model) responses and logs the process.\n3. `test_full_docs_no_code_scan`: Tests generating full documentation without scanning code if not needed.\n4. `test_missing_run_triggers_code_fallback_with_limits`: Tests triggering code fallback when \"How to Run\" sections are missing, with limits on code files and time budget.\n5. `test_no_code_flag_skips_code_fallback`: Tests skipping code fallback when the `--no-code` flag is specified.\n6. `test_force_code_flag_triggers_code_fallback`: Tests forcing code fallback when the `--force-code` flag is enabled.\n7. `test_custom_title_and_filename`: Tests generating documentation with a custom title and filename.\n8. `test_insert_into_index`: Tests inserting generated documentation into an existing index file.\n9. `test_docs_index_default_and_injection`: Tests default and injection of generated documentation into an existing docs directory's index file.\n10. `test_insert_into_root_index`: Tests inserting generated documentation into the root index file.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:9f0d37bcbc57a013c11fd908528d6ce6ecd27c9db6d5f4746e019d3fcdaf8461:part2:6bbe7d26a85f376316a924b9f7e5d33cb08b1ccb650e5cc867902d439ce763e3": "The module contains several test functions for a summarization process. It includes tests for chunking triggers multiple calls and logs, applying a chunk edit hook, parallel chunk summarization, hierarchical merge logging, cached chunks reuse, and no LLM calls when chunking is set to none. Each test function uses a dummy client to simulate the behavior of an actual language model client and asserts various conditions about the number of calls made, the content of those calls, and any output or logs generated during the summarization process.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:_create_fixture:5675c8d3bf55141cd14245ca756e44dd0045d114cea40d032101b6eb08d2285c:5675c8d3bf55141cd14245ca756e44dd0045d114cea40d032101b6eb08d2285c": "This function `_create_fixture` creates a temporary directory structure with nested subdirectories and files. It generates an HTML file and Markdown README, along with a JSON file, in the specified temporary path. The HTML file contains basic page content, while the Markdown file includes structured documentation sections such as Overview, Purpose & Problem Solving, How to Run, Inputs, Outputs, System Requirements, and Examples.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:_mock_llm_client:a527fb1056ae236d964889c53cf7492b19a3e9de786788e70a8fc41a55e96e00:a527fb1056ae236d964889c53cf7492b19a3e9de786788e70a8fc41a55e96e00": "The `_mock_llm_client` function returns an object that simulates a language model client. This mock client has a `summarize` method, which takes three parameters: `text`, `prompt_type`, and an optional `system_prompt`. The method returns a predefined summary string formatted using `textwrap.dedent` to remove leading whitespace.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:test_cached_chunks_reused:ee1f606bf4aba4b075bd76fdaf9836ac834f4b3dccbd701615708fb3141248f7:ee1f606bf4aba4b075bd76fdaf9836ac834f4b3dccbd701615708fb3141248f7": "This function tests the caching mechanism for text chunks. It creates a dummy language model client that records its calls and returns a response based on the call count. The function then uses this client to summarize a large text by chunking it, with caching enabled. The first summary triggers three calls to the client due to chunking. Subsequent summaries of the same text reuse the cached results, as evidenced by no additional calls being made.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:test_chunk_edit_hook_applied:e61885e14f22f48f5fa98fc410e901b4a5aa9902cc8776e1c719fbae36ac096a:e61885e14f22f48f5fa98fc410e901b4a5aa9902cc8776e1c719fbae36ac096a": "The function `test_chunk_edit_hook_applied` tests the `_summarize_manual` function from the `manual_utils` module. It creates a dummy language model client that records its calls and returns specific values based on the system prompt. The function also defines a hook that converts chunks of text to uppercase. The test passes if the final result is \"final\" and the last call to the client's `summarize` method has the text converted to uppercase.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:test_chunking_none_no_llm_calls:ed0dc14dd2f664d52f7654c35c364bea195eb50ed573d5ef444d745de8226021:ed0dc14dd2f664d52f7654c35c364bea195eb50ed573d5ef444d745de8226021": "The function `test_chunking_none_no_llm_calls` tests the behavior of a documentation generation tool when chunking is disabled and no language model calls are made. It sets up a temporary directory with a large text file, mocks an LLM client that records its calls, and runs the main documentation generation function with chunking set to \"none\". The test asserts that the LLM client was called five times and that the first call includes the system prompt containing the word \"Overview\".",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:test_chunking_triggers_multiple_calls_and_logs:e409940ed5c4d0a3a1d88957ca38d09323b48040210f00169688a8339b2d8c0f:e409940ed5c4d0a3a1d88957ca38d09323b48040210f00169688a8339b2d8c0f": "This function tests the chunking and merging functionality of a language model client. It creates a dummy client that records its calls, simulates summarization responses, and logs actions. The test provides two long paragraphs as input, which are expected to trigger multiple summarization calls due to automatic chunking. The final merge call is checked for specific system prompt and text content. The function also asserts the number of calls and checks the output captured by `capsys` for log messages indicating chunk processing and merge results.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:test_collect_docs_filters:f4e9a18b0096c66150b19d5becf91f74247e4f3f3c46a8a61e5b762c63074d66:f4e9a18b0096c66150b19d5becf91f74247e4f3f3c46a8a61e5b762c63074d66": "The function `test_collect_docs_filters` is a unit test that verifies the functionality of the `collect_docs` method from the `explaincode.py` module. It creates a temporary directory with several files, including Markdown and text files. The `collect_docs` method is expected to filter out non-Markdown files and return only those with `.md` extensions. The test asserts that the returned set of file names includes \"keep.md\" but excludes \"skip.txt\".",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:test_custom_output_directory:5fb926e1206659fc473a8b65cdbe2aa6e0ddbdb3beddb211246a1fc1a115dece:5fb926e1206659fc473a8b65cdbe2aa6e0ddbdb3beddb211246a1fc1a115dece": "This function tests the functionality of DocGen-LM's CLI interface by creating a temporary project directory, setting up a mock language model client using `monkeypatch`, and running the main command with custom output directories. It asserts that the expected HTML and JSON files are generated in the specified output directory.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:test_custom_title_and_filename:dcdbb2dd5c50d77b96b6f0a3b7ec37125139be216f805aafeda9ce8263ba45f5:dcdbb2dd5c50d77b96b6f0a3b7ec37125139be216f805aafeda9ce8263ba45f5": "The function `test_custom_title_and_filename` is a test case designed to verify the functionality of generating documentation with custom titles and filenames. It uses a temporary path (`tmp_path`) and a monkeypatch to mock the LLM client during execution. The test calls the `main` function with specified project path and a custom title. After execution, it checks for the existence of an output HTML file and an evidence JSON file in the temporary directory. Additionally, it asserts that the generated HTML file contains the expected custom title (`<h1>Fancy Guide</h1>`).",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:test_detect_placeholders:c2d598e763cb824490cf7144140b9f4857f334e4f596aa17d478cd3224a8a507:c2d598e763cb824490cf7144140b9f4857f334e4f596aa17d478cd3224a8a507": "The function `test_detect_placeholders` tests the `detect_placeholders` method from the `explaincode.py` module. It provides a string containing placeholders in double square brackets and asserts that the method correctly identifies these placeholders as missing. The expected result is a set containing \"Overview\" and \"Outputs\".",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:test_docs_index_default_and_injection:12572baf0b1e728be47a97c6863cccb8833da81005a54f42fcf50b767ef1f4f4:12572baf0b1e728be47a97c6863cccb8833da81005a54f42fcf50b767ef1f4f4": "This function tests the default behavior of documentation generation and manual injection. It creates a temporary directory, sets up an initial `index.html` file with a navigation section, mocks an LLM client, runs the main documentation generation process with manual insertion enabled, and then verifies that the user manual and evidence files are created. It also checks if the navigation in the `index.html` points to the newly generated user manual.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:test_extract_snippets_skips_large_file:69a0ad4ec01f98c2e2e02e93ccaa8a9a0e57cf5c78e99b736ae16275064a40b5:69a0ad4ec01f98c2e2e02e93ccaa8a9a0e57cf5c78e99b736ae16275064a40b5": "This function tests the `extract_snippets` method from the `explaincode.py` module. It creates a temporary file named \"big.py\" with a size of 210,000 bytes. The function then attempts to extract snippets from this file using the `extract_snippets` method with specified parameters: `max_files=1`, `time_budget=5`, and `max_bytes=200,000`. The test asserts that the \"big.py\" file is not included in the returned list of snippets. Additionally, it checks that a log message indicating a file size limit exceeded is present in the captured logs.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:test_extract_text_docx_preserves_headings:6fba8b1c0f2fa3e11d30d651d1dc8d214b2053ea9af61028d6d4797bba14ae8d:6fba8b1c0f2fa3e11d30d651d1dc8d214b2053ea9af61028d6d4797bba14ae8d": "This function tests the `extract_text` method from the `explaincode` module to ensure it preserves headings when extracting text from a DOCX file. It creates a temporary DOCX document with a heading and a paragraph, saves it, and then uses the `extract_text` method to read the content. The test asserts that the extracted text starts with a Markdown-style heading (`# Title`) and contains the plain text \"Text\".",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:test_extract_text_html_preserves_headings_and_code:a3fce41376ef3bac0bd436a626f5495e15299add04bac297c7d1a879ea86e8d3:a3fce41376ef3bac0bd436a626f5495e15299add04bac297c7d1a879ea86e8d3": "The function `test_extract_text_html_preserves_headings_and_code` tests the `extract_text` function from the `explaincode.py` module. It creates a temporary HTML file with headings (`<h1>`, `<h2>`) and code blocks (`<pre><code>`). The function reads this HTML file and extracts its text content, preserving the headings and code formatting. The test asserts that the extracted text contains the expected Markdown formatted headings (`# Main`, `## Section`) and code block syntax (````print('hi')````).",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:test_extract_text_markdown_preserves_headings_and_code:22c20fa2cba8fe7be8cc1415bfc638ae7da251c1a47e1c84cb5e88bde7aed420:22c20fa2cba8fe7be8cc1415bfc638ae7da251c1a47e1c84cb5e88bde7aed420": "The function `test_extract_text_markdown_preserves_headings_and_code` tests the `extract_text` function from the `explaincode.py` module. It creates a temporary Markdown file with a heading and a code block, writes the content to the file, and then reads it back using the `extract_text` function. The test asserts that the extracted text contains the original heading and code block, ensuring that the function preserves markdown formatting when extracting text from files.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:test_force_code_flag_triggers_code_fallback:cf0dff7d4b314d7aa03cbd2f18fe9168e3a56b381227427eb7be804069cb8af4:cf0dff7d4b314d7aa03cbd2f18fe9168e3a56b381227427eb7be804069cb8af4": "The function `test_force_code_flag_triggers_code_fallback` tests the behavior of a command-line interface (CLI) tool when the `--force-code` flag is used. It sets up a temporary directory, mocks certain functions to simulate the ranking and extraction of code files, and captures log output. The test asserts that the `rank_code_files` and `extract_snippets` functions are called exactly once each, and that specific log messages indicating the trigger of a code scan and completion of the first pass are present in the captured log text.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:test_full_docs_no_code_scan:2776382fc713657025704f8ed5305f3b9a819a76c7569c6cfee8570667c1fa41:2776382fc713657025704f8ed5305f3b9a819a76c7569c6cfee8570667c1fa41": "This function `test_full_docs_no_code_scan` is a unit test for the `explaincode.py` module. It simulates the process of generating documentation without performing code scanning. The test uses a temporary directory (`tmp_path`) and monkeypatches several functions to control their behavior during the test:\n\n1. `_create_fixture(tmp_path)`: Creates a fixture in the temporary directory.\n2. `fake_rank(root: Path, patterns: list[str]) -> list[Path]`: A mock function for ranking code files, which increments a tracker and returns a list containing a single file path.\n3. `fake_extract(files: Iterable[Path], *, max_files: int, time_budget: int, max_bytes: int) -> dict[Path, str]`: A mock function for extracting snippets from files, which increments another tracker and returns an empty dictionary.\n\nThe test sets up logging to capture informational messages and then calls the `main` function with specific command-line arguments (`--path`, `--scan-code-if-needed`). It asserts that the ranking and extraction functions were not called (tracked by zero values), logs contain \"DOC PASS\" and \"Code scan skipped\".",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:test_graceful_missing_docx:faa9c6d0664e63f6e0e5961b11941ac254a8c237eaf6d6c08717e64e29f23c04:faa9c6d0664e63f6e0e5961b11941ac254a8c237eaf6d6c08717e64e29f23c04": "This function tests the graceful handling of missing `docx` dependency in the `explaincode` module. It creates a temporary directory, attempts to create and save a `.docx` file if the `docx` library is available, then mocks the `Document` class from `docx` and sets up a mock LLM client. The function runs the main command with the specified path and asserts that the output files (`user_manual.html` and `user_manual_evidence.json`) exist in the temporary directory.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:test_hierarchical_merge_logged:1de5da77787ae500baa99a521147e270df7f62c450f8a382dff217bb81c490a4:1de5da77787ae500baa99a521147e270df7f62c450f8a382dff217bb81c490a4": "This function `test_hierarchical_merge_logged` tests the hierarchical merging of text summaries using a mock LLM client and caching mechanism. It asserts that the final summary is \"short\" after three calls to the mock client, with each call appending details to its `calls` list. The test also checks that the output contains a specific log message indicating a hierarchical merge pass.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:test_html_summary_creation:d479dcf72276cb7520a4a2ddefff2d88b74a078560ec56854a278d3e4b3545ed:d479dcf72276cb7520a4a2ddefff2d88b74a078560ec56854a278d3e4b3545ed": "This function `test_html_summary_creation` tests the creation of HTML summaries for a user manual. It uses a temporary path and a monkeypatch to mock an LLM client. The function runs the main command with the specified path, checks for the existence of generated files (`user_manual.html` and `user_manual_evidence.json`), and validates their contents. It ensures that the overview section exists in the evidence data, contains evidence, and is correctly linked in the HTML navigation.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:test_infer_sections_infers_entries:75067a3dd26bb50cad102e970379a51835d06b8e8258fce6a9fd751b08d29d4d:75067a3dd26bb50cad102e970379a51835d06b8e8258fce6a9fd751b08d29d4d": "The function `test_infer_sections_infers_entries` tests the `infer_sections` function from the `explaincode` module. It asserts that the returned dictionary contains an \"Overview\" section with the value \"Some context\". For all other required sections specified in `REQUIRED_SECTIONS`, it checks that their values end with \"(inferred)\". The assertion ensures that no section contains the string \"No information provided.\"",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:test_infer_sections_no_context_defaults:aa279b782aa9e3f16a0264a8ffd1cb85cd326c08381741513c1f96a59cffbeaf:aa279b782aa9e3f16a0264a8ffd1cb85cd326c08381741513c1f96a59cffbeaf": "The function `test_infer_sections_no_context_defaults` is a unit test that checks the behavior of the `infer_sections` function from the `explaincode.py` module when no context is provided. It asserts that if an empty string is passed to `infer_sections`, all values in the returned dictionary are equal to \"No information provided.\"",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:test_insert_into_index:c5b845df5826bbc7da599f4e332892272c9b0ce5bfb89f2eff9f25242451b4b6:c5b845df5826bbc7da599f4e332892272c9b0ce5bfb89f2eff9f25242451b4b6": "The function `test_insert_into_index` is a test case for the `explaincode.py` module. It uses the `pytest` framework and the `monkeypatch` fixture to simulate the behavior of an LLM client during testing. The function creates a temporary directory, sets up a mock LLM client, runs the main function with specified command-line arguments to insert documentation into an HTML index file, and then checks if a link to \"user_manual.html\" is present in the generated HTML content.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:test_insert_into_root_index:7cf731cf80917eab77bb3e377988553937ad25d3af4aa4b0ade6ba272aa68517:7cf731cf80917eab77bb3e377988553937ad25d3af4aa4b0ade6ba272aa68517": "This function `test_insert_into_root_index` tests the functionality of inserting a link to a user manual into an HTML index file. It uses a temporary directory (`tmp_path`) and a mock LLM client (`_mock_llm_client`). The test performs the following steps:\n\n1. Creates a fixture in the temporary path.\n2. Writes an initial HTML file with a `<nav>` element to `index.html`.\n3. Sets up a monkeypatch to replace the `LLMClient` attribute of the `explaincode` module with the mock client.\n4. Calls the `main` function with command-line arguments to insert a link into the index file.\n5. Verifies that the user manual and evidence files exist in the `docs` directory.\n6. Parses the modified `index.html` using BeautifulSoup.\n7. Checks if the `<nav>` element exists and contains an anchor (`<a>`) tag linking to the user manual.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:test_llm_fill_placeholders_per_section_logging:beb98d79ef701c0dc4a8b0b3dfd2c7fda18df45bfee5db93e6865834731265b1:beb98d79ef701c0dc4a8b0b3dfd2c7fda18df45bfee5db93e6865834731265b1": "The function `test_llm_fill_placeholders_per_section_logging` tests the `llm_fill_placeholders` function from the `explaincode` module. It sets up a mock LLM client that simulates responses based on placeholders in a manual template. The test provides evidence files with input and output data, which are used to fill placeholders in the manual. The function logs each placeholder filled and asserts that the correct sections of the manual are replaced with the provided evidence.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:test_map_evidence_overview_priority_and_filters:868e905c7af5d823443682210b6b45898fcd295752dc596fa4a60d484ad3ce73:868e905c7af5d823443682210b6b45898fcd295752dc596fa4a60d484ad3ce73": "The function `test_map_evidence_overview_priority_and_filters` tests the functionality of mapping evidence to sections, specifically focusing on filtering out certain files and prioritizing others. It uses a dictionary `docs` containing file paths as keys and their content as values. The function calls `explaincode.map_evidence_to_sections(docs)` to map the evidence to sections and then extracts the sources from the \"Overview\" section of the result. It asserts that specific files (`tests/ignore.md`, `examples/ignore.md`, `fixtures/ignore.md`) are not included in the sources, while others (`README.md`, `docs/guide.md`, `src/other.md`) are included and in a specific order.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:test_map_evidence_snippet_limits:4fb428f90c3ea72e54a50238f645bfd189481583076e90f945541cd5969c46b7:4fb428f90c3ea72e54a50238f645bfd189481583076e90f945541cd5969c46b7": "The function `test_map_evidence_snippet_limits` tests the functionality of mapping evidence to sections, specifically focusing on snippet limits. It creates a dictionary of documents with long and short content exceeding and within the maximum snippet lines limit defined by `explaincode.MAX_SNIPPET_LINES`. The function then maps this evidence to sections and asserts that snippets longer than the limit are truncated, while those within the limit remain intact. Additionally, it checks that the section map for the short document contains only the header \"# Inputs\".",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:test_missing_run_triggers_code_fallback_with_limits:8cc6f73462894d3f21bf415dde3410b8629ef66996c0fec76a6cd416e1e7bd40:8cc6f73462894d3f21bf415dde3410b8629ef66996c0fec76a6cd416e1e7bd40": "The function `test_missing_run_triggers_code_fallback_with_limits` is a unit test for a system that generates project documentation. It simulates the scenario where certain sections of the documentation are missing and need to be filled using code snippets. The test uses a mock LLM client (`Dummy`) to provide specific responses based on the content of the system prompt and the text being summarized.\n\nThe function sets up a temporary directory with a `README.md` file containing an overview, creates dummy Python files in the directory, and configures monkeypatch to replace functions like `rank_code_files`, `extract_snippets`, and `LLMClient` with mock implementations. It then calls the main function of the project with specific command-line arguments to trigger the code fallback mechanism.\n\nThe test asserts that:\n- The HTML output does not contain \"NEEDS_RUN_INSTRUCTIONS\".\n- The `rank_code_files` function was called once.\n- The `extract_snippets` function was called once with the specified parameters.\n- Only one file was scanned and processed.\n- Log messages indicate that missing sections were detected, a specific prompt was used, and code from a Python file filled the missing section.\n\nThis test ensures that the system can handle cases where documentation is incomplete and can use code snippets to fill in the gaps.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:test_no_code_flag_skips_code_fallback:a60a4b37e995929db7790c30fb206d44ba52907f65f0dd81cd56e8d5755f4904:a60a4b37e995929db7790c30fb206d44ba52907f65f0dd81cd56e8d5755f4904": "The function `test_no_code_flag_skips_code_fallback` tests the behavior of a code summarization tool when the `--no-code` flag is used. It sets up a temporary directory with a README file, mocks the LLM client and ranking/extracting functions, and runs the main function with the specified flags. The test verifies that the code scan is skipped due to the `--no-code` flag, and logs confirm this action while still providing an overview summary from the README file.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:test_parallel_chunk_summarization:53643da3e31cb46d3cc249ec3f7a0b7174180e9589d7c1ac9d3b04c1df2e1aa1:53643da3e31cb46d3cc249ec3f7a0b7174180e9589d7c1ac9d3b04c1df2e1aa1": "This function tests the parallel chunk summarization process using a simulated slow client and a response cache. It measures the time taken to summarize a large text by splitting it into chunks and asserts that the total duration is less than 1.5 times the delay introduced in the simulation.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:test_parse_manual_infers_missing_sections:c245f944d0a68b1d5cd19463e7e96d7d3af5691c6e6fb11d1398236e2403ac81:c245f944d0a68b1d5cd19463e7e96d7d3af5691c6e6fb11d1398236e2403ac81": "This function tests the `parse_manual` method from the `explaincode.py` module. It uses a stub class to simulate the behavior of an LLM client, which returns a guessed summary for any prompt. The test asserts that the parsed dictionary contains the expected \"Overview\" section with the provided text and an inferred \"Inputs\" section without the phrase \"No information provided.\"",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:test_pdf_summary_creation:874c90b36c91f90e1ac427091bce64dbd7ff833a2e9f1c0893ad366b5c64639c:874c90b36c91f90e1ac427091bce64dbd7ff833a2e9f1c0893ad366b5c64639c": "This function `test_pdf_summary_creation` is a test case for creating PDF summaries using the `explaincode.py` tool. It sets up a temporary directory, mocks the LLM client to simulate language model responses, and runs the main command with specified path and output format. The assertions check if the generated PDF file and evidence JSON exist in the temporary directory.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:test_render_html_includes_toc_and_sources_block:d56fa523a4d92ab69e7431f13d8fafd9a7c3fa01561a988101b1e18b040ff55e:d56fa523a4d92ab69e7431f13d8fafd9a7c3fa01561a988101b1e18b040ff55e": "The function `test_render_html_includes_toc_and_sources_block` tests the `render_html` function from the `explaincode` module. It verifies that the generated HTML includes a table of contents (TOC) and sections for source files. The test sets up mock data with two sections, \"Overview\" and \"How to Run\", each containing evidence snippets from different files. It then calls `render_html` with these sections and a title. Using BeautifulSoup, it checks if the resulting HTML contains a navigation element (`nav`) with a link to the \"Overview\" section. Additionally, it asserts that there are source blocks (`div` elements with class `sources`) containing text from both \"readme.md\" and \"run.py\".",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:test_render_html_renders_markdown_headings_and_code:5980f7befc544c4167faf5e9505be04b33dc4245960c980468a2baba48bd06b3:5980f7befc544c4167faf5e9505be04b33dc4245960c980468a2baba48bd06b3": "This function tests the `render_html` method from the `explaincode.py` module. It creates a dictionary of sections, where each section contains a Markdown heading followed by a Python code block. The function then renders these sections into HTML using the `render_html` method and checks if the resulting HTML contains an `<h1>` element with the text \"Title\" and a `<pre><code>` element containing the text \"print('hi')\".",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:test_scan_code_categorizes_snippets:2866f07cca1d2072122fb54d5a7ee368af2e1795855427cf865eeb4e1d1a3c1a:2866f07cca1d2072122fb54d5a7ee368af2e1795855427cf865eeb4e1d1a3c1a": "This function tests the `scan_code` method in the `explaincode` module. It sets up a temporary directory with three Python files and uses monkeypatching to mock the `collect_docs`, `rank_code_files`, and `extract_snippets` functions from the same module. The `fake_extract` function is defined to return specific snippets for each file based on their names. The test then calls `scan_code` with specified categories and parameters, asserting that the returned dictionary correctly categorizes the files according to the expected snippets.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:test_scan_code_skips_non_source_dirs:9487a04985a633c085df310c4bbcd5e64ebf47de738dfacee4dbb0c8a8123b05:9487a04985a633c085df310c4bbcd5e64ebf47de738dfacee4dbb0c8a8123b05": "This function tests the `scan_code` method from the `explaincode` module. It creates a temporary directory structure with source files in \"src\", test files in \"tests\", and example files in \"examples\". The `collect_docs` function is mocked to return an empty list for any base path. The `scan_code` method is then called with the temporary path, a title of \"How to Run\", and various parameters such as maximum files, time budget, and maximum bytes per file. The result is checked to ensure that only the source file in \"src\" is included under the \"How to Run\" key.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:test_validate_manual_references_flags_missing:9a95018d49ae3418331eb11f7a32b7bce238e4d5d4a20dd17bc7aedfa113587b:9a95018d49ae3418331eb11f7a32b7bce238e4d5d4a20dd17bc7aedfa113587b": "This function tests the `validate_manual_references` method from the `explaincode` module. It creates a temporary directory, writes a Python file named `exists.py`, and sets up a dictionary `sections` with a key \"Overview\" containing a reference to both `exists.py` and a non-existent file `missing.py`. The function then calls `validate_manual_references` with these parameters and an empty evidence dictionary. After the function execution, it asserts that:\n1. `exists.py` is still listed in the \"Overview\" section.\n2. `missing.py [missing]` is added to the \"Overview\" section, indicating a missing reference.\n3. The `evidence` dictionary contains a key \"Overview\" with a sub-key \"missing_references\" listing `missing.py`.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_html_writer.py:a1aeaba6fec7461888e75a51cdc213dbeb5d81eaf06741979e1d495b15314fc9:a1aeaba6fec7461888e75a51cdc213dbeb5d81eaf06741979e1d495b15314fc9": "The module defines functions to generate HTML documentation for projects and modules. It includes:\n\n- `write_index`: Generates an index page listing project summary, links to modules, and summaries of each module.\n- `write_module_page`: Generates a detailed HTML page for a specific module, including its name, summary, classes, methods, and functions.\n- `test_write_index`, `test_write_module_page`, `test_subfunction_rendering`, and `test_subclass_rendering`: Unit tests to verify the correctness of the above functions.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_html_writer.py:test_subclass_rendering:0b0d3589ff293d1c730becaf38e42b9abbf01eafd64303d03c83e33a14eee899:0b0d3589ff293d1c730becaf38e42b9abbf01eafd64303d03c83e33a14eee899": "The function `test_subclass_rendering` tests the rendering of subclass information in HTML documentation. It creates a mock module data structure with a class `A` that has a subclass `B`. The subclass `B` contains a method `m`. The function writes this module data to an HTML file using the `write_module_page` function and then reads the generated HTML file. It asserts that the HTML contains `<details>` tags, indicating expandable sections, \"Class: B\", the method signature \"def m(self)\", and exactly one code block (`<pre><code>`) containing the method definition.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_html_writer.py:test_subfunction_rendering:f27aed63879019d06ee2960d622d60f5b100db5865e15b62df3ee83c771e56f8:f27aed63879019d06ee2960d622d60f5b100db5865e15b62df3ee83c771e56f8": "The function `test_subfunction_rendering` is designed to test the rendering of subfunctions within a module's documentation. It uses a temporary path to create a mock module data structure, which includes a nested function (subfunction) named \"inner\" inside another function \"outer\". The function then writes this module data to an HTML file using `write_module_page`, and reads the generated HTML content. It asserts that the HTML contains `<details>` tags, indicating expandable sections for subfunctions, and checks if the subfunction name is present in the HTML. Additionally, it verifies that both the outer and inner functions' source code are highlighted in the HTML output, ensuring proper syntax highlighting.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_html_writer.py:test_write_index:abf2ad032aaa04c0c73ad8f1aeed5b0c77171f4285f0aa963ae935504d9d503e:abf2ad032aaa04c0c73ad8f1aeed5b0c77171f4285f0aa963ae935504d9d503e": "The function `test_write_index` is a unit test for the `write_index` function. It checks if the generated HTML index file contains the expected content, including project summary, module links, and summaries. The test uses a temporary path to create an index.html file and asserts that it contains specific tags and text, ensuring proper rendering of the documentation structure.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_html_writer.py:test_write_module_page:43578d7e753f223f17ffc665a1eb87470ea9f0ce52a8c5a41d830fd2b379e69f:43578d7e753f223f17ffc665a1eb87470ea9f0ce52a8c5a41d830fd2b379e69f": "The function `test_write_module_page` is designed to test the generation of an HTML page for a Python module using the `write_module_page` function. It sets up a temporary directory, defines mock data for a module including its name, summary, classes, and functions, and then calls `write_module_page` with this data. The function asserts that the generated HTML file contains specific elements such as a header, links to other modules, class and method summaries, and code snippets. It checks for the presence of certain strings and ensures that the HTML structure is correct, including the use of Markdown-like syntax for formatting.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_integration.py:e977cba7f0b91bc157a456c9b49e68be4ca45d263b578fcfe7b372ef54d38deb:e977cba7f0b91bc157a456c9b49e68be4ca45d263b578fcfe7b372ef54d38deb": "The module defines two tests for a documentation generator. The first test, `test_docgenerator_generates_html`, checks that the generator can process Python and MATLAB files in a project directory and produce HTML output with summaries. It uses a mock LLMClient to simulate API responses.\n\nThe second test, `test_static_copied_from_any_cwd`, ensures that static files like CSS are copied to the output directory regardless of the current working directory when running the generator.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_integration.py:test_docgenerator_generates_html:077a7bd9e5df8375cfe5ac401d99a17b0edee9d15bc9e8075144067983296ce8:077a7bd9e5df8375cfe5ac401d99a17b0edee9d15bc9e8075144067983296ce8": "The function `test_docgenerator_generates_html` tests the functionality of a documentation generator by creating a temporary project directory with Python and MATLAB files. It then simulates an interaction with a language model using a mock client to return a summary for each file. The function asserts that the main command (`main`) returns 0, indicating success. Finally, it checks that HTML files are created in the output directory for each file processed, and verifies that the summary text is included in one of the generated HTML files.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_integration.py:test_static_copied_from_any_cwd:15da737cc67dc4b6ad22da51a71c735ac0221c29eae226e3d6e214c5b7a31932:15da737cc67dc4b6ad22da51a71c735ac0221c29eae226e3d6e214c5b7a31932": "The function `test_static_copied_from_any_cwd` tests the behavior of a documentation generation tool when run from any working directory. It creates a temporary project directory, writes a simple Python module to it, and sets up an output directory for the generated documentation. The function uses a mock LLM client to simulate successful ping and summary responses. It changes the current working directory to the temporary path and runs the main function of the documentation generator with the specified project and output directories. After execution, it asserts that the static `style.css` file has been copied to the output directory.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_llm_client.py:ff8a0c5e5d3895b53e3efd3ac0badb2dca6ba723a90e55d61bc0a3a56cb89180:ff8a0c5e5d3895b53e3efd3ac0badb2dca6ba723a90e55d61bc0a3a56cb89180": "The module defines a set of unit tests for an `LLMClient` class. The client interacts with a language model to generate summaries and sanitize text. The tests cover various scenarios, including successful pinging, handling exceptions during pinging, retrying summary generation, raising runtime errors, sanitizing text, and ensuring prompt templates vary by type (class, function, readme).",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_llm_client.py:test_ping_failure:c4ed551e88d3eba2db24df954a83dc9806cdc080982bb5b2510766fed5789d59:c4ed551e88d3eba2db24df954a83dc9806cdc080982bb5b2510766fed5789d59": "This function tests the behavior of an `LLMClient` when a connection failure occurs during a ping request. It uses the `patch` decorator from the `unittest.mock` module to mock the `requests.get` method, causing it to raise a `RequestException` with the message \"fail\". The function then asserts that calling the `ping` method on an instance of `LLMClient` raises a `ConnectionError`.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_llm_client.py:test_ping_success:e3b2f3b81a34492074a63d936b2248a244b9e3d46a730a06e29596c103f30ee8:e3b2f3b81a34492074a63d936b2248a244b9e3d46a730a06e29596c103f30ee8": "The function `test_ping_success` tests the `ping` method of an `LLMClient` class. It creates a mock response object that simulates a successful HTTP GET request without raising any exceptions. The function then asserts that calling `client.ping()` returns `True`, indicating a successful ping. It also verifies that the `requests.get` function was called once with the specified URL and timeout, and that `raise_for_status` on the mock response was called to ensure no errors occurred during the request.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_llm_client.py:test_prompt_varies_by_type:fb29e39e7fd245f3b667dbc9b16776c142bd4c6a85b95f3ba6e4dcad7aca113b:fb29e39e7fd245f3b667dbc9b16776c142bd4c6a85b95f3ba6e4dcad7aca113b": "The function `test_prompt_varies_by_type` tests the behavior of the `summarize` method in the `LLMClient` class. It uses a mock response to simulate an HTTP POST request and checks if the prompts for summarizing a class and a function differ based on their types. The test asserts that the prompts are formatted using specific templates (`PROMPT_TEMPLATES[\"class\"]` and `PROMPT_TEMPLATES[\"function\"]`) and that they are not equal to each other.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_llm_client.py:test_readme_prompt_template_used:3e4c414ba3a9030e598e78ec017195a56a046fec0be2dfb77e264cf3a088fda4:3e4c414ba3a9030e598e78ec017195a56a046fec0be2dfb77e264cf3a088fda4": "The function `test_readme_prompt_template_used` tests whether the correct prompt template is used when summarizing a README file. It creates an instance of `LLMClient`, mocks the response from the language model, and patches the HTTP POST request to return the mock response. The function then calls `client.summarize` with \"foo\" as the text and \"readme\" as the type. It asserts that the second message content in the prompt matches the expected format of the README prompt template with \"foo\" inserted into it.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_llm_client.py:test_sanitize_summary_filters_phrases:fecfe881433b35c654c94b0d4246878841cca1ac35639ff5943080c68e1359ed:fecfe881433b35c654c94b0d4246878841cca1ac35639ff5943080c68e1359ed": "",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_llm_client.py:test_summarize_raises_runtime_error_with_message:bfc9ae80adfddddcab24f6ce990dd57758e06ea0a37276ad3c17f43aa3c09282:bfc9ae80adfddddcab24f6ce990dd57758e06ea0a37276ad3c17f43aa3c09282": "This function tests the `summarize` method of an `LLMClient` class. It mocks a request to a language model server that raises an HTTP error and a JSON parsing error. The function asserts that a `RuntimeError` is raised with the message \"server exploded\" when calling the `summarize` method with specific arguments.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_llm_client.py:test_summarize_retries_and_returns_summary:f9769083cf6ae5da6242fac5008805b8ccc3d0a4b2100725e338c2687af20710:f9769083cf6ae5da6242fac5008805b8ccc3d0a4b2100725e338c2687af20710": "This function tests the `summarize` method of an `LLMClient` class. It mocks a request to a language model that initially fails with an exception and then succeeds, returning a JSON response containing a summary message. The test asserts that the client retries the request once upon failure, waits for 1 second before retrying, and sends the correct prompt formatted with the provided text and module name.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_manual_utils.py:79194c18898c3be5fd9b77410afeef01c9f0a1405b52a64720962e71b081ca75:79194c18898c3be5fd9b77410afeef01c9f0a1405b52a64720962e71b081ca75": "The module defines two functions: `_count` and `test_chunk_docs_respects_token_limit`, `test_find_placeholders`. The `_count` function calculates the number of tokens in a given text using a tokenizer from `manual_utils`. The `test_chunk_docs_respects_token_limit` function tests if documents are chunked correctly according to a token limit. The `test_find_placeholders` function checks if placeholders within a text are identified and returned as a set.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_manual_utils.py:_count:c8ca15e7d492787f3288f26facf98fb39bf4614a96d4592fcf3e6977fbdc85bf:c8ca15e7d492787f3288f26facf98fb39bf4614a96d4592fcf3e6977fbdc85bf": "This function `_count` takes a string `text` as input and returns the number of tokens in the text. It uses the `TOKENIZER` from the `manual_utils` module to encode the text into tokens and then calculates the length of this tokenized list, which represents the count of tokens in the original text.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_manual_utils.py:test_chunk_docs_respects_token_limit:2b161b74498ea8137e5677c0b4cac9d8cce13f8f09a9ac739073cd13d602ea5f:2b161b74498ea8137e5677c0b4cac9d8cce13f8f09a9ac739073cd13d602ea5f": "The function `test_chunk_docs_respects_token_limit` tests the `chunk_docs` function from the `manual_utils` module. It verifies that the function correctly splits a list of document strings into chunks, ensuring each chunk does not exceed a specified token limit. The test creates three documents, each consisting of 1000 characters repeated, and then calls `chunk_docs` with a token limit of 2000. It asserts that the resulting list of chunks contains exactly two elements and that the number of tokens in each chunk is less than or equal to 2000.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_manual_utils.py:test_find_placeholders:000e6145081ca719bf3b8f97bd997f1866aa17b1a090cf22b1df157c3c042144:000e6145081ca719bf3b8f97bd997f1866aa17b1a090cf22b1df157c3c042144": "The function `test_find_placeholders` tests the `find_placeholders` method from the `manual_utils.py` module. It asserts that the method correctly identifies and returns a set of placeholder tokens found in a given text string. The test case checks if the placeholders `[[NEEDS_OVERVIEW]]` and `[[FOO]]` are accurately extracted from the input text.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_parser_matlab.py:d371df41f01bfadecc63c5f1bddb7b77eb2309a17405bffe247ca4a3e17973bd:d371df41f01bfadecc63c5f1bddb7b77eb2309a17405bffe247ca4a3e17973bd": "This module includes two test functions for parsing MATLAB files. The `test_parse_simple_matlab` function checks if the parser correctly extracts a header and a single function from a simple MATLAB file. The `test_parse_multiple_functions` function verifies that the parser can handle multiple functions in a single file, including their names and arguments.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_parser_matlab.py:test_parse_multiple_functions:ccd0bee5f58cd13ded4c6c47a9fdafba4d5c5e98106b6296a38eade486f7cdc2:ccd0bee5f58cd13ded4c6c47a9fdafba4d5c5e98106b6296a38eade486f7cdc2": "This function, `test_parse_multiple_functions`, is designed to test the functionality of parsing multiple MATLAB functions from a source file. It creates a temporary file containing two MATLAB functions: `compute` and `square`. The function then calls `parse_matlab_file` with the path to this temporary file as an argument.\n\nThe expected output is verified through assertions:\n1. The header of the parsed result should be an empty string.\n2. There should be exactly two functions parsed from the file.\n3. The names of these functions should be \"compute\" and \"square\".\n4. The arguments for each function should match their definitions: `compute` takes two arguments (`a`, `b`) and `square` takes one argument (`x`).",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_parser_matlab.py:test_parse_simple_matlab:3a86b7e9b90ae62c008764e4b79e08a4d9e3bbeef42659a0a2bd63b337387235:3a86b7e9b90ae62c008764e4b79e08a4d9e3bbeef42659a0a2bd63b337387235": "This function `test_parse_simple_matlab` tests the parsing of a simple MATLAB file using the `parse_matlab_file` function. It creates a temporary MATLAB file with a header and a single function definition, then asserts that the parsed result contains the correct header and function details. The test checks for the presence of the function name \"add\" and its arguments [\"x\", \"y\"].",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_parser_python.py:0656a74b22ae45e63880587901e7b10ae787467de6bd22083f6803af85bd3957:0656a74b22ae45e63880587901e7b10ae787467de6bd22083f6803af85bd3957": "This module contains tests for parsing Python files using the `parse_python_file` function from the `parser_python` module. It includes several test cases to verify the correctness of the parser, covering various scenarios such as simple modules, complex function signatures, nested structures, deeply nested classes, and classes inside methods. Each test case creates a temporary Python file with specific content, parses it using `parse_python_file`, and asserts that the parsed results match the expected structure and attributes of the code.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_parser_python.py:test_class_inside_method:255142db4f7f7c6ab07ead997a01e560d01f74fa9d3eab82e57434d36726c7eb:255142db4f7f7c6ab07ead997a01e560d01f74fa9d3eab82e57434d36726c7eb": "This function tests the parsing of a Python file containing a class inside another method. It creates a temporary file with the specified source code, parses it using `parse_python_file`, and asserts that the outer class `A` has one subclass `B`, which in turn contains one method `m`.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_parser_python.py:test_deeply_nested_classes:c6941e7bf0c3e42d1a431224d99e257abc17f879eb35491aa0587c01008d80cc:c6941e7bf0c3e42d1a431224d99e257abc17f879eb35491aa0587c01008d80cc": "The function `test_deeply_nested_classes` is designed to test the parsing of Python files containing deeply nested classes. It uses a temporary directory provided by `tmp_path` to create a file named `deep.py` with a nested class structure. The function then calls `parse_python_file` to parse this file and asserts that the nested classes are correctly identified and their methods are properly listed.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_parser_python.py:test_parse_complex_signature:de7241b09455225d7e4940b567426d75c067dd9696cdf91898932c7dc2027753:de7241b09455225d7e4940b567426d75c067dd9696cdf91898932c7dc2027753": "This function tests the parsing of a complex Python function signature. It creates a temporary file with a sample Python code snippet containing a function with various parameters and a docstring. The function then parses this file using `parse_python_file` and checks if the parsed signature matches the expected output, as well as if the docstring is correctly extracted and included in the source code.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_parser_python.py:test_parse_nested_structures:a8c504f17f9fafbcbf8b0f3d2b36ddd10bcd8430aa01e69f608eb054aa238649:a8c504f17f9fafbcbf8b0f3d2b36ddd10bcd8430aa01e69f608eb054aa238649": "This function tests the parsing of nested structures in Python files. It creates a temporary file with nested functions and classes, then uses `parse_python_file` to parse the file. The test asserts that the parsed result contains the expected nested structures: a function named \"outer\" with a subfunction \"inner\", and a class named \"A\" with a subclass \"B\" containing a method \"method\".",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_parser_python.py:test_parse_simple_module:0a6062426de7093cc9135ed7d223eb3c2104a9ae2e07cab54bcbb662c206038b:0a6062426de7093cc9135ed7d223eb3c2104a9ae2e07cab54bcbb662c206038b": "This function tests the parsing of a simple Python module using the `parse_python_file` function. It creates a temporary file with a sample Python script containing a module docstring, a class with a method, and a standalone function. The test asserts that the parsed result includes the correct module docstring, class name, class docstring, method signature, method docstring, and source code for both the method and the function. Additionally, it verifies that the function's return type is correctly identified as \"int\".",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_reviewer.py:83233473a3bb44ee0c5e26502caa85ad29205c84af0e40280e3fd12a3f730505:83233473a3bb44ee0c5e26502caa85ad29205c84af0e40280e3fd12a3f730505": "The module defines a test suite for a code review tool. It includes functions to create temporary module pages, and tests to detect issues such as assistant phrasing, contradictions, and hallucinations in the code documentation. The `test_autofix_removes_phrasing` function also checks if autofix functionality removes specified phrases from the generated HTML files.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_reviewer.py:_make_module:be00b1a17ce76e1a37ea4f9ac1a2150d9db23951b45771070b544982b1337412:be00b1a17ce76e1a37ea4f9ac1a2150d9db23951b45771070b544982b1337412": "The function `_make_module` creates a temporary module page with specified summary and methods. It constructs a dictionary `data` containing the module's name, summary, and optionally classes and methods. If methods are provided, it includes a class named \"Foo\" with an empty docstring and summary, and the list of methods. The function then writes this data to a module page using the `write_module_page` function, which takes the temporary path, data, and a list of tuples specifying file names and paths. Finally, it returns the path to the generated module HTML file (`mod.html`).",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_reviewer.py:test_assistant_phrasing_detected:623edbe11ed048878199182592ca4264f4156328fed761eef5011257051e14e2:623edbe11ed048878199182592ca4264f4156328fed761eef5011257051e14e2": "This function `test_assistant_phrasing_detected` is designed to test if the assistant phrasing is detected and included in the output when generating documentation for a Python project. It creates a temporary module with specific content, runs the main function of the project with this temporary path as an argument, captures the standard output, and asserts that both \"[ASSISTANT]\" and \"mod.html\" are present in the output.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_reviewer.py:test_autofix_removes_phrasing:b8a7ebfd17317d40c3c9f10153f468397ee3d0121ff368913283a6bed7479c9e:b8a7ebfd17317d40c3c9f10153f468397ee3d0121ff368913283a6bed7479c9e": "The function `test_autofix_removes_phrasing` is a unit test that verifies the functionality of an autofix feature. It creates a temporary directory, generates an HTML file with specific content using `_make_module`, and then runs the main function with the `--autofix` option. The test checks if the phrase \"You can\" has been removed from the generated HTML content.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_reviewer.py:test_contradiction_detected:f8ddd0057582cb319a777d9a0a72449372754601bdc812493f03a57846acf219:f8ddd0057582cb319a777d9a0a72449372754601bdc812493f03a57846acf219": "This function `test_contradiction_detected` is designed to test the detection of contradictions within a module's documentation. It takes two parameters: `tmp_path`, which is a temporary directory path provided by the `pytest` framework, and `capsys`, which captures standard output and standard error.\n\nThe function performs the following steps:\n1. Defines a list of methods with specific attributes such as name, signature, docstring, and source code.\n2. Creates a module in the temporary directory using `_make_module`, passing it the temporary path, a description indicating no methods are defined, and the list of methods.\n3. Calls the `main` function with the string representation of the temporary path.\n4. Reads the captured output from standard output (`out`) using `capsys.readouterr().out`.\n5. Asserts that the string \"[CONTRADICTION]\" is present in the captured output, indicating that a contradiction has been detected.\n\nThis test ensures that the system correctly identifies and reports contradictions in the documentation of Python modules.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_reviewer.py:test_hallucination_detected:9c7ce459442d01793a066b49434e20cd9784240fa3045daf799cf084a09b5bc9:9c7ce459442d01793a066b49434e20cd9784240fa3045daf799cf084a09b5bc9": "This function `test_hallucination_detected` is designed to test for the detection of hallucinations during documentation generation. It creates a temporary directory, simulates a module implementation within that directory, and then runs the main documentation generation process using the specified path. The function captures the output generated by the process and asserts that the string \"[HALLUCINATION]\" is present in the output, indicating that the detection mechanism has identified a potential issue of generating incorrect or misleading information.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_scanner.py:3ec32c624e4312ae44349511245ebc4be1d33ae9233f8c4ba760f4c5f65f37f1:3ec32c624e4312ae44349511245ebc4be1d33ae9233f8c4ba760f4c5f65f37f1": "The module defines a test suite for the `scan_directory` function from the `scanner` module. It includes three tests:\n\n1. **test_scan_directory_ignore_folder**: Creates files and directories, including an \"ignore_me\" directory with a file inside it. Tests that the `scan_directory` function ignores the \"ignore_me\" directory when provided as an ignore list.\n\n2. **test_scan_directory_mixed_file_types**: Creates files of various types (Python, M, TXT) in different directories. Tests that the `scan_directory` function returns only Python and M files, excluding TXT files and nested MD files.\n\n3. **test_scan_directory_skips_git_folder**: Creates a file inside a `.git` directory. Tests that the `scan_directory` function skips any files within the `.git` directory from the results.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_scanner.py:create_files:61936c3ac012d5205655ba6a7e19ab7ca78544ba12f4944bd4aa2b6f953cd250:61936c3ac012d5205655ba6a7e19ab7ca78544ba12f4944bd4aa2b6f953cd250": "The function `create_files` takes a base directory and a list of relative file paths as arguments. It iterates over the list of file paths, creating any necessary parent directories using `path.parent.mkdir(parents=True, exist_ok=True)`, and then writes an empty string to each file using `path.write_text(\"\")`.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_scanner.py:test_scan_directory_ignore_folder:844f37b8a1ad21ddfaebca5a853e591c4820825674d0e60cd0d340daa19fd917:844f37b8a1ad21ddfaebca5a853e591c4820825674d0e60cd0d340daa19fd917": "The function `test_scan_directory_ignore_folder` tests the `scan_directory` function with a temporary directory containing various files and subdirectories. It ensures that files within directories specified in the ignore list are not included in the result. The test creates a temporary directory, populates it with files and a subdirectory to be ignored, then calls `scan_directory` with the path of the temporary directory and a list containing the name of the directory to ignore. The expected output is a set of file paths excluding those within the ignored directory. The function asserts that the result matches the expected set of file paths.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_scanner.py:test_scan_directory_mixed_file_types:3ec1c89aa6b59292ccb996264b160d8ddb5229a49e3428067bb182cb3e24b728:3ec1c89aa6b59292ccb996264b160d8ddb5229a49e3428067bb182cb3e24b728": "This function `test_scan_directory_mixed_file_types` tests the `scan_directory` function by creating a temporary directory with files of various types and then scanning it. It asserts that the scan result contains only Python and MATLAB files, excluding text and Markdown files, and correctly identifies nested directories.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_scanner.py:test_scan_directory_skips_git_folder:75c3ec20e06b515392f40168f2a65b60e56efeebcd5a2f6c842239fd07ed112b:75c3ec20e06b515392f40168f2a65b60e56efeebcd5a2f6c842239fd07ed112b": "This function tests the `scan_directory` function to ensure it skips files and directories within a `.git` folder. It creates a temporary directory with specified files, including those inside a `.git` subdirectory, then scans the directory. The test asserts that the path to \"good.py\" is included in the scan result while paths containing \".git\" are excluded.",
  "PROJECT:7ccbc41643685004d87ee38085517aca5bf79e7099f28dc21f516eb15acdc90a:7ccbc41643685004d87ee38085517aca5bf79e7099f28dc21f516eb15acdc90a": "This project consists of multiple modules for generating documentation and analyzing code. The `cache.py` module provides a caching mechanism for responses. The `chunk_utils.py` module includes functions for chunking text into manageable parts. The `docgenerator.py` module handles the main logic for summarizing Python files, including parsing classes and functions, and generating summaries. The `explaincode.py` module focuses on collecting documentation from code, analyzing it, and injecting it into a user manual. The `gui_wrapper.py` module provides a graphical interface for running commands and displaying logs. The `html_writer.py` module generates HTML content from the collected data. The `llm_client.py` module interacts with a language model to generate summaries. The `manual_utils.py` module assists in parsing and summarizing user manuals. The `parser_matlab.py` and `parser_python.py` modules parse MATLAB and Python files, respectively. The `reviewer.py` module reviews the generated documentation for quality issues. The `scanner.py` module scans directories for source code files. The `summarize_utils.py` module provides utility functions for summarizing text. The project includes numerous test modules to ensure functionality across different aspects of the system.",
  "README:f1cb802fcbfcec44847809c9e8a7a65f232451af52e977b266e09dc473b5712a:f1cb802fcbfcec44847809c9e8a7a65f232451af52e977b266e09dc473b5712a": "DocGen-LM is a tool that generates static HTML documentation for Python and MATLAB projects by analyzing source files with a local LLM. It supports nested functions and subclasses, rendering complex structures as expandable sections in the output. The tool includes both CLI and GUI interfaces, allowing users to specify project directories, output paths, and LLM server details. Additionally, it provides a utility called `explaincode.py` for generating lightweight project summaries with options for PDF output and code scanning.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\cache.py:ResponseCache:4bf39f0ddf33468e133fc0de74e4b5ffcc04454990de01f6d9556f317e81e88f:bb8c5e04ff12539d13e7ca41ecbd56f704e29527621cb046143ffeb35745f4a7": "The `ResponseCache` class provides a mechanism for caching and persisting language model (LLM) responses using deterministic keys derived from file paths and content. It initializes by loading existing cache data from a specified file path, or creating an empty cache if the file does not exist. The class includes methods to get and set cached values, ensuring that changes are persisted to disk with proper formatting.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\cache.py:__init__:8b5c10444606ffbc9da1741a226105c669597fe38b767c5715e89560e731b4d4:4d9182371bfb2c0f3af43aaa918dbd364b276ebd480f2d55a08d9848dbad8e75": "Initializes a `ResponseCache` instance with a specified file path. If the file exists and contains valid JSON data, it loads the data into an internal dictionary `_data`. If the file does not exist or contains invalid JSON, it initializes `_data` as an empty dictionary.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\cache.py:_save:353e7c2c1a589b49c7f3484aa95e55c54489b102d752df3a6c1fae250350d613:bd86e4bfd15af431f507e9ffad5a42d257a7e44deb8a827951de9ff7a72097a5": "This function `_save` is a method of the `ResponseCache` class. It saves the cached data to a file in JSON format. The data is written using UTF-8 encoding and formatted with an indentation of 2 spaces for better readability, and keys are sorted alphabetically.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\cache.py:get:a2aad8e8e39394961351d2b20a3448b43bdb29f238adc131abb483662f831d5e:c8c72860fa480602327b344b348a7b808f6ea784877d89e4a05cb62912ad89ab": "The `get` method in the `ResponseCache` class retrieves the cached value associated with a given key. It accepts a string `key` as an argument and returns the corresponding cached value if it exists, or `None` if the key is not found in the cache.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\cache.py:make_key:77bf3ca2be4b78e9a6743bdaf655228ec0b82b984aacd426cfa703c4ef250fe8:767caf83deb7d48683cdf80acc02dff7ce863691446be7d111cf0ea4bf5e0a0b": "The `make_key` function generates a unique key by combining the file path with the SHA-256 hash of the content. This key is used for deterministic caching in the `ResponseCache` class, ensuring that responses are stored and retrieved based on their source file and content.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\cache.py:set:7e4479b9c8b2435d239858cb76104f21676c57325f40b1ea537c6fed483e9c59:8d9b9bf390ad2229e7f68ad67943a8bddfc395f5284933e81240ed3dceea9a97": "The `set` method in the `ResponseCache` class stores a value under a specified key and persists this data to disk. It updates an internal dictionary `_data` with the provided key-value pair and then calls the `_save` method to ensure the changes are written to storage.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\chunk_utils.py:_split_blocks:916a2309c858ded83e89fdb7d7684ddad5f09562b824b23a18715d375e328d1a:49589ae413dbc61ce014dd1fa102aa41554bebe18b8b9d38538e5cdbde2b92fb": "The function `_split_blocks` takes a string `text` as input and returns a list of Markdown blocks, which are separated into paragraphs, headings, and code fences. It processes the text line by line, identifying block boundaries based on specific patterns (e.g., empty lines, heading syntax, and code fence markers). The function handles nested structures and ensures that each block is properly formatted and stripped of unnecessary whitespace before being added to the result list.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\chunk_utils.py:_split_long_block:ed0cb40b4f2f904f22b72ba6eedca26ebad610381f2f86a0b8cf2f67292a25c5:9e9b69ff96cf6833b6161605130c8f492d3e11f78da7d8d101fa7829b0678a31": "This function `_split_long_block` takes a string `block`, a tokenizer, and an integer `chunk_size_tokens`. It encodes the block into tokens using the provided tokenizer. If the number of tokens is less than or equal to `chunk_size_tokens`, it returns the original block as a single-element list. Otherwise, it calculates an average character length per token and determines a maximum character length for each chunk based on this average. The function then splits the block into chunks of characters up to `max_chars` in size and returns these chunks as a list.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\chunk_utils.py:chunk_text:deab173f148509c837a5af653b8fd1055ead1fd84cf9c01f9f8333c37718c0e0:01b8f6fdb832b980969c3a7c4a22204d35b38b59a0c25db95ac28515e0ae17d9": "The `chunk_text` function splits a given text into chunks of approximately the specified number of tokens. It uses natural break points such as blank lines, Markdown headings, and fenced code blocks to ensure meaningful divisions. If a single block exceeds the token limit, it falls back to splitting that block by character length. The function returns a list of chunked text.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\chunk_utils.py:get_tokenizer:5111cd14c00e80d0356a94d262a76665684af798c9019e28f11ff67a11b71520:2b3f1ce6b7d43f80923d6ca3b06fffc6a04a68f2856c69865b5d7ec54a429f8e": "The `get_tokenizer` function returns a tokenizer object used for estimating token counts. It first attempts to import and use the `tiktoken` library with the \"cl100k_base\" encoding. If `tiktoken` is not available or encounters an error, it falls back to using the \"gpt-3.5-turbo\" model. If both models fail, it prints a warning message indicating that token counts will be approximate and returns a simple tokenizer class that splits text into tokens by whitespace.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\docgenerator.py:_build_function_prompt:13a860b33b5005452433772506becd6a5ee84cb6e62a308f9999b911433abf13:8e91dfaf6d96fbb473557d11e827e711f652882acd2ea2ecc14a6745f00c214d": "This function `_build_function_prompt` constructs a prompt for summarizing a Python function based on its source code. It takes four parameters: `source`, `class_name`, `class_summary`, and `project_summary`. The function returns a string that includes the following elements:\n\n1. A brief introduction as a documentation generator.\n2. Information about the class to which the function belongs, if provided (`class_name`).\n3. A summary of the class, if provided (`class_summary`).\n4. A summary of the project, if provided (`project_summary`).\n5. Instructions on how to summarize the function based on its source code.\n6. The source code itself enclosed in a code block.\n\nThe purpose of this prompt is to provide context and instructions for generating a concise summary of a Python function, ensuring that the summary adheres to specific guidelines and uses only the provided information and code.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\docgenerator.py:_chunk_module_by_structure:825f6a10e7445e1bb006a336ed5e4db051c1d24dd061c347a4f9c736687c1567:a72ca18613eb564886dca50e91cb8bda4990ca88f637ed1eb14a4a5238490482": "The function `_chunk_module_by_structure` processes a parsed Python module dictionary, breaking down its source code into text chunks based on the specified `chunk_size_tokens`. It first extracts the module's docstring and adds it to blocks if available. Then, it iterates through classes and functions within the module, adding their source code to blocks. If a class or function's source exceeds the token limit, it is further chunked using another function (`chunk_text`). The function ensures that chunks do not exceed the token limit by combining smaller blocks until the limit is reached, then starting new chunks. Finally, it returns a list of text chunks representing the module's parsed structure.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\docgenerator.py:_rewrite_docstring:ddb0e982201318de6c7f5c5a5ee051a06b07622ae6805c3c5ba79fddc07a5cd9:2b568b3bd955c3706aab61b1274e9ce067608bc3b83567d6c2010d0bb6179922": "The function `_rewrite_docstring` rewrites the docstring of a code item using an optional context provided by class and project summaries. It uses an LLM client to generate the new docstring, caches the result for future use, and updates the item with the sanitized summary or a default message if no summary is available.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\docgenerator.py:_summarize_class_recursive:17084ec99d83c7f3e29d256f11d20c724b5979435e4e80b01a4fa7836b2946ca:05545fc49af89e2e2030f527899efe335ca383251f9b657dee4e082617c3c316": "This function recursively summarizes a class and its methods. It first summarizes the methods, then constructs a prompt for summarizing the class itself, caches the result, and updates the class's docstring and summary. If the original docstring exists, it rewrites it using the updated summary. The function also handles subclasses by calling itself recursively.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\docgenerator.py:_summarize_methods_recursive:b813c6613905a511db5ccc0ec7368f8adb4437a9e08e050585bda79dfde4187d:511294f5d054840f766102a58f33cdd6510c09ae9bed46f8f6c32c7cf57c39ea": "This function recursively summarizes methods within a given class and its subclasses. It takes class data, a file path, an LLM client, a response cache, a tokenizer, maximum context tokens, and a chunk token budget as inputs. For each method in the class, it generates a summary using the `_summarize_chunked` function and assigns it to both the `summary` and `docstring` keys of the method dictionary. The function then recursively calls itself for each subclass within the current class.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\docgenerator.py:_summarize_module_chunked:f726be9df98009f5187276a69fcd46227cb53ea096239204bcb1c63c7b311c22:12164ebc467de30417d75aa6bce2048107d749aa05d1a0adb5419fcaf2a88a24": "This function `_summarize_module_chunked` is designed to summarize a Python module using structure-aware chunking. It takes parameters including an LLM client, response cache, key prefix, module text, module dictionary, tokenizer, maximum context tokens, and chunk token budget.\n\nThe function first calculates the available tokens for summarization after accounting for overhead from system prompt and template encoding. If the entire module text fits within these available tokens, it caches and summarizes the module directly.\n\nIf the module text is too large, it attempts to structure-awarely split the module into smaller chunks based on its structure. If successful, it recursively summarizes each chunk and then combines these summaries into a single technical paragraph using another recursive function `_merge_recursive`. This process ensures that the final summary does not exceed the available tokens.\n\nThe function handles potential exceptions during chunking and summarization steps, printing warnings and falling back to direct summarization if necessary. It uses a set of instructions to guide the merging process, ensuring that only explicitly defined code is summarized without speculation or critique.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:Config:0b3ed3eff1c79c43fbe5d931fef9fce219dad2ae4a03975c80a50074ce4a92d9:594733ac4138c0c5ad11ce6e6840136f00c85e7c41a44ed0802b36201d93f5ba": "The `Config` class defines a data structure for configuration settings parsed from command-line interface (CLI) arguments. It includes properties such as file paths, output formats, and various boolean flags to control behavior related to code scanning, chunking, and file size limits.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:_edit_chunks_in_editor:f1a5d705935582f2dc3640e05c031975e1db699de4e2112ae12ac7bc460b0a72:7ccb7e4d990ab112a8bb022b43e2daa15a97ccc3f0cfb59fe5e4cdcbc61055ed": "This function `_edit_chunks_in_editor` takes a list of strings (`chunks`) as input, where each chunk is separated by lines containing `---`. It opens these chunks in the user's default editor (either specified by the `EDITOR` or `VISUAL` environment variables, or defaults to \"vi\" if neither is set). After editing, it reads back the modified content, splits it into individual chunks based on the separator, and returns a list of non-empty, stripped chunks.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:collect_docs:ed77324fa373c73ccc8559c8ea323217c948794399210a615fa1e55a5c7853fd:e240a53f873f1b6e9dd7e671f89590e96edd981c74438739a81adc6ce8f0271a": "The `collect_docs` function collects documentation files from a specified base directory. It searches for files with specific extensions (`.md`, `.txt`, `.html`, `.docx`) in the project root and within a subdirectory named `docs`. The function uses glob patterns to match these file types and ensures that only unique files are returned by maintaining a set of seen paths.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:collect_files:4d3654312c995ea47d8b6390eeab31de6e308c14b363881c49fbe8c9dda76412:eae31f02a5b22b8ae8a67970756c848cdf2be9209440bd6a7c1437eab3094d76": "Collects files from a specified base directory that are relevant for summarization, including common document types like README.md, text files, HTML, DOCX, CSV, JSON. Optionally accepts additional patterns to include specific file types. Returns a list of unique file paths.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:detect_placeholders:1b686d93632765f9062ffc8ed8f256b129aacc4ee5796e76b8696d233e692ab3:c802c7411466b96c4d60fc18c1f342cc75b03efd1043be2a31cc99173af5a987": "This function `detect_placeholders` takes a string `text` as input and returns a list of section names that are still marked by placeholder tokens. It uses the helper function `find_placeholders` to identify all placeholders in the text. Then, it filters these placeholders against predefined SECTION_PLACEHOLDERS dictionary to match them with their corresponding section names, returning only those sections that contain placeholders.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:extract_snippets:cc55f18b72d3fe5eb83c60dca498baaf3edb7fd5990fb5810cff6ca28054e461:8cd55f9fb6ba32dce8b373a979ad3589d0154892de0084f98f05265c80f569da": "This function `extract_snippets` processes a list of Python and MATLAB files to extract relevant code snippets. It filters files based on the number of files processed (`max_files`), time elapsed (`time_budget`), and file size (`max_bytes`). For each file, it reads up to the specified byte limit and extracts:\n- Module docstring\n- Docstrings from classes and functions\n- Function arguments related to I/O operations\n- CLI parser code\n- `__main__` block content\n\nThe extracted snippets are stored in a dictionary with the file paths as keys. The function uses logging to provide information about each file being processed and any issues encountered during extraction.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:extract_text:5b618deb46a8aa3cd1f07ec0871bb95b1872538c68457e9f546353021bc5beb5:8d37c86ac5e2fdead89b76eb732ef8b50aa8a52b4918057dd2ce1c4f513aacbb": "The `extract_text` function reads the content of a file located at the given `path` and extracts plain text based on its file type. It handles different file formats such as `.html`, `.md`, and `.docx`. For HTML files, it uses BeautifulSoup to parse the content, replace headings with markdown-style headers, and convert code blocks into fenced code blocks. For Markdown files, it simply reads the text. For DOCX files, if the `Document` class from the `python-docx` library is available, it parses the document and extracts text, converting heading styles into markdown-style headers. If any exceptions occur during the process, it returns an empty string.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:infer_sections:415feac8c4cd09fed70c476f1d13ab4c478b3289aa6276cf8f56e1172447a04b:6ea28a067a36526477314595794cef33e8f6d5cb58c8be1d891aeca9674ed1c9": "The `infer_sections` function takes a string of plain text and attempts to infer manual sections from it. If the input text is non-empty, it places the entire text under an \"Overview\" section and generates placeholder content for other required sections labeled \"(inferred)\". If the input text is empty, it provides a default message indicating that no information exists for all sections. The function returns a dictionary where keys are section names and values are the corresponding content.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:inject_user_manual:377c43249078e291a53eb2536f539cfa8bf472a2afaa429d44f11adfa75b346f:3acdf3101f2ae84579377644317b7c324d18ba1556fddbe3fedd84ea39d61c8c": "Inserts a top-level link to a user manual into an HTML file. The link is added to the first navigation element (`<nav>` or `<ul>`) if present; otherwise, it is inserted at the start of the first element in `<body>` or the document root.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:insert_into_index:3385c489a4cc96628432e7f6730acf48402cd10f4c7f136ea1af4b0298df63a5:5dda1cddc9f32b54af0d03577a2e3d2705d108b0d1bae3d240f5f5dd539cea8d": "The function `insert_into_index` appends a navigation entry linking to a specified file into an HTML index file. It reads the existing content of the index file using BeautifulSoup, finds or creates a container element (either `<ul>` or `<nav>`), checks if the link already exists, and then adds a new `<a>` tag with the provided title and filename as its href attribute. Finally, it writes the updated HTML back to the index file.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:llm_fill_placeholders:e0e7ec0f86bc2205459651c87585a4148d030f9c496cc836da4c4fd124e327db:fb997728898771a421ac89c061b2a95eccd16bfc4276ef06e5224e93cdc4282a": "The function `llm_fill_placeholders` takes a string `manual_text`, a dictionary of `code_snippets`, an `LLMClient` object, and a `ResponseCache` object as input. It fills placeholder tokens in `manual_text` using the code snippets provided. The function iterates over each section in `code_snippets`, concatenates the code snippets into a single string, and checks if the combined text exceeds the maximum context token limit. If it does, the snippet is summarized using the `summarize_chunked` function. Then, a prompt is created to update the manual by replacing the placeholder for the current section with the relevant information from the code snippets. The updated manual is returned as output.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:llm_generate_manual:27176ae15f302a38a6bde100788a7b07ddaa4e5cc8c83671b082ae359a6e16fb:359d02b4df2083dcaf25d9e5fb7791792384511fe6a5f088ef2e8c5b329749ea": "The function `llm_generate_manual` takes a dictionary of documentation snippets, an LLM client, a response cache, and an optional chunking strategy as input. It maps the documentation snippets to manual sections, performs an LLM call for each section, and assembles the final manual text. The function returns the manual text, a mapping of source files to the sections they contributed, and an evidence map capturing the snippets used for each section.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:map_evidence_to_sections:a10549945d7d42b987c26de2b9e6b52fa2d2d6d064db6f9540de8c8e9ae4a8e8:4093fa6ba6b1277dfbe92aff87c501b63aed2afa1030bcd032cdafddca0081df": "The `map_evidence_to_sections` function takes a dictionary of documentation snippets as input and returns two dictionaries: one mapping section names to a list of tuples containing source paths and snippets, and another mapping each source path to the set of sections it contributed to. The function processes each snippet by checking if it contains any keywords associated with specific sections. If a keyword is found, the function extracts up to 10 lines (or fewer if in excluded directories) following the keyword as a snippet. It then adds this snippet to the corresponding section in `section_map` and records the section in `file_map`. After processing all snippets, it sorts the entries in each section by length or priority, keeping only the top 10 snippets per section.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:parse_manual:c707d39b7e9f85323f63d7b5820c0c926b481802df5ec679830536e83b002542:412b7051640c77f528c30db5741f54e4404be1317f32112fb26246fa8906fde6": "The `parse_manual` function takes a string of text, an optional LLMClient instance, and a boolean flag for inferring missing sections. It parses the input text into structured sections based on lines containing a colon. If `infer_missing` is True and any required sections are absent, it uses the provided LLMClient to infer these sections and marks them as \"(inferred)\". The function returns a dictionary of section titles and their corresponding content.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:rank_code_files:e7476981a802279613be0db714e193ed44aee49feeced5fb1ee44466866d9f87:c480caff561416eb4f94e7de4a12a1cb26ea3e96ce8fc77d1d77eb3a7991ce72": "The `rank_code_files` function ranks Python, MATLAB, and Jupyter Notebook files under a specified root directory based on simple heuristics. It skips certain directories and file extensions to focus on relevant code files. The ranking is determined by a score that increases if the file path contains keywords related to running or configuring software (e.g., \"run\", \"main\", \"cli\") and if it matches patterns specified by the user for documentation references. The function returns a list of paths sorted by their scores in descending order, with higher scores indicating more relevant files.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:render_html:5789a899e08d8de56820b9583bc3636deb9b73cb2e21a7bd178fb7d6c5925e9d:676dbd3001d95be9bfc6cbffe4e84637613c3167952b927a3c5d9a86f8a11a25": "The `render_html` function generates HTML content from a dictionary of sections, a title, and an optional evidence map. It slugifies section titles for navigation links, constructs a table of contents (TOC) using these slugs, and populates the body with section content. If a section is empty or lacks information, it renders supporting snippets from the evidence map instead. The function also handles Markdown rendering if available, escaping text otherwise. Finally, it wraps everything in an HTML structure with basic styling for readability.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:scan_code:d0b053db7430278d292930a6639ca315295c1475e88cfb10e8bf95223bafe82d:d9e82d404cb4ae5576904d982666a9df39a5111a8f38668f57f448b214503891": "The `scan_code` function collects source code snippets from a specified base directory, grouping them by manual sections. It searches for keywords associated with the given sections (or all known sections if none are provided) and returns a dictionary mapping section names to another dictionary of relative file paths and their corresponding snippet text.\n\nHere's a breakdown of the function's key steps:\n\n1. **Pattern Collection**: The function collects patterns from documentation files in the base directory. It searches for keywords that match specific criteria (e.g., containing slashes or ending with \".py\").\n\n2. **File Ranking**: It ranks code files based on the collected patterns.\n\n3. **Snippet Extraction**: The function extracts snippets from the ranked files, limiting the number of files and bytes processed based on provided parameters.\n\n4. **Categorization**: It categorizes the extracted snippets by the specified sections or all known sections. For each section, it checks if any keywords associated with that section are present in the snippet text.\n\n5. **Result Compilation**: The function compiles the categorized snippets into a final dictionary and returns it, excluding empty sections.\n\nThis function is useful for collecting relevant code snippets from a project's source files and organizing them by specific documentation sections, facilitating the generation of structured documentation.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:slugify:22057c7364a6d34e1d199dcde0c4084431df159a620b88dc5f71f1fd38ed5898:c3681857bab75151bf60941f40c7d883848af1cd02c174eaa3eda935e589bcaa": "Converts a given string into a filesystem-friendly slug by replacing non-alphanumeric characters with underscores and converting to lowercase. If the resulting slug is empty, returns \"user_manual\".",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:validate_manual_references:0d2f5d402b248d5901a69dd06bfc07a753d10a476ea345b4626538ccac1c9efc:557b850bf3d8df1d0bff6fdfc241d6cbe97090de97ee5cb9935d2a95f8958c00": "This function `validate_manual_references` checks for references in documentation sections that lack corresponding files within a project. It uses regular expressions to identify file paths or module names in the text of each section. If a referenced file is not found under the specified project root, it appends \"[missing]\" to the reference in the section text. Additionally, if an `evidence_map` is provided, it records these missing references under the corresponding section's \"missing_references\" list. The function modifies the input `sections` dictionary in place with the updated text and updates the `evidence_map` accordingly when necessary.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:write_pdf:8f36d629ba041aa3b6c5e19eff9bf2e8d4bae601778352023439fd1a9bf7fb5d:0def29af197aef8f497e05526eadedcfecb59afc02d3bfc836ec3584686fb922": "The `write_pdf` function takes HTML content and a file path as input. It checks if the `canvas` module is available; if not, it returns `False`. Otherwise, it converts the HTML to plain text, creates a PDF document using the `canvas` library, writes the text lines into the PDF, saves the document at the specified path, and returns `True` on success.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:__init__:265949bfb922f39f768841de9fdfbd7cb092a70769e1159be4f773afd2235c06:9d35f778efa96a222c6df7ce5dae0288df9ecdc70d2c30b83a98cdb10f33aa29": "The `__init__` method initializes a `CollapsibleBox` instance. It sets up a toggle button with the provided title and makes it checkable. The button's style is customized to remove borders, change text color, and set font weight. The arrow type of the button is set to right. A connection is made between the button's click event and the `on_toggled` method.\n\nA content widget is created and initially set to be invisible. A vertical layout is added to the main widget, setting its margins to zero. The toggle button and content widget are then added to this layout in that order.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:__init__:a634a9a761c8445444638677a3864f4b37d4d2f3dd1b8c3edde06a7adaf44482:b6f2673b90468b240453cf63bfaa61d88bdae8e725f6491a8203d1258095fca3": "This function initializes the `MainWindow` class, setting up a graphical user interface for the DocGen-LM documentation tool. It includes components for selecting project and output directories, configuring options such as including private functions and supported languages, and selecting an output format for ExplainCode. The interface also provides buttons to run commands for generating documentation and explanations, handle logging, and manage the state of running processes.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:__init__:b3d8b0945286a7118954e0296b25fb82c37ea5f6e588b0709e7fc4c145c20aa4:de0a42b9d730abefce25c430e926f87db029bab75015fb3521355221c7f84936": "The `__init__` method initializes a new instance of the `PathLineEdit` class. It accepts an optional `parent` object and calls the constructor of its superclass with this parent. The method then sets the drag-and-drop acceptance property of the line edit to `True`, enabling it to accept dropped data.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:__init__:ed8cc71ce2ea222521521151ed173090240eca9e57ec4f77f6cb89b48c3dfcba:a626d76f8e9f63e93a39e5e1562bd2fdbef2949d47a8e6e8b660c2309b6fe0e8": "The `__init__` method initializes a new instance of the `CommandRunner` class. It takes a list of commands (`cmds`) as an argument and assigns it to the instance variable `self.cmds`. The superclass constructor is also called using `super().__init__()`, ensuring that any initialization defined in the parent class is executed.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:_reader:466f5e790baf164d8bf3aaa9eba6bd12db87f680b2070889972aa5280c21f6bc:b45811d97e7a47e1700e4c3a89fd188ded4bd46e70749cf47587bb3df6c6657c": "The `_reader` method reads a stream character by character, emitting chunks of text as they are read. It handles carriage returns and newlines to ensure the GUI can update progress bars correctly. Any buffered text is flushed when the stream ends.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:append_log:67b5f605d77e475df8be79be88076ecc43282126fdead090a0c69b1bc26e0de7:3f5bd0aaf4442991222ca01921ee39c1e1535afd0cfde348700f269a32c1e314": "This function `append_log` appends text to a log widget in the `MainWindow`. It uses a regular expression to split the input text into parts, handling carriage return characters (`\\r`) by moving the cursor to the start of the line and removing any existing text before inserting new content. The function ensures that the log widget scrolls to the end after appending the text.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:build_docgen_cmd:3f5903773dd73a063539f00cb7dc3bba6bd1a5eb282f9c51ee38c80b0ba31346:db5be93b703b90b55a304db73f1136911e5a707d781024afbfb94574bcee020a": "This function constructs a command to run the `docgenerator.py` script with specified parameters based on user input in a graphical user interface (GUI). It initializes a list with the command `pythonw` and the script path `docgenerator.py`. It then appends project and output directory paths from GUI elements. If the \"Include Private\" checkbox is checked, it adds the `--include-private` flag to the command. The function also gathers selected programming languages (Python or MATLAB) from checkboxes in the GUI and appends them as a comma-separated string with the `--languages` flag if any are selected. Finally, it returns the constructed command list.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:build_explain_cmd:056e38b3357856c35d87bd15ddd5d5187de5f88c1d8da90b2ffbd5fd0967685b:046fac90039c8d1fba3d2089dca6ea3f90e05590bd0f57aaa2d0fabe43134a67": "This function `build_explain_cmd` constructs a command to run the `explaincode.py` script with specified parameters. It gathers project directory, output path, and output format from GUI elements (`project_edit`, `output_edit`, `format_combo`). Additionally, it conditionally includes data file path if selected in the GUI (`include_data_cb` checkbox checked and `data_edit` not empty). The constructed command is returned as a list of strings ready to be executed.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:dark_style:a27717d6431cdcd4f92d01b9b86fb484aa886773068640ac3a26337bd723e238:7a398615d138aaa24ed3bf5fd3883bf815b3ca25c8376a27c7b374782a469c1c": "This function `dark_style` returns a string containing CSS styles for a dark-themed graphical user interface. The styles define the appearance of various widgets such as `QWidget`, `QLineEdit`, `QPlainTextEdit`, `QComboBox`, and `QPushButton`. The background colors, text colors, fonts, and borders are customized to provide a visually appealing and consistent look in a dark environment.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:dragEnterEvent:295ca7a8f36b2f39232158925a40aadb38d657f06526122a58eaf7e9c09a2116:a8f4c8ef6b1a8699bd0befe37366ee2d0bc18159e246fe7cc75b30319e5ccf88": "The `dragEnterEvent` method in the `PathLineEdit` class handles drag-and-drop events. It checks if the dropped data contains URLs and accepts the proposed action if it does.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:dropEvent:5c36fff7eab57dd9fe65e7ad0f83d880c353ecc6f9dc780928fbf94913bddac9:49755e4b9dec6d5be8256f42415f2bfe9eae0939fe8df2a701a3201c1debb092": "The `dropEvent` method in the `PathLineEdit` class handles the processing of drop events. It extracts URLs from the dropped data and sets the object's text to the local file path of the first URL found. This allows the `PathLineEdit` widget to accept file paths through drag-and-drop operations.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:on_finished:e8a4e497d4708384af9f207ec8fd1b1d5a34abaa2688fe36a628c0b666b5c2de:63ddfac7a0157e8c7b8f4d9f344896869e3f4e46e809b050dbf66df50efe64c3": "This function `on_finished` is a method of the `MainWindow` class. It is triggered when a process finishes execution. The function appends a log entry indicating the exit code of the process and sets the running state of the application to false, indicating that no processes are currently active.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:on_toggled:839b212c712b000198f5d1bf47988d31b6b8b8191b2a2ee145ef01cbfa032f12:a4f5867a665375bc91f054a5ca2adb0f32123de2b3fe7bac6ddf3e43db7befc7": "The `on_toggled` method in the `CollapsibleBox` class handles the toggling of the content section. When called, it checks whether the toggle button is currently checked. If it is, it sets the arrow on the toggle button to a down arrow and makes the content widget visible. If the toggle button is not checked, it sets the arrow to a right arrow and hides the content widget. This method allows for the dynamic expansion and collapse of content sections within the user interface component.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:run:6d8a6e8f2d2ead5d6649abf6d27879046d47bde6c8f082a602b6ac31ae69f6ce:c934ebff45ee9021a734047bb45ecefc1e1dc8ff50a0a71f227073ca3a231a85": "The `run` method of the `CommandRunner` class manages the execution of a list of commands. It iterates through each command, emitting the command string to an output stream. For each command, it starts two threads that read from both the standard output and standard error streams in real-time. These threads call the `_reader` method to handle the output. After starting the threads, it waits for the command process to complete using `proc.wait()`, capturing the return code. If an exception occurs during the execution of a command or if any thread encounters an error, it emits an error message and sets the return code to -1. Finally, it emits a signal indicating that the command execution has finished with the appropriate return code.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:run_both:f5467ae6863449b8c918a4c94edf5b2844ab4d558152de5e76417bfd0e455af6:1c8b59d5070b69f10af2c3041edfe9eca0f9210c3aa91f5c0e1b50e2db0c5a84": "This function, `run_both`, is a method within the `MainWindow` class. It clears the log and then runs two commands: one for building documentation using `build_docgen_cmd()` and another for generating explanations using `build_explain_cmd()`.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:run_commands:576f827f1dda5edf2f51620c03e76a39755bf4d73e0a0d33994bcb77a858cad3:b7ba175ef4a56b551b4653206fe8cd163f3335a666768540808a66c062ea47c4": "This function `run_commands` in the `MainWindow` class is designed to execute a list of commands for generating documentation. It first checks if both project and output directories are set by verifying non-empty text in `project_edit` and `output_edit`. If either directory is not set, it appends an error message to the log. If both directories are set, it proceeds to run the commands using an instance of `CommandRunner`, passing the list of commands as an argument. It connects the output signal from `CommandRunner` to a method `append_log` for logging purposes and the finished signal to another method `on_finished`. Finally, it starts the execution of the commands by calling `start()` on the `runner` instance.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:run_docgen:6e05f76a67163023c525646516c236e2922130440603162b8caf124e3ddf6833:c65b6bf78288a4f7cc1527b28115f30e2c67de3b313c49f6c44d89fdeba205f1": "This function, `run_docgen`, clears the log and then executes a command to generate documentation. It calls another method, `build_docgen_cmd`, to construct the command for generating documentation before running it.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:run_explain:26c41417c1eb68b190a4359529729e1220ba0057f69261c1d1d6c8391024f6db:982a9cac6c4c926232144e5a733acc746cbf088355a24eabd4b8af38078afbbb": "This function `run_explain` in the class `MainWindow` is responsible for executing a command to generate documentation. It first clears any existing log entries and then runs a command built by the method `build_explain_cmd()`. This command likely involves invoking the `explaincode.py` utility with appropriate arguments based on the current configuration of the application, such as project directories, output paths, and language model details. The execution of this command is handled internally within the `MainWindow` class, ensuring that any output or errors are captured and logged appropriately for user feedback.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:select_dir:9b977562aabfd19fed0cde5f979a6b6cab20a2ca42c20f2fef58b5befefc16c6:c6592d0b3bfd7146aedaa671b4066f003b01b3537fd82bc3c939865a14edb362": "This function `select_dir` is part of the `MainWindow` class in a graphical user interface for a documentation tool. It allows users to select an existing directory by opening a file dialog. The selected directory path is then displayed in a specified `QLineEdit` widget.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:select_file:301b18ac9225e18fe33ab0ed818437e46ce963e1ac37b5843af36c71a28d0383:f012e17a8edfec8e77b4df451a9a3a53aa8639104fb0d7bcce581199d836151a": "This function `select_file` in the `MainWindow` class is designed to open a file dialog for selecting data files such as JSON, CSV, or TXT files. When a user selects a file and confirms their choice, the path of the selected file is set as the text of the provided `QLineEdit` widget.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:setContentLayout:84b698088a8c6460c4bae78e3e1978be0dc5d0a16a3522f1445b30444be6fbc5:af0a6406f5799de1d99e5fd0882b3742c46e19a60b304ea6de05858d644f83ca": "The `setContentLayout` method sets the layout for the content widget within the `CollapsibleBox` class. It takes a single parameter `layout`, which is presumably a layout object used to organize and position child widgets within the content area. This method assigns this layout to the content widget, allowing for dynamic changes in how its children are arranged visually.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:set_running:352b41d8db00fcce60fcecae755dca1ebfcbf46e56acbaa9196c8eb70bdaea6c:c2d8d90dc3c3ee9ff47aa25f1c3afe4152330962a7169022f40487da602c2a17": "This function sets the enabled state of three buttons (`docgen_btn`, `explain_btn`, and `both_btn`) based on the value of the `running` parameter. If `running` is `True`, all buttons are disabled; if `running` is `False`, all buttons are enabled.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\html_writer.py:_highlight:fe289c9fd43e40e1304227ad64fa0bb295156cd7387dca6da31ff891a7e1fdda:765a9266ca9e39dd74b6bce47ff90e52bacc88c90749e1875aa2bbaf8784bcf2": "The function `_highlight` takes a string `code` and a string `language` as input. It returns the code highlighted in HTML format based on the specified language using the Pygments library. If the language is \"matlab\", it uses the `MatlabLexer`. If the language is \"python\", it uses the `PythonLexer`. For any other language, it uses the `TextLexer`. The highlighted code is wrapped in `<pre><code>` tags to preserve formatting and syntax highlighting when displayed in a web browser.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\html_writer.py:_render_class:0401c4e41cba78c2f474e9ed85ed99715f75bc2f94c23361ed314db555dc323d:9ebd3d8c1d06ad207ad70c899b564f8ff0beb63d73a4331a9ce72f57bd962562": "This function `_render_class` is designed to generate HTML content for a class and its subclasses. It takes three parameters: `cls`, which is a dictionary representing the class; `language`, specifying the programming language (though it's not used in the function); and `level`, an optional integer indicating the heading level, defaulting to 2.\n\nThe function returns a list of HTML strings. It starts by creating an HTML heading tag (`<h1>` to `<h6>`) based on the `level` parameter, using the class name from the `cls` dictionary as both the ID and the text content. If the class has a docstring or summary, it appends a paragraph containing this documentation.\n\nThe function then iterates over any methods associated with the class, calling `_render_function` for each method to generate HTML parts for them, prefixing the method name with \"Method: \". For each subclass of the current class, it creates a `<details>` element, adds a summary section with the subclass name, and recursively calls `_render_class` to generate HTML for the subclass.\n\nThis function is part of a larger system that generates static HTML documentation for Python projects by analyzing source files with a local LLM. It handles the rendering of classes and their components in a structured format suitable for web presentation.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\html_writer.py:_render_function:77129a9bc7fa2bb9a01f74b9b68cb2d5e5b59df67ddb7af7239d159cda04d14e:699fe285151db344f9a0e01c9cb45c472da3164ac702b8c706df1fb09a3cfc61": "This function `_render_function` is designed to generate HTML content for a given function and its nested subfunctions. It takes three parameters: `func`, which is a dictionary containing information about the function; `language`, which specifies the programming language (e.g., Python, MATLAB); and `level`, which controls the depth of the HTML headings used for rendering (default is 3). The function returns a list of HTML strings.\n\nThe function starts by creating an HTML heading tag based on the `level` parameter and the function's signature or name. It then appends this tag to the `parts` list. If the function has a summary or docstring, it adds a paragraph element containing the escaped summary text. If the function has source code, it calls another function `_highlight` to highlight the code based on the specified language and appends the highlighted code to the `parts` list.\n\nThe function then iterates over any nested subfunctions of the current function. For each subfunction, it creates a `<details>` element with a `<summary>` tag containing the subfunction's signature or name. It recursively calls `_render_function` for each subfunction, increasing the heading level by 1 to reflect its nesting depth within the parent function. The HTML parts generated for each subfunction are appended to the `parts` list.\n\nFinally, the function returns the complete list of HTML strings representing the rendered function and its subfunctions.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\html_writer.py:write_index:b7be7c36875a9c426944032c51da4233f7bf31af1fcca24472854993767c3710:54e2e9bbbdcf8cfb6d68d31ca8aa5c406b049fa71d3db337fa5ecc87f3b8442a": "This function `write_index` generates the content for an `index.html` file. It takes three parameters: `output_dir`, which is the directory where the HTML file will be saved; `project_summary`, a string containing a summary of the project; and `page_links`, an iterable of tuples where each tuple contains a text label and a link to another page. Optionally, it can also take `module_summaries`, a dictionary that maps module names to summaries.\n\nThe function creates a directory structure if it doesn't exist at the specified `output_dir`. It constructs HTML for navigation links using the provided `page_links` and optionally includes summaries from `module_summaries`. The body of the HTML document is built by combining the project summary, a horizontal rule, and a list of module links. If there are any module summaries, they are included with each link.\n\nFinally, it uses a helper function `_render_html` to generate the complete HTML content and writes this content to `index.html` in the specified output directory.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\html_writer.py:write_module_page:0c5172b45a0306f4977a26898e8ed64ab38f0688ade066e503afee03dda31575:0a66a974a1343daf827a0970a93a48023a5db8668f764191544084d46c6536ec": "This function `write_module_page` generates an HTML documentation page for a module. It takes three parameters: `output_dir`, which is the directory where the output HTML file will be saved; `module_data`, a dictionary containing information about the module such as its name, language, summary, classes, and functions; and `page_links`, an iterable of tuples representing links to other pages.\n\nThe function first constructs the destination directory for the output HTML file. It then extracts the module's name and language from `module_data`. A navigation bar is created with a link to the project overview page and any additional links provided in `page_links`.\n\nThe body of the HTML page is built by concatenating sections for the module summary, classes, and functions. Each class and function is rendered using helper functions `_render_class` and `_render_function`, respectively.\n\nFinally, the complete HTML content is generated using a template function `_render_html`, which takes the module name, title, body content, and navigation bar as parameters. The resulting HTML is written to a file named after the module in the specified output directory.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\llm_client.py:LLMClient:dfa601b20cf4db8e9418337c45ddf1e6e1a5c6668c152a915397bf43d6b050b2:009ca49135e5578004b3773e87124769f683d1c0f26d61e417667c66d0f69bf5": "The `LLMClient` class provides a thin wrapper around the LMStudio HTTP API, offering methods to ping the API and summarize text using specified prompts. The `ping` method checks if the API is reachable within a given timeout period. The `summarize` method constructs a prompt based on the provided text and prompt type, sends it to the API, and returns a sanitized summary of the response. It retries up to three times in case of failures, handling exceptions and errors gracefully.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\llm_client.py:__init__:8addee3554d45186a2e547c3583c06c01f019ba3961c6baad61314f51f429e73:b5df2a2743149d9a89332ac6242d3d8fb0a677189da7b76713bdc236a4c0143d": "The `__init__` method initializes an instance of the `LLMClient` class. It takes two parameters: `base_url`, which defaults to \"http://localhost:1234\", and `model`, which defaults to \"local\". The method sets the `base_url` attribute by stripping any trailing slashes, constructs the `endpoint` attribute by appending \"/v1/chat/completions\" to the base URL, and assigns the `model` attribute with the provided model type.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\llm_client.py:ping:20f22501d60b02c28fedba1dca913dd43e0545009c09ff7b486bafbc76f15db6:5fa3f4007f9a19cd1975764f28d73cbbbdc5229b6623984d8c3dcdedda2be1c5": "The `ping` method in the `LLMClient` class checks if the API is reachable by sending a GET request to the base URL with a specified timeout. If the server responds successfully, it returns `True`. If there is an exception during the request (e.g., network issues or invalid URL), it raises a `ConnectionError` with a message indicating that the server cannot be contacted.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\llm_client.py:sanitize_summary:43226b95deefd609c65619ae1be2626180c80dbbec20dd8f8d1b6e30410adb04:bfb4c059f28a5c9c407b6a6bf00c41165190b320148b93f6ad99219013612bc7": "",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\llm_client.py:summarize:c7abddf55aadd8c1a123eaa479d2898d45ed3971bd8c800131f98d73eb710acd:b3e5e6cf280c5f6a7dca230918d7a64d7edfb41ebcbc6395d2936dc3f81baef7": "The `summarize` method in the `LLMClient` class is designed to generate a summary for a given text using a specified prompt type. It constructs a payload with the model, temperature, and formatted prompt, then attempts up to three times to send this payload to an endpoint using a POST request. If successful, it extracts and sanitizes the response content to return as the summary. The method handles potential HTTP errors and request exceptions by retrying the request after a short delay. If all attempts fail, it raises a `RuntimeError` with the accumulated error message.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\manual_utils.py:_count_tokens:89430f1fb3b6fdeda7ce94cdb9c2ceeed164e26116237f06f6c1bb54b84559d5:46779fe3de6033090e661845b5628851df4a86e42eb6c5884c573a9c848b8135": "A function named `_count_tokens` that takes a string `text` as input and returns an integer representing the approximate number of tokens in the text. The function uses a tokenizer to encode the text and then calculates the length of the encoded list, which corresponds to the token count.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\manual_utils.py:_split_text:aea9af38d40f157be0e48138b682ad6c78c0ccde123f2fe845a8a9fb7b07f8c7:fbe13d4b92a9d36cf3c61727cf0cd7f93d9e457cddf22f21d0690477c0b10f62": "This function splits a given text into manageable chunks while respecting specified maximum token and character limits. It first splits the text into paragraphs, then iterates through each paragraph to determine if it fits within the token and character constraints. If a paragraph exceeds these limits, it is further split using another function (`chunk_text`). The resulting chunks are collected in a list and returned.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\manual_utils.py:_summarize_manual:e3f21d0e97ee4b18192968c5c700de56c9b9529948891bdfd67a80ee8a6ae501:e26449d6c713c529d587b4ead05aa71dc02c25673e4915bc3e69e65f2f34e74b": "The function `_summarize_manual` generates a summary for a given text using a language model client and a caching mechanism. It supports different chunking strategies: manual, automatic (with token limits), or none. The function handles text splitting, caching of responses, and hierarchical merging to ensure the output does not exceed token or character limits. If chunking is enabled, it processes each chunk individually and merges them if necessary. The function also includes error handling for network failures and logs warnings for content exceeding limits.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\manual_utils.py:chunk_docs:b41402ee2f462c3333300a5266a1b8703678516486af4ade2bf4b9a54b2619bb:4114487c1179e00d9690e7fd33305cc095fc24e0956ba5cc893378702cba67c4": "This function `chunk_docs` takes a list of strings (`docs`) and an integer (`token_limit`) as input. It joins the non-empty strings in `docs`, separated by double newlines, into a single string. If the resulting string is empty, it returns an empty list. Otherwise, it calls another function `_split_text` with the joined text, a maximum token limit of `token_limit`, and a maximum character limit of three times `token_limit`. The result of `_split_text` is returned as a list of strings, effectively splitting the input documents into chunks based on the specified token limit.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\manual_utils.py:find_placeholders:d4290af7d3a71cc7309ed5534e3080198a523d3b3fdbeacb65096f498aab10d8:dafc004f2d1ef7f651fa4698ea182a553c7962c451d1d432e2a1c8aca8816a57": "The function `find_placeholders` searches for placeholder tokens enclosed in double backticks followed by two square brackets, such as ``[[TOKEN]]``, within a given string. It returns a set of these placeholder tokens found in the text.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\parser_matlab.py:parse_matlab_file:1fec6a9fa0b958e0df81ae6c63c7e263aaa3c6b53396286f66a5f43adcdc9a78:f64c5b3aebe4abf1933ab91475915ca7475338cb202cd2ba3b5e35483d072224": "The function `parse_matlab_file` reads and parses a MATLAB `.m` file to extract its basic structure. It returns a dictionary containing the file's header comments and any function declarations found within the file. The header is extracted as leading lines starting with `%`, and each function declaration is identified using a regular expression that matches lines defining functions, capturing their names and arguments.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\parser_python.py:_format_arg:215c1205b72853b1c460b04984b845c26f724c98c5b6250e4477f46ba54ebb54:aaaf7755589aad4f1ddb50cc983ddcc47166ff5b5eb615a0d43f7cdd3660124b": "This function formats an argument from an AST (Abstract Syntax Tree) node, appending its type annotation if available. It constructs a string representation of the argument name and optionally appends its type annotation using `ast.unparse`.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\parser_python.py:_format_arguments:e7778815b4fa1d042e78b1712e4002e7d4c4f93fcbce600eaa529d639ff49108:294463138e1b6e286049e61181dcabf62351a126414a5a5eb4205b69b966ef57": "The function `_format_arguments` takes an `ast.arguments` object as input and returns a string representation of the arguments it contains. It handles positional-only, regular, variable-positional, keyword-only, and variable-keyword arguments, including their default values if provided. The function uses helper functions to format individual arguments and constructs the final string by joining these parts with commas.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\parser_python.py:_format_signature:2fc9dc2e2d3060e198acdd53a5de3e937a6324dd6a8a89123ec6c5d18b2fa5ac:fbf8dc659e1ae8c3e99401a0e2545dd7b28f66c357a0bc4ee5892aa85fdbaba2": "This function `_format_signature` takes an `ast.FunctionDef` or `ast.AsyncFunctionDef` object as input and returns a string representing the signature of the function. The signature includes the function name, its parameters formatted by `_format_arguments`, and the return type if specified.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\parser_python.py:_parse_classes:3370c9b250af117ec967d1348b8b9a8587bc28d6ce93d05f72240b72673f904f:8e2e1d387badb5f06d03f9e20a2ceae079f4f26215b88a57451b4033dfc3f639": "This function recursively parses all `ClassDef` nodes within a list of AST nodes. It iterates through each node, checks if it is an instance of `ClassDef`, and if so, appends the parsed class to the result list. If the node is a `FunctionDef` or `AsyncFunctionDef`, it recursively calls itself with the body of the function as the new set of nodes to parse. The function returns a list of dictionaries representing all classes found in the provided AST nodes.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\parser_python.py:parse_class:934108e027644f2536db93bc28b53d2579c8f63ff371d049e532ba6816f96f8c:88d84b0c3fce8b77779d4f8131d9d5dfdfb997d05c8166f3987a4c6af3604aa4": "The function `parse_class` takes an AST node representing a class and the source code as input. It returns a dictionary containing information about the class, including its name, docstring, methods, subclasses, and source code segment. The function iterates through the body of the class node to identify method definitions and recursively parses any nested classes.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\parser_python.py:parse_classes:b70b5892c72bfed336195d0c0d24b143348fcec6d11ff50e17a016eca503f236:0b9860838a1c87f40fcaa671a7100b2515b12707c6d202a9dee98bf0961742cd": "This function, `parse_classes`, serves as a public interface for parsing classes within an abstract syntax tree (AST) of Python code. It accepts two parameters: `node`, which is the AST node to be parsed, and `source`, a string containing the source code from which the AST was derived.\n\nThe function leverages a helper function `_parse_classes` to perform the actual parsing. It retrieves the body of the given `node` using `getattr(node, \"body\", [])`, providing an empty list as a fallback if no body is found. This ensures that the function can handle cases where the node does not have a body without raising an error.\n\nThe parsed classes are returned as a list of dictionaries, each representing a class and containing relevant information extracted from the source code.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\parser_python.py:parse_function:5cedc560cab6b784be7dfcd24c7b31efd1bd313b926b48dfe13a5c610df179fe:09f0616a0c293d6fabc56ed2b781346cc87a31b5590cefeecc293231f143653a": "This function `parse_function` takes an abstract syntax tree (AST) node representing a function definition (`ast.FunctionDef` or `ast.AsyncFunctionDef`) and the source code as input. It returns a dictionary containing information about the function, including its name, signature, return type, docstring, source code segment, subfunctions, and subclasses.\n\nThe function initializes a dictionary `func_info` with keys for the function's name, signature, return type, docstring, source code, subfunctions, and subclasses. It then iterates through the body of the node to find any nested function definitions (either synchronous or asynchronous) and adds their parsed information to the `subfunctions` list.\n\nAdditionally, it calls `_parse_classes` to extract any subclass definitions from the function's body and stores them in the `subclasses` list. Finally, the function returns the populated `func_info` dictionary.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\parser_python.py:parse_python_file:62383571c5d0b9bf52e0aaac64bf49611da67ec709f010381a93797619fe10a5:fb795e86bd205e89cd26315ab4d8a3bc381e81440fef037935979e7da0193421": "The function `parse_python_file` reads a Python source file and extracts structured information such as the module docstring, classes, and functions. It uses the `ast` module to parse the source code into an abstract syntax tree (AST). The function iterates through the AST nodes, identifying class definitions (`ClassDef`) and function definitions (`FunctionDef`, `AsyncFunctionDef`). For each identified node, it calls helper functions `parse_class` and `parse_function` to extract detailed information. The results are stored in a dictionary and returned.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\reviewer.py:_is_generated_html:bcbad81174bb2dde7bf886f87dad4343fdb2d4261b1472de0119f09c307a6fc7:0b9315cb9a876ec6454bc9ed604e8646efbaf5d241711cae032e996c9b26fd3a": "The function `_is_generated_html` checks if a given string `text` appears to be output from the DocGen-LM tool. It returns `True` if the text contains specific markers indicating it is generated by DocGen-LM, such as \"Generated by DocGen-LM\", an `<h1>` heading for project documentation, or headings for classes and methods in HTML format.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\reviewer.py:check_assistant_phrasing:f3a30a991b66fc76283e47d1b6745b030fe7ec95937b75d6aa2dc6407c9a3fab:173dff68a0a88e2e3670c84e9b27c0e3eff30b8384a9555c96bcb218bcf5fcfb": "This function `check_assistant_phrasing` takes a string `html` as input and returns a list of strings. The function searches for paragraphs (`<p>` tags) in the HTML content, strips any HTML tags from them, converts the text to lowercase, and checks if it contains any phrases listed in `ASSISTANT_PHRASES`. If a match is found, it appends a string containing the matched text and its line number in the original HTML to the `findings` list. The function then returns this list of findings.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\reviewer.py:check_contradictions:807103c369a4014e548ace76a13a8341e255610fe7c4e00bc95e723e2162f084:dbae9d538b4b0b2aeef860bb3e6959bcfea20a667e05227ecada1cd6e04e8821": "Function `check_contradictions` analyzes an HTML string to identify contradictions between the content and a brief summary at the beginning. It extracts paragraphs, methods, functions, and classes from the HTML. If the summary states there are no methods but methods are found, or if the summary states there are no functions or classes but they are found, it adds a description of the contradiction to a list. The function returns this list of contradictions.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\reviewer.py:check_hallucinations:5d00d98d655cb5524579bb58c3c1d8503d42b72d1e412372a0f657924d13314c:96f7853b7e19d90d9a9910a0091656f13c92bb18a55b80ff94be281abbbcecf2": "The function `check_hallucinations` takes an HTML string as input and returns a list of hallucination phrases detected within the HTML. It extracts all paragraph tags (`<p>`) from the HTML, strips any HTML tags from the text content, converts it to lowercase, and checks if any predefined hallucination terms are present in the text. If a term is found, it is added to the list of findings, which is then returned.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\scanner.py:_is_subpath:72ac3b8a1b85a2ead5c93b302acf28f807968a029abf9b4400e0526e2bf28a52:c407d832452318a30c2aab115e0b9898899c42124aa3d4f643ea0a352bb9a6ce": "This function checks if one directory (`path`) is a subdirectory of another directory (`parent`). It returns `True` if `path` is either equal to or inside `parent`, and `False` otherwise. The check is performed using the `relative_to()` method, which raises a `ValueError` if `path` is not related to `parent`.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\scanner.py:scan_directory:d8de0a563b640286aeed5866702bdcd4f0dcdd9728fef7c7f8407a11fc241386:7930f99bfd43670875fc162607cd489dc4c214a8d76384a10a2b494ad6f7f0ff": "The `scan_directory` function recursively discovers Python (``.py``) and MATLAB (``.m``) files within a specified directory. It takes two parameters: `base_path`, which is the directory to search, and `ignore`, a list of paths relative to `base_path` that should be skipped. The function returns a sorted list of absolute paths to discovered source files.\n\nThe function uses `os.walk` to traverse the directory tree. For each directory, it prunes ignored directories and internal `.git` folders. It then checks each file; if the file is a Python or MATLAB file and not in the ignore list, its absolute path is added to the results list. Finally, the function returns the sorted list of discovered source files.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\summarize_utils.py:summarize_chunked:d7c5ef2e1f5387ea25de7fe748a5e5147c67e17c7b1272f273a0af54b5a20659:cccb7382406a64b8f2f135645006dcd166e9b53fbf388fb2a184576e92f87acc": "The function `summarize_chunked` is designed to summarize a given text by chunking it if necessary. It uses an LLM client, a response cache, and various parameters such as key prefix, text, prompt type, system prompt, maximum context tokens, and chunk token budget.\n\n1. **Initialization**: The function initializes a tokenizer, retrieves a template based on the prompt type, calculates overhead tokens for the system prompt and template, and determines available tokens for summarization.\n\n2. **Single Chunk Check**: If the encoded length of the text is less than or equal to the available tokens, it generates a cache key and calls `_summarize` to get the summary.\n\n3. **Chunking**: If the text is too long, it attempts to chunk the text into manageable parts using `chunk_text`. If chunking fails, it logs a warning and proceeds with summarizing the entire text.\n\n4. **Summarization of Chunks**: For each chunk, it generates a cache key and calls `_summarize` to get individual summaries. These partial summaries are stored in a list.\n\n5. **Merging Summaries**: If there are no partial summaries, it returns an empty sanitized summary. Otherwise, it defines instructions for merging summaries into a single technical paragraph. It calculates the merge budget based on available tokens and uses a recursive function `_merge_recursive` to combine the partial summaries. This function splits the summaries into groups if they exceed the merge budget and recursively merges them until a single summary is obtained.\n\n6. **Final Summary**: If merging fails, it logs a warning and returns a sanitized version of the concatenated partial summaries. Otherwise, it returns a sanitized final summary.\n\nThe function handles exceptions during chunking and summarization, logging warnings for failures and returning sanitized summaries in case of errors.",
  "section:Examples:ebeb5f899d403e797d1cf638b44acb8547ffd8ae000cdb739251070b25b3c598": "### Examples\n\n#### Python Function Example\nHere is an example of a Python function:\n\n```python\ndef add(x: int, y: int) -> int:\n\"\"\"Add two numbers.\"\"\"\nreturn x + y\n```\n\nTo use this function, you can call it with two integers:\n\n```python\nresult = add(3, 5)\nprint(result)  # Output: 8\n```\n\n#### Python Class Example\nHere is an example of a Python class:\n\n```python\nclass Greeter:\n\"\"\"Says hi.\"\"\"\n\ndef greet(self, name: str = \"World\") -> str:\n\"\"\"Return a greeting.\"\"\"\nreturn f\"Hello, {name}\"\n```\n\nTo use this class, you can create an instance and call the `greet` method:\n\n```python\ngreeter = Greeter()\nprint(greeter.greet())  # Output: Hello, World\nprint(greeter.greet(\"Alice\"))  # Output: Hello, Alice\n```\n\n#### MATLAB Function Example\nHere is an example of a MATLAB function:\n\n```matlab\nfunction y = add(x, y)\ny = x + y;\nend\n```\n\nTo use this function, you can call it with two numbers:\n\n```matlab\nresult = add(3, 5);\ndisp(result);  % Output: 8\n```\n\n#### README Example\nHere is an example of a simple README file:\n\n```markdown\n# Example Project\n\n## Description\nThis is an example project demonstrating how to structure and document code.\n\n## How to Run\nTo run the project, follow these steps:\n1. Clone the repository.\n2. Install dependencies.\n3. Execute the main script.\n\nFor more details, see the [example.py](example.py) file.\n```\n\n#### JSON Example\nHere is an example of a simple JSON file:\n\n```json\n{\n\"input\": \"data\"\n}\n```\n\nTo parse this JSON file, you can use a library like `json` in Python:\n\n```python\nimport json\n\nwith open(\"sample.json\", \"r\") as file:\ndata = json.load(file)\nprint(data)  # Output: {'input': 'data'}\n```\n\nThese examples illustrate how to write and use functions, classes, MATLAB scripts, README files, and JSON files.",
  "section:How to Run:merge0:867420bf613991adccae85f196c87d293f286827e8f773d6e89dfd3c774ba86e": "To run the provided modules and scripts, follow these steps:\n\n1. **Install Dependencies**:\nEnsure all required dependencies are installed using `pip` by running:\n```bash\npip install -r requirements.txt\n```\n\n2. **Set Up Environment Variables**:\nSome functionalities may require environment variables to be set. For example, if you are using an LLM client that requires authentication, ensure the necessary API keys or tokens are set in your environment.\n\n3. **Run Specific Modules/Scripts**:\n\n- **Running `docgen-lm` Command-Line Interface**:\nTo generate documentation using the `docgen-lm` command-line interface, execute the following command:\n```bash\npython docgen_lm.py --source_dir /path/to/source --output_dir /path/to/output --llm_url http://localhost:8080 --model_name lmstudio --max_context_tokens 4096\n```\n- `--source_dir`: Path to the directory containing your Python and MATLAB files.\n- `--output_dir`: Directory where the generated HTML documentation will be saved.\n- `--llm_url`: URL of the LLM server.\n- `--model_name`: Name of the model to use with the LLM.\n- `--max_context_tokens`: Maximum number of tokens per context.\n\n- **Running Unit Tests**:\nTo run unit tests for specific modules, navigate to the module directory and execute:\n```bash\npython -m unittest discover -s /path/to/module/tests\n```\nReplace `/path/to/module/tests` with the actual path to the test directory within the module.\n\n- **Running GUI Application**:\nTo run the PyQt5 application for generating documentation and running ExplainCode, execute:\n```bash\npython gui_wrapper.py\n```\nThis will start a graphical user interface where you can select directories/files, configure options, and initiate documentation generation.\n\n- **Running Specific Test Functions**:\nFor more granular control over testing, you can directly run specific test functions. For example, to run the `test_write_index` function from the `html_writer` module:\n```bash\npython -m unittest html_writer.test_html_writer.TestHTMLWriter.test_write_index\n```\nReplace `html_writer.test_html_writer.TestHTMLWriter.test_write_index` with the actual path to the specific test function you wish to run.\n\nBy following these steps, you should be able to effectively use and test the provided modules and scripts according to your needs.",
  "section:How to Run:part0:b7c9d6b99d284d5724c84d4705f47c9a2274f443bf8871d429ed839d27b1dc20": "## How to Run\n\nTo run the provided modules and scripts, follow these steps:\n\n1. **Install Dependencies**:\nEnsure all required dependencies are installed. This can typically be done using `pip` by running:\n```bash\npip install -r requirements.txt\n```\n\n2. **Set Up Environment Variables**:\nSome functionalities may require environment variables to be set. For example, if you are using an LLM client that requires authentication, ensure the necessary API keys or tokens are set in your environment.\n\n3. **Run Specific Modules/Scripts**:\nDepending on which module or script you wish to run, follow the instructions below:\n\n### Running `docgen-lm` Command-Line Interface\n\nTo generate documentation using the `docgen-lm` command-line interface, execute the following command:\n```bash\npython docgen_lm.py --source_dir /path/to/source --output_dir /path/to/output --llm_url http://localhost:8080 --model_name lmstudio --max_context_tokens 4096\n```\n- `--source_dir`: Path to the directory containing your Python and MATLAB files.\n- `--output_dir`: Directory where the generated HTML documentation will be saved.\n- `--llm_url`: URL of the LLM server.\n- `--model_name`: Name of the model to use with the LLM.\n- `--max_context_tokens`: Maximum number of tokens per context.\n\n### Running Unit Tests\n\nTo run unit tests for specific modules, navigate to the module directory and execute:\n```bash\npython -m unittest discover -s /path/to/module/tests\n```\nReplace `/path/to/module/tests` with the actual path to the test directory within the module.\n\n```bash\npython -m unittest discover -s /path/to/test_llm_client/tests\n```\n\n### Running GUI Application\n\nTo run the PyQt5 application for generating documentation and running ExplainCode, execute:\n```bash\npython gui_wrapper.py\n```\nThis will start a graphical user interface where you can select directories/files, configure options, and initiate documentation generation.\n\n### Running Specific Test Functions\n\nFor more granular control over testing, you can directly run specific test functions. For example, to run the `test_write_index` function from the `html_writer` module:\n```bash\npython -m unittest html_writer.test_html_writer.TestHTMLWriter.test_write_index\n```\n\nReplace `html_writer.test_html_writer.TestHTMLWriter.test_write_index` with the actual path to the specific test function you wish to run.\n\nBy following these steps, you should be able to effectively use and test the provided modules and scripts according to your needs.",
  "section:How to Run:part1:8c9e6edb7858e40fcd712ebc69f48ffc0f047afc8edac54ff09da940871b93da": "### How to Run\n\nTo run the application, follow these steps:\n\n1. **Install Dependencies**:\nEnsure that all required dependencies are installed. You can install them using pip:\n```bash\npip install PyQt5 Pygments lmstudio-client pytest\n```\n\n2. **Clone the Repository** (if applicable):\nIf you have a repository containing the project, clone it to your local machine:\n```bash\ngit clone https://github.com/your-repo/your-project.git\ncd your-project\n```\n\n3. **Run the Application**:\nExecute the main script using Python:\n```bash\npython main.py\n```\n\n4. **Using the GUI**:\n- Open the application window.\n- Select the project/output directory by dragging and dropping or using the directory selectors.\n- Configure DocGen/ExplainCode options as needed.\n- Click on \"Run\" to start processing.\n\n5. **Running Commands Asynchronously**:\n- The application uses `QThread` for asynchronous command execution, ensuring that long-running processes do not block the main thread.\n\n6. **Logging**:\n- Command output and process status are logged in a log area within the GUI.\n- Logs can be saved or viewed directly from the interface.\n\n7. **Testing**:\n- To run tests, use pytest:\n```bash\npytest test_module.py\n```\n- Replace `test_module.py` with the specific test file you want to run.\n\n8. **Generating Documentation**:\n- The application can generate documentation for Python files using the `docgenerator` module.\n- It supports parsing MATLAB and Python files, summarizing classes and functions, and generating HTML content.\n\n9. **Analyzing Code**:\n- The application includes functionality in `explaincode.py` to collect documentation from code, analyze it, and inject it into a user manual.\n\n10. **Reviewing Documentation**:\n- The `reviewer.py` module helps review the generated documentation for quality issues.\n\nFor more detailed information on each module and its functionalities, refer to the project's documentation or source code comments.",
  "section:Inputs:9d66384c7f8d06aade1cce1ba13866d471830b19dd2aa1dcd420f46d68718983": "### Inputs\n\nThe `map_evidence_to_sections` function requires a dictionary of paths and their corresponding documentation snippets as input. Each key in the dictionary should be a `Path` object representing the source file, and each value should be a string containing the documentation snippet.\n\nExample:\n```python\ndocs = {\nPath(\"src/long.md\"): \"# Inputs\\nline 1\\nline 2\\n...\",\nPath(\"tests/short.md\"): \"# Inputs\\nline A\\nline B\"\n}\nsection_map, file_map = map_evidence_to_sections(docs)\n```\n\nThe `main` function requires several command-line arguments to configure settings for summarizing project documentation. These include:\n\n- `--path`: The target project directory (default is the current directory).\n- `--output-format`: The output format for the summary, either \"html\" or \"pdf\" (default is \"html\").\n- `--output`: The destination directory for generated summary.\n- `--title`: The title for the generated manual (default is \"User Manual\").\n- `--insert-into-index`: A flag to insert a link to the manual into index.html in the output directory.\n- `--chunking`: The chunking mode, which can be \"auto\", \"manual\", or \"none\" (default is \"auto\").\n\nExample:\n```sh\npython explaincode.py --path /path/to/project --output-format pdf --output /path/to/output --title \"My Project Manual\"\n```\n\nThe `summarize_chunked` function requires an LLMClient, a ResponseCache, and the text to be summarized. The text should be a string containing the content to be summarized.\n\nExample:\n```python\nfrom explaincode import LLMClient, ResponseCache\n\nclient = LLMClient()\ncache = ResponseCache(\"path/to/cache.json\")\ntext = \"This is a long piece of text that needs summarization.\"\nsummary = summarize_chunked(client, cache, \"key_prefix\", text)\n```\n\nThe `parse_class` function requires an AST node representing a class definition and the source code as input.\n\nExample:\n```python\nimport ast\n\nsource_code = \"\"\"\nclass MyClass:\ndef my_method(self):\npass\n\"\"\"\ntree = ast.parse(source_code)\ncls_info = parse_class(tree.body[0], source_code)\n```\n\nThe `parse_function` function requires an AST node representing a function or async function and the source code as input.\n\nExample:\n```python\nimport ast\n\nsource_code = \"\"\"\ndef my_function():\nreturn \"Hello, World!\"\n\"\"\"\ntree = ast.parse(source_code)\nfunc_info = parse_function(tree.body[0], source_code)\n```\n\nThe `parse_manual` function requires a string of text containing the manual content and an optional LLMClient instance.\n\nExample:\n```python\ntext = \"\"\"\nInputs: input data\nOutputs: output data\n\"\"\"\nmanual_sections = parse_manual(text)\n```\n\nThe `llm_generate_manual` function requires a dictionary of documentation snippets, an LLM client, a response cache, and an optional chunking strategy as input. The dictionary keys should be `Path` objects representing the source files, and values should be strings containing the documentation snippets.\n\nExample:\n```python\nfrom explaincode import LLMClient, ResponseCache\n\nclient = LLMClient()\ncache = ResponseCache(\"path/to/cache.json\")\ndocs = {\nPath(\"src/long.md\"): \"# Inputs\\nline 1\\nline 2\\n...\",\nPath(\"tests/short.md\"): \"# Inputs\\nline A\\nline B\"\n}\nmanual_text, file_map, evidence_map = llm_generate_manual(docs, client, cache)\n```\n\nThe `test_chunking_triggers_multiple_calls_and_logs` function does not require any inputs as it is a test function. It uses dummy data and assertions to verify the functionality of chunking and merging.\n\nExample:\n```python\ndef test_chunking_triggers_multiple_calls_and_logs(tmp_path: Path, capsys: pytest.CaptureFixture[str]) -> None:\n# Test implementation here\n```\n\nThe `test_map_evidence_snippet_limits` function does not require any inputs as it is a test function. It uses dummy data and assertions to verify the functionality of snippet limits.\n\nExample:\n```python\ndef test_map_evidence_snippet_limits() -> None:\n# Test implementation here\n```\n\nThe `test_llm_fill_placeholders_per_section_logging` function does not require any inputs as it is a test function. It uses dummy data and assertions to verify the functionality of filling placeholders in a manual.\n\nExample:\n```python\ndef test_llm_fill_placeholders_per_section_logging(tmp_path: Path, caplog: pytest.LogCaptureFixture) -> None:\n# Test implementation here\n```",
  "section:Outputs:merge0:e40295687ae78d32d3cd6e2258acd8e659ba80f80d6292470c17a6aede96dda6": "The modules `test_subclass_docs_and_method_summary`, `test_docgenerator_generates_html`, `test_static_copied_from_any_cwd`, `test_llm_client`, `test_manual_utils`, `test_parser_matlab`, `test_parser_python`, `test_reviewer`, and `test_scanner` all output the following:\n\n- **Return Value**: The function asserts that the return value of `main` is 0, indicating successful execution.\n- **Documentation Content**: It checks that the generated HTML documentation contains summaries for the subclass and method.\n- **HTML Output**: It verifies that the generator can process Python and MATLAB files in a project directory and produce HTML output with summaries.\n- **Static Files**: It ensures that static files like CSS are copied to the output directory regardless of the current working directory when running the generator.\n- **LLM Client**: The `llm_client` module provides an interface to a local Large Language Model (LLM) backend called LMStudio, including methods for pinging the API and generating summaries with retries on failures.\n- **Manual Utilities**: The `manual_utils` module provides functions for splitting text into chunks and generating summaries using a language model, including utilities for token counting, text chunking, placeholder detection, and summarization with caching to improve performance.\n- **HTML Rendering**: The `html_writer` module provides HTML rendering utilities for generating documentation pages using simple template substitution, highlighting code snippets with Pygments, and rendering HTML content based on templates.\n\nThe GUI interface includes a dark-themed design with a header, project/output directory selectors, DocGen/ExplainCode options, and a log area. It supports drag-and-drop functionality for selecting directories/files and has collapsible boxes to organize settings. Command execution is handled asynchronously using `QThread` to prevent blocking the main thread, and it includes support for running DocGen and ExplainCode with customizable options. Logging of command output and process status is also provided.\n\nThe project modules include `cache.py`, `chunk_utils.py`, `docgenerator.py`, `explaincode.py`, `gui_wrapper.py`, `html_writer.py`, `llm_client.py`, `manual_utils.py`, `parser_matlab.py`, `parser_python.py`, `reviewer.py`, and `scanner.py`. These modules handle various aspects of generating documentation, analyzing code, and interacting with a language model to generate summaries. The project also includes numerous test modules to ensure functionality across different aspects of the system, such as testing the generation of documentation for a Python project containing a subclass with a method and testing the generation of a project summary using the `docgenerator` module.",
  "section:Outputs:part0:0e2c060a20e024e2b0bea95ddc5d9d295d435df6ac286a10b9697e7b37990769": "### Outputs\n\nThe module `test_subclass_docs_and_method_summary` outputs the following:\n\n- **Return Value**: The function asserts that the return value of `main` is 0, indicating successful execution.\n- **Documentation Content**: It checks that the generated HTML documentation contains summaries for the subclass and method.\n\nThe module `test_docgenerator_generates_html` outputs the following:\n\n- **Return Value**: The function asserts that the return value of `main` is 0, indicating successful execution.\n- **HTML Output**: It verifies that the generator can process Python and MATLAB files in a project directory and produce HTML output with summaries.\n\nThe module `test_static_copied_from_any_cwd` outputs the following:\n\n- **Return Value**: The function asserts that the return value of `main` is 0, indicating successful execution.\n- **Static Files**: It ensures that static files like CSS are copied to the output directory regardless of the current working directory when running the generator.\n\nThe module `test_llm_client` outputs the following:\n\n- **Return Value**: The function asserts various scenarios related to successful pinging, handling exceptions during pinging, retrying summary generation, raising runtime errors, sanitizing text, and ensuring prompt templates vary by type (class, function, readme).\n\nThe module `test_manual_utils` outputs the following:\n\n- **Return Value**: The function asserts that the `_count` function correctly calculates the number of tokens in a given text.\n- **Chunking Functionality**: It verifies if documents are chunked correctly according to a token limit.\n- **Placeholder Detection**: It checks if placeholders within a text are identified and returned as a set.\n\nThe module `test_parser_matlab` outputs the following:\n\n- **Return Value**: The function asserts that the MATLAB parser correctly extracts headers and functions from a simple MATLAB file.\n- **Multiple Functions**: It verifies that the parser can handle multiple functions in a single file, including their names and arguments.\n\nThe module `test_parser_python` outputs the following:\n\n- **Return Value**: The function asserts various scenarios related to parsing Python files, covering simple modules, complex function signatures, nested structures, deeply nested classes, and classes inside methods.\n- **Parsed Results**: It verifies that the parsed results match the expected structure and attributes of the code.\n\nThe module `test_reviewer` outputs the following:\n\n- **Return Value**: The function asserts various scenarios related to detecting issues such as assistant phrasing, contradictions, and hallucinations in the code documentation.\n- **Autofix Functionality**: It checks if autofix functionality removes specified phrases from the generated HTML files.\n\nThe module `test_scanner` outputs the following:\n\n- **Ignore Folder**: It verifies that the `scan_directory` function ignores the \"ignore_me\" directory when provided as an ignore list.\n- **Mixed File Types**: It tests that the `scan_directory` function returns only Python and M files, excluding TXT files and nested MD files.\n- **Skips Git Folder**: It checks that the `scan_directory` function skips any files within the `.git` directory from the results.\n\nThe module `test_subclass_docs_and_method_summary` outputs the following:\n\n- **Return Value**: The function asserts that the return value of `main` is 0, indicating successful execution.\n- **Documentation Content**: It checks that the generated HTML documentation contains summaries for the subclass and method.",
  "section:Outputs:part1:b178ab7178e778a3a1621ee88a0e92b4c1a7189ede9a2493eb03ab205c3a5420": "### Outputs\n\n1. **GUI Interface**:\n- A dark-themed GUI with a header, project/output directory selectors, DocGen/ExplainCode options, and a log area.\n- Drag-and-drop functionality for selecting directories/files.\n- Collapsible boxes to organize settings.\n\n2. **Command Execution**:\n- Asynchronous command execution using `QThread` to handle long-running processes without blocking the main thread.\n- Support for running DocGen and ExplainCode with customizable options.\n\n3. **Logging**:\n- Logging of command output and process status.\n\n4. **HTML Rendering**:\n- The `html_writer` module provides HTML rendering utilities for generating documentation pages using simple template substitution.\n- Functions for highlighting code snippets with Pygments and rendering HTML content based on templates.\n- Defines functions to write index and module-specific documentation pages, handling project summaries, page links, and nested structures like classes and methods.\n\n5. **LLM Client**:\n- The `llm_client` module provides an interface to a local Large Language Model (LLM) backend called LMStudio.\n- Includes:\n- A `SYSTEM_PROMPT` for the documentation model.\n- Common rules for prompt templates.\n- A `README_PROMPT` for enriching project summaries from README files.\n- A dictionary `PROMPT_TEMPLATES` containing different prompt templates for summarizing modules, classes, functions, READMEs, projects, docstrings, and user manuals.\n- A `sanitize_summary` function to remove unwanted commentary from summaries.\n- An `LLMClient` class that:\n- Initializes with a base URL and model name.\n- Includes a `ping` method to check if the API is reachable.\n- Implements a `summarize` method to generate summaries using the LLM, handling retries on failures.\n\n6. **Manual Utilities**:\n- The `manual_utils` module provides functions for splitting text into chunks and generating summaries using a language model.\n- Includes utilities for token counting, text chunking, placeholder detection, and summarization with caching to improve performance.\n- Uses concurrent processing to handle large texts efficiently.\n\n7. **DocGen-LM Tool**:\n- Generates static HTML documentation for Python and MATLAB projects by analyzing source files with a local LLM.\n- Supports nested functions and subclasses, rendering complex structures as expandable sections in the output.\n- Includes both CLI and GUI interfaces, allowing users to specify project directories, output paths, and LLM server details.\n- Provides a utility called `explaincode.py` for generating lightweight project summaries with options for PDF output and code scanning.\n\n8. **Project Modules**:\n- Multiple modules for generating documentation and analyzing code, including:\n- `cache.py`: Provides a caching mechanism for responses.\n- `chunk_utils.py`: Includes functions for chunking text into manageable parts.\n- `docgenerator.py`: Handles the main logic for summarizing Python files, including parsing classes and functions, and generating summaries.\n- `explaincode.py`: Focuses on collecting documentation from code, analyzing it, and injecting it into a user manual.\n- `gui_wrapper.py`: Provides a graphical interface for running commands and displaying logs.\n- `html_writer.py`: Generates HTML content from the collected data.\n- `llm_client.py`: Interacts with a language model to generate summaries.\n- `manual_utils.py`: Assists in parsing and summarizing user manuals.\n- `parser_matlab.py` and `parser_python.py`: Parse MATLAB and Python files, respectively.\n- `reviewer.py`: Reviews the generated documentation for quality issues.\n- `scanner.py`: Scans directories for source code files.\n- `summarize_utils.py`: Provides utility functions for summarizing text.\n\n9. **Testing**:\n- The project includes numerous test modules to ensure functionality across different aspects of the system, such as:\n- `test_subclass_docs_and_method_summary`: Tests the generation of documentation for a Python project containing a subclass with a method.\n- `test_project_summary_is_sanitized`: Tests the generation of a project summary using the `docgenerator` module.\n\nThese outputs provide a comprehensive overview of the functionalities and modules involved in generating HTML documentation for Python and MATLAB projects using a local LLM.",
  "section:Overview:dd3fc95a3d91657431f7d96f6e2e1db47ca997e2d196f66602101b598fb9a64e": "The user manual provides a comprehensive guide on how to set up and use a documentation generation tool. The process involves creating a temporary directory with essential files such as `README.md` and dummy Python files. The tool uses monkeypatch to replace functions like `rank_code_files`, `extract_snippets`, and `LLMClient` with mock implementations, allowing for controlled testing environments.\n\nThe manual includes several tests that ensure the system's functionality under various conditions. One test checks if the HTML output excludes \"NEEDS_RUN_INSTRUCTIONS\" and verifies that specific functions are called as expected. Another test focuses on mapping evidence to sections while filtering out certain files and prioritizing others based on their content. The `render_html` function is tested for its ability to include a table of contents (TOC) and source blocks in the generated HTML.\n\nThe `infer_sections` function demonstrates how to handle cases where documentation is incomplete by inferring missing sections and providing placeholder content. The `validate_manual_references` method ensures that all referenced files are accounted for, marking any missing references appropriately. The `test_html_summary_creation` function validates the creation of HTML summaries, checking for the presence of evidence and correct navigation links.\n\nAdditionally, the manual covers edge cases such as disabling chunking and skipping code fallbacks when specific flags are used. Each section is designed to be self-contained, providing clear instructions and examples to help users effectively utilize the documentation generation tool.",
  "section:Purpose & Problem Solving:d057de42c3698d43016f714dca7486b41ea1e56ab7152c5e95c4745b600aafc6": "**Purpose & Problem Solving**\n\nThe purpose of this module is to address the need for efficiently discovering Python and Objective-C source files within a directory structure, while providing flexibility in excluding certain paths. The primary problem it solves is the manual and time-consuming process of identifying relevant source files across complex project directories.\n\nBy implementing a recursive function `scan_directory`, the module automates the discovery of these files, ensuring that only necessary files are considered for further processing or analysis. This automation saves time and reduces the risk of human error in file selection.\n\nThe internal helper function `_is_subpath` is crucial for filtering out paths that should be ignored, such as build directories, temporary files, or other non-source code artifacts. This ensures that only relevant source files are included in the final list, enhancing the efficiency and accuracy of subsequent operations on these files.\n\nOverall, this module provides a practical solution to the problem of managing and processing large collections of Python and Objective-C source files by automating their discovery and filtering based on specified criteria.",
  "section:System Requirements:35ee29904876f4bf57fb1bf4176a4ea9e208dadf68420cc5b5389d4dcd820165": "# System Requirements\n\n- **Python Version**: Python 3.7 or higher.\n- **Dependencies**:\n- `unittest.mock` (included in the standard library from Python 3.3 onwards)\n- `pathlib` (included in the standard library from Python 3.4 onwards)\n- `tiktoken`\n- `markdown` (for handling Markdown files)\n- `python-docx` (for handling DOCX files)\n- `reportlab` (for generating PDFs)\n\n# Installation\n\nTo install all required dependencies, run:\n\n```bash\npip install -r requirements.txt\n```\n\nThese requirements ensure that the system is equipped to handle the functionalities described in the user manual."
}