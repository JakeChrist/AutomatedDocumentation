{
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\cache.py:2e37ab4b52e9489ed2b2dc8e686dc29df25416d04f5b423c47ba2cc9aecf698c": "A simple on-disk cache for LLM responses. Implements methods to initialize the cache from a file, generate deterministic keys based on file paths and content, retrieve cached values, store new values with persistence to disk, and save the cache data to a JSON file.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\cache.py:ResponseCache:__init__:919483e1ff4b05cae685fcac27aa9458bc309d42dd717af59b0942962ccdf4e4": "Initializes an object with a file path. If the file exists, reads its contents as JSON and stores it in `_data`. If the file does not exist or is not valid JSON, initializes `_data` as an empty dictionary.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\cache.py:ResponseCache:_save:d6c96e0258c810e9fec48856af580533cfc0aa8f13ea666bb1d396aa4abe5e41": "Writes JSON data to a file with indentation and sorted keys.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\cache.py:ResponseCache:e71b85560faee0eca19443b5e2bd9a284b0c1a66253f05257ea1146df1cb0d97": "The `ResponseCache` class manages caching for code summaries generated by DocGen-LM. It provides methods to initialize with a file path, generate a deterministic key from file content, retrieve cached data, store new data, and persist cache to disk using JSON format.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\cache.py:ResponseCache:get:eeb84b4591575a8ed2767f4abac56f1f2dd0697e81322599734b8b31e94ddcce": "Returns the cached value associated with a given key if it exists.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\cache.py:ResponseCache:make_key:4f63c9f618b20a79035ed49cae07b9b800a46f352498e23dc8700f47c38fe96d": "Function `make_key` takes two parameters: `file_path` (a string representing the path to a file) and `content` (a string representing the content of the file). It returns a deterministic key by hashing the content using SHA-256 and appending the file path to the hash digest.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\cache.py:ResponseCache:set:0bc8af7637662ae14e3eca8604a4d7155ff442d423955a243d6b586ffee8d8ba": "Stores a value in a dictionary using a key and persists the data to disk.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\docgenerator.py:8ae62a06e44b789417fa7f4991b5a92a22e909ce4b708335098f242db32a22e8": "This Python script generates HTML documentation for a project by scanning directories for Python and MATLAB files. It uses a locally running language model (LLM) to parse the code, request summaries, and write the documentation. The script handles command-line arguments for source directory, output directory, ignored paths, LLM URL, and model name. It processes each file, parses its content, and requests summaries for modules, classes, methods, and standalone functions. Summaries are cached to avoid redundant requests. Finally, it writes an index page and individual module pages with the generated documentation.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\docgenerator.py:_build_function_prompt:670b8d28ed1a1a6ce14a55c34d539d05135080550920ce5c8efe157d4c16418a": "The function `_build_function_prompt` constructs a context-enriched prompt for summarizing Python code. It takes the source code of a function, along with optional class and project summaries, and returns a string that includes these contexts followed by instructions on how to summarize the function based solely on its source code.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\docgenerator.py:_rewrite_docstring:057f39ae759f4961f694edf5d76268c0e3c0ef036d42d974cdff112ebeb55b38": "The function `_rewrite_docstring` takes an `LLMClient`, a `ResponseCache`, a file path, and a dictionary representing an item with source code and a docstring. It optionally accepts class name, class summary, and project summary for context. The function checks if the source or docstring is empty and prints a warning if so. It constructs a prompt based on the provided context or default `DOC_PROMPT`. A cache key is generated using the file path, item name, and key content. If the result is available in the cache, it uses that; otherwise, it generates a summary using the LLM client and updates the item's docstring with the sanitized result or \"No summary available.\"",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\docgenerator.py:_summarize:508f181bffdc3183407ff1df9835d831ec64072614b5e4fe0cfae9b224f9b0b4": "This function `_summarize` takes an `LLMClient`, a `ResponseCache`, a `key`, a `text`, and a `prompt_type` as parameters. It checks if the summary for the given key is already cached. If it is, it returns the cached summary. Otherwise, it uses the LLM client to generate a new summary for the text based on the prompt type, caches this new summary under the specified key, and then returns it.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\docgenerator.py:main:ab2e56159500ab26630d01b1eb1707c20ac412221c02f9fee1294ff4ca22c360": "The `main` function serves as the entry point for generating HTML documentation using a local Large Language Model (LLM). It parses command-line arguments to specify the source directory, output location, and optional parameters such as LLM server URL and model name. The function initializes an LLM client, checks connectivity, sets up directories, and processes Python and MATLAB files within the source directory. It generates summaries for modules, classes, methods, functions, and the project itself using the LLM. Summaries are cached to avoid redundant requests. Finally, it writes HTML documentation pages based on the generated summaries and project structure.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\html_writer.py:9b2e72e8bdc2835996b15bcb66324f8943dcb090d544473c3e1e1f965968876b": "This module provides utilities for rendering HTML documentation pages using simple template substitution. It includes functions to highlight code snippets and render HTML content based on project summaries and module data. The `write_index` function generates the main index page with project summary and navigation links. The `write_module_page` function creates detailed documentation pages for individual modules, including classes, methods, and functions, with syntax highlighting for source code.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\html_writer.py:_highlight:6f66a3db89d6c161d5e0da85d517b3e70c98bce374fb5269d625e0fc5530ced2": "The function `_highlight` takes a string `code` and a string `language`, and returns the code highlighted for the specified language using Pygments. If the language is \"matlab\", it uses the MatlabLexer; if \"python\", it uses the PythonLexer; otherwise, it uses the TextLexer. The output is formatted as HTML with `<pre>` and `<code>` tags, and syntax highlighting applied.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\html_writer.py:_render_html:328455b22753f98d3e4bbc0627ab1f7629f28f3bbb19c98fbf5b82a6b32fcb9e": "This function `_render_html` takes four parameters: `title`, `header`, `body`, and `nav_html`. It reads a template from a file specified by `_TEMPLATE_PATH`, which is expected to be in UTF-8 encoding. The function then formats this template using the provided title, header, body, and navigation HTML, and returns the resulting HTML string.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\html_writer.py:write_index:e36fb9b05a02409fa8e9689b8d90b236ecf08e6311f249066b2572f2cbccd584": "This function `write_index` generates the content for an `index.html` file in a specified output directory. It takes parameters for the project summary, navigation links, and optional module summaries. The function creates the destination directory if it doesn't exist, constructs HTML elements for the project summary and navigation links, and optionally includes summaries of modules. It then renders these elements into a complete HTML document using `_render_html` and writes this document to `index.html` in the output directory.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\html_writer.py:write_module_page:7ac85a59aa92db4aa6367dc0174b37c387721811f52895b9d7d3398522163601": "This function `write_module_page` generates an HTML documentation page for a Python or MATLAB module. It takes three parameters: the output directory (`output_dir`), a dictionary containing module data (`module_data`), and an iterable of tuples representing navigation links (`page_links`). The function creates a directory structure if it doesn't exist, constructs a navigation menu, and populates the body with summaries, classes, methods, and functions from the module data. It uses HTML escaping to ensure safe rendering and includes syntax highlighting for code snippets. Finally, it writes the generated HTML content to a file named after the module in the specified output directory.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\llm_client.py:017f9fceffc8768792b7a26edd6d84ef2f0fac121d5ed21de6be7e6e3592b3af": "This module defines an interface to a local language model backend called LMStudio. It includes:\n\n- Constants for system prompts and common rules.\n- A function `sanitize_summary` to clean up generated summaries by removing unwanted phrases.\n- A class `LLMClient` that:\n- Initializes with a base URL and model name.\n- Includes a method `ping` to check if the LMStudio API is reachable.\n- Implements a method `summarize` to generate summaries for given text using specified prompt types, handling retries on errors.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\llm_client.py:LLMClient:__init__:700c23b8c0716a1aaf00c10fbc2e056bef4f6e1dca9c72b739185f920ef55cf8": "Initializes an object with a base URL and a model. The base URL is stripped of any trailing slashes, and the endpoint for chat completions is constructed using this base URL. The model type is also set during initialization.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\llm_client.py:LLMClient:f9e0ab1ef6b5775ed20de99277fb248f3c6cb716f3015b6596d86e44aae411e4": "The `LLMClient` class is designed for interacting with a Large Language Model (LLM) server to generate summaries of Python and MATLAB code. It provides methods for checking API reachability (`ping`) and summarizing code using specified prompts, handling retries on failures.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\llm_client.py:LLMClient:ping:3fe5655e89accd067c6ddc9c1cc323c9dd9eac2dea9be6646ea4d470b3e0a436": "The function `ping` checks if the API is reachable by sending a GET request to the server's base URL with an optional timeout. It returns `True` if the request is successful and the server responds without errors. If the server cannot be contacted or there is an error in the request, it raises a `ConnectionError` with a message indicating that the LMStudio server at the specified URL is unreachable.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\llm_client.py:LLMClient:summarize:b1a476007dba66e5510bf80c9aee0418d5bacde02f9b1185988415d3f5b7a4f3": "The function `summarize` takes a string `text` and a string `prompt_type`, and returns a summary of the text using a template based on the prompt type. It constructs a payload with the model, temperature, and messages, including a system prompt and the formatted user prompt. The function attempts to send this payload to an endpoint three times, handling potential HTTP errors and request exceptions by retrying after a short delay. If all attempts fail, it raises a `RuntimeError` with the last error message.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\llm_client.py:sanitize_summary:bcea224b1bba3aff8be264e04b9e8c54ce5236e8cf4c081f8d72e0e3d7c1e711": "The `sanitize_summary` function removes meta-commentary from a given text by filtering out lines that start with specific phrases or contain certain keywords related to summaries, outputs, and responses. It processes the input text by splitting it into lines, checking each line against predefined bad start phrases and keywords, and appending only those lines that do not match these criteria to a filtered list. Finally, it joins the filtered lines back into a single string and returns the sanitized result.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\parser_matlab.py:15cf90e58e5b33528fe0fc6fa2e48fa77e43bd0fed902a29ea22b67a2f78ff68": "This module defines a function `parse_matlab_file` that takes the path to a MATLAB `.m` file and returns a dictionary containing the file's header comments and any `function` declarations found. Each function entry provides the name of the function and a list of arguments. The parsing uses simple line-based techniques as outlined in the Software Requirements Specification (SRS).",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\parser_matlab.py:parse_matlab_file:50f41de5e2e1c8fdffea1c984d24f46145d4d408781f8fa7d4243a8bc46654e5": "The `parse_matlab_file` function reads and parses a MATLAB `.m` file to extract its basic structure. It returns a dictionary containing the file's header comments and any function declarations found. The function identifies the start of the body by looking for non-comment lines, extracts comment lines as the header, and uses a regular expression to find and parse function declarations, capturing their names and arguments.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\parser_python.py:3a2a9b7664504ae6c8ef1905e400d9f06a7eb0f0680741d90e30ce977a1ce987": "This module provides a parser for Python files using the `ast` module to extract structured information according to the Software Requirements Specification (SRS). It includes functions to format function arguments and signatures, parse Python source files, and return structured data containing module docstring, classes, and functions. Each class and function is represented with its name, signature, docstring, and source code segment.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\parser_python.py:_format_arg:d7ce868de9873ad7f1bcd4df2ea863fdf43bfad8861e307036bc48f66e930cef": "Formats a function argument by appending its type annotation, if present.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\parser_python.py:_format_arguments:8d584330c67627ec3d44e46adadb6250be24cfae8ba767da7655103fa939f93a": "Formats the arguments of a function or method into a string representation. Handles positional-only, regular, variable positional, and variable keyword arguments, including their default values if provided.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\parser_python.py:_format_signature:f10b20606d0982feb4fcd52ec447895a7722c7833f3cab2cb524c874bf99be92": "This function `_format_signature` takes an `ast.FunctionDef` or `ast.AsyncFunctionDef` object as input and returns a string representing the signature of the function. It formats the function name, parameters, and return type (if present) into a readable string.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\parser_python.py:parse_python_file:5e79ff2a7577080bcef496e37e312ddc1c2eb206bb828290116bf67cf25e16a0": "The `parse_python_file` function reads a Python source file and extracts structured information such as the module docstring, classes, and functions. It uses the `ast` module to parse the source code and extract relevant details about each class and function, including their names, signatures, docstrings, and source code segments. The parsed information is returned as a dictionary.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\reviewer.py:6a93d618a253fc978a2efb4e7a399150eeb0d2bed5d4abd80181174fa8881fe1": "This module provides a tool for reviewing HTML documentation generated by DocGen-LM. It includes functions to check for assistant-like phrases, contradictions, and hallucinations in the documentation. The `review_directory` function can be used to review all HTML files in a specified directory, and an optional `--autofix` flag can be used to automatically fix certain issues by sanitizing paragraphs. The module uses BeautifulSoup for parsing HTML and regular expressions for text matching.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\reviewer.py:_find_line_number:14053a6310dade35ea28fd2ed8cd56000be56da5e2f7f1bd8161c6393734cf12": "Finds the line number of a given phrase within an HTML string. Returns the line number if found; otherwise, returns -1. The search is case-insensitive.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\reviewer.py:_is_generated_html:aff64e9f88cba6df0cd72b7bc31b5be8e74477b4b54ea2d106e00a781a5c4fe0": "The function `_is_generated_html` checks if a given string `text` appears to be output from DocGen-LM by looking for specific HTML tags and structures commonly found in the tool's documentation. It returns `True` if any of the following conditions are met:\n- The text contains the exact string `<h1>Project Documentation</h1>`.\n- The text matches a regular expression pattern that looks for an `<h2>` tag with \"Class:\" as its content.\n- The text matches a regular expression pattern that looks for an `<h3>` tag with \"Method:\" as its content.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\reviewer.py:_review_file:92296f8d601a0fc27ea7fd6ed755eeaa6afb6af5e8ca8de872fa259444ce7257": "The `_review_file` function processes an HTML file located at a specified path, reviews it for specific issues such as assistant phrasing, contradictions, and hallucinations. It returns a list of review results indicating any problems found. If the `autofix` parameter is set to `True` and issues are detected, the function attempts to sanitize the paragraphs in the HTML file and writes the changes back to the original file.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\reviewer.py:_sanitize_paragraphs:677897bc974e5910fe7c757d3eb2872e7bdd35f1cfa3970be84d8a1d2426050d": "The function `_sanitize_paragraphs` processes HTML content using a `BeautifulSoup` object. It iterates through all paragraph (`<p>`) elements within the HTML, retrieves their text content, sanitizes it using the `sanitize_summary` function, and then updates the paragraph element with the sanitized text.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\reviewer.py:check_assistant_phrasing:316460cf59de95d187207ee47ca6e518ff269fb0183f3ce5456d16ea88043fa4": "This function `check_assistant_phrasing` takes a BeautifulSoup object and an HTML string as input. It searches for paragraphs in the HTML that contain any of a list of predefined assistant-like phrases. If such a phrase is found, it appends the text of the paragraph along with its line number to a list. The function returns this list of findings.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\reviewer.py:check_contradictions:8b5c3fd09e90840d6552c55f298ef3e158c08191a163cff60413437d76f3c04e": "The `check_contradictions` function analyzes the content of an HTML document parsed with BeautifulSoup. It checks for contradictions between the text in the first two paragraphs and the presence of specific headings (methods, functions, classes) in the document. If a contradiction is found, it appends a description of the contradiction to a list. The function returns this list of findings.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\reviewer.py:check_hallucinations:af3b7348426b5607a305b2116977c4a1c7a47b12c231fb689b9f00b21626662e": "The function `check_hallucinations` takes a BeautifulSoup object as input and returns a list of hallucination phrases detected within the HTML content. It searches through all paragraph (`<p>`) tags, extracts their text content, converts it to lowercase for case-insensitive comparison, and checks if any predefined hallucination terms are present. If a term is found, it is added to the findings list, which is then returned.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\reviewer.py:main:84271247b7b6fc6897f96efad0977ce3ba9db51411840fc0f7cfa374ed4df5c0": "The `main` function serves as the entry point for a command-line tool designed to review generated HTML documentation. It accepts an optional list of arguments (`argv`) and performs the following tasks:\n\n1. **Argument Parsing**: Utilizes `argparse.ArgumentParser` to define and parse command-line arguments. The primary argument is `directory`, which specifies the path to the directory containing the HTML output files. An optional argument, `--autofix`, is provided to enable automatic rewriting of files to fix identified issues.\n\n2. **Review Execution**: Invokes the `review_directory` function with the parsed directory path and a boolean flag indicating whether autofix should be applied.\n\n3. **Return Value**: Returns an integer value of 0, typically used to indicate successful execution of the script.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\reviewer.py:review_directory:535459b5a84e67dce9df3591e5e4bf1ecf1cd71713c26e330809c4440392fd6f": "The function `review_directory` traverses a directory and its subdirectories, searching for `.html` files. For each file found, it calls `_review_file` to process the file and generate review results. If an error occurs during processing, it prints an error message and continues with the next file. The results from `_review_file` are printed line by line.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\scanner.py:_is_subpath:5ea2edab8861042dabf25e44d6d42b1b3a99a28023a9b473778c528875a1bc86": "Determines whether a given path is a subpath of another path. Returns `True` if the path is equal to or within the parent directory, otherwise returns `False`.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\scanner.py:fd7e0f952dd35ca841116789b2d99cfc36e1d26a7cf0ee616028fe9532c20347": "The module implements a function to recursively discover Python (``.py``) and Objective-C (``.m``) source files within a specified directory. It includes an ignore mechanism based on relative paths provided by the user. The function filters out ignored directories and files, ensuring that only relevant source files are returned in their absolute paths.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\scanner.py:scan_directory:4162a0d18296861f0156c467b9a72f05b07cde83872bba6c10d04f9e25be8829": "The `scan_directory` function recursively discovers Python (``.py``) and MATLAB (``.m``) files under a specified base directory while ignoring specified paths. It returns a list of absolute paths to the discovered source files, excluding those within ignored directories or matching any patterns in the ignore list. The function uses `os.walk` to traverse the directory tree and filters out unwanted file types and paths based on the provided criteria.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_cache.py:97b2ae8f04e70da29a7fb5d7cb91652ea871818ccc183154b3320347b5835642": "The module defines two functions for testing a response cache. The first function, `test_cache_round_trip`, tests setting and retrieving a value from the cache using a temporary file. The second function, `test_cache_get_missing`, tests retrieving a non-existent key from the cache, expecting it to return `None`. Both functions use the `ResponseCache` class from the `cache` module, which is initialized with a path to a JSON file for storage.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_cache.py:test_cache_get_missing:e12214ef69217299d0d199b9bd1f88131f3aca62d84cf642323db45312a12b27": "The function `test_cache_get_missing` tests the behavior of a `ResponseCache` object when attempting to retrieve a value for a key that does not exist in the cache. It creates a temporary directory, initializes a `ResponseCache` instance with a file path within this directory, and asserts that calling `get` on a non-existent key returns `None`.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_cache.py:test_cache_round_trip:7bf568ecb111710272e7680f3276e4b2dc4c9521660703b8b8ab16d21ed38183": "The function `test_cache_round_trip` tests the caching mechanism of a `ResponseCache` class. It creates a temporary file to store cache data, initializes a `ResponseCache` object with this file path, and sets a cache entry using a key generated for a specific file and content. Then, it reloads the cache from the same file and asserts that the cached value can be retrieved correctly.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_docgenerator.py:1e22c7b72bac2901aac233a2d473a5555079e2829489face9b5103480a267f0a": "The module defines several test functions to validate the behavior of a code documentation tool. It uses the `unittest.mock` library to mock interactions with an `LLMClient`, which is presumably used for generating summaries. The tests cover scenarios such as skipping invalid Python files, handling class and function summaries, dealing with non-UTF8 encoded files, managing class without docstrings, sanitizing project summaries, using README summaries, and ensuring that only relevant files are generated in the output directory.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_docgenerator.py:test_generates_class_and_function_summaries:0ff4a00c08f05d3150614c3751adab47f8fb5a56d48ae69a3963c6e332c2d454": "The function `test_generates_class_and_function_summaries` is a unit test for the `main` function of a documentation generator tool. It sets up a temporary project directory with a Python module containing a class and a function, and an output directory for the generated HTML documentation.\n\nIt then mocks the `LLMClient` to simulate responses from a language model when summarizing the code elements. The test asserts that the `main` function runs successfully (returning 0) and that the generated HTML files contain the expected summaries of the class and function, as well as the module summary.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_docgenerator.py:test_handles_class_without_docstring:df4e9a92306ed0fd9a63b5bce6320c1384816c2b0f2ac68f91332d74a009af90": "The function `test_handles_class_without_docstring` tests the handling of a Python class without a docstring by creating a temporary project directory, writing a Python module with an empty class to it, and then running the `main` function from the `docgenerator` module. It uses a mock LLM client to simulate responses for summarizing modules, projects, and classes. The test asserts that the return value of the `main` function is 0 (indicating success) and that the generated HTML file contains the summary for the class.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_docgenerator.py:test_project_summary_is_sanitized:46ced7332bfe428861d7ec1e3334632058bf2cafd265ae1496d8d676b58fb6d1": "The function `test_project_summary_is_sanitized` is a unit test for the `main` function of the DocGen-LM tool. It creates a temporary project directory with a Python module, sets up a mock LLM client to simulate responses, and runs the main function with specified parameters. The test asserts that the output HTML file does not contain certain phrases (\"You can run this\" and \"It prints.\") while verifying that the return code is 0.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_docgenerator.py:test_readme_summary_used:4736c5ec736cdab45ed444506d6462e5070c049d6c732b1ef94e967dc0d5e0c5": "This function tests the generation of a README summary using the `main` function from the `docgenerator` module. It creates a temporary project directory with a Python module and a README file. The function then mocks an LLM client to simulate responses for summarizing different parts of the project, including the README. After running the `main` function with the specified project directory and output location, it asserts that the README summary is included in the generated HTML documentation and that the LLM client was called with the correct parameters to generate the README summary.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_docgenerator.py:test_skips_invalid_python_file:6f78e161cc211a95ded464512c3e1589f4dba135aaf072de2967db39813a316b": "This function tests the behavior of a documentation generator when encountering an invalid Python file. It creates a temporary project directory with a file containing invalid syntax due to a leading zero in a numeric literal. The function then attempts to generate documentation for this project using a mock LLM client that returns a predefined summary and ping response. After running the main function, it asserts that only the index page is generated in the output directory, while no HTML file is created for the invalid Python file.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_docgenerator.py:test_skips_non_utf8_file:66f5e9b0ccd361d5f1e2fcbcfc30ef9f6e76a827516a239584eb616415fc1067": "This function tests the behavior of the `main` function when encountering a non-UTF-8 encoded file. It creates a temporary project directory with a non-UTF-8 encoded Python file and specifies an output directory for documentation. The function uses a mock LLM client to simulate successful ping and summary generation. When running the main function, it asserts that the return code is 0, indicating success. Additionally, it checks that only the index.html file exists in the output directory, while the bad.html file does not exist, suggesting that non-UTF-8 files are skipped during documentation generation.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_html_writer.py:7247a9aa5e05fddd880ec79654eda9db73ceaa91fdf553c3dd7d528c2025a70f": "The module defines two functions, `test_write_index` and `test_write_module_page`, which are used to test the functionality of writing HTML index and module pages. The tests use a temporary path to create files and verify their contents against expected output.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_html_writer.py:test_write_index:469a95a21b75a54fef75551ff35e2ee77a987ba5a6df6d7e65b621f6978636d3": "The `test_write_index` function tests the `write_index` function, which generates an HTML index file for a project documentation. It creates a temporary directory, defines links and summaries for modules, calls `write_index`, reads the generated HTML file, and asserts that various elements are present in the HTML, including the project title, module links, summaries, and headers. The test ensures that the HTML structure is correct and that the summaries are rendered as expected.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_html_writer.py:test_write_module_page:dbb19bacc3d70649e03a22e6bb165f3564180ad6cc0428c33c02861ae32960ee": "This function `test_write_module_page` tests the generation of an HTML module page. It takes a temporary path, module data, and links as input. The function writes the module page to the specified path using the provided data and links. It then reads the generated HTML file and asserts that it contains various elements such as project overview links, external module links, class summaries, method signatures with docstrings, function summaries, and code snippets.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_integration.py:e977cba7f0b91bc157a456c9b49e68be4ca45d263b578fcfe7b372ef54d38deb": "The module defines two test functions for a documentation generator. The first function, `test_docgenerator_generates_html`, tests the generation of HTML files from Python and MATLAB code in a project directory. It uses a mock LLMClient to simulate responses and verifies that HTML files are created with expected content.\n\nThe second function, `test_static_copied_from_any_cwd`, tests the copying of static files (like CSS) into the output directory regardless of the current working directory. It also uses a mock LLMClient and asserts that the static file is correctly copied to the output directory.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_integration.py:test_docgenerator_generates_html:39ee34a2a44a6b6088bf4fc57ed13e42c2716c21a345ecf4bc604e7b032d6f7d": "The function `test_docgenerator_generates_html` tests the `main` function of a documentation generator tool. It creates a temporary project directory with Python and MATLAB files, sets up a mock LLM client to return a predefined summary, and runs the main function with specified project and output directories. The test asserts that the main function returns 0 (indicating success), and checks that HTML files for the project, including summaries, are created in the output directory.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_integration.py:test_static_copied_from_any_cwd:bec3e648fe2fafa0c11fa2fdd43df0f00349978f5cf910197a75b387b86f1f39": "The function `test_static_copied_from_any_cwd` tests the generation of static HTML documentation for a Python project using the DocGen-LM tool. It creates a temporary project directory with a single Python module, sets up a mock LLM client to return a predefined summary, and runs the main function with the specified project and output directories. The test asserts that the `style.css` file is generated in the output directory's static folder.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_llm_client.py:ff8a0c5e5d3895b53e3efd3ac0badb2dca6ba723a90e55d61bc0a3a56cb89180": "This module defines unit tests for an `LLMClient` class, which interacts with a language model. The tests cover the following functionalities:\n\n1. **Ping Method**: Verifies that the client can successfully ping the server and handle both successful and failed responses.\n2. **Summarize Method**: Tests the method's ability to retry requests in case of failures and returns the correct summary text. It also checks how different types (class, function, readme) affect the prompt sent to the language model.\n3. **Sanitize Summary Function**: Ensures that certain phrases are filtered out from the summary text.\n\nThe tests use mock objects for `requests` calls and `time.sleep` to simulate network delays and responses. They also utilize `pytest` for assertions and exception handling.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_llm_client.py:test_ping_failure:74b17897b06af328d83eda1398fc7e1c15e9c9ea0ae827ade91ab43f3c629b2e": "This function tests the `ping` method of an `LLMClient` class. It uses a mock to simulate a request failure when attempting to connect to a specified URL. The test asserts that a `ConnectionError` is raised as expected when the ping operation fails due to a network issue or invalid server address.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_llm_client.py:test_ping_success:2b99adf3021db12e2e0f40c248096ad982430f951f45bab61b60012941703e56": "The function `test_ping_success` tests the `ping` method of an `LLMClient` class. It sets up a mock response that simulates a successful HTTP GET request and asserts that calling `client.ping()` returns `True`. The test also verifies that the `requests.get` method is called once with the specified URL and timeout, and that `raise_for_status` on the mock response is called to ensure the request was successful.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_llm_client.py:test_prompt_varies_by_type:fc0d3aa5bb90bb830ec7114855b428cbb8054423fefffa7c0bab222044ebe015": "This function tests the `summarize` method of an `LLMClient` class, which generates prompts for summarizing Python and MATLAB code using a language model. The test ensures that the prompts vary by type (class vs. function) when called with different parameters. It uses mocking to simulate HTTP requests and assertions to verify that the generated prompts match expected templates and are distinct for different types of code elements.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_llm_client.py:test_readme_prompt_template_used:2a26690e61df65d79a42edc6f517a0f0e0a24dbab3e743c2cac77e79e6c33756": "This function tests the use of a README prompt template in an LLMClient's summarize method. It sets up a mock response from an LLM server and patches the requests.post method to return this mock response. The function then calls client.summarize with \"foo\" as the text and \"readme\" as the language, capturing the generated README prompt from the post call arguments. Finally, it asserts that the captured prompt matches the expected format of the README template with \"foo\" inserted into it.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_llm_client.py:test_sanitize_summary_filters_phrases:8fe592545e11a4ab2fea4bcc158cbdf6e55590d99a4b0fc97dcc49d17ca56b77": "",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_llm_client.py:test_summarize_raises_runtime_error_with_message:4fc0b69cb85be064c3b93d9e0c611a562ac685c99e7af0cd7f7ad0c96d567995": "The function `test_summarize_raises_runtime_error_with_message` is a unit test for the `summarize` method of an `LLMClient`. It tests that a `RuntimeError` with the message \"server exploded\" is raised when the LLM server returns an HTTP error and a JSON parsing error. The test uses mocking to simulate the behavior of the `requests.post` method and the `time.sleep` function, and it asserts that the expected exception is raised using the `pytest.raises` context manager.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_llm_client.py:test_summarize_retries_and_returns_summary:09493bbe0427d6706fdf0a52589e4c7439780f8b275adce4b5a5efab27a17451": "The function `test_summarize_retries_and_returns_summary` tests the `summarize` method of an `LLMClient` class. It uses a mock `requests.post` to simulate HTTP requests and a mock `time.sleep` to simulate delays. The test asserts that after two failed attempts due to exceptions, the method successfully receives a response from the LLM server, returns the summary content, and waits for 1 second between retries.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_parser_matlab.py:d371df41f01bfadecc63c5f1bddb7b77eb2309a17405bffe247ca4a3e17973bd": "The module contains two test functions to verify the functionality of a MATLAB file parser. The `test_parse_simple_matlab` function checks if the parser correctly extracts the header and a single function from a simple MATLAB file. The `test_parse_multiple_functions` function tests the parser's ability to handle multiple functions within a single MATLAB file, ensuring that each function's name and arguments are accurately parsed.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_parser_matlab.py:test_parse_multiple_functions:06b0ead45b7d8c56df573527d808fab68d59d95a7406e6443145016d2948524d": "This function, `test_parse_multiple_functions`, tests the parsing of MATLAB files containing multiple functions. It creates a temporary file with two MATLAB functions: `compute` and `square`. The function then calls `parse_matlab_file` to parse this file and asserts that the parsed result contains the correct header (empty), two functions named \"compute\" and \"square\", and the expected arguments for each function.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_parser_matlab.py:test_parse_simple_matlab:041913e1ad43b7572f239df9cbbfa7cf1c116649bd6b1246db0cfef40aa9e818": "The function `test_parse_simple_matlab` is a unit test for parsing MATLAB files using the `parse_matlab_file` function. It creates a temporary MATLAB file with a simple function definition, then calls `parse_matlab_file` to parse the file and asserts that the parsed result contains the expected header and function details.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_parser_python.py:c9cd0efc42de5b3182fc1d64d54b126c109e111267c90017988eccb169d8325a": "The module defines two test functions to parse Python files using a hypothetical `parse_python_file` function from the `parser_python` module. It tests parsing of simple modules and complex function signatures, verifying the extracted documentation strings, method signatures, and source code snippets.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_parser_python.py:test_parse_complex_signature:ab6604a0db9dd1dbe1e06e1c3e188a4fc8a2ce7d37819788a777ed2e42b0a9be": "This function tests the parsing of a complex Python function signature. It creates a temporary file with a sample Python code containing a function with various parameters and annotations. The function then parses this file using `parse_python_file` and checks that the parsed signature matches the expected format, and that the docstring is correctly extracted from the source code.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_parser_python.py:test_parse_simple_module:40129e853cbc7e7aad98189e084fd6192a2b98548d134c67328f583c5484c4d3": "This function `test_parse_simple_module` is designed to test the parsing functionality of a Python file using a hypothetical `parse_python_file` function. It creates a temporary Python file with a simple module containing a class and a function, writes it to a specified path, and then parses this file.\n\nThe function asserts that:\n- The module docstring matches \"Example module.\"\n- There is one class named \"Greeter\" with the correct docstring.\n- The Greeter class has one method named \"greet\" with the correct signature and docstring.\n- The source code of the greet method contains the expected string \"Return a greeting.\"\n- There is one function named \"add\" with the correct signature, return type, and docstring.\n- The source code of the add function contains the expected string \"Add two numbers.\"\n\nThis test ensures that the parsing logic correctly extracts and summarizes the structure and content of Python modules.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_reviewer.py:83233473a3bb44ee0c5e26502caa85ad29205c84af0e40280e3fd12a3f730505": "This module defines several functions and tests for a code review assistant. It includes:\n\n1. `_make_module`: A helper function to create a temporary module with specified summary and methods, then write an HTML page for it.\n2. `test_assistant_phrasing_detected`: Tests if the assistant detects phrasing like \"You can use this class\" in the module summary.\n3. `test_contradiction_detected`: Tests if the assistant detects contradictions between the module summary and the defined methods.\n4. `test_hallucination_detected`: Tests if the assistant detects when the module summary contains features not implemented by any method.\n5. `test_autofix_removes_phrasing`: Tests if the assistant can automatically remove phrasing like \"You can call this\" from the HTML output when using the `--autofix` option.\n\nThe tests use a temporary path and capture system output to verify the behavior of the code review assistant.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_reviewer.py:_make_module:03a70723b780968321a89ed2a217c76e81f15f65c167bd6908d234fbced29286": "The `_make_module` function creates a temporary module page for documentation purposes. It takes three parameters: `tmp_path`, which is the path to the temporary directory where the module page will be created; `summary`, which is a string summarizing the module; and `methods`, an optional parameter that specifies methods for a class within the module.\n\nThe function constructs a dictionary `data` with keys for the module's name, summary, classes, and functions. If `methods` are provided, it adds a class named \"Foo\" to the `classes` list in `data`. The function then calls `write_module_page` to generate the HTML content for the module page based on the `data` dictionary and saves it as \"mod.html\" in the temporary directory specified by `tmp_path`. Finally, it returns the path to the generated \"mod.html\" file.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_reviewer.py:test_assistant_phrasing_detected:e766436e7d3780e31616bb87864b287aebb1d39efae0c11375314c9e9d03b225": "The function `test_assistant_phrasing_detected` is designed to test if assistant phrasing is detected and included in the generated documentation. It creates a temporary module with specific content, runs the main function of the DocGen-LM tool on this module, captures the output, and asserts that both \"[ASSISTANT]\" and \"mod.html\" are present in the output.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_reviewer.py:test_autofix_removes_phrasing:a0fb27aa79d12754f7bba20d1fb43ac5f8a9952d9e3eeb09ac403a4259658294": "The function `test_autofix_removes_phrasing` is designed to test the functionality of an autofix feature within a documentation generation tool. It creates a temporary Python module with a specific phrase, runs the main function of the tool with the `--autofix` option on this module, and then checks if the specified phrase has been removed from the generated HTML file.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_reviewer.py:test_contradiction_detected:c55ddb9d4ed9a31c8c819d3695641008825e6f877d2b804b0f10c07be0762bab": "This function `test_contradiction_detected` tests if a contradiction is detected when summarizing code. It creates a temporary module with no methods defined and runs the main function with this directory as input. The output is captured and checked to ensure that the string \"[CONTRADICTION]\" is present, indicating that a contradiction was detected during the summary process.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_reviewer.py:test_hallucination_detected:fcf3ed2d97fd2acb9244d510792fae2bd55fd337c6e1f7f4461f483c063231a2": "The function `test_hallucination_detected` is designed to test for the detection of hallucinations in documentation generated by the DocGen-LM tool. It creates a temporary Python module with specified content, runs the main function of the tool on this module, and captures the output. The function then asserts that the string \"[HALLUCINATION]\" is present in the captured output, indicating that the tool has detected a hallucination in the generated documentation.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_scanner.py:3ec32c624e4312ae44349511245ebc4be1d33ae9233f8c4ba760f4c5f65f37f1": "The module defines a function `scan_directory` from the `scanner` module and tests to ensure it works correctly. The tests create temporary files, call `scan_directory`, and verify that the returned list of file paths matches expected results. The tests check if directories specified in the ignore list are excluded, if files with mixed extensions are included, and if a `.git` directory is skipped.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_scanner.py:create_files:944d660740328196d3d2b8533dfa9a9c50cb927c31fc3386eb3202b99b08e761": "This function `create_files` takes a base directory and a list of file paths relative to that directory. It iterates over the list, creating any necessary parent directories for each file if they do not already exist, and then creates an empty file at each specified path.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_scanner.py:test_scan_directory_ignore_folder:e7f9fdfb390123e2fcdf1332d07f024635b54de6bb332f44017951c99f13a284": "The function `test_scan_directory_ignore_folder` tests the `scan_directory` function by creating a temporary directory with various files and subdirectories, including an ignored folder. It then calls `scan_directory` with the path to the temporary directory and a list of folders to ignore. The function asserts that the result contains only the paths of the files and directories that were not ignored.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_scanner.py:test_scan_directory_mixed_file_types:6831a0f5e38081779adebdc6e8a53f114e3abbb2b120f551e5288b9df36733af": "This function `test_scan_directory_mixed_file_types` is designed to test the functionality of scanning a directory for Python and MATLAB files. It uses a temporary path provided by `tmp_path` fixture, which creates a temporary directory during the test execution.\n\nThe function calls `create_files` with the temporary path and a list of file names to create within that directory. These file names include both Python (`one.py`, `four.py`) and MATLAB (`two.m`, `six.m`) files, as well as non-code files like `three.txt` and Markdown files in a nested directory.\n\nThe function then calls `scan_directory` with the path of the temporary directory and an empty list as arguments. The result of this call is stored in the variable `result`.\n\nFinally, the function asserts that the set of file paths returned by `scan_directory` matches the expected set of Python and MATLAB files, excluding non-code files and those in nested directories.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_scanner.py:test_scan_directory_skips_git_folder:f02ebc0f22f01822943ba5cbf0408800f963a601ab435edeeff78961806dbe94": "The function `test_scan_directory_skips_git_folder` is a unit test that checks if the `scan_directory` function correctly skips files and directories within the `.git` folder. It creates a temporary directory with specified files, including some inside the `.git` directory, then calls `scan_directory` on this path. The test asserts that the file `good.py` is included in the result, while no paths containing `.git` are present in the returned list of scanned items.",
  "PROJECT:1325a6541720de78a2e45ab046343ade296d7d9bab709a8d36410bd9056b25b9": "This codebase implements a system for summarizing and reviewing Python and MATLAB code using language models. It includes functionality for parsing code files, generating summaries, caching results, and reviewing the quality of generated summaries.",
  "README:f43f4e7af6a0afcd043ca9d5320c977629d769e2d3ffb8ce252fa76846d43ab5": "DocGen-LM is a tool that generates static HTML documentation for Python and MATLAB projects by analyzing source files and summarizing them with a local Large Language Model (LLM). It provides a command-line interface to specify the project directory, output location, and optional parameters such as LLM server URL and model name.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\cache.py:ResponseCache:b0db65b7fc8663d3ea2f2fc2a4be17323366b9635a8f294571c914ed7bba5175": "This function persists key-value pairs where keys are stable and values are responses from a language model.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\cache.py:__init__:f560462c44c12cfed6c3460c5981adddd93dddef31ab4a12505f9cd30e688ce7": "Initializes a `ResponseCache` instance with a file path. Loads existing cache data from the specified JSON file if it exists, otherwise initializes an empty dictionary to store cache data.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\cache.py:_save:48811ae69748b41f321ba043c5159c033d3cdc1ef1c902622f28ff10cbf129fb": "The `_save` method in the `ResponseCache` class writes the cached data to a file using JSON format. It uses the `write_text` method of the `file` attribute, which is assumed to be an instance of a file-like object. The data is serialized to JSON with an indentation of 2 spaces and sorted keys for better readability and consistency.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\cache.py:get:1ba4f29b866ec5013882ed5f59a0bc2baf407c1b29e947b40d7fc3cb90c1758a": "The `get` method in the `ResponseCache` class retrieves the cached value associated with a given key. It returns the cached data if the key exists, otherwise, it returns `None`.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\cache.py:make_key:ad58ef430d0990f57eb8883bc6d529e92773eedce94876f3d4330274a6558a6d": "The `make_key` function generates a deterministic key for a given file path and content. It uses the SHA-256 hash algorithm to create a unique digest from the content, then concatenates this digest with the file path to form the key. This key can be used as a cache identifier to retrieve or store cached data associated with the specified file and its content.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\cache.py:set:b6100506f25a6ea1a25458f6b14dabcc7ea828fac5def45c84b8c50d8a098fca": "This function `set` in the `ResponseCache` class stores a value under a specified key and persists the cache to disk. It takes two parameters: `key` (a string) and `value` (a string). The function updates an internal dictionary `_data` with the provided key-value pair and then calls another method `_save()` to serialize and save the updated cache to disk in JSON format.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\docgenerator.py:_build_function_prompt:c9f56ab4c396c71f3555e66c28f85195a6234dd89801ebf5663c19bb28eb8e6d": "This function `_build_function_prompt` constructs a prompt for summarizing Python code based on its source. It takes four parameters: `source`, `class_name`, `class_summary`, and `project_summary`. The function returns a string that includes the following elements:\n1. A statement identifying the role of the documentation generator.\n2. Information about the class the function belongs to, if provided.\n3. A summary of the class, if available.\n4. A description of the project, if provided.\n5. Instructions for summarizing the function based on its source code.\n6. The actual source code of the function enclosed in a code block.\n\nThe purpose of this prompt is to provide context and instructions to a language model when generating summaries for Python functions.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\docgenerator.py:_rewrite_docstring:eb4ebc70819153d815adb70a91882a587b5b8aa350c93a88f58c37d381776048": "This function `_rewrite_docstring` takes a client for an LLM, a response cache, a file path, and a dictionary representing an item (likely a code element). It optionally accepts parameters for class name, class summary, and project summary. The function checks if the source or docstring is provided; if not, it prints a warning and returns.\n\nIt constructs a prompt based on whether context parameters are provided. If they are, it uses `_build_function_prompt` to create a prompt including the source code and optional context information. If no context parameters are provided, it uses a predefined `DOC_PROMPT`.\n\nA cache key is generated using `ResponseCache.make_key`, combining the file path, item name, source code, and any additional context. The function then calls `_summarize` with the client, cache, key, prompt, and type \"docstring\" to generate or retrieve a summary.\n\nFinally, it updates the item's docstring with the sanitized result of the summary or sets it to \"No summary available.\" if no summary is generated.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\docgenerator.py:_summarize:cc5bdfb13878c60608d7246f2d14e69e10e30b738d1c165da4d94f3212d88e10": "The function `_summarize` takes an `LLMClient`, a `ResponseCache`, a `key`, a `text`, and a `prompt_type` as parameters. It checks if the summary for the given `key` is already cached. If it is, it returns the cached summary. Otherwise, it generates a new summary using the provided `client` and `prompt_type`, caches this new summary under the given `key`, and then returns it.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\docgenerator.py:main:563959f3786dd8c2ac556399af88772870e271991ccbd7e2dd162cedd8d089f7": "The `main` function serves as the entry point for the DocGen-LM tool. It parses command-line arguments to specify the source directory, output location, and optional parameters such as LLM server URL and model name. The function initializes an LLM client, checks connectivity, sets up directories, and processes each file in the source directory to generate summaries using language models. It handles Python and MATLAB files separately, parsing them into modules, classes, and functions. Summaries are cached for reuse and reviewed for quality. Finally, it generates HTML documentation pages based on the parsed and summarized data.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\html_writer.py:_highlight:6fbc4622377d2fb528275037d821f6d133294e66eb55ff7601208fbae82b407b": "This function `_highlight` takes a string `code` and a string `language` as input. It uses the Pygments library to syntax-highlight the code based on the specified language. If the language is \"matlab\", it uses the MatlabLexer; if \"python\", it uses the PythonLexer; otherwise, it uses the TextLexer. The output is formatted using HtmlFormatter with no classes and nowrap option enabled. The function returns a string wrapped in `<pre><code>` tags to preserve formatting when displayed in HTML.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\html_writer.py:_render_html:dbb7268d4adf8e1257de9f45ddf1e09322f334c5e68364e63c423ff933869478": "The function `_render_html` takes four parameters: `title`, `header`, `body`, and `nav_html`. It reads a template from `_TEMPLATE_PATH` and formats it with the provided parameters to generate an HTML string. The template includes placeholders for `title`, `header`, `body`, `navigation`, and `static_path`, which are replaced by the actual values passed to the function.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\html_writer.py:write_index:cf2cf89ae5891c46eeb1b6388aa22f9cb8dcee5a1d986566ea107fa1471a4836": "This function `write_index` generates the content for an `index.html` file in a specified output directory. It takes parameters for the project summary, navigation links, and optional module summaries. The function creates the destination directory if it doesn't exist, constructs HTML elements for the project summary and navigation links, and optionally includes summaries for modules. Finally, it renders the complete HTML content using `_render_html` and writes it to `index.html`.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\html_writer.py:write_module_page:85171a747479cfb95d3fb1a183a8c0385189961a23c33368ea2bbda2b9cd85da": "This function `write_module_page` generates a static HTML documentation page for a Python or MATLAB module. It takes the output directory, module data, and page links as input parameters. The function creates the destination directory if it doesn't exist. It constructs the navigation menu using provided links and adds a summary of the module. Then, it iterates through classes and functions within the module, extracting their names, summaries, docstrings, and source code. Source code is highlighted based on the language (Python or MATLAB). Finally, it renders the HTML content using `_render_html` and saves the generated page to the output directory with a filename corresponding to the module name.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\llm_client.py:LLMClient:5670248690f3cd5fa1b3c69519dfc26e6cc9da85500699ca791b27c1a40f032a": "A thin wrapper around the LMStudio HTTP API.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\llm_client.py:__init__:fa181acd96eadb2a6fea6c75286604e28e4c21cbfb65b1bdaedb6a2a112effc2": "The `__init__` method initializes a new instance of the `LLMClient` class. It sets up the client with the base URL and model name for interacting with an LLM server. The base URL is configured to point to a local LLM server running on \"http://localhost:1234\" by default, but it can be customized. The endpoint for sending requests to generate completions is derived from the base URL. Additionally, the model parameter specifies which language model to use; it defaults to \"local\" if not provided.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\llm_client.py:ping:87c92e24ba62139a180608ed3d9e0313def809b067107c09321cd2c279ed6cd5": "The `ping` method of the `LLMClient` class checks if the Large Language Model (LLM) server is reachable. It sends a GET request to the server's base URL with an optional timeout parameter. If the server responds successfully, it returns `True`. If there is any issue in contacting the server, such as network problems or the server being down, it raises a `ConnectionError` with a message indicating that the LLM server cannot be reached.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\llm_client.py:sanitize_summary:89c73c6b3a593f80bed5dd67041a6492dc85efc5f1802c97ce6b317c3dad84a2": "The function `sanitize_summary` takes a string `text` as input and returns a sanitized version of the text by removing lines that start with certain phrases considered meta-commentary or repetitive. It uses a list of bad starting phrases to filter out unwanted lines, ensuring that the summary is concise and focused on the main content rather than introductory or redundant statements.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\llm_client.py:summarize:5fd15337f8191b968a98eb26aced997298b8b45d7e6b54eb8b3234d0973eb088": "The `summarize` method in the `LLMClient` class generates a summary for a given piece of code (`text`) using a specified prompt type (`prompt_type`). It uses a template from `PROMPT_TEMPLATES` to format the input text into a prompt. The method constructs a payload with the model name, temperature, and formatted prompt, then sends this payload to an LLM server at `self.endpoint`. If the request fails due to HTTP errors or other exceptions, it retries up to three times before raising a `RuntimeError` with the accumulated error message.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\parser_matlab.py:parse_matlab_file:ee4e1592967f9cc7d189639c1b812ece79973efbec2a4c3ddfc8de1bb4468f0b": "This function `parse_matlab_file` reads and parses a MATLAB `.m` file to extract its basic structure. It returns a dictionary containing the file's header comments and any function declarations found within the file. The header is extracted as all lines starting with `%`, and function declarations are identified using a regular expression that matches lines defining functions, capturing their names and arguments.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\parser_python.py:_format_arg:71b87b1831e3400b297eaf8b5cf5dc7be74c46c9dc12fc4540031daff4b5a598": "Formats an argument by appending its type annotation, if present.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\parser_python.py:_format_arguments:e6468e229dbcd3e008d2dcc96205852ab3054a620dbdb3b6a8b2685050beeca6": "This function `_format_arguments` takes an `ast.arguments` object as input and returns a string representation of the arguments it contains. The function processes positional-only arguments, regular arguments, variable positional arguments, keyword-only arguments, and variable keyword arguments, formatting each according to Python syntax rules. It handles default values for arguments by appending them in the format `arg=default`. The function uses an iterator to manage default values efficiently.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\parser_python.py:_format_signature:b66ed0cb2dd19e8e39d3e370de44e292be5f2ca6730af9c88102d025684a5400": "This function `_format_signature` takes an `ast.FunctionDef` or `ast.AsyncFunctionDef` object as input and returns a string representing the signature of the function. It formats the function name, parameters, and return type (if specified) into a readable string format. The function uses another helper function `_format_arguments` to handle the formatting of the parameters.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\parser_python.py:parse_python_file:d453925633372fab29abc32a70de9acd5c7a858cfdfce0c9f3ddf8dffa6e6733": "The function `parse_python_file` reads a Python source file and extracts structured information about its module docstring, classes, and functions. It uses the `ast` module to parse the source code and iterates through the nodes to identify class definitions and function definitions. For each identified class or function, it collects details such as name, signature, documentation string, and source code segment. The results are returned in a dictionary format containing the parsed information.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\reviewer.py:_find_line_number:73a0d9f43ab9e93f6286ddec51e190c87f45fce8e9220de25964b6bdbb8187da": "The function `_find_line_number` takes two parameters: `html`, which is a string representing HTML content, and `phrase`, which is the substring to search for within the HTML. It returns the line number where the phrase is found, with line numbering starting from 1. If the phrase is not found, it returns -1. The search is case-insensitive.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\reviewer.py:_is_generated_html:078133111b23f5fa866c41c1bb2d6d10034136752c43aab264330f977c0e79a9": "This function checks if a given string of text appears to be output from the DocGen-LM tool. It returns `True` if the text contains specific HTML tags that are characteristic of the tool's documentation format, such as `<h1>Project Documentation</h1>`, `<h2>` tags with \"Class:\" content, and `<h3>` tags with \"Method:\" content.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\reviewer.py:_review_file:f7493561845c1521ee381fa38152bc5abddc41d4051f235e9c534ea1dab2de3a": "The function `_review_file` takes a file path and an optional `autofix` flag as input. It reads the HTML content of the specified file, checks for assistant phrasing, contradictions, and hallucinations using respective functions (`check_assistant_phrasing`, `check_contradictions`, `check_hallucinations`). If any issues are found, it appends a formatted message to the results list indicating the type of issue and the file name. If the `autofix` flag is set and there are issues, it sanitizes the paragraphs in the HTML content using `_sanitize_paragraphs` and writes the modified content back to the file. Finally, it returns the list of review results.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\reviewer.py:_sanitize_paragraphs:2d1a85bd28f35a875872a71848fbdd62c3db6d3e48ef722af8982d422b8e40b4": "The function `_sanitize_paragraphs` processes a `BeautifulSoup` object to clean up paragraph (`<p>`) elements. It iterates through all `<p>` tags in the provided HTML content, retrieves their text using `.get_text()`, sanitizes this text with a hypothetical `sanitize_summary` function, and then replaces the original text within each `<p>` tag with the sanitized version.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\reviewer.py:check_assistant_phrasing:686115eadf90ac61f63b536fab0471c86786a466e9790ebf01b9d5bf6ff30143": "The function `check_assistant_phrasing` takes a BeautifulSoup object and an HTML string as input. It searches for paragraphs in the HTML that contain any of the phrases listed in `ASSISTANT_PHRASES`. If a match is found, it appends the text of the paragraph along with its line number to a list of findings. The function returns this list of findings.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\reviewer.py:check_contradictions:e5754cc9422505cc786489689891a594e0c2086db8050f4bdfe7c2b7de190775": "This function `check_contradictions` analyzes an HTML document parsed with BeautifulSoup to identify contradictions between the text content and the presence of specific code elements. It returns a list of contradiction descriptions based on the following checks:\n\n1. If the summary text contains \"no methods\" but actual method headers are found.\n2. If the summary text contains \"no functions\" but actual function headers are found.\n3. If the summary text contains \"no classes\" but actual class headers are found.\n\nThe function extracts summary text from the first two paragraph tags, identifies method, function, and class headers using specific HTML tag structures, and compares these with the claims made in the summary to detect contradictions.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\reviewer.py:check_hallucinations:1a903ca03cf12b9b73e9e22b054755f0b73ecc56d2eecb07d51a42eb67b3f317": "Function `check_hallucinations` takes a BeautifulSoup object as input and returns a list of hallucination phrases detected within paragraph tags (`<p>`). It iterates through all paragraph elements, extracts their text content (stripping whitespace and converting to lowercase), and checks if any predefined hallucination terms are present. If a term is found, it is added to the findings list.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\reviewer.py:main:661c9f7991acc0ff94ef7fe6b0998b5cdb6d49a206cf06eb82749fa53c25a5f3": "The `main` function serves as the entry point for a command-line tool designed to review generated HTML documentation. It accepts an optional list of arguments (`argv`) and processes them using Python's `argparse` module. The function expects at least one argument, which is the path to the directory containing the HTML output.\n\nIt also allows for an optional flag (`--autofix`), a boolean switch that indicates whether the tool should automatically rewrite files to fix identified issues in the documentation.\n\nThe parsed arguments are then used to call the `review_directory` function, passing it the specified directory path and the value of the `autofix` flag. The `main` function returns an integer value (`0`) indicating successful execution.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\reviewer.py:review_directory:313eea30bed4807c69bf7fc20fbc073ca1b50b2b2958fdfe980bd6bd4c2fe1fd": "The `review_directory` function takes a directory path and an optional autofix flag. It recursively searches the directory for HTML files using `rglob`. For each file, it attempts to review the file content by calling `_review_file` with the file path and autofix flag. If successful, it prints each line of the results. If an exception occurs during file reading, it catches the exception, prints an error message, and continues to the next file.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\scanner.py:_is_subpath:6946a11f4b7a66ec3511ab85e9320e847410c6dc0120c8a6ece3683677933533": "Function `_is_subpath` checks whether a given `path` is either equal to or located within a specified `parent` directory. It uses the `relative_to` method of the `Path` class to determine if the `path` can be made relative to the `parent`. If successful, it returns `True`, indicating that `path` is a subpath of `parent`; otherwise, it catches the `ValueError` and returns `False`.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\scanner.py:scan_directory:67b73b56b485c75c1bf476a6ce66cda22286177af1f6fcb09e2019e60ad9ea96": "The `scan_directory` function recursively discovers Python (``.py``) and MATLAB (``.m``) files under a specified base directory while ignoring specified paths. It returns a list of absolute paths to the discovered source files, excluding those in ignored directories or matching any ignore patterns. The function uses `os.walk` to traverse the directory tree, filters out unwanted file types and paths, and collects the results in a sorted list.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_cache.py:test_cache_get_missing:f344fdf1c8d16a1679ecbaff3f33b31dadfd31076d30c98a113445a02f7a853a": "The function `test_cache_get_missing` tests the behavior of a `ResponseCache` object when attempting to retrieve a value for a key that does not exist in the cache. It creates a temporary directory, initializes a `ResponseCache` instance with a path to a JSON file within this directory, and asserts that calling `get` on a non-existent key returns `None`.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_cache.py:test_cache_round_trip:69a6ad281b658d55d2201888882932cef04997172fe5778f9624d3bc07947130": "This function tests the round-trip caching functionality of a `ResponseCache` class. It creates a temporary file to store the cache, initializes a `ResponseCache` instance with this file, sets a cache entry for a specific key (\"file.py\", \"content\") with the value \"summary\", and then reads this value back from the cache using a new `ResponseCache` instance. The test asserts that the retrieved value matches the original cached value, ensuring that the caching mechanism works correctly.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_docgenerator.py:test_generates_class_and_function_summaries:11d5681e4853ee2259be4cde44df3461807a6f878dec09f6f7ac06563beb71d7": "The function `test_generates_class_and_function_summaries` tests the generation of summaries for classes and functions in a Python project using a mock Large Language Model (LLM) client. It creates a temporary project directory with a sample Python module containing a class and a function, sets up an output directory, and mocks the LLMClient to return predefined summaries for different code elements. The function then calls the `main` function with the project directory and output location as arguments. After execution, it asserts that the generated HTML files contain the expected summaries for the class and function, as well as the module.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_docgenerator.py:test_handles_class_without_docstring:af59aa63db4da65d05830b74af241d5067fe353e11d8d480975c680395727702": "The function `test_handles_class_without_docstring` is a unit test for a documentation generation tool. It checks that the tool correctly handles Python classes without docstrings by:\n\n1. Creating a temporary project directory with a single Python file containing an empty class.\n2. Setting up a mock LLM client to simulate responses during the summarization process.\n3. Running the main function of the documentation generator with the specified project and output directories.\n4. Verifying that the exit code is 0, indicating successful execution.\n5. Reading the generated HTML file and asserting that it contains the summary for the class, which should be \"class summary\" in this case.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_docgenerator.py:test_project_summary_is_sanitized:df515075c074ed721225b06bdd172af32bbad47cff14ff70d76c43cbd76ff19f": "The function `test_project_summary_is_sanitized` is designed to test the generation of HTML documentation for a Python project using a mock Large Language Model (LLM) client. It creates a temporary project directory with a sample Python module, sets up an output directory for the generated documentation, and uses a mock LLM client to simulate responses during the summarization process. The function then asserts that the output HTML does not contain certain phrases (\"You can run this\" and \"It prints.\") while expecting others (\"module summary,\" \"project summary,\" \"function summary,\" and \"improved function doc\") to be present.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_docgenerator.py:test_readme_summary_used:a17d2fe6df9ebeb984ad93f752fdaa02bab6b82ddd2b34b51d61070aee51eb51": "The function `test_readme_summary_used` is a unit test that verifies the functionality of summarizing and reviewing Python and MATLAB code using language models. It sets up a temporary project directory with a module file (`mod.py`) and a README file, then uses a mock LLM client to simulate the generation of summaries for different components of the project. The test asserts that the README summary is included in the generated HTML documentation and that the LLM client was called correctly with the appropriate arguments.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_docgenerator.py:test_skips_invalid_python_file:d1094980a3b2d0c32e0ddbb68f9a87151806635c3d486d9a049f6dab19622d92": "The function `test_skips_invalid_python_file` tests the behavior of a documentation generation tool when encountering an invalid Python file. It creates a temporary project directory with an invalid Python file (`bad.py`) that contains syntax errors due to a leading zero in a number. The function then calls the main function of the documentation generator, passing the path to the project directory and specifying an output directory for the generated documentation.\n\nThe test uses a mock LLM client to simulate successful pinging and summarization operations. After executing the main function, it asserts that the return value is 0 (indicating success), and checks that only the index page (`index.html`) is generated in the output directory, while no documentation file for the invalid Python file (`bad.py`) is created.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_docgenerator.py:test_skips_non_utf8_file:1e770e32734b054a88edbdd760005f9f94160f7f76de1d6231e3198e993a0d4c": "The function `test_skips_non_utf8_file` tests the behavior of the `main` function when encountering a non-UTF-8 encoded Python file. It creates a temporary project directory with a non-UTF-8 file named \"bad.py\" and sets up a mock LLMClient to return a dummy summary. The function then calls `main` with the project directory and output location, expecting it to return 0 (indicating success). Finally, it asserts that an index.html file is created in the output directory but not a bad.html file, indicating that non-UTF-8 files are skipped during documentation generation.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_html_writer.py:test_write_index:ba882901588259f581699ecd0ec998c04bcba6e27f867e35093d9c6bd15ecfe1": "This function `test_write_index` is designed to test the functionality of writing an index file for a project documentation. It takes a temporary path as input and performs several assertions to ensure that the generated HTML index file contains the expected content.\n\nThe function creates a list of links and summaries, then calls the `write_index` function with these inputs along with a project summary and title. After writing the index file, it reads the contents of the `index.html` file from the temporary path.\n\nAssertions are made to check that:\n- The project title and summary are correctly encoded in HTML.\n- The links for modules are included twice each in the HTML.\n- The module names with special characters are correctly encoded.\n- The section headers \"Modules\" and \"Project Documentation\" are present.\n- Only one summary is rendered, indicating that duplicates are not included.\n- The HTML structure includes unordered lists (`<ul>`) and small tags (`<small>`).\n\nThis function ensures that the `write_index` function behaves as expected when generating documentation index files.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_html_writer.py:test_write_module_page:f9dc0568d22600a78827e4141166276e4e88e461ef3eb65c1cc853802e5a10e3": "The function `test_write_module_page` is designed to test the functionality of writing a module page for a Python or MATLAB project. It takes a temporary path as an argument and creates a mock module data dictionary containing information about classes, functions, and their summaries. The function then calls `write_module_page` with this data and the specified output directory.\n\nThe test checks if the generated HTML file contains various elements such as links to other modules, the project overview link, class and method summaries, and source code snippets. It asserts that specific strings are present in the HTML content, ensuring that the module page is correctly formatted and includes all necessary information.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_integration.py:test_docgenerator_generates_html:8a95eb03e2f81558cb841e102e214fb935bd41d316c5bf2c91eacdc5a0e6665b": "The function `test_docgenerator_generates_html` is a unit test for the `main` function of a documentation generator tool. It sets up a temporary project directory containing a simple Python file and a simple MATLAB file. The test then mocks an LLMClient to simulate successful ping and summary generation. After running the main function with the specified project and output directories, it asserts that the return value is 0 (indicating success), and verifies that HTML files for the project, its Python file, and its MATLAB file have been created in the output directory. Additionally, it checks that a specific summary string appears in the generated HTML file for the Python function.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_integration.py:test_static_copied_from_any_cwd:5dce4e1e97a8ce1d2f3af5e7621b265df12d1370c79ce05a6738dcc19762fa93": "This function tests the generation of static HTML documentation for a Python project using a mock Large Language Model (LLM) client. It creates a temporary project directory with a simple Python module, sets up an output directory, and uses the `monkeypatch` to change the current working directory to the temporary path. The function then calls the `main` function with the project directory and output location as arguments. After the call, it asserts that the return value of `main` is 0, indicating success. Finally, it checks that a static CSS file has been created in the output directory.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_llm_client.py:test_ping_failure:9ff05716a0cab15e49b24710c3997272796d47328ac05d596533068d48673cfa": "This function tests the `ping` method of an `LLMClient` class by simulating a request failure. It uses the `patch` decorator from the `unittest.mock` module to replace the `requests.get` method with a side effect that raises a `RequestException`. The test asserts that calling the `ping` method on the client object raises a `ConnectionError`.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_llm_client.py:test_ping_success:2d7681aba5dce6a98d6a16ed5e9426c30a4d3103390094bc3e4c4e12b5598e16": "This function tests the `ping` method of an `LLMClient` class by mocking its HTTP GET request and verifying that it returns `True` upon successful execution. It asserts that the `raise_for_status` method of the mock response is called once, indicating a successful status check. The test ensures that the client can successfully communicate with the LLM server without errors.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_llm_client.py:test_prompt_varies_by_type:2abbd924ded7b130acd6e553fc46f368148954bd36632d3b1078c3e0456b542c": "This function tests the `summarize` method of an `LLMClient` class to ensure that it generates different prompts based on the type of code being summarized. It uses a mock response from an LLM client and patches the `requests.post` call to return this mock response. The function then calls `summarize` with two different types (\"class\" and \"function\") and asserts that the generated prompts are as expected according to predefined templates (`PROMPT_TEMPLATES`). It also checks that the prompts for class and function summaries are not identical, confirming that the type-specific behavior is working correctly.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_llm_client.py:test_readme_prompt_template_used:59a84040d0bd255b8c7404dcd87b490811eb0e9b4103aa48f23e75863be9d736": "This function tests if the README prompt template is used correctly when summarizing a file. It creates an instance of `LLMClient`, mocks its response to simulate a successful API call, and then asserts that the generated prompt matches the expected format from `PROMPT_TEMPLATES[\"readme\"]`.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_llm_client.py:test_sanitize_summary_filters_phrases:124b9ac062ac86393640a86c4dc5057846173a47f6a96b820f447a8fc61aa4fb": "",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_llm_client.py:test_summarize_raises_runtime_error_with_message:bfd16b33bc21d867dcde4c523aae9dc15ae5eb55b5ee840a0a551589bc116627": "This function tests the `summarize` method of an `LLMClient` class. It mocks an HTTP request to a language model server that raises an exception when attempting to generate a summary. The test asserts that a `RuntimeError` is raised with the message \"server exploded\" when the `summarize` method is called with specific parameters.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_llm_client.py:test_summarize_retries_and_returns_summary:8dca373ee97f0e0de2959b9c474027d8ee207ec52e1b1f639966e9a98c1d00bb": "The function `test_summarize_retries_and_returns_summary` tests the `summarize` method of an `LLMClient` class. It sets up a mock response from an LLM server that simulates a request failure followed by a successful response. The test asserts that after two retries, the method returns the expected summary text and that it waits for 1 second between retries.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_parser_matlab.py:test_parse_multiple_functions:1060f89d0c3fb11a733b522a93eac5b9f7b2795654d48461db4370fb7c8863ad": "This function `test_parse_multiple_functions` tests the parsing of a MATLAB file containing multiple functions. It creates a temporary MATLAB file with two functions, `compute` and `square`, and then uses the `parse_matlab_file` function to parse this file. The test checks that the parsed result contains the correct number of functions, their names, and arguments.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_parser_matlab.py:test_parse_simple_matlab:9a0e25b20e4785badb3a2b7fe06c17b71e37724bdab6d5dd99cc1dd0b9664c28": "This function `test_parse_simple_matlab` tests the parsing of a simple MATLAB file using the `parse_matlab_file` function. It creates a temporary file with MATLAB code, calls the parser, and asserts that the header is correctly extracted and that one function named \"add\" with arguments \"x\" and \"y\" is identified in the parsed result.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_parser_python.py:test_parse_complex_signature:c1720163b3f5c56138a08b96ea1988363488b36a1b58bb096110728ed85ceb52": "This function tests the parsing of a complex Python function signature. It creates a temporary file with a sample Python code containing a function with various parameters and a docstring. The function `parse_python_file` is called to parse this file, and the resulting dictionary is checked for the correct signature and docstring of the function.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_parser_python.py:test_parse_simple_module:a055c316bef4ee75f9f3a254365fc37ccd213de28b23e80820fb89ed7fd9e6c0": "This function `test_parse_simple_module` tests the parsing of a simple Python module using the `parse_python_file` function. It creates a temporary file with a sample Python script containing a docstring, a class with a method, and a standalone function. The function then asserts that the parsed result contains the correct module docstring, class name, class docstring, method signature, method docstring, and source code content for both the method and the function.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_reviewer.py:_make_module:56facbe7cef1ea12c4670a7de8ce0d769f286f7d186b084b3ab87f5ddd8bf23f": "This function `_make_module` creates a temporary HTML documentation page for a Python module. It takes three parameters: `tmp_path`, which is the path to the temporary directory where the documentation will be written; `summary`, which is a string summarizing the module; and `methods`, which is an optional list of methods to include in the documentation.\n\nThe function constructs a dictionary `data` with keys for the module's name, summary, classes, and functions. If `methods` is provided, it adds a class named \"Foo\" with empty docstring and summary fields, and populates the `methods` key with the provided list of methods.\n\nIt then calls the `write_module_page` function to write the HTML documentation page to the specified temporary path using the constructed `data` dictionary and a list of tuples specifying the index file and its name. Finally, it returns the path to the generated module HTML file (`mod.html`).",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_reviewer.py:test_assistant_phrasing_detected:365eca99e5b0315b698c89a61df51004c331f619d51df652137be4be8172c1ae": "The function `test_assistant_phrasing_detected` is designed to test the detection of assistant phrasing in HTML output generated by a documentation tool. It creates a temporary Python module with specific content, runs the main function of the documentation tool on this module, and checks if the output contains both \"[ASSISTANT]\" phrasing and a reference to \"mod.html\".",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_reviewer.py:test_autofix_removes_phrasing:077b161b9a9e332ffd90479cf58c5e8150ea7ed8b700cfb51534db8d4c25e168": "This function `test_autofix_removes_phrasing` is designed to test the functionality of an autofix feature within a documentation generation tool. It creates a temporary Python module with a specific phrase (\"You can call this.\") and then runs the main function of the tool with the `--autofix` option, specifying the path to the temporary directory containing the module. After running the command, it reads the generated HTML file from the same directory and asserts that the phrase \"You can\" has been removed from the HTML content. This ensures that the autofix feature is working as expected by verifying that unwanted phrases are omitted from the final documentation output.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_reviewer.py:test_contradiction_detected:3ab95522cb6fcd5b5b17a4875b3fbfcdf262708fa7bd386b5286c34cd76f6e25": "This function `test_contradiction_detected` is designed to test the detection of contradictions within a Python project. It takes two parameters: `tmp_path`, which represents a temporary directory path, and `capsys`, which captures standard output.\n\nThe function performs the following steps:\n1. Defines a list of methods with a single method named \"bar\" that has an empty docstring and source code.\n2. Creates a module in the specified temporary path using `_make_module` function, indicating that no methods are defined.\n3. Calls the `main` function with the path to the temporary directory as an argument.\n4. Captures the standard output generated by the `main` function using `capsys.readouterr().out`.\n5. Asserts that the string \"[CONTRADICTION]\" is present in the captured output, indicating that a contradiction has been detected.\n\nThis test ensures that the system correctly identifies contradictions when no methods are defined in the project, as expected.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_reviewer.py:test_hallucination_detected:095b97edd614f0dd58774a386ced5157e7755576a46a1f2608398bcc35a08fd1": "This function `test_hallucination_detected` is designed to test for the detection of hallucinations during the summarization process of Python and MATLAB code using a local Large Language Model (LLM). It performs the following steps:\n\n1. Creates a temporary module within the specified `tmp_path` directory, with the content \"Implements tic-tac-toe features\".\n2. Invokes the `main` function with the path to the temporary module as an argument.\n3. Captures the output generated by the `main` function using `capsys`.\n4. Asserts that the string \"[HALLUCINATION]\" is present in the captured output, indicating that a hallucination has been detected during the summarization process.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_scanner.py:create_files:9e3a38f8b2ff65af491f2a1d035df1620277d3d0d09e720ddf253d7770743b8b": "This function `create_files` takes a base directory and a list of relative file paths as input. It iterates over each relative path, constructs the full path by appending it to the base directory, creates any necessary parent directories (if they don't already exist), and then writes an empty string to each file.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_scanner.py:test_scan_directory_ignore_folder:22833d18a62fe6f0ff6f972ba7347fcabdd3e9b470290e77697910cae51b807a": "This function `test_scan_directory_ignore_folder` tests the `scan_directory` function with a temporary directory containing various files and subdirectories. It creates a set of expected file paths that should be included in the scan result, excluding files in the \"ignore_me\" subdirectory. The function asserts that the actual result matches the expected set of file paths.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_scanner.py:test_scan_directory_mixed_file_types:3b5b1ffb47284e1dac66e1c89101c052fd6e0141ef421ad4c6ce7d5c29a824fc": "The function `test_scan_directory_mixed_file_types` is designed to test the functionality of scanning a directory for Python and MATLAB files. It creates a temporary directory with various file types, including Python (`one.py`, `four.py`), MATLAB (`two.m`, `six.m`), and non-code files (`three.txt`). The function then calls `scan_directory` with the path to this temporary directory and an empty list of excluded extensions. The expected result is a set of paths to the Python and MATLAB files, excluding any non-code files or nested directories containing non-code files. The test asserts that the actual result matches the expected set of file paths.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_scanner.py:test_scan_directory_skips_git_folder:e3207059adc82c60985c68bc0a4cb6356917fb942d5274c8a9849da8cd3ec05f": "The function `test_scan_directory_skips_git_folder` tests the behavior of a directory scanning function when it encounters a `.git` folder. It creates a temporary directory with files, including one inside a `.git` subdirectory, and then calls `scan_directory` to get a list of file paths. The test asserts that the path to the \"good.py\" file is included in the result, while paths containing \".git\" are excluded."
}