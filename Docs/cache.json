{
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\cache.py:ResponseCache:06df9210eda5d038d82b9b595f4fe1d80293675f14635a1113ebb8b2837f5004:06df9210eda5d038d82b9b595f4fe1d80293675f14635a1113ebb8b2837f5004": "The `ResponseCache` class provides a caching mechanism for storing and retrieving response data, using file paths and content hashes to generate unique keys. It supports progress tracking by maintaining a mapping of processed module paths and their associated information, allowing documentation generation to be resumed from where it left off. The class ensures data persistence by serializing the cache to disk in JSON format whenever changes are made.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\cache.py:ResponseCache:__init__:283588304f15e4b8f02e0474286ba4c1200ccede12e8640bd9d91f3295183773:283588304f15e4b8f02e0474286ba4c1200ccede12e8640bd9d91f3295183773": "Initializes an object with a file path, loads JSON data from the file if it exists, handles JSON decoding errors by setting empty data, and ensures a progress tracking dictionary exists in the data structure.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\cache.py:ResponseCache:_save:d6c96e0258c810e9fec48856af580533cfc0aa8f13ea666bb1d396aa4abe5e41:d6c96e0258c810e9fec48856af580533cfc0aa8f13ea666bb1d396aa4abe5e41": "The function writes serialized JSON data to a file. It converts the object's `_data` attribute into a JSON formatted string with indentation and sorted keys, then saves it to the file using UTF-8 encoding.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\cache.py:ResponseCache:clear_progress:4afabd3c72dd7481e402d4d9e731329ea3d6f3c362d796a37005901574f205f9:4afabd3c72dd7481e402d4d9e731329ea3d6f3c362d796a37005901574f205f9": "Function clears all saved progress information by resetting the \"__progress__\" key in internal data storage and persisting the change.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\cache.py:ResponseCache:get:eeb84b4591575a8ed2767f4abac56f1f2dd0697e81322599734b8b31e94ddcce:eeb84b4591575a8ed2767f4abac56f1f2dd0697e81322599734b8b31e94ddcce": "The function retrieves a cached value associated with the specified key from an internal data store. It takes a string key as input and returns the corresponding value if it exists, or None if the key is not found. The implementation delegates to a dictionary-like object's get method to perform the lookup operation.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\cache.py:ResponseCache:get_progress:39ba9bd1b428ced00430a3d9e89153d2e8ee91f6f6623d13eafd158f4de0b69a:39ba9bd1b428ced00430a3d9e89153d2e8ee91f6f6623d13eafd158f4de0b69a": "The function retrieves and returns a shallow copy of the progress data stored in the object's internal data structure. It accesses the \"__progress__\" key from the internal \"_data\" dictionary and returns a new dictionary containing the same key-value pairs, preventing external modification of the original progress data.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\cache.py:ResponseCache:make_key:4f63c9f618b20a79035ed49cae07b9b800a46f352498e23dc8700f47c38fe96d:4f63c9f618b20a79035ed49cae07b9b800a46f352498e23dc8700f47c38fe96d": "Function that generates a deterministic key by combining a file path with a SHA-256 hash of the file's content. The key is formatted as \"file_path:digest\" where digest is the hexadecimal representation of the hash.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\cache.py:ResponseCache:set:0bc8af7637662ae14e3eca8604a4d7155ff442d423955a243d6b586ffee8d8ba:0bc8af7637662ae14e3eca8604a4d7155ff442d423955a243d6b586ffee8d8ba": "Stores a string value under a specified key in memory and immediately persists the data to disk.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\cache.py:ResponseCache:set_progress_entry:5213bc08e476bb362c55f096cf9227f60da37d1862f66ae21b376f8dbf55a79f:5213bc08e476bb362c55f096cf9227f60da37d1862f66ae21b376f8dbf55a79f": "Records module data for a specified path in the progress map and saves the updated data.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\cache.py:__init__:27035d77b17a485e9438ce93264789cafd5cf44e8a7617b40527f3d1aff51347:27035d77b17a485e9438ce93264789cafd5cf44e8a7617b40527f3d1aff51347": "Initializes the ResponseCache instance by loading cached data from a specified file path. If the file exists and contains valid JSON data, it loads the data into the `_data` attribute; otherwise, it initializes an empty dictionary. Ensures that a `__progress__` key exists in the data to track progress.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\cache.py:__init__:65e99db4e0154f5162844567b3b5898687f3c5ba589620bb23bbf1c373488d26:65e99db4e0154f5162844567b3b5898687f3c5ba589620bb23bbf1c373488d26": "Initializes a ResponseCache instance by loading data from a JSON file at the specified path. Creates an empty dictionary if the file doesn't exist or contains invalid JSON. Ensures a \"__progress__\" key exists in the loaded data.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\cache.py:_save:a2df77d674fbd042d8e9c130d7c1a0b4fa99e84e12ae946948d9f840202dc04a:a2df77d674fbd042d8e9c130d7c1a0b4fa99e84e12ae946948d9f840202dc04a": "The `_save` method serializes the cached response data stored in `self._data` to a JSON format with indentation and sorted keys, then writes this data to a file specified by `self.file`. The method uses UTF-8 encoding for the file write operation.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\cache.py:_save:a4eecf31e5f2864aee9beffa4464f1a9670bb45ec458d49b845aadd4a672d4d5:a4eecf31e5f2864aee9beffa4464f1a9670bb45ec458d49b845aadd4a672d4d5": "The `_save` method in the `ResponseCache` class serializes the cached data stored in `self._data` to a JSON format and writes it to a file specified by `self.file`. The JSON output is formatted with an indentation of two spaces and keys are sorted alphabetically. The file is written using UTF-8 encoding. This method persists the cache data to disk.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\cache.py:b7996266039c2634cf466bed532ccc6ffe7e701fec85156374b5bb40d1ebd2f5:b7996266039c2634cf466bed532ccc6ffe7e701fec85156374b5bb40d1ebd2f5": "The module implements a disk-based cache for storing and retrieving Large Language Model (LLM) responses. It provides functionality to save and load cached data from a JSON file, using deterministic keys derived from file paths and content hashes. The cache supports storing individual response entries and tracking progress of processed modules. The implementation ensures data persistence by writing changes to disk upon modification.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\cache.py:clear_progress:08ae01ebb420092ca063007df5aea24152cb241a7b0b8edc72aea3e9e394d92c:08ae01ebb420092ca063007df5aea24152cb241a7b0b8edc72aea3e9e394d92c": "The `clear_progress` method removes all saved progress information by resetting the `\"__progress__\"` key in the internal data dictionary to an empty dictionary, then saves the updated state.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\cache.py:clear_progress:a29c32a93a66463da7daaa6e77d580c9d5067f7b0ed9e68f44ba217bc443a2b9:a29c32a93a66463da7daaa6e77d580c9d5067f7b0ed9e68f44ba217bc443a2b9": "The `clear_progress` method removes all saved progress information by resetting the \"__progress__\" key in the internal data dictionary to an empty dictionary, then saves the updated data.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\cache.py:get:ba2551f915aeffa334341b44e9c94784caea65ed774339df7eaf1fc7245bb1f5:ba2551f915aeffa334341b44e9c94784caea65ed774339df7eaf1fc7245bb1f5": "The `get` method retrieves a cached value associated with the specified key from the `_data` storage. It returns the value if the key exists, or None if the key is not present. The method accepts a string key and returns an optional string value.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\cache.py:get:d83f22accabd69717124cee515163e2d98a80268d8cd75b5a405f9e8d65c1f23:d83f22accabd69717124cee515163e2d98a80268d8cd75b5a405f9e8d65c1f23": "The `get` method retrieves a cached value associated with the specified key from the internal data storage of the `ResponseCache` class. It takes a string key as input and returns the corresponding cached value if it exists, or None if the key is not found. The method accesses the cached data through the `_data` attribute using the standard dictionary `get` method.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\cache.py:get_progress:169a263d41b452941ae962fa071bcd163e974f57d5cbf7647c29f5a1160c786e:169a263d41b452941ae962fa071bcd163e974f57d5cbf7647c29f5a1160c786e": "The function `get_progress` retrieves and returns a shallow copy of the progress tracking data stored in the `_data` attribute of the `ResponseCache` class. The progress data maps processed module paths to their corresponding information. By returning a copy, the function prevents external modifications to the internal progress mapping.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\cache.py:get_progress:7fcc4a0b6edaca23a4505c81e1855c0238456d6c55ea38ce3fea22db19b5a1aa:7fcc4a0b6edaca23a4505c81e1855c0238456d6c55ea38ce3fea22db19b5a1aa": "Returns a shallow copy of the progress data mapping from processed module paths to their associated data. The progress data is retrieved from the internal `_data` dictionary using the key \"__progress__\". This ensures that external modifications to the returned dictionary do not affect the internal state of the ResponseCache instance.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\cache.py:make_key:1f593e8984573caf6e9db1a32bad2683b02c2ff19e073a331d96f7495d50aabd:1f593e8984573caf6e9db1a32bad2683b02c2ff19e073a331d96f7495d50aabd": "The function `make_key` generates a deterministic cache key by combining a file path with a SHA-256 hash of the file's content. It takes two parameters: `file_path` (a string representing the path to a file) and `content` (a string containing the file's content). The function encodes the content as UTF-8, computes its SHA-256 hash, and returns a string formatted as \"{file_path}:{digest}\", where digest is the hexadecimal representation of the hash. This ensures that the same file path and content combination will always produce the same key, enabling consistent cache lookups.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\cache.py:make_key:da2d3fbb013ae3c4d7ed4a2ee607c79c6c6525c1e6d7c94c2580f77adc7fea35:da2d3fbb013ae3c4d7ed4a2ee607c79c6c6525c1e6d7c94c2580f77adc7fea35": "The function `make_key` generates a deterministic key for a given file path and content by creating a SHA-256 hash of the content encoded in UTF-8 and concatenating it with the file path, separated by a colon. This key can be used to uniquely identify a specific file and its content combination.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\cache.py:set:dc48ab50d861ca4e69ad9febae8706fb8bc8bd668bd38d278e666fe595ed6344:dc48ab50d861ca4e69ad9febae8706fb8bc8bd668bd38d278e666fe595ed6344": "The `set` method in the `ResponseCache` class stores a string value under a specified key in an internal data structure and immediately persists this data to disk. The method takes two parameters: `key` (a string identifier) and `value` (a string value to be stored). After storing the value, it calls the `_save()` method to ensure the data is written to disk.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\cache.py:set:ff82763ae925b6c4225c75e7586458b4704ca83db1b771fa7b90c2804419741d:ff82763ae925b6c4225c75e7586458b4704ca83db1b771fa7b90c2804419741d": "Stores a string value under a specified key in the cache and persists the updated cache data to disk.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\cache.py:set_progress_entry:18ee10626740a9d7bf29e77e0640a07c3d138e1deb592be6f9d39ed460b3b0e5:18ee10626740a9d7bf29e77e0640a07c3d138e1deb592be6f9d39ed460b3b0e5": "Records module data for a given path in the progress map and saves the cache.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\cache.py:set_progress_entry:84fc8c910ff18ccc0e3a8ad39d102e990120c005d2396731fcd25c5e21827d23:84fc8c910ff18ccc0e3a8ad39d102e990120c005d2396731fcd25c5e21827d23": "Records module data for a specified path in the progress map and saves the updated data.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\chunk_utils.py:9148eb950a26929210792751150dea2da5c0a8399b370e1ed539eb2faeed37b0:9148eb950a26929210792751150dea2da5c0a8399b370e1ed539eb2faeed37b0": "The module provides utilities for splitting text into chunks based on natural boundaries like blank lines, Markdown headings, and code fences. It includes functions to estimate token counts using the `tiktoken` library, with a fallback to a simple space-based tokenizer if `tiktoken` is unavailable. The main function `chunk_text` splits input text into segments approximately matching a specified token size, preserving structural elements of the text. When a single block exceeds the token limit, it falls back to character-based splitting to ensure all content is included. Helper functions manage the identification of text blocks and handle the fallback splitting logic for oversized sections.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\chunk_utils.py:_Simple:11aadc4a5209958fb7da6e03034e51918d221e582ba6734e541c8a3f0aab7cd8:11aadc4a5209958fb7da6e03034e51918d221e582ba6734e541c8a3f0aab7cd8": "The `_Simple` class provides basic text encoding and decoding functionality for processing input strings and token lists. The `encode` method strips FIM tokens from a string and splits it into words, while the `decode` method joins a list of tokens into a single string. This class serves as a simple utility for handling text transformations within the documentation generation process.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\chunk_utils.py:_Simple:decode:0063ff559a778604c0b04e065f2daad212b42862c65cdd97a4fe338261b13bd3:0063ff559a778604c0b04e065f2daad212b42862c65cdd97a4fe338261b13bd3": "This function takes a sequence of tokens as input and returns a single string formed by joining the tokens with spaces. The function does not perform any decoding of encoded data or transformation of token representations. It simply combines the provided tokens into a space-separated string.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\chunk_utils.py:_Simple:encode:aa827c73b9b4f1291471e35dcaad0a352e62db69ae2c71f3c7bf8ac77bf42653:aa827c73b9b4f1291471e35dcaad0a352e62db69ae2c71f3c7bf8ac77bf42653": "The function takes a string input, removes FIM tokens from it using a helper function, and splits the resulting string into a list of words based on whitespace separation.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\chunk_utils.py:_split_blocks:ec9299b93d46a020b2cc0a7cef2486893d2eb6ceda3b6c194920c423670c170c:ec9299b93d46a020b2cc0a7cef2486893d2eb6ceda3b6c194920c423670c170c": "The function `_split_blocks` takes a Markdown-formatted text string and splits it into distinct blocks, separating paragraphs, headings, and code fences. It processes the input line by line, tracking whether it is inside a code block (indicated by triple backticks) and appending lines accordingly. When encountering a new heading (line starting with `#`) or an empty line, it finalizes the current block and starts a new one. The result is a list of strings, each representing a distinct block of content from the input text.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\chunk_utils.py:_split_long_block:7a0c3fdafa12c53272f6288f6a32a9fb8d9b549e348037c1dfa060952c7aaa5f:7a0c3fdafa12c53272f6288f6a32a9fb8d9b549e348037c1dfa060952c7aaa5f": "The function `_split_long_block` splits a text block into smaller chunks based on a token limit using a character-based approximation when the token count exceeds the specified chunk size. It encodes the input block using a provided tokenizer, calculates an average character length per token, determines the maximum number of characters per chunk, and then divides the block into segments of that size. If the block's token count is less than or equal to the chunk size, it returns the block as a single-element list. The function handles edge cases where tokenization might result in zero-length averages by ensuring minimum values are used.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\chunk_utils.py:chunk_text:e43092d275e04d9bb261169256a5b630bbe8f04d625a2b3f196d6767f0dd9dd1:e43092d275e04d9bb261169256a5b630bbe8f04d625a2b3f196d6767f0dd9dd1": "The function `chunk_text` divides a given text into smaller segments, where each segment contains approximately a specified number of tokens. It processes the text by identifying natural breakpoints such as blank lines, Markdown headings, and code blocks to preserve structure. If a block exceeds the token limit, it is further split based on character length. The function utilizes a provided tokenizer to calculate token counts and returns a list of text chunks that adhere to the specified token size constraint.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\chunk_utils.py:decode:dfe3c45e00285657a26567649cbda742a89530f187b781c27a447f8b424a655a:dfe3c45e00285657a26567649cbda742a89530f187b781c27a447f8b424a655a": "The function `decode` takes a list of tokens as input and returns a single string formed by joining the tokens with spaces. It is a method of the class `_Simple`.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\chunk_utils.py:encode:fd5f20421f99b82f38afbcf6774bf03a2ec2a3c9112e3304052003e7d2e12970:fd5f20421f99b82f38afbcf6774bf03a2ec2a3c9112e3304052003e7d2e12970": "The function `encode` takes a string input `text`, removes FIM (Fix, Improve, Modify) tokens from it using the `strip_fim_tokens` utility, and then splits the resulting string into a list of words based on whitespace separation. The output is a list of strings where each string represents a word from the processed input text.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\chunk_utils.py:get_tokenizer:9e7d9bbca5a8e30518ebce42b12cda72541d33dd8647996df8c0a3cfec64c64c:9e7d9bbca5a8e30518ebce42b12cda72541d33dd8647996df8c0a3cfec64c64c": "The function `get_tokenizer()` returns a tokenizer object for estimating token counts. It attempts to use the `tiktoken` library to load the `cl100k_base` encoding, with fallback to `gpt-3.5-turbo` if the former fails. To prevent network-related warnings during encoding loading, it temporarily suppresses unraisable exception hooks. If `tiktoken` is unavailable or fails to load, it provides a simple fallback tokenizer that splits text into tokens by whitespace and joins them back with spaces. A warning message is printed to `stderr` if `tiktoken` is not available. The returned tokenizer supports `encode` and `decode` methods, with `encode` stripping FIM tokens before processing.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\chunk_utils.py:strip_fim_tokens:086173eee8f977f3a2005c7b05bc04e4fc148b05268c1d1f58c93d254325a2b9:086173eee8f977f3a2005c7b05bc04e4fc148b05268c1d1f58c93d254325a2b9": "The function `strip_fim_tokens` removes FIM (Fill-In-Middle) special tokens from the input string `text`. It uses a regular expression `FIM_RE` to identify and substitute these tokens with empty strings, effectively stripping them from the text. The function returns the modified string with the tokens removed.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\docgenerator.py:790e84c9f06963fa4a190b32761e9ec794933f749bba99c58330687b57f958c9:merge0:3f34c435b70df1db7d2cc6b2b3a8a5bc065e64a5adc3460954b282da3c1f8601": "This module implements a command-line interface for generating HTML documentation from source code using language models, supporting Python, MATLAB, C++, and Java file types. It processes source files by parsing their structure, summarizing content through recursive LLM interactions, and producing structured HTML output with an index page and individual module pages. The implementation includes functions for cleaning output directories, caching LLM responses to avoid redundant processing, chunking module structures for efficient processing, and recursively summarizing classes and their members. It builds context-aware prompts for function summarization, rewrites docstrings using LLMs, and handles token budgeting for LLM interactions while including error handling for network failures and processing issues. The system supports resuming previous runs and clearing progress after successful execution, with command-line argument parsing for configuration management.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\docgenerator.py:790e84c9f06963fa4a190b32761e9ec794933f749bba99c58330687b57f958c9:part0:6f455d4018be53ca6673dae7ee8ef8ea25ac236aa3f05027ef856efdd324c009": "Module implements a command-line interface for generating HTML documentation from source code using LLMs. It processes Python, MATLAB, C++, and Java files by parsing their structure, summarizing content with LLMs, and producing HTML output. The implementation includes functions for cleaning existing output directories, caching LLM responses, chunking module structures for processing, summarizing modules with recursive merging of partial results, building context-aware prompts for function summarization, rewriting docstrings with LLMs, and recursively processing functions and class members. The system handles token budgeting for LLM interactions and includes error handling for network failures and processing issues.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\docgenerator.py:790e84c9f06963fa4a190b32761e9ec794933f749bba99c58330687b57f958c9:part1:2525e47e8dcb5b6e66d4b57e251aaa6fe5dc924d2317c8b1b62328461a5d13f9": "The module defines functions for generating HTML documentation using a local language model. It includes recursive summarization of classes and their members, handling of various source file types, caching of LLM responses, and command-line argument parsing for configuration. The main function processes source files, summarizes modules and their contents, and writes output files including an index and individual module pages. It supports resuming previous runs and clearing progress after successful execution.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\docgenerator.py:_build_function_prompt:e848503120386a83ccdf2cb40d2540565060f6acdb19bf9d23ea322dda3fe668:e848503120386a83ccdf2cb40d2540565060f6acdb19bf9d23ea322dda3fe668": "The function `_build_function_prompt` generates a context-enriched prompt for summarizing a given function's source code. It accepts the function's source code and optional class and project context details, then constructs a structured prompt string that includes information about the function's class and project, along with instructions for generating a summary. The resulting prompt is formatted for use in an automated documentation generation system, ensuring that the summary adheres to specific formatting and content guidelines.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\docgenerator.py:_chunk_module_by_structure:5a07ede6044b82e9b91695e5fad9a92d4b61930c472d901bd377f2f5eb868440:5a07ede6044b82e9b91695e5fad9a92d4b61930c472d901bd377f2f5eb868440": "The function `_chunk_module_by_structure` takes a parsed module dictionary, a tokenizer, and a maximum chunk size in tokens, and returns a list of text chunks derived from the module's structure. It processes the module's docstring, classes (including their methods and variables), and functions, organizing their source code into blocks. Each block is checked against the token limit; if it exceeds the limit, it is further chunked using the `chunk_text` utility. Blocks are aggregated into chunks based on the token limit, ensuring that no individual chunk exceeds the specified size. The function handles tokenization and separation between blocks using double newlines. The final list of text chunks is returned for use in documentation generation.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\docgenerator.py:_insert:9975ae5f72ed4d828992f3a94284a8fdf345cf5cb19a542a412df016c4fea6fc:9975ae5f72ed4d828992f3a94284a8fdf345cf5cb19a542a412df016c4fea6fc": "The function `_insert` recursively inserts a file entry into a nested dictionary structure representing a directory tree. It takes a dictionary `tree`, a list of path parts `parts`, a file name `name`, and a file link `link`. If `parts` is empty, it appends the file tuple `(name, link)` to the `__files__` key in the current tree node. Otherwise, it processes the first part of the path, creates or retrieves the corresponding subtree, and recursively inserts the remaining parts. This enables building a hierarchical representation of files organized by directory structure.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\docgenerator.py:_merge_recursive:7dadb8794d39cccd033e5047725a6e5eaab17ddd3c9a74091adc034c00fcc6a6:7dadb8794d39cccd033e5047725a6e5eaab17ddd3c9a74091adc034c00fcc6a6": "The function `_merge_recursive` is a recursive helper function designed to merge a list of documentation strings into a single consolidated string. It takes a list of strings (`items`) and an optional depth parameter for recursion tracking. The function constructs a prompt by joining the items with bullet points and checks if the total token count fits within the specified `available_tokens`. If it does, it summarizes the prompt using a client-side summarization function with caching. If not, it attempts to split the items into groups that fit within the token limit and recursively merges those groups. When only one item remains, it processes that item directly using a chunked summarization method. The recursion continues until all items are merged into a single output string.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\docgenerator.py:_rewrite_docstring:72f9f26a43331f5d2d8a9bcac4b3cae56a613513985afa48f4bebe65a75385b9:72f9f26a43331f5d2d8a9bcac4b3cae56a613513985afa48f4bebe65a75385b9": "The function `_rewrite_docstring` updates the docstring of a code item by rewriting it using an LLM, with optional contextual information. It takes an LLM client, cache, file path, and item dictionary as inputs, and optionally accepts class name, class summary, and project summary for context. If no source or docstring is present, it issues a warning and returns early. If only a docstring exists, it returns without modification. Otherwise, it constructs a prompt based on the presence of contextual information, generates a cache key, and uses `_summarize_chunked` to obtain a rewritten docstring from the LLM. The resulting docstring is sanitized and stored back in the item dictionary.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\docgenerator.py:_summarize:9bea64ef4cc5e4ca9f9efe3b30d0717e3095462f0dd61d4e7b67948fb54a6375:9bea64ef4cc5e4ca9f9efe3b30d0717e3095462f0dd61d4e7b67948fb54a6375": "The function `_summarize` takes an LLM client, a response cache, a key, text to summarize, and a prompt type. It first checks if a cached response exists for the given key. If so, it returns the cached response after sanitizing it to prevent tokenizer errors. If no cached response is found, it generates a new summary using the LLM client, stores the result in the cache, and then returns the generated summary.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\docgenerator.py:_summarize_class_recursive:09c0bbff5a2d7e0802d9f3733e1bf3eb00b9058a89c09dcf7a5b7f96336c86e0:09c0bbff5a2d7e0802d9f3733e1bf3eb00b9058a89c09dcf7a5b7f96336c86e0": "The function `_summarize_class_recursive` recursively summarizes a class and its members, including methods and variables, by generating documentation summaries using an LLM. It processes the class data to extract method and variable information, constructs prompts for summarization, and utilizes caching to avoid redundant processing. The function updates the class's docstring and summary fields with the generated content, and applies rewriting logic to individual methods and variables. Additionally, it recursively handles subclasses by calling itself on each subclass in the class data structure.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\docgenerator.py:_summarize_function_recursive:5edd2c934bd7ebd9e778e92acdc36576e9c93b64714d3bb11292e7bff0aaee71:5edd2c934bd7ebd9e778e92acdc36576e9c93b64714d3bb11292e7bff0aaee71": "The function `_summarize_function_recursive` recursively summarizes a given function and its nested subfunctions and subclasses. It takes a dictionary representation of a function, along with contextual information such as class and project summaries, and uses an LLM client to generate a summary. The function builds a prompt based on the source code or signature of the function, caches the response, and processes the function's content in chunks if necessary. If the `rewrite` flag is enabled, it also rewrites the function's docstring. After summarizing the function itself, it recursively calls itself for each subfunction and invokes `_summarize_class_recursive` for each subclass. The function modifies the input `func` dictionary by adding a \"summary\" field and potentially updating the docstring.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\docgenerator.py:_summarize_members_recursive:9724fa09c31ab24002abe7af178233ea727cddd829ef96aea334a70e263037d2:9724fa09c31ab24002abe7af178233ea727cddd829ef96aea334a70e263037d2": "The function `_summarize_members_recursive` recursively summarizes the methods and variables of a given class and its subclasses. For each method, it retrieves or constructs the source code, generates a cache key, and uses `_summarize_chunked` to produce a summary. The resulting summary is stored in the method's data under the keys \"summary\" and \"docstring\". It then calls `_summarize_function_recursive` to further process the method. Similarly, for each variable, it generates a summary and stores it in the variable's data. Finally, it recursively processes any subclasses present in the class data. The function operates with progress tracking using `tqdm` and utilizes an LLM client, response cache, tokenizer, and token budget settings for processing.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\docgenerator.py:_summarize_module_chunked:9c6562963f3662e377eee5e8ca0e7066cbc98ef01aa2eaa0d20e9b10d2e2a06b:9c6562963f3662e377eee5e8ca0e7066cbc98ef01aa2eaa0d20e9b10d2e2a06b": "The function `_summarize_module_chunked` summarizes a module by using structure-aware chunking to manage token limits for LLM processing. It first checks if the entire module text fits within the available token budget; if so, it summarizes the full text directly. Otherwise, it chunks the module based on its structure and summarizes each chunk separately. The partial summaries are then recursively merged into a single summary, ensuring that token limits are respected at each step. If any step fails, it falls back to summarizing the full module or returns a sanitized summary of partial results. The function uses a caching mechanism to avoid reprocessing identical inputs and integrates with a tokenizer to manage token counts. It supports progressive logging of chunk processing and handles exceptions gracefully by printing warnings and returning sanitized outputs.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\docgenerator.py:clean_output_dir:7e692cc645bd809723a0b10c5df12a7f8e41481afcf8b91f6479176c47601905:7e692cc645bd809723a0b10c5df12a7f8e41481afcf8b91f6479176c47601905": "The function `clean_output_dir` removes HTML files from a specified output directory if they were generated by DocGen-LM. It iterates through all files in the directory, checks if a file ends with \".html\", and reads the first line of the file. If the first line contains the string \"Generated by DocGen-LM\", the file is deleted. Any errors encountered during file checking or removal are caught and printed as warnings.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\docgenerator.py:main:1da022d26b118ee79b0594dfabedc71e241799560d428dbe14f8d500bd68f114:1da022d26b118ee79b0594dfabedc71e241799560d428dbe14f8d500bd68f114": "The `main` function serves as the primary entry point for generating HTML documentation from source code using a local LLM. It accepts command-line arguments to configure the source directory, output destination, LLM API endpoint, and processing options such as token limits and resume behavior. The function initializes an LLM client, validates connectivity, and sets up tokenization and chunking parameters for processing.\n\nIt scans the source directory for supported files (Python, C++, Java, MATLAB), parses them into structured data, and summarizes each module using chunked processing to manage token limits. Progress is tracked via a cache, enabling resumable documentation generation. Class and function members are recursively summarized with project context, and markdown documentation from README and docs directories is incorporated.\n\nThe function builds a navigation tree from the processed modules, generates a project outline, and creates an index page and individual module pages in HTML format. It also sanitizes summaries and writes them to the output directory, clearing progress if specified. The function returns an integer exit code indicating success or failure.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:5c43aa85822144159cdb19689df89d86e6e5d4d653e2c12166248aeee5cd442a:merge0:96aceb6a37f822b7b391613b8f75a814ab52224cf21dc9c7a3c7c4018ea54e30": "The module provides functionality for generating project documentation summaries by processing documentation and code files through a series of defined steps. It includes configuration handling, file collection from specified paths, and text extraction from various document formats. The system supports section mapping based on keywords, code file ranking using heuristics, and utilities for inserting navigation links into HTML index files. Key functions scan code files to extract relevant content such as docstrings, function signatures, CLI parsers, and main blocks, organizing them by manual sections. These snippets are used to generate documentation via LLMs, with support for filling placeholder tokens in text using extracted code information. The module also offers capabilities for rendering HTML from structured sections, parsing manual content into sections, validating file references, inferring section structure from plain text, and generating PDFs from HTML. A main orchestration function accepts command-line arguments to configure processing parameters, collect and read documentation files, process them using an LLM client with caching, and attempt multiple passes to generate a manual. In case of LLM failure, it falls back to inferring sections from combined text, ultimately rendering output as HTML or PDF and optionally inserting it into an index file while saving evidence maps separately.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:5c43aa85822144159cdb19689df89d86e6e5d4d653e2c12166248aeee5cd442a:part0:cad03170c79ae4f0d1d2f36c57f3909c62a26464f20a175abadc08436cee8417": "The module defines functionality for generating project summaries from documentation and code files. It includes configuration handling, file collection from specified paths, text extraction from various document formats, section mapping based on keywords, and ranking of code files using heuristics. The module also provides utilities for inserting navigation links into HTML index files and detecting placeholder tokens in text. Key components are classes and functions for processing documentation and code to produce structured summaries.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:5c43aa85822144159cdb19689df89d86e6e5d4d653e2c12166248aeee5cd442a:part1:1d7f8b24a1310f8f2ff2b36d1a1e2d3af8011bf41c2706426d0f025a6d5852db": "The module defines functions for extracting code snippets from files, organizing them by manual sections, and generating documentation using LLMs. It includes logic to scan code files, parse Python syntax, and identify relevant content such as docstrings, function signatures, CLI parsers, and main blocks. The `scan_code` function collects and categorizes these snippets based on section keywords. The `llm_generate_manual` function uses LLMs to create a manual from documentation snippets, handling both inferred and provided content. The `llm_fill_placeholders` function updates the manual by replacing placeholder tokens with information extracted from code snippets. A helper function `_edit_chunks_in_editor` allows users to modify content in an external editor before processing.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:5c43aa85822144159cdb19689df89d86e6e5d4d653e2c12166248aeee5cd442a:part2:728ef003d9b9cf619f2797bd3f130e29e504e38c3a5e8a9633d300640b8df8a4": "The module defines functions for rendering HTML from structured sections, parsing manual content into sections, validating file references within those sections, inferring section structure from plain text, and generating PDFs from HTML. The `render_html` function constructs an HTML document with navigation and styled content, incorporating evidence snippets when sections are empty. The `parse_manual` function splits input text into sections based on colon-separated headings and fills missing required sections using a language model if enabled. The `validate_manual_references` function checks for missing file references in section content and annotates them. The `infer_sections` function creates a basic section structure from plain text when structured parsing fails. The `write_pdf` function converts HTML to a PDF using a canvas library.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:5c43aa85822144159cdb19689df89d86e6e5d4d653e2c12166248aeee5cd442a:part3:a9277aadc6312b031707b1eddb8a882d73e638ba5c39005838093b1f6829288b": "The module defines a function `main` that orchestrates the generation of project documentation summaries. It accepts command-line arguments for specifying the target directory, output format (HTML or PDF), output destination, title, and various options related to code scanning and chunking. The function configures processing parameters based on these inputs, collects and reads documentation files, and processes them using an LLM client with caching. It attempts to generate a manual through multiple passes, including filling placeholders with code context if needed. If LLM processing fails, it falls back to inferring sections from the combined text. The final output is rendered as HTML or PDF, optionally inserted into an index file, and evidence maps are saved separately.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:Config:fbb0e2afc1dfa011a20c3e5f9ba896ca98e5d0fae45f98cdd1b68aa85328dded:fbb0e2afc1dfa011a20c3e5f9ba896ca98e5d0fae45f98cdd1b68aa85328dded": "The `Config` class serves as a configuration handler for the DocGen-LM documentation generation tool, managing settings and parameters needed for processing source code across multiple programming languages including Python, MATLAB, C++, and Java. It supports features such as automatic progress saving, resumable documentation generation, and integration with LMStudio as the backend LLM server. The class facilitates the generation of static HTML documentation with support for nested structures like functions and subclasses while providing options for customizable output formats and project summaries.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:_edit_chunks_in_editor:c170e94e36b6fd5d9495dfaebb99e2311a07c52752cf31fa809d55bc2c2f0a02:c170e94e36b6fd5d9495dfaebb99e2311a07c52752cf31fa809d55bc2c2f0a02": "The function `_edit_chunks_in_editor` takes a list of strings (`chunks`) and opens them in a user's preferred text editor for modification. The chunks are joined with a separator line (`---`) and written to a temporary file. After the user edits and saves the file, the function reads the updated content, splits it back into chunks using the same separator, and returns a list of non-empty, stripped chunks. The editor used is determined by environment variables `EDITOR` or `VISUAL`, defaulting to `vi` if neither is set. Temporary files are automatically deleted after use.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:_slugify:53d7061658c2546bb6c3b89d7e44e2cf29986a56d8a94709f673ea6e9a715ee8:53d7061658c2546bb6c3b89d7e44e2cf29986a56d8a94709f673ea6e9a715ee8": "The function `_slugify` takes a string input and converts it to a URL-friendly slug format. It replaces all non-alphanumeric characters with hyphens, converts the text to lowercase, and removes any leading or trailing hyphens from the result.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:collect_docs:d741338c13555da1dee0e79952bf52bf1e05894942dc2aa878c3c606c2f70474:d741338c13555da1dee0e79952bf52bf1e05894942dc2aa878c3c606c2f70474": "The function `collect_docs` gathers documentation files located under a specified base directory. It identifies files matching certain patterns in two locations: the project root and a nested `docs` directory. Specifically, it collects files with extensions `.md`, `.txt`, `.html`, and `.docx` in the root, and recursively finds `.html` and `.md` files within the `docs` subdirectory. The function ensures that each file is included only once by tracking seen paths and returns a list of unique documentation file paths.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:collect_files:3e684c8a24a847c73ceee9fcbc331b98307c3808ce361139876a9167501433ed:3e684c8a24a847c73ceee9fcbc331b98307c3808ce361139876a9167501433ed": "The function `collect_files` takes a base directory path and an optional iterable of additional file patterns, then returns an iterable of file paths relevant for summarization. It first defines a list of default file patterns including README.md, text files, HTML files, DOCX files, CSV files, and JSON files. It collects all files matching these patterns recursively from the base directory. If additional patterns are provided, it extends the collection with files matching those patterns as well. The function ensures that each file path appears only once in the result by tracking seen paths, returning a list of unique file paths.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:detect_placeholders:0e5d68781a1baf3ece7c75d096931146750fddfb95514a04bf9216ca144d61f1:0e5d68781a1baf3ece7c75d096931146750fddfb95514a04bf9216ca144d61f1": "The function `detect_placeholders` takes a string input `text` and returns a list of section names that are still marked by placeholder tokens. It first identifies all placeholders present in the input text using the helper function `find_placeholders`, then filters and returns the names of sections from `SECTION_PLACEHOLDERS` whose corresponding tokens are found in the text.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:extract_snippets:8e68973fd57938f159d08cfb5028833a1858da96f819bee33297e568a0d48c05:8e68973fd57938f159d08cfb5028833a1858da96f819bee33297e568a0d48c05": "The function `extract_snippets` extracts relevant code snippets from a collection of files, returning a dictionary mapping file paths to their extracted content. It iterates through the provided files, respecting limits on the number of files, total time spent, and individual file sizes. For Python files (`.py`), it parses the abstract syntax tree to extract module and function/class docstrings, identifies I/O signatures in functions, and captures CLI parser definitions and `__main__` blocks. For non-Python files, it includes the entire file content. The function skips files that exceed size limits, cannot be read, or fail parsing. Progress is logged, and a progress bar is displayed using `tqdm`.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:extract_text:10327891ba05ffffba26cfe70e855320eb3cc025764f6f32c98e7e5124d8da6f:10327891ba05ffffba26cfe70e855320eb3cc025764f6f32c98e7e5124d8da6f": "The function `extract_text` reads and extracts plain text from a file located at the given path, handling different file types based on their suffix. For HTML files, it processes headings by converting them to Markdown-style headers and code blocks into fenced code blocks, then returns the cleaned text. For Markdown (`.md`) files, it directly returns the file's content. For Word documents (`.docx`), it extracts paragraphs, converts heading styles to Markdown headers, and appends other text as-is. For all other file types, it reads the file as plain text. If any error occurs during processing, it returns an empty string.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:infer_sections:6d8293aa54196554b4f20c7141b09f2fb65431537312581627b0e33f7f8f95f6:6d8293aa54196554b4f20c7141b09f2fb65431537312581627b0e33f7f8f95f6": "The function `infer_sections` takes a string input `text` and returns a dictionary mapping section names to their corresponding content. If the input text is non-empty, it assigns the text to the \"Overview\" section and populates the remaining required sections with placeholder content indicating that the details are inferred. If the input text is empty, all required sections are assigned a default message stating that no information is provided. The function uses a predefined list `REQUIRED_SECTIONS` to determine which sections to include in the output dictionary.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:inject_user_manual:d98b3c89371262fff9ec465f8b3b21bbada9a173358f501111a438351c8e0912:d98b3c89371262fff9ec465f8b3b21bbada9a173358f501111a438351c8e0912": "The function `inject_user_manual` inserts a hyperlink to a user manual into an HTML file specified by `index_path`. The link, with the text defined by `title` and pointing to `filename`, is added as the first item in the first navigation element (`<nav>` or `<ul>`) found in the document. If no such elements exist, the link is inserted at the beginning of the first element within the `<body>` tag or the document root. The function uses BeautifulSoup to parse and modify the HTML content, and it handles potential read errors by returning silently if parsing fails.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:insert_into_index:267aa0d0983a3d72b16c5370984b18588c990a259995bf50d6cd07acc763579f:267aa0d0983a3d72b16c5370984b18588c990a259995bf50d6cd07acc763579f": "The function `insert_into_index` appends a navigation link to an HTML file. It takes the path to an index file, a title for the link, and the filename to link to. The function reads the HTML content of the index file, parses it using BeautifulSoup, and finds either a `<ul>` or `<nav>` element to insert the new link into. If a link with the same `href` attribute already exists, it does nothing. Otherwise, it creates a new anchor tag with the provided title and filename, wraps it in a list item if the container is a `<ul>`, and appends it to the container. Finally, it writes the modified HTML back to the index file. If any errors occur during parsing or writing, the function silently returns without making changes.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:llm_fill_placeholders:70a17627a17f21a1e53c193b0167ca42e8073803ccfc67c617a6b658841342da:70a17627a17f21a1e53c193b0167ca42e8073803ccfc67c617a6b658841342da": "The function `llm_fill_placeholders` replaces placeholders in a manual text with relevant code snippets using an LLM. It takes a manual text, a dictionary of code snippets organized by section, an LLM client, and a response cache. For each section, it constructs a prompt that includes the manual text and the corresponding code snippets. If the combined token count exceeds the maximum context size, it summarizes the snippets first. The function then calls the LLM to update the manual text with information from the code snippets, using a system prompt for guidance. The updated manual text is returned after processing all sections.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:llm_generate_manual:94658d4a01ef930d6780ec4adbac987688592006c56eb0f28404e611f7dbbf25:94658d4a01ef930d6780ec4adbac987688592006c56eb0f28404e611f7dbbf25": "The function `llm_generate_manual` generates a user manual from provided documentation snippets by mapping them to predefined sections, performing LLM-based summarization for each section, and assembling the final manual text. It takes a dictionary of documentation paths to content, an LLM client, a response cache, and an optional chunking strategy.\n\nFor each required section:\n\nThe function returns:\n1. The assembled manual text.\n2. A mapping of source files to the sections they contributed to.\n3. An evidence map detailing which snippets were used for each section, including whether the content was inferred.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:main:174a2328f4126fa59560b6ace7d422115f709343783f76e86fddb06a53de0f70:174a2328f4126fa59560b6ace7d422115f709343783f76e86fddb06a53de0f70": "The `main` function serves as the primary entry point for generating project documentation using an LLM-based summarization process. It accepts command-line arguments to configure the documentation generation workflow, including input path, output format (HTML or PDF), title, and code scanning options.\n\nIt initializes a configuration object based on parsed arguments and sets up logging. The function collects existing documentation files from the target directory, reads their content, and performs an initial LLM-based summarization pass. It tracks which sections are contributed by each file and detects any unresolved placeholders.\n\nIf code scanning is enabled and required (based on missing placeholders or explicit flags), it scans relevant source code files to gather context. This context is then used to fill in remaining placeholders via a second LLM pass.\n\nAfter processing, the function validates references within the generated documentation and renders the final output as either HTML or PDF. If specified, it injects a link to the generated manual into an `index.html` file. Evidence maps are saved to a JSON file for reference. The function returns an integer indicating success (0) or failure (non-zero).",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:map_evidence_to_sections:7e2971d002cf365799c989163f4aa9899a3f347a720235188b59f248bbbf06c4:7e2971d002cf365799c989163f4aa9899a3f347a720235188b59f248bbbf06c4": "The function `map_evidence_to_sections` maps documentation snippets from source files to specific manual sections based on keyword matching. It takes a dictionary of file paths to their content and returns a tuple containing:\n\n1. A dictionary mapping section names to lists of tuples, where each tuple consists of a file path and a snippet of text belonging to that section.\n2. A dictionary mapping each file path to the set of sections it contributed to.\n\nThe function processes each file's content, identifying lines that match keywords associated with different sections. For matching lines, it collects subsequent non-empty lines up to a maximum line limit (`MAX_SNIPPET_LINES`), excluding certain directories like \"tests\", \"examples\", and \"fixtures\". Snippets are truncated if they exceed the limit.\n\nFor the \"Overview\" section, special handling is applied to prioritize README files and those in a \"docs\" directory. The snippets for each section are sorted by length (descending) except for \"Overview\", which uses a custom sorting key prioritizing specific file types. Only the top 10 snippets per section are retained.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:parse_manual:48e29a62a6b3230fc18bd342e1186b0e4860eaa26c3c70d23ffed6d36d5b1b4e:48e29a62a6b3230fc18bd342e1186b0e4860eaa26c3c70d23ffed6d36d5b1b4e": "The function `parse_manual` takes a text input and parses it into structured sections based on colon-separated headings. It splits the input on lines containing a colon and stores the resulting sections in a dictionary, preserving their order. If `infer_missing` is enabled and required sections are missing, it uses an LLM client to generate content for those sections, marking them as inferred. The function returns a dictionary of section names mapped to their respective content.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:rank_code_files:94ea1ade637fca519292368dbf60da53cff5ff15fab013df304ceca62dffa032:94ea1ade637fca519292368dbf60da53cff5ff15fab013df304ceca62dffa032": "The function `rank_code_files` takes a root directory path and a list of patterns, and returns a list of code file paths ranked by a simple heuristic. It supports Python (.py), MATLAB (.m), Jupyter Notebook (.ipynb), C++ (.cpp), C header (.h), and Java (.java) files.\n\nThe function traverses the directory tree starting at `root`, skipping certain directories such as venv, .git, __pycache__, node_modules, dist, build, tests, examples, samples, and fixtures. It assigns a score to each file based on whether keywords like \"run\", \"main\", \"cli\", \"config\", \"io\", \"dataset\", \"reader\", \"writer\", or \"pipeline\" appear in the relative path of the file, and whether any of the provided patterns match the relative path. Files with higher scores are ranked first. The final list is sorted by score (descending) and then lexicographically by path.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:render_html:70bc8020c188661de09c8d7b7d7fafe5a7ce306b7e7c1b73a474e37c182c286f:70bc8020c188661de09c8d7b7d7fafe5a7ce306b7e7c1b73a474e37c182c286f": "The `render_html` function generates an HTML document from a dictionary of sections, a title, and an optional evidence map. It creates a navigable HTML page with a table of contents, section headers, and content rendered from markdown or escaped plain text. When section content is missing or marked as \"no information provided,\" it displays supporting evidence snippets and source files instead. The function uses internal helper logic to slugify section titles for anchors, escapes HTML content for safety, and applies basic styling to the output.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:scan_code:c8b141fa65ae105ee515aa023c9c66adc1e99e08867f0b4c5b9e176ca01f6062:c8b141fa65ae105ee515aa023c9c66adc1e99e08867f0b4c5b9e176ca01f6062": "The function `scan_code` collects source code snippets from a specified base directory, organizing them by manual sections based on keyword matching. It takes a base path and optional parameters to limit the number of files, time budget, and maximum file size. The function identifies relevant files by analyzing documentation files for patterns and ranks them accordingly. It then extracts snippets from these files, matching them to predefined section keywords and returning a dictionary mapping section names to file paths and their corresponding code snippets. Empty sections are excluded from the final result.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:slugify:caac45232c36676319c37242aa7c4716ea5d57cb8b9990cf4a816d8cf442edfc:caac45232c36676319c37242aa7c4716ea5d57cb8b9990cf4a816d8cf442edfc": "The `slugify` function converts input text into a filesystem-friendly string by replacing non-alphanumeric characters with underscores, converting to lowercase, and removing leading/trailing underscores. If the result is empty, it returns \"user_manual\".",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:validate_manual_references:d34ba2aa8f5ea2d2f1ea6cfa375964cdc9fdfce43013722779f383fa15c59f7d:d34ba2aa8f5ea2d2f1ea6cfa375964cdc9fdfce43013722779f383fa15c59f7d": "The function `validate_manual_references` identifies and flags file references within a dictionary of section texts that do not correspond to existing files in a project. It scans each section's text for substrings matching common file extensions (e.g., `.py`, `.m`, `.md`) and checks if the referenced paths or filenames exist relative to the project root. If a reference is missing, it appends `[missing]` to the reference in the text and optionally records the missing references in an `evidence_map` under a `missing_references` key for the corresponding section. The input `sections` dictionary is modified in place to reflect these updates.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:write_pdf:8140a94bb0d7a2c13a4dcbbf155b54f0511322eb98711a3db41f5fd991ded752:8140a94bb0d7a2c13a4dcbbf155b54f0511322eb98711a3db41f5fd991ded752": "The function `write_pdf` converts HTML content into a PDF file using the `canvas` module. It takes an HTML string and a file path as inputs, parses the HTML to extract text, and writes the text to a PDF document with a specified page size. The function returns `True` if successful, or `False` if the `canvas` module is not available.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:5926181734a7563ef6f4826600a07d1f6edba568682c797aef063109cf81a3a3:5926181734a7563ef6f4826600a07d1f6edba568682c797aef063109cf81a3a3": "The module implements a graphical user interface for running documentation generation and explanation tools. It defines custom widgets including a path line edit that accepts file drops and a collapsible box for organizing options. A command runner thread handles execution of external processes, capturing output in real time. The main window contains input fields for project and output directories, checkboxes for DocGen options, and controls for ExplainCode settings. Buttons trigger execution of DocGen, ExplainCode, or both tools sequentially. The interface supports dark-themed styling and displays command output in a log area with scrollable text handling. File dialogs enable selection of directories and data files. The application uses PyQt5 for the GUI framework and subprocess for executing external Python scripts.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:CollapsibleBox:0bd2e06ad412e325a49f3986a843fe1343551ecc701365875006d1b17c7cb8c2:0bd2e06ad412e325a49f3986a843fe1343551ecc701365875006d1b17c7cb8c2": "The `CollapsibleBox` class implements a toggleable UI element that displays a title with an arrow indicator, allowing users to show or hide its content area. When toggled, the arrow direction changes to reflect the current state, and the visibility of the associated content widget is updated accordingly. The class provides a method to assign a custom layout to the content area for flexible widget arrangement.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:CollapsibleBox:__init__:3872795cd50f67882abd634cee89722f78baef841dae8e915249543f655adece:3872795cd50f67882abd634cee89722f78baef841dae8e915249543f655adece": "Initializes a collapsible section widget with a toggle button and content area. Creates a tool button styled as a title bar with right-pointing arrow indicator that toggles visibility of the content widget when clicked. Sets up vertical layout containing both the toggle button and content area, with content initially hidden. Configures the toggle button to be checkable and connects its click signal to the toggle handler method. Applies custom stylesheet styling to the toggle button with specific color and font properties.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:CollapsibleBox:on_toggled:f90ec87aaa91989724254207a4e933efac34041b0616a24b2d270248eb906904:f90ec87aaa91989724254207a4e933efac34041b0616a24b2d270248eb906904": "Function that handles toggle button state changes by updating the button's arrow direction and showing or hiding associated content based on whether the button is checked.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:CollapsibleBox:setContentLayout:ac9bfe1723225a787e6fed8f56df1803aac7bf21a8460cdab57bb446c2364b27:ac9bfe1723225a787e6fed8f56df1803aac7bf21a8460cdab57bb446c2364b27": "The function sets the layout for an object's content area. It takes a layout parameter and assigns it to the layout property of the content attribute of the instance.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:CommandRunner:1569301e2434fad26355af31ea14f6ee6c2cbdd38aab6843938de753206efa8b:1569301e2434fad26355af31ea14f6ee6c2cbdd38aab6843938de753206efa8b": "The `CommandRunner` class executes a sequence of shell commands by spawning subprocesses and capturing their output in real-time. It uses dedicated reader threads to handle stdout and stderr streams, ensuring proper emission of output chunks and handling of special characters like carriage returns and newlines. The class stops execution if any command fails and emits a finished signal with the overall return code.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:CommandRunner:__init__:e101f462c35c5d2aea35db85e4ee5dd50b4513aa99b522541dc82c8e27a017f4:e101f462c35c5d2aea35db85e4ee5dd50b4513aa99b522541dc82c8e27a017f4": "Initializes an object with a collection of commands and calls the parent class initializer.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:CommandRunner:_reader:8cbfd3ce114ed1c88228963326a3e4e5c43e87fbd062a6965099f60e48b826d6:8cbfd3ce114ed1c88228963326a3e4e5c43e87fbd062a6965099f60e48b826d6": "Function reads from a stream character by character, collecting characters into buffers until specific delimiters are encountered. When a carriage return is found, the current buffer is emitted followed by the carriage return itself. When a newline is found, the buffer content plus the newline is emitted and the buffer is reset. Any remaining buffered text is emitted when the stream ends. The function emits chunks through an output signal.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:CommandRunner:run:c94857cc54e41729c04041a0a02b8ef637ddeb94d917c5048d30a4c9036c500a:c94857cc54e41729c04041a0a02b8ef637ddeb94d917c5048d30a4c9036c500a": "Function executes a sequence of shell commands, emitting output for each command. It uses subprocess to run commands and threads to handle stdout and stderr reading concurrently. The function tracks return codes and stops execution if any command fails. Upon completion, it emits the final return code.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:MainWindow:4ca63a0cb47b1c2e2ec1ae8519d33afc41353689022013a049b25bb7c7d3a8be:4ca63a0cb47b1c2e2ec1ae8519d33afc41353689022013a049b25bb7c7d3a8be": "The `MainWindow` class implements the graphical user interface for the DocGen-LM documentation tool, providing controls for selecting project and output directories, configuring documentation generation and explanation options, displaying logs, and initiating various documentation tasks. It manages UI elements such as buttons, input fields, and log displays, and handles user interactions to execute commands for generating static HTML documentation from source code using a local LLM. The class supports running documentation generation, resuming previous sessions, explaining code, or performing both tasks sequentially, while updating the interface to reflect the current state of operations.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:MainWindow:__init__:d09dab32ae9ef4e133e914ec11d6c84613bb775ec3893e18fb08391be630cfaa:d09dab32ae9ef4e133e914ec11d6c84613bb775ec3893e18fb08391be630cfaa": "Initializes the user interface for a documentation tool. Sets up the window title and style, creates a header with a logo and title, and adds input fields for project and output directories with browse buttons. Configures options for DocGen including checkboxes for including private functions and language selection. Adds settings for ExplainCode such as output format and data analysis options. Includes a log display area and action buttons for running DocGen, resuming DocGen, running ExplainCode, or executing both tools. Organizes all components into a vertical layout.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:MainWindow:append_log:479035b003afdc113e4797fee7c099619ef8d0c73b903f780a2ffa361feaaf55:479035b003afdc113e4797fee7c099619ef8d0c73b903f780a2ffa361feaaf55": "Function appends text to a log widget while handling carriage return characters by removing existing line content and inserting new text at the end of the log. It ensures the scroll bar remains at the maximum position after appending.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:MainWindow:build_docgen_cmd:0bb90693d605ca6dd10cc8c288bcba60e30d0e2879a67edc4e2df09ee6cb5998:0bb90693d605ca6dd10cc8c288bcba60e30d0e2879a67edc4e2df09ee6cb5998": "Function builds a command list for running a documentation generator script with specified project and output paths, optional resume flag, and private inclusion flag.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:MainWindow:build_explain_cmd:7b8696f7337008622c6bc5488b4fc92413596481c1750330bdc72564631f2cb5:7b8696f7337008622c6bc5488b4fc92413596481c1750330bdc72564631f2cb5": "Function builds a command list for executing an explanation process with specified project path, output location, and format. Includes optional data parameter when enabled and populated. Returns the constructed command array for subprocess execution.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:MainWindow:dark_style:024d23387b641216e7d149e6c045b026f1a451318d781be0d3d84d51867f51ef:024d23387b641216e7d149e6c045b026f1a451318d781be0d3d84d51867f51ef": "Function defines a dark theme style sheet for Qt widgets with dark gray background colors, light gray text, and specific styling for input fields, buttons, and labels.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:MainWindow:on_finished:c98dd27bd106b89d8d5059a01d5a7c208db9c09ee3836ee9d932c0f5bdb99f8b:c98dd27bd106b89d8d5059a01d5a7c208db9c09ee3836ee9d932c0f5bdb99f8b": "Function that handles process completion by logging the exit code and updating the running status.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:MainWindow:run_both:123251ea533aa28d4fb511b62f853998d3769fcced0962a00cdc1cb16c3cfef0:123251ea533aa28d4fb511b62f853998d3769fcced0962a00cdc1cb16c3cfef0": "The function executes two commands sequentially by clearing a log and then running a documentation generation command followed by an explanation command.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:MainWindow:run_commands:259d9e78ac20ac9cd282474591a8079c54a2e042ef9670b77335a47dad9adaff:259d9e78ac20ac9cd282474591a8079c54a2e042ef9670b77335a47dad9adaff": "Function executes a series of commands using a command runner after validating project and output directory settings, then connects runner signals to update log and handle completion.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:MainWindow:run_docgen:0249c14aca7d5d21ff6d3b7929c59f2dbc05b970b05e9329f97566991188ecf6:0249c14aca7d5d21ff6d3b7929c59f2dbc05b970b05e9329f97566991188ecf6": "Function executes documentation generation by clearing logs and running the documentation generation command.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:MainWindow:run_docgen_resume:3ccc689d89d3b9b2ab503890dea8bd89d99eb8079f6815145e40aaba2eea6816:3ccc689d89d3b9b2ab503890dea8bd89d99eb8079f6815145e40aaba2eea6816": "Function executes documentation generation with resume capability by clearing logs and running build command with resume flag.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:MainWindow:run_explain:aaae3953f6dfd026db21ab5cd9b5c637f7a8e0fee01ae706e4db035bf9a67663:aaae3953f6dfd026db21ab5cd9b5c637f7a8e0fee01ae706e4db035bf9a67663": "The function clears the log and executes a command built by `build_explain_cmd()`.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:MainWindow:select_dir:2a0195f8b02fa1d0340ed30e33775539f64b5ddf0498a2fae1d7426f16c229f5:2a0195f8b02fa1d0340ed30e33775539f64b5ddf0498a2fae1d7426f16c229f5": "Function that opens a file dialog to select a directory and sets the selected path to a line edit widget. Takes a parent widget and a line edit widget as parameters. Displays a dialog with \"Select Directory\" title. If a directory is selected, the line edit text is updated with the directory path. Returns nothing.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:MainWindow:select_file:eefcbb0d572a55989ebf1a954aae8e90553ec7f2c5c165ee8e6029c3df4770d3:eefcbb0d572a55989ebf1a954aae8e90553ec7f2c5c165ee8e6029c3df4770d3": "Function that opens a file dialog to select a data file and sets the selected file path to a line edit widget. The dialog filters for JSON, CSV, and TXT files, with an option to show all files. If a file is selected, the path is displayed in the provided line edit field.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:MainWindow:set_running:0060e79ba63c4489d68b4a831c921909f5e89ae4a7e0028231ef70a8d4836731:0060e79ba63c4489d68b4a831c921909f5e89ae4a7e0028231ef70a8d4836731": "Function that enables or disables multiple buttons based on a running state flag. Takes a boolean parameter 'running' and iterates through four buttons (docgen_btn, resume_btn, explain_btn, both_btn). For each button, it sets the enabled state to the logical inverse of the running parameter value. When running is True, all buttons are disabled; when running is False, all buttons are enabled.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:PathLineEdit:9047ab00a20f8e46e91c980e842ce02385a8bf99dbed7268c434c6b2656dcbad:9047ab00a20f8e46e91c980e842ce02385a8bf99dbed7268c434c6b2656dcbad": "The `PathLineEdit` class extends a line edit widget to support drag-and-drop functionality for file paths. It handles drag enter events to accept URL data and processes drop events to extract and set local file paths as the widget's text content. The class enables users to directly drop files or directories onto the widget to populate the path.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:PathLineEdit:__init__:c9e8a7be9ec3c7638ba891fb56438f32b028d50d553e3cf05183fab3aa0b6309:c9e8a7be9ec3c7638ba891fb56438f32b028d50d553e3cf05183fab3aa0b6309": "Initializes a class instance with optional parent parameter, calls parent class initialization, and enables drag-and-drop acceptance functionality.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:PathLineEdit:dragEnterEvent:362f23d15259d38f2384b97d4fe0df74d022e537eb20da5aa442f957d48d0d35:362f23d15259d38f2384b97d4fe0df74d022e537eb20da5aa442f957d48d0d35": "The function handles the drag enter event for a widget, accepting drag operations that contain URL data.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:PathLineEdit:dropEvent:2bae52494ea3b00064a9fc268f5338cc663c0b954be820963c807172bd13b7cf:2bae52494ea3b00064a9fc268f5338cc663c0b954be820963c807172bd13b7cf": "The function handles drag-and-drop events by extracting file URLs from the event's MIME data. When URLs are present, it converts the first URL to a local file path and sets it as the widget's text content.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:__init__:10bfeb02e9c012e26785eb8be03428fafb9fd0ea29b00ee4f7a69ddc28061b3d:10bfeb02e9c012e26785eb8be03428fafb9fd0ea29b00ee4f7a69ddc28061b3d": "The `__init__` method initializes a `PathLineEdit` instance. It calls the parent class constructor and enables drag-and-drop functionality by setting `setAcceptDrops(True)`.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:__init__:16299510ff2d6902a46f7d19af36156fc96f24be2ff34f95dbc47807d1ae491e:16299510ff2d6902a46f7d19af36156fc96f24be2ff34f95dbc47807d1ae491e": "Initializes the main window for the DocGen-LM Documentation Tool, setting up the user interface with a header containing a logo and title, project and output directory selectors, DocGen options including private function inclusion and language selection, ExplainCode options for output format and data analysis, a log display area, and control buttons for running DocGen, resuming DocGen, running ExplainCode, or running both tools. The interface uses a dark theme style and includes collapsible sections for options.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:__init__:405fca3ce1d95d60b028a3be06836af3ff14b889cd967aaa3a8ea8b41d9565b8:405fca3ce1d95d60b028a3be06836af3ff14b889cd967aaa3a8ea8b41d9565b8": "The `__init__` method initializes a `CollapsibleBox` widget with a title and optional parent. It creates a toggle button styled to display the title with a right-pointing arrow, which changes orientation when clicked. The button is connected to the `on_toggled` method to handle visibility toggling of the content area. A `QWidget` is created to hold the collapsible content, initially hidden. The layout is set up to vertically arrange the toggle button and content widget with no margins.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:__init__:5811e7358d79dd74c3d5ce6b76cbbd5fc5455196f4c7f0bab124fd9ad3a676ca:5811e7358d79dd74c3d5ce6b76cbbd5fc5455196f4c7f0bab124fd9ad3a676ca": "Initializes a CollapsibleBox widget with a title and parent. Creates a toggle button styled with custom CSS that displays the title text, and a content widget that is initially hidden. The layout arranges the toggle button above the content widget with no margins. Connects the toggle button's clicked signal to the on_toggled slot.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:__init__:5f2ff440fcb462eadc33446f6df833ff284162d8713fc04f7354635e23820425:5f2ff440fcb462eadc33446f6df833ff284162d8713fc04f7354635e23820425": "Initializes the `MainWindow` class, setting up the graphical user interface for the DocGen-LM documentation tool. Configures the window title, style, and layout with components including a header with logo and title, project and output directory selectors, DocGen options (such as including private functions and language selection), ExplainCode options (output format and data analysis settings), a log display area, and action buttons for running documentation generation tasks. The interface uses a collapsible box for organizing options and connects various UI elements to their respective handler functions.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:__init__:776121b10c54e6da03b096f010190f7c3d162c3394570eb3033097294efa98fc:776121b10c54e6da03b096f010190f7c3d162c3394570eb3033097294efa98fc": "The `__init__` method initializes a `CommandRunner` instance. It accepts a parameter `cmds`, which is assigned to the instance attribute `self.cmds`. The method calls the parent class's `__init__` method using `super().__init__()`.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:__init__:95fbf02e6745291af9c5dbb009aa6e5ee8eea7ee2b1aa648f23b6b05703182ab:95fbf02e6745291af9c5dbb009aa6e5ee8eea7ee2b1aa648f23b6b05703182ab": "Initializes a PathLineEdit instance with optional parent widget, calling the parent constructor and enabling drag-and-drop functionality for file paths.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:__init__:ea8888224d34ad2b834c193fc5934ea4345afb8919d30e5c4182eba5de0e3d92:ea8888224d34ad2b834c193fc5934ea4345afb8919d30e5c4182eba5de0e3d92": "The `__init__` method initializes a `CommandRunner` instance by calling the parent class constructor and storing the provided `cmds` parameter as an instance attribute.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:_reader:1176b052e8c5a24ba9872768ce91cf27ea2fe85f17a07bf931b91b45a0d7a107:1176b052e8c5a24ba9872768ce91cf27ea2fe85f17a07bf931b91b45a0d7a107": "The function `_reader` reads from a given stream character by character and emits output chunks. It handles carriage returns by emitting them separately to support progress bar updates in the GUI, and flushes any buffered text when the stream ends. The function maintains a buffer for characters that have not yet been emitted, appending new characters to it until a newline or carriage return is encountered, at which point it emits the accumulated content plus the special character, then resets the buffer.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:_reader:9437546777e8e83cedc3011e27c721b157b12d6fa97e2ba66a5aaeb8087c8c7c:9437546777e8e83cedc3011e27c721b157b12d6fa97e2ba66a5aaeb8087c8c7c": "The function `_reader` reads from a given stream character by character and emits output chunks. It handles carriage returns by emitting them separately to allow GUI progress bar updates, and ensures any buffered text is flushed upon stream completion. Newline characters trigger emission of the buffered line followed by a newline, while other characters are appended to the buffer. The function continues reading until the end of the stream is reached.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:append_log:72586774fcd7cb577c19a3ece7c17113a25a66119a9326cf980cd3df4c4faef1:72586774fcd7cb577c19a3ece7c17113a25a66119a9326cf980cd3df4c4faef1": "The function `append_log` appends text to a log widget while handling carriage return characters by replacing the current line content. It moves the cursor to the end of the log, processes the input text by splitting on carriage returns, and either inserts text or clears and replaces the current line when a carriage return is encountered. Finally, it scrolls the log to the bottom to ensure the latest entry is visible.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:append_log:8a3a4792941cf3b74d6a1e995b73e8cb82b16ee9b1cce408ab986adda78a9e33:8a3a4792941cf3b74d6a1e995b73e8cb82b16ee9b1cce408ab986adda78a9e33": "The function `append_log` appends text to a log widget in the main window, ensuring proper handling of line endings. It moves the text cursor to the end of the log, splits the input text by carriage return characters, and processes each part accordingly. If a carriage return is encountered, it removes the current line before inserting new content. Otherwise, it inserts the text part at the cursor position. Finally, it updates the scroll bar to ensure the latest log entry is visible.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:build_docgen_cmd:4128ceac21df50cdbb32c53610bef17903d56dae52aab84b4b172e6b1388ca9f:4128ceac21df50cdbb32c53610bef17903d56dae52aab84b4b172e6b1388ca9f": "",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:build_docgen_cmd:9ed047355fa7366081162ace668b580a8c4f17e99fa34954ff5a278a5b88447d:9ed047355fa7366081162ace668b580a8c4f17e99fa34954ff5a278a5b88447d": "",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:build_explain_cmd:5ee08ab5281fd969f9120c897c1711740e4f4a5d2dee0ef751079bc80cdba57b:5ee08ab5281fd969f9120c897c1711740e4f4a5d2dee0ef751079bc80cdba57b": "The function `build_explain_cmd` constructs and returns a command list for executing the `explaincode.py` script with specified parameters. The command includes the Python interpreter path, script name, project path from `self.project_edit`, output location from `self.output_edit`, and selected output format from `self.format_combo`. If the data inclusion checkbox is checked and a data path is provided in `self.data_edit`, the command also includes the data path as an argument.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:build_explain_cmd:c991fa7b0f627346ee3a0a226e1a21231d960021a084a63156edef18ab6f93ca:c991fa7b0f627346ee3a0a226e1a21231d960021a084a63156edef18ab6f93ca": "The function `build_explain_cmd` constructs and returns a command list for executing the `explaincode.py` script with specified arguments. The command includes the Python interpreter path, the script name, and arguments for the project path, output location, and output format, which are derived from the GUI input fields. If the data inclusion checkbox is checked and a data path is provided, the command also includes the data path argument. The function returns the constructed command as a list of strings.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:dark_style:aa1d80e65eab8f38f5ae77ea784a43e225fb3da50bfba11181bbfe708f465ed5:aa1d80e65eab8f38f5ae77ea784a43e225fb3da50bfba11181bbfe708f465ed5": "The function `dark_style` defines a CSS stylesheet for a Qt-based graphical user interface, configuring the visual appearance of various UI elements to use a dark color scheme. It sets background and text colors for widgets, defines styling for input fields like `QLineEdit` and `QPlainTextEdit`, specifies button styles with hover effects, and adjusts label font weights. The style uses dark gray tones (#1e1e1e, #2d2d2d) for backgrounds and light gray (#d4d4d4) for text, with subtle borders and padding for a consistent look.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:dark_style:cc65fd9ec502cfff5f19eb8316d9fc44c3b4ee81862d37462dac5fd4d15c9bae:cc65fd9ec502cfff5f19eb8316d9fc44c3b4ee81862d37462dac5fd4d15c9bae": "The function `dark_style` defines and returns a CSS-style string that establishes a dark-themed visual appearance for a Qt application's user interface elements. It specifies background colors, text colors, fonts, and border styles for various widget types including general widgets, line edits, plain text edits, combo boxes, push buttons, and labels. The style uses a dark gray color scheme with subtle highlights and hover effects for interactive elements.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:dragEnterEvent:38539a0da8ad1be0727b80a78eccab0d137d2f4ab86e44e21c1d4e0fe90484fc:38539a0da8ad1be0727b80a78eccab0d137d2f4ab86e44e21c1d4e0fe90484fc": "The `dragEnterEvent` method handles drag-and-drop operations by accepting events that contain URL data, allowing users to drop file paths or URLs onto the PathLineEdit widget.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:dragEnterEvent:50ebcc5a44f0182753950006d3f6ccac9bbc3e490cfae7e7a6de5a3527464610:50ebcc5a44f0182753950006d3f6ccac9bbc3e490cfae7e7a6de5a3527464610": "The `dragEnterEvent` method in the `PathLineEdit` class handles drag-and-drop events when an object is dragged into the widget's area. It checks if the dragged data contains URLs using `event.mimeData().hasUrls()`. If URLs are present, it accepts the proposed action, allowing the user to drop files or links onto the widget.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:dropEvent:05df6a82d220b4eb7b836a5f2677f8d6e479cc29434fd8e661e275b6387c1ece:05df6a82d220b4eb7b836a5f2677f8d6e479cc29434fd8e661e275b6387c1ece": "The `dropEvent` method handles drag-and-drop operations on the `PathLineEdit` widget. When a file or directory is dropped onto the widget, it extracts the local file path from the first URL in the drop event and sets it as the text content of the line edit.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:dropEvent:90231b977d7ad880a8ac53d677d1bec8a7a2d78992988c26b116379782267ad4:90231b977d7ad880a8ac53d677d1bec8a7a2d78992988c26b116379782267ad4": "The `dropEvent` method handles drag-and-drop operations on the PathLineEdit widget. When a file or directory is dropped onto the widget, it extracts the local file path from the first URL in the mime data and sets it as the text content of the line edit.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:on_finished:1a3b1bcde5cb712a626c3f87f84d4b8b1b9f57ab5adc7d7bc2615b17aa98ca6d:1a3b1bcde5cb712a626c3f87f84d4b8b1b9f57ab5adc7d7bc2615b17aa98ca6d": "The function `on_finished` is called when a process completes execution. It logs the exit code of the process using the `append_log` method and updates the running state of the application to False using the `set_running` method.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:on_finished:23a885f70acbf1d8e20bb0a673ea0a92ce939965da730a42d229837a24b9af8a:23a885f70acbf1d8e20bb0a673ea0a92ce939965da730a42d229837a24b9af8a": "The function `on_finished` is called when a process completes execution. It logs the exit code of the process using the `append_log` method and updates the running state of the application to False using the `set_running` method.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:on_toggled:5da55eefb99ee39a85c09cbcc1c68b35d49ea6fceff6e6c50164b1c50e869371:5da55eefb99ee39a85c09cbcc1c68b35d49ea6fceff6e6c50164b1c50e869371": "The `on_toggled` method handles the visual update of a collapsible box when its toggle state changes. It checks whether the toggle button is in a checked (active) state, and based on that, sets the arrow direction of the button to point down or right. It also shows or hides the content area associated with the collapsible box, depending on the toggle state.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:on_toggled:6fe83efa08a2e218ba121bb5675cedc80266410d232e179d6710449e271efde8:6fe83efa08a2e218ba121bb5675cedc80266410d232e179d6710449e271efde8": "The function `on_toggled` handles the toggle state change of a button within the `CollapsibleBox` class. When the button is checked (toggled on), it sets the button's arrow direction to down and makes the content box visible. When unchecked (toggled off), it changes the arrow direction to right and hides the content box.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:run:1158fd44c10964516dc55bd90b5e7963b889f26a956e82f89a686a926dab1834:1158fd44c10964516dc55bd90b5e7963b889f26a956e82f89a686a926dab1834": "The `run` method executes a sequence of commands stored in `self.cmds`. For each command, it spawns a subprocess, captures the stdout and stderr using dedicated reader threads, and emits the command line as output. It waits for the process to complete and checks the return code. If any command fails (non-zero return code), the execution stops. If an exception occurs during command execution, it emits the exception message and sets the return code to -1. Finally, it emits a `finished` signal with the overall return code.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:run:f61b5eb5af84d8df06a806e966bcee70cd3446700f8a8893849ddef2de583d19:f61b5eb5af84d8df06a806e966bcee70cd3446700f8a8893849ddef2de583d19": "The `run` method executes a sequence of commands stored in `self.cmds`. For each command, it emits the command line to `self.output`, spawns a subprocess to execute it, and uses separate threads to read the subprocess's stdout and stderr. It waits for the process to complete and checks the return code. If any command fails (non-zero return code), the method stops execution and emits the final return code via `self.finished`. If an exception occurs during command execution, it emits the exception message, sets the return code to -1, and stops further execution.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:run_both:4f3c7054b0dfd5ec2992e041b9dcc319174f721fecf757b695e4a3ec7fb6fce3:4f3c7054b0dfd5ec2992e041b9dcc319174f721fecf757b695e4a3ec7fb6fce3": "The function `run_both` clears the log and executes two commands sequentially: one for building documentation generation and another for explaining commands.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:run_both:fc2427910961b6ff889a3bf96833f6a3582c78bad916e083f956c03acd1ba009:fc2427910961b6ff889a3bf96833f6a3582c78bad916e083f956c03acd1ba009": "The function `run_both` clears the log and executes two commands sequentially: one for building a documentation generation command and another for building an explanation command. These commands are retrieved using the methods `build_docgen_cmd()` and `build_explain_cmd()`, respectively. The function is intended to initiate both documentation generation and explanation processes within the application's interface.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:run_commands:81028765db2525b8867111dcb8e22a39806f97317d87346a0fe022d78cf0c1e7:81028765db2525b8867111dcb8e22a39806f97317d87346a0fe022d78cf0c1e7": "The function `run_commands` executes a series of commands using a `CommandRunner` object. It first validates that both project and output directory fields are set, displaying an error message and returning early if they are not. If validation passes, it sets the UI to a running state, creates a `CommandRunner` instance with the provided commands, connects its output and finished signals to appropriate handler methods, and starts the runner.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:run_commands:8f820eb0e409316280b67a00e442e5cdc39ba0d70b1c501ba4edf20aea62cf34:8f820eb0e409316280b67a00e442e5cdc39ba0d70b1c501ba4edf20aea62cf34": "The function `run_commands` initiates the execution of a series of commands through a `CommandRunner` instance. It first checks whether the project and output directory fields are set; if not, it logs an error message and returns. If both directories are specified, it sets the UI state to running, creates a `CommandRunner` with the provided commands, connects its `output` signal to the `append_log` method for logging, and connects its `finished` signal to the `on_finished` method. Finally, it starts the command execution in a separate thread.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:run_docgen:009a3fefd2b945ba57d47d6520dd76bd681d3391bc828548afcade5a49389423:009a3fefd2b945ba57d47d6520dd76bd681d3391bc828548afcade5a49389423": "The `run_docgen` function clears the log output and executes documentation generation commands by calling `build_docgen_cmd()` to construct the command list and then running those commands through `run_commands()`.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:run_docgen:2156526626094f4ff23c6b7545b710954070854491dafd49e6ab1d9b477a7886:2156526626094f4ff23c6b7545b710954070854491dafd49e6ab1d9b477a7886": "The `run_docgen` function clears the log output and executes the documentation generation command built by `self.build_docgen_cmd()`. It uses `self.run_commands()` to run this command, which likely triggers the documentation generation process using the configured LLM backend. The function serves as an entry point for initiating the documentation generation workflow within the GUI.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:run_docgen_resume:83f1a07ecaa787f78f480b04cf463918f4944afcca18172017e866e2935b7c85:83f1a07ecaa787f78f480b04cf463918f4944afcca18172017e866e2935b7c85": "The function `run_docgen_resume` clears the log display and executes a documentation generation command with the resume option enabled. It utilizes the `build_docgen_cmd` method to construct the command with `resume=True`, then runs this command through `run_commands`. This allows the documentation generation process to continue from a previously saved state.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:run_docgen_resume:8b8a594a849ecab950c817674c52983f7694e9b4008a5103c2216921a0561877:8b8a594a849ecab950c817674c52983f7694e9b4008a5103c2216921a0561877": "The function `run_docgen_resume` clears the log display and executes documentation generation commands with a resume flag enabled. It calls `build_docgen_cmd` with `resume=True` to generate or continue documentation, then runs the resulting command through `run_commands`.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:run_explain:7adc4708a7d5730a06a2c9080b78f4cf22d833ecc8ff313cccce69eb56c3620f:7adc4708a7d5730a06a2c9080b78f4cf22d833ecc8ff313cccce69eb56c3620f": "The `run_explain` function clears the log output and executes a command generated by `build_explain_cmd()`. It utilizes `run_commands` to process the built command, likely related to generating or explaining documentation content. The function serves as an entry point for initiating an explanation or documentation generation task within the application's workflow.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:run_explain:ca92c569295e31d734b3627e4c04d69bdabd11330f7e91025474bc0d9d4b8b96:ca92c569295e31d734b3627e4c04d69bdabd11330f7e91025474bc0d9d4b8b96": "The `run_explain` function clears the log display and executes a command built by `build_explain_cmd()`. It uses `run_commands` to process the command list containing the single explain command.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:select_dir:37637e46c501c6db7754414cf624c51335dd788be586a314a0ad63804df85103:37637e46c501c6db7754414cf624c51335dd788be586a314a0ad63804df85103": "The function `select_dir` provides a dialog interface for users to choose a directory path. When invoked, it opens a file dialog window allowing directory selection. If a directory is chosen, the selected path is set into the provided `line_edit` widget. If no directory is selected, the `line_edit` remains unchanged.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:select_dir:c5c482dc560724185c4fd9de23a869512fee773eba654234ccc21921d67425e2:c5c482dc560724185c4fd9de23a869512fee773eba654234ccc21921d67425e2": "The function `select_dir` is a method of the `MainWindow` class that opens a file dialog to allow the user to select a directory. When a directory is selected, the path is set into the provided `line_edit` widget. If no directory is selected, the `line_edit` remains unchanged.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:select_file:1bd863dc8ef80ffce2c58b2e1f7552ab20b569f00db6d9a3b2c29f204978b92a:1bd863dc8ef80ffce2c58b2e1f7552ab20b569f00db6d9a3b2c29f204978b92a": "The function `select_file` enables the user to choose a data file through a file dialog interface. It accepts a `line_edit` parameter, which is updated with the selected file's path if a file is chosen. The dialog filters for JSON, CSV, and text files, alongside all file types. If no file is selected, the line edit remains unchanged.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:select_file:4d0411d462eb35378391cf58be72a174509539f244aa77963b55fc1e9daeaaf5:4d0411d462eb35378391cf58be72a174509539f244aa77963b55fc1e9daeaaf5": "The function `select_file` provides a file selection dialog to choose a data file. It uses `QFileDialog.getOpenFileName` to display a dialog for selecting files with extensions *.json, *.csv, or *.txt, and shows all files as an option. If a file path is selected, it sets the text of the provided `line_edit` widget to that path.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:setContentLayout:475f94e875c9403d454f267fd080bcea89d4afeaebb77fa7ab93b147a9ea117c:475f94e875c9403d454f267fd080bcea89d4afeaebb77fa7ab93b147a9ea117c": "The function `setContentLayout` sets the layout for the content area of the `CollapsibleBox` instance. It takes a single parameter, `layout`, which is assigned to the `setLayout` method of the `content` attribute. This allows the visual arrangement of widgets within the collapsible box's content section to be customized through the provided layout object.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:setContentLayout:53621ec8afc98c9522fbe3029a79d127be119065055660c32704dba5f8d9bbda:53621ec8afc98c9522fbe3029a79d127be119065055660c32704dba5f8d9bbda": "The `setContentLayout` method sets the layout for the content area of the CollapsibleBox widget by assigning the provided layout object to the content's layout property.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:set_running:2b3e01b8dba6008cb1c898fe2242976b5bb72238bb85cf6c67e0e7906163d2ab:2b3e01b8dba6008cb1c898fe2242976b5bb72238bb85cf6c67e0e7906163d2ab": "Sets the enabled state of multiple buttons based on the running parameter. When running is True, disables the buttons (docgen_btn, resume_btn, explain_btn, both_btn). When running is False, enables the buttons.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:set_running:ad5931ef80ae23ff6052c63e0ca34c0a335a679c52b0daf055291098de2c40a3:ad5931ef80ae23ff6052c63e0ca34c0a335a679c52b0daf055291098de2c40a3": "The function `set_running` takes a boolean parameter `running` and updates the enabled state of four UI buttons (`docgen_btn`, `resume_btn`, `explain_btn`, `both_btn`). If `running` is `True`, the buttons are disabled; if `False`, they are enabled. This functionality is used to control user interaction with these buttons during documentation generation processes.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\html_writer.py:3e0a79e574fdf9a5116be8a3a5e1b9cee87f67c23446e50ea22dc4ef6e6e3a7c:3e0a79e574fdf9a5116be8a3a5e1b9cee87f67c23446e50ea22dc4ef6e6e3a7c": "Module provides HTML rendering utilities for generating documentation pages from structured data. It includes functions to render navigation trees, highlight code snippets using Pygments, and generate complete HTML pages with templates. The module supports rendering project overviews, module pages with classes, functions, and variables, and handles nested structures through recursive rendering functions. It uses a template-based approach to assemble final HTML output with proper escaping and formatting.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\html_writer.py:_flatten_nav_tree:eff06f130453f5583373ed17622afbe4e87e37ed3434f62c27d847b2439c823d:eff06f130453f5583373ed17622afbe4e87e37ed3434f62c27d847b2439c823d": "Generates a flattened iterable of (name, link) tuples from a nested navigation tree structure. Traverses the tree recursively, skipping the \"__files__\" key at each level, and yields file names and their corresponding links from the \"__files__\" lists while descending into subdirectories. The function processes the tree in a depth-first manner to produce a linear sequence of file entries.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\html_writer.py:_highlight:1f24cde23d3654dedda4304bfd7a17625c07fd65ab4f92d0d67b779bec71ab19:1f24cde23d3654dedda4304bfd7a17625c07fd65ab4f92d0d67b779bec71ab19": "The function `_highlight` takes a string of code and a language identifier as input, and returns the code formatted with syntax highlighting for the specified language using the Pygments library. It selects an appropriate lexer based on the language (supporting MATLAB, Python, C++, Java, or plain text), applies HTML formatting to the highlighted code, and wraps it in `<pre><code>` tags for proper display.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\html_writer.py:_render:20a99ec0a186c0a273fb0906b6a9a2f5dc35538d1306a11422090c815af34481:20a99ec0a186c0a273fb0906b6a9a2f5dc35538d1306a11422090c815af34481": "The function `_render` recursively generates an HTML unordered list representation of a nested directory structure. It takes a dictionary `node` representing the structure and a boolean `is_root` indicating if the current node is the root level. If `is_root` is true and `include_home` is enabled, it adds a link to an index page with the label \"\ud83c\udfe0 Project Overview\". For each file in the `__files__` list of the node, it creates an HTML list item with a hyperlink to the file. For each directory key in the node (excluding `__files__`), it creates a collapsible details element with a summary tag containing the directory name and recursively processes its contents. The result is a nested HTML structure suitable for displaying project hierarchies in a web interface.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\html_writer.py:_render_class:a7e363db44f5ceb3d92545369e19b9874203d66474b70e6e40460f5efe8e46ac:a7e363db44f5ceb3d92545369e19b9874203d66474b70e6e40460f5efe8e46ac": "The function `_render_class` generates HTML content for a class and its nested elements, including variables, methods, and subclasses. It takes a dictionary representing the class, the programming language, and an optional heading level. The output is a list of HTML strings that define the class structure with appropriate headings, documentation, variable details, method summaries, and collapsible subclass sections. Variables and methods are rendered with their respective summaries and source code highlighting. Subclasses are displayed in collapsible `<details>` blocks with nested rendering. The function uses HTML escaping to ensure safe output and supports hierarchical heading levels up to `<h6>`.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\html_writer.py:_render_function:9428aa1dac5780360b9d84685761b1625b4cb0215a259b74ef456329bf0af40c:9428aa1dac5780360b9d84685761b1625b4cb0215a259b74ef456329bf0af40c": "The function `_render_function` generates HTML content for a given function and its nested subfunctions. It takes a dictionary representing the function, the programming language, an optional heading level, and an optional prefix. The output is a list of HTML string fragments.\n\nThe function creates an HTML heading element with an ID based on the function's name, followed by a paragraph containing the function's summary or docstring. If source code is present, it applies syntax highlighting using `_highlight`. For each subfunction in the function's `subfunctions` list, it wraps the rendered subfunction content in a `<details>` element with a `<summary>` tag indicating \"Subfunction\". The heading level is incremented for nested subfunctions to maintain proper hierarchy. The returned list contains all HTML parts for the function and its nested structures.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\html_writer.py:_render_html:9681ee9bf482d87dab7cac61beb01da9ddbfc32536eba86df0bf5587bbb7db24:9681ee9bf482d87dab7cac61beb01da9ddbfc32536eba86df0bf5587bbb7db24": "The function `_render_html` generates an HTML document by formatting a template with provided content. It takes four parameters: `title`, `header`, `body`, and `nav_html`. The template is read from a file specified by `_TEMPLATE_PATH`, and the content is formatted using these parameters. The resulting HTML includes a comment indicating generation by DocGen-LM, along with references to a static CSS file for styling.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\html_writer.py:_render_nav_tree:6dd37bc61e7a07a1a8c1866ef194161baa7b773d2fa3a2fce957b3d2b82f4744:6dd37bc61e7a07a1a8c1866ef194161baa7b773d2fa3a2fce957b3d2b82f4744": "The function `_render_nav_tree` generates HTML code for a nested navigation tree from a dictionary structure. It takes a dictionary `tree` representing the navigation hierarchy and an optional boolean `include_home` to determine whether to include a home link. The function uses a nested helper function `_render` to recursively process the tree, creating HTML list items for files and collapsible sections for directories. Files are rendered as links, while directories are shown as expandable summary elements containing nested lists. The output is a string of HTML code representing the complete navigation structure.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\html_writer.py:write_index:f0009e08d6a4fde47f3223f0204e1ce2192693df927acf99906f669686cb5729:f0009e08d6a4fde47f3223f0204e1ce2192693df927acf99906f669686cb5729": "The function `write_index` generates an `index.html` file in the specified output directory. It takes a project summary, a navigation tree, and optional module summaries as inputs. The function creates the output directory if it does not exist, renders the navigation tree into HTML, and constructs a body containing the project summary and a list of modules with their respective links and summaries. Each module entry includes a link to its documentation page and an optional summary. The final HTML content is generated using a helper function `_render_html` and written to `index.html`.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\html_writer.py:write_module_page:66025b08f3f20be00602dd7efdb4c7222d82365118775f27734ce80ddab94aaf:66025b08f3f20be00602dd7efdb4c7222d82365118775f27734ce80ddab94aaf": "The function `write_module_page` generates an HTML documentation page for a given module. It takes an output directory, module data, and a navigation tree as inputs. The function creates the output directory if it does not exist, extracts the module name and language from the module data, and renders a navigation bar using `_render_nav_tree`. It then builds the page body by including a summary, class definitions, variables with their summaries and source code highlights, and functions with their details. Finally, it constructs the complete HTML page using `_render_html` and writes it to a file named after the module in the specified output directory.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\llm_client.py:8c10f070f2c8b3e3bde249f5ea3f8fa746a3f3f1de1670c852597f9131c944de:8c10f070f2c8b3e3bde249f5ea3f8fa746a3f3f1de1670c852597f9131c944de": "The module defines an interface for interacting with a local LLM backend, specifically designed for generating code summaries. It includes prompt templates for different code elements such as modules, classes, functions, and README files, along with a system prompt that instructs the model to produce factual, concise descriptions without self-reference or extraneous information. The `LLMClient` class handles communication with the LMStudio API, sending requests and processing responses, including token counting and sanitization of output to remove unwanted content. It supports retry logic for failed requests and includes utilities for cleaning up special tokens and filtering out meta-commentary from summaries.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\llm_client.py:LLMClient:__init__:700c23b8c0716a1aaf00c10fbc2e056bef4f6e1dca9c72b739185f920ef55cf8:700c23b8c0716a1aaf00c10fbc2e056bef4f6e1dca9c72b739185f920ef55cf8": "Initializes an object with a base URL, constructs an API endpoint path, and sets a model identifier. The base URL is stripped of any trailing slashes before being stored. The endpoint is formed by appending the chat completions path to the base URL. The model parameter is stored as an instance attribute.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\llm_client.py:LLMClient:ec66f26171270dc207ffd1b5a3c3292d71786729d43de8a591e8d6c654b85a93:ec66f26171270dc207ffd1b5a3c3292d71786729d43de8a591e8d6c654b85a93": "The `LLMClient` class facilitates communication with a local LLM API endpoint, enabling it to ping the server for connectivity checks and generate summaries of input text using specified prompt templates. It manages API requests with retry logic, handles streaming responses, and ensures token usage stays within budget limits during summarization tasks. The client is initialized with a base URL and model name, and it constructs the necessary endpoint for chat completions.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\llm_client.py:LLMClient:ping:3fe5655e89accd067c6ddc9c1cc323c9dd9eac2dea9be6646ea4d470b3e0a436:3fe5655e89accd067c6ddc9c1cc323c9dd9eac2dea9be6646ea4d470b3e0a436": "Function that checks API connectivity by sending an HTTP GET request to a base URL and returning True if successful, raising a ConnectionError with a specific message if the request fails.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\llm_client.py:LLMClient:summarize:d645c0bd2d6fc772b12d74e25271d6590e2e1e37ccdc8d959e6a4fae9a56c574:d645c0bd2d6fc772b12d74e25271d6590e2e1e37ccdc8d959e6a4fae9a56c574": "Function `summarize` generates a summary of input text using a specified prompt template and communicates with a language model API. It constructs a prompt from the input text and a selected template, checks token usage against a budget, and sends a request to an endpoint with system and user messages. The function handles retries on failure, processes streaming responses, and returns sanitized output from the model. It includes logging for prompt size, request progress, and errors during execution.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\llm_client.py:__init__:78c6a5d7cfff2cdc19ab3e3cfcd9a50e5c36531bf1ff39fd2d936740b20378aa:78c6a5d7cfff2cdc19ab3e3cfcd9a50e5c36531bf1ff39fd2d936740b20378aa": "Initializes the LLMClient instance with a specified base URL and model.\n\nParameters:\n\nThe method sets up the client's endpoint by appending \"/v1/chat/completions\" to the base URL and stores the provided model name for subsequent API requests.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\llm_client.py:__init__:7bb980db665c5bf9c3abfb882a8a354f91d3c5797ac8f4e6bc17ef9af9b0517f:7bb980db665c5bf9c3abfb882a8a354f91d3c5797ac8f4e6bc17ef9af9b0517f": "Initializes the LLMClient with a base URL and model name. Sets up the endpoint for API requests by appending the chat completions path to the base URL, ensuring no trailing slash is present. The model parameter specifies which model to use for requests.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\llm_client.py:ping:1ff03a578f00684f1cac1f9550ccdf71012b338290831cacc3163ac406b67fa2:1ff03a578f00684f1cac1f9550ccdf71012b338290831cacc3163ac406b67fa2": "The function `ping` checks if the LLM API is reachable by sending an HTTP GET request to the server's base URL. It takes an optional timeout parameter and returns `True` if the server responds successfully. If the server cannot be reached or raises an HTTP error, it raises a `ConnectionError` with a descriptive message. The function uses `requests.get` to perform the check and `response.raise_for_status()` to handle HTTP errors.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\llm_client.py:ping:76580d4cfebb32c95afa8e6fa9356034814b82596b302988056e85ebbb9ab4e4:76580d4cfebb32c95afa8e6fa9356034814b82596b302988056e85ebbb9ab4e4": "The `ping` method checks if the LLM API is reachable by sending an HTTP GET request to the base URL. It returns `True` if the server responds successfully within the specified timeout period. If the request fails due to network issues or an invalid response, it raises a `ConnectionError` with a descriptive message indicating that the LMStudio server cannot be reached. The method uses `requests.get` with a configurable timeout and validates the response using `response.raise_for_status()` to ensure the server is operational.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\llm_client.py:sanitize_summary:7dd73e4b23bbe0254ecdf6de874242d8af22d80d53d4961dfe5e99903b8623e8:7dd73e4b23bbe0254ecdf6de874242d8af22d80d53d4961dfe5e99903b8623e8": "",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\llm_client.py:summarize:39939b948e23aa652b68a6f98388c052ff8dc4772602ee3435883e6b3644d460:39939b948e23aa652b68a6f98388c052ff8dc4772602ee3435883e6b3644d460": "The `summarize` method of the `LLMClient` class generates a summary of input text using a specified prompt template. It constructs a prompt from the provided text and a template, checks if the prompt's token count exceeds a given budget, and sends the prompt to an LLM endpoint via a POST request. The method handles retries on failure, logs request progress, and returns the sanitized response content. It supports configurable model parameters such as temperature and maximum tokens, and includes error handling for HTTP and request exceptions.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\llm_client.py:summarize:c68fd60bf47667fea5c2411bdfdbeafa810731a9977c5493a833635252826262:c68fd60bf47667fea5c2411bdfdbeafa810731a9977c5493a833635252826262": "The `summarize` method generates a summary of the provided text using a specified prompt template and communicates with an LLM endpoint. It constructs a prompt from a template and the input text, checks the token count against a budget, and sends a request to the LLM with system and user messages. The method handles retries on failure, processes streaming responses, and returns the sanitized content of the LLM's response. If all retry attempts are exhausted, it raises a `RuntimeError` with the last error message.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\manual_utils.py:1a9e3f658f9a14649ee2ba63e5e339212e4e0cfa827ecc803d7ca51083a3738b:1a9e3f658f9a14649ee2ba63e5e339212e4e0cfa827ecc803d7ca51083a3738b": "The module implements functions for splitting documentation into chunks, summarizing content using an LLM client, and merging summaries into a structured user manual. It includes logic for handling token and character limits, caching responses, and managing parallel processing of document parts. The module supports different chunking strategies\u2014automatic, manual, or none\u2014and applies system prompts tailored to chunking or merging tasks. Placeholder tokens are identified and handled during the summarization process. The implementation uses a tokenizer for estimating token counts and includes error handling for network failures and chunking issues.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\manual_utils.py:_count_tokens:6e248e9c15157f87557fed2912e3c02139413c9bdcebbc63d1b677496f6ff521:6e248e9c15157f87557fed2912e3c02139413c9bdcebbc63d1b677496f6ff521": "The function `_count_tokens` takes a string input `text` and returns an integer representing the approximate number of tokens in that text. It uses a global `TOKENIZER` object to encode the text and then counts the length of the resulting encoded sequence.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\manual_utils.py:_split_text:ca0c4346dc151d406dd1880de6b05cdb9dac3cac4e574d4c2c41bde6ccd3b53a:ca0c4346dc151d406dd1880de6b05cdb9dac3cac4e574d4c2c41bde6ccd3b53a": "The function `_split_text` splits a given text into chunks based on token and character limits. It takes a string `text`, and optional parameters `max_tokens` (default 2000) and `max_chars` (default 6000). The text is first split into paragraphs using double newlines as delimiters. Each paragraph is evaluated for token and character count, and if it exceeds the limits, it is further chunked using `chunk_text`. Paragraphs are added to the current chunk until adding another would exceed either limit. When a limit is exceeded, the current chunk is finalized and added to the list of chunks, and a new chunk is started with the current paragraph. The function returns a list of text chunks that respect both token and character constraints.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\manual_utils.py:_summarize_manual:f472f46f7575293af983be4b59bf32f85ab50ed5658e9252ad26f8639891f5a1:f472f46f7575293af983be4b59bf32f85ab50ed5658e9252ad26f8639891f5a1": "The function `_summarize_manual` generates a manual summary of input text using a specified chunking strategy. It supports \"manual\", \"auto\", and \"none\" chunking modes, and employs caching to avoid recomputation. The function splits text into chunks when necessary, processes each chunk with an LLM client, and merges results hierarchically if needed. It handles errors gracefully, logs debug and info messages, and sanitizes outputs to prevent token limit issues. If the input is within limits and chunking is not required, it summarizes the entire text in one call. The function also supports a post-processing hook for modifying chunked summaries before merging.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\manual_utils.py:chunk_docs:56ba7939486e0a21ed743a6444fe9d032ebba306d646dbfb66ff2b8b3de9213f:56ba7939486e0a21ed743a6444fe9d032ebba306d646dbfb66ff2b8b3de9213f": "The function `chunk_docs` takes a list of strings (`docs`) and an optional integer parameter `token_limit` (defaulting to 2000) as inputs. It joins the non-empty strings from the input list with double newlines, then splits the resulting text into chunks of approximately `token_limit` tokens using the helper function `_split_text`. The maximum character limit for each chunk is set to three times the token limit. If the joined text is empty, it returns an empty list. Otherwise, it returns a list of chunked text strings.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\manual_utils.py:find_placeholders:be40a2c4badd57a683022c7ffe0c7b7df8a23e181f1d22a81b062020504835e0:be40a2c4badd57a683022c7ffe0c7b7df8a23e181f1d22a81b062020504835e0": "The function `find_placeholders` takes a string input `text` and returns a set of placeholder tokens found within that text. These placeholders are defined as strings matching the pattern `[[TOKEN]]`, where `TOKEN` represents the content between the double square brackets. The function utilizes a regular expression object `PLACEHOLDER_RE` to identify all occurrences of this pattern in the input text and returns them as a set, ensuring uniqueness of the found placeholders.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\parser_cpp.py:20fbb103bacaa4a0b0e1faa76ad26882965689f182fed8716afa4e58a1cc1689:20fbb103bacaa4a0b0e1faa76ad26882965689f182fed8716afa4e58a1cc1689": "Module defines a C++ file parser that extracts namespaces, classes, functions, and public variables. It processes source code line-by-line to identify structural elements and their associated documentation comments. The parser collects leading comment blocks preceding each element and captures the source code snippets for each parsed item. It handles both single-line and multi-line comment formats, including block comments delimited by `/* */`. The output structure includes module-level documentation, lists of classes with their methods and variables, and a list of functions, each containing name, signature, documentation, and source code. The parser supports class body parsing to distinguish public methods and variables based on access specifiers. It returns data in a format compatible with Python file parsing functions.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\parser_cpp.py:_extract_block:af3e8790d90d1facdae27d429248e5845dded69613dd4be6b71e7d1ccf0b0937:af3e8790d90d1facdae27d429248e5845dded69613dd4be6b71e7d1ccf0b0937": "The function `_extract_block` extracts a block of text from a list of lines starting at a specified index. It takes the starting line and continues reading subsequent lines until the number of opening braces matches the number of closing braces, indicating the end of the block. The function returns the extracted text along with the index of the last line processed.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\parser_cpp.py:_get_preceding_comment:45aababf613235060661168adcd246e0a0bf89f165423ec5af43f112342c006a:45aababf613235060661168adcd246e0a0bf89f165423ec5af43f112342c006a": "The function `_get_preceding_comment` collects contiguous comment lines that appear before a specified index in a list of code lines. It handles both single-line comments (starting with `//`) and multi-line comments (enclosed between `/*` and `*/`). The function processes lines in reverse order from the given index, extracting and formatting comment content while preserving the original structure. It returns a string containing all collected comments, joined by newlines and stripped of extraneous whitespace.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\parser_cpp.py:_parse_class_body:5a7653d143e0644d0a259c14dd1462dbdec2788f32ba210bb618bfcfccfea587:5a7653d143e0644d0a259c14dd1462dbdec2788f32ba210bb618bfcfccfea587": "The function `_parse_class_body` parses the body of a class definition from a list of source code lines and extracts public methods and variables. It takes a list of strings representing lines of code, along with start and end indices defining the range to parse. The function returns a tuple containing two lists: one for methods and one for variables. Each method is represented as a dictionary with keys for name, signature, docstring, and source code. Each variable is represented as a dictionary with keys for name, type, docstring, and source code. The function tracks access level (public, protected, private) and only processes elements marked as public. It identifies methods by detecting function signatures followed by opening braces and variables by detecting lines ending with semicolons that do not contain parentheses. Comments preceding each element are retrieved using a helper function `_get_preceding_comment`, and code blocks for methods are extracted using `_extract_block`.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\parser_cpp.py:parse_cpp_file:f9da37c21d714e06577e971f50cbd52ced38702b9b1f1354f0392b5dd1fcf31e:f9da37c21d714e06577e971f50cbd52ced38702b9b1f1354f0392b5dd1fcf31e": "The function `parse_cpp_file` parses a C++ source file and returns structured information about its contents. It reads the file as text and processes it line-by-line to extract module-level documentation, namespaces, classes, and functions.\n\nThe function identifies the module-level comment by skipping initial empty lines and comments. It tracks the current namespace if present. For each class or struct, it extracts the name, preceding documentation, source block, and nested methods and variables. For each function definition (identified by a parenthesis followed by a brace, excluding control flow statements), it captures the function signature, name, preceding documentation, and source block.\n\nThe result is a dictionary containing:",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\parser_java.py:729faf96c4d338772a690be0eaf2138a3bbdae3288180abc6c0056faa4919469:729faf96c4d338772a690be0eaf2138a3bbdae3288180abc6c0056faa4919469": "Module implements a parser for Java source files to extract package information, class definitions, public methods, and variables. It processes Java files line-by-line, identifying package declarations, class blocks, and their contents including documentation comments. The parser handles both single-line variable declarations and method signatures within classes. It supports extraction of Javadoc-style comments and line comments preceding code elements. The output structure includes module-level documentation, a list of classes with their methods and variables, and an empty functions list. Each extracted element contains its source code and associated documentation. The parser uses helper functions to manage comment extraction and block parsing for class bodies.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\parser_java.py:_extract_block:560b00ccfff0bbe6eefdd14afe6facde512c6692a918bc3ee73dcd1702309427:560b00ccfff0bbe6eefdd14afe6facde512c6692a918bc3ee73dcd1702309427": "The function `_extract_block` extracts a contiguous block of code from a list of lines, starting at a specified index. It begins with the line at `start` and continues reading subsequent lines until the brace count becomes zero or less. The brace count is calculated by summing the number of opening braces `{` and subtracting the number of closing braces `}` in each line. The function returns a tuple containing the extracted block as a string and the index of the last line processed.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\parser_java.py:_get_preceding_comment:973dc363fbb7c3257616fbd6e6ab59e00235cfe73a751eb31cae5149461921bf:973dc363fbb7c3257616fbd6e6ab59e00235cfe73a751eb31cae5149461921bf": "The function `_get_preceding_comment` extracts and returns the preceding comment block from a list of code lines up to a specified index. It handles both single-line comments (starting with `//`) and multi-line comments (enclosed in `/* */`). The function traverses the lines backward from the given index, collects relevant comment lines, and formats them into a single string with proper indentation and line breaks. If a multi-line comment is encountered, it collects all lines until the opening comment marker (`/*`) is found, then combines them into a single comment block. The function stops collecting when it encounters a non-comment line or an empty line, ensuring that only relevant comments preceding the specified line are returned.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\parser_java.py:_parse_class_body:3a11c75bd4f57b1c0cf54ce9ffebcf0b6e9b6ec9318dcfc7c33470a483204293:3a11c75bd4f57b1c0cf54ce9ffebcf0b6e9b6ec9318dcfc7c33470a483204293": "The function `_parse_class_body` extracts method and variable declarations from a list of source code lines within a specified range. It identifies public methods by checking for lines starting with \"public \", containing parentheses, and ending with a block delimiter (`{` or `{}`), extracting their signatures, docstrings, and source code. It also identifies public variables by detecting lines ending with semicolons and not containing parentheses, capturing their names, types, and associated docstrings. The function returns two lists: one of method dictionaries and another of variable dictionaries, each containing metadata such as name, signature/type, docstring, and source line.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\parser_java.py:parse_java_file:ff4f5c6b296d49b9c0658744a1f8499ce8e9806f2b1c415cb812323c25348e37:ff4f5c6b296d49b9c0658744a1f8499ce8e9806f2b1c415cb812323c25348e37": "The function `parse_java_file` reads and parses a Java source file located at the specified path, returning a dictionary containing information about the file's package, module-level documentation, classes, and functions. It processes the file line by line to identify and extract the package declaration, module docstring, and class definitions. For each class found, it extracts the class name, its docstring, methods, and variables by parsing the class body. The function uses helper functions `_get_preceding_comment`, `_extract_block`, and `_parse_class_body` to assist in extracting comments, code blocks, and class contents. The result includes a structured representation of the Java file's components, with support for nested structures such as methods and variables within classes.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\parser_matlab.py:15cf90e58e5b33528fe0fc6fa2e48fa77e43bd0fed902a29ea22b67a2f78ff68:15cf90e58e5b33528fe0fc6fa2e48fa77e43bd0fed902a29ea22b67a2f78ff68": "The module provides a parser for MATLAB `.m` files that extracts file header comments and function declarations. It reads the file content line by line, identifies leading comment blocks as the file header, and collects function definitions from the remaining content. Each function entry includes its name and a list of arguments parsed from the function signature. The parser uses regular expressions to match function declarations and handles both comma-separated and semicolon-separated argument lists. The output is a dictionary containing the extracted header text and a list of function details, where each detail includes the function name and its arguments.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\parser_matlab.py:parse_matlab_file:e4ec051b07683415ca030c17d1096b4822dafca869af8eebdf457c2fdd6900cd:e4ec051b07683415ca030c17d1096b4822dafca869af8eebdf457c2fdd6900cd": "The function `parse_matlab_file` reads and parses a MATLAB `.m` file, extracting its header comments and any function declarations. It returns a dictionary with two keys: `\"header\"`, containing the leading comment lines from the file, and `\"functions\"`, a list of dictionaries describing each function found in the file. Each function dictionary includes the function's name and a list of its arguments. The parsing process identifies functions based on the `function` keyword and captures the function name and argument list using a regular expression. Blank lines are allowed within the header comments, and arguments can be separated by either semicolons or commas.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\parser_python.py:9b7a83be6356666450a5a1a457ffe2e114b6726c1c43053f6e27962b7ce8f0aa:9b7a83be6356666450a5a1a457ffe2e114b6726c1c43053f6e27962b7ce8f0aa": "Module defines a parser for Python files that extracts structured information using the `ast` module. It processes classes and functions, capturing their signatures, docstrings, and source code segments. The parser supports nested structures, including methods within classes and subfunctions within functions. It formats function arguments and handles default values, annotations, and keyword-only parameters. The main entry point is `parse_python_file`, which reads a file and returns a dictionary containing module-level information, classes, and functions. Helper functions format argument lists and function signatures, while recursive parsing handles nested definitions.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\parser_python.py:_format_arg:aadeb9bf213cffd41d2a37d4a2dff4e9f614b1e2436231b7db76b7e679a5b39b:aadeb9bf213cffd41d2a37d4a2dff4e9f614b1e2436231b7db76b7e679a5b39b": "The function `_format_arg` takes an `ast.arg` object and returns a string representation of the argument name, optionally including its type annotation if present. If the argument has an annotation, it appends the annotation to the argument name in the format `arg_name: annotation`. If no annotation exists, it simply returns the argument name.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\parser_python.py:_format_arguments:56876f33708b1a29b47b39aa2fdd7ea18eb0331e5b75745290ba34c7c9664cf0:56876f33708b1a29b47b39aa2fdd7ea18eb0331e5b75745290ba34c7c9664cf0": "The function `_format_arguments` generates a string representation of Python function arguments defined in an abstract syntax tree (AST). It processes positional-only arguments, regular arguments, default values, *args, **kwargs, and keyword-only arguments, formatting them according to Python syntax. The function handles argument defaults by unwrapping them using `ast.unparse`, and ensures proper separation with commas. It also appends a forward slash `/` after positional-only arguments and a `*` before keyword-only arguments when needed. The result is a comma-separated string that reflects the signature of a Python function's parameter list.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\parser_python.py:_format_signature:65cd4e5ddf8405dded17f80cd7fbec7927fc1ef8a12112ebff10e5f1f333576d:65cd4e5ddf8405dded17f80cd7fbec7927fc1ef8a12112ebff10e5f1f333576d": "The function `_format_signature` generates a string representation of a function's signature from an abstract syntax tree (AST) node. It takes a function definition node (`func`) of type `ast.FunctionDef` or `ast.AsyncFunctionDef` and returns a formatted string that includes the function name, its parameters, and optional return type annotation. The parameters are processed using a helper function `_format_arguments`, and if the function has a return type annotation, it is appended to the signature with an \" -> \" prefix.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\parser_python.py:_parse_classes:07b0b0db938deb74eab4f2acf090219353bcd1546385088be53d5b78c594d0a2:07b0b0db938deb74eab4f2acf090219353bcd1546385088be53d5b78c594d0a2": "The function `_parse_classes` recursively extracts all `ClassDef` nodes from a list of AST nodes and returns a list of dictionaries containing parsed class information. It processes each node in the input list, and if the node is a class definition, it calls `parse_class` to parse the class. If the node is a function definition, it recursively parses the function's body for nested class definitions. The function supports both synchronous and asynchronous function definitions.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\parser_python.py:parse_class:349abf9b64a9a954ad177a6b32c4af300d08a3d1e3785f3a9fe53c1e76958dd8:349abf9b64a9a954ad177a6b32c4af300d08a3d1e3785f3a9fe53c1e76958dd8": "The function `parse_class` takes an AST node representing a class and the source code as input, and returns a dictionary containing information about the class. The dictionary includes the class name, its docstring, a list of methods defined within the class (parsed using `parse_function`), a list of nested subclasses (parsed using `_parse_classes`), and the source code segment corresponding to the class definition. The function processes the body of the class node, identifying function definitions and subclass definitions, and organizes them into the returned dictionary structure.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\parser_python.py:parse_classes:4c6b8bdae571ea3223dcd3ade313e6d7a8448d3930c190e025e186387a9a7b06:4c6b8bdae571ea3223dcd3ade313e6d7a8448d3930c190e025e186387a9a7b06": "The function `parse_classes` is a public wrapper that extracts class definitions from an abstract syntax tree (AST) node. It takes an AST node and the corresponding source code as input, retrieves the body of the node, and passes it to the internal `_parse_classes` function for processing. The result is a list of dictionaries containing information about the parsed classes.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\parser_python.py:parse_function:c49a2180edcd8ca572ab39049f31782c9c8451cd7cd116c749097bed122e688b:c49a2180edcd8ca572ab39049f31782c9c8451cd7cd116c749097bed122e688b": "The function `parse_function` takes an AST node representing a function or asynchronous function and the source code as input, and returns a dictionary containing information about the function. The dictionary includes the function's name, signature, return type, docstring, source code segment, and lists of nested functions and classes. It recursively processes the function body to identify and include any nested functions and classes.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\parser_python.py:parse_python_file:a2e25cfefe34c441a99613416becc49704135394e8fc4898d9dbfcf73562669e:a2e25cfefe34c441a99613416becc49704135394e8fc4898d9dbfcf73562669e": "The function `parse_python_file` takes a file path as input and parses the Python source code into a structured dictionary. It reads the file content, uses the `ast` module to parse the code into an abstract syntax tree, and extracts the module's docstring along with information about classes and functions defined at the top level of the module. For each class definition, it calls `parse_class` to extract details, and for each function or async function definition, it calls `parse_function`. The result is a dictionary containing the module docstring, a list of parsed classes, and a list of parsed functions.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\retrofit_sidebar.py:8370d6cbf5c0d9441a1d498ad822f2524357c097e7e2a0b8bbc981c22cc593a9:8370d6cbf5c0d9441a1d498ad822f2524357c097e7e2a0b8bbc981c22cc593a9": "The module implements a tool to replace documentation sidebars with hierarchical lists of modules. It scans a source directory for files, constructs a tree structure from their paths, and generates HTML unordered lists to populate sidebar elements in documentation files. The tool uses BeautifulSoup for HTML parsing and modification, and includes command-line argument parsing to specify source and documentation directories. The process involves resolving file paths, building a nested dictionary representation of the module structure, and converting this structure into HTML list elements with appropriate links. The script operates on all HTML files within the specified documentation directory, modifying their sidebar content in place.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\retrofit_sidebar.py:_paths_to_tree:ca749014ae8db3df3e4ddc8fb58e6354dfe726578a55d580f747f7c6e95bf676:ca749014ae8db3df3e4ddc8fb58e6354dfe726578a55d580f747f7c6e95bf676": "The function `_paths_to_tree` converts a list of file paths into a nested dictionary representing a directory tree structure. Each path is split into its constituent parts, and the function iteratively builds the tree by creating nested dictionaries for each directory level. The final component of each path is added as a key with a value of `None`. The resulting dictionary mirrors the hierarchical organization of the input file paths.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\retrofit_sidebar.py:_tree_to_ul:965b9c1537797aa41bdfe79b5efb5732c2b3f43d73345e48ea33d9f3417c5038:965b9c1537797aa41bdfe79b5efb5732c2b3f43d73345e48ea33d9f3417c5038": "The function `_tree_to_ul` recursively constructs an HTML unordered list (`<ul>`) from a nested dictionary structure (`tree`). It uses a `BeautifulSoup` object to create and manipulate HTML tags. Each key in the dictionary corresponds to a list item (`<li>`), with nested dictionaries generating child `<ul>` elements. For non-dictionary values, it creates an anchor tag (`<a>`) linking to an HTML file derived from the current path and filename. The `base` parameter maintains the relative path context for generating correct links. The function returns the constructed `<ul>` element.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\retrofit_sidebar.py:main:eed9a98078938bfc0cba44e65a4c33e8a7fcd35b43b55b338678c25acba44c17:eed9a98078938bfc0cba44e65a4c33e8a7fcd35b43b55b338678c25acba44c17": "The `main` function serves as the entry point for a documentation tool that replaces a documentation sidebar with a hierarchical module list. It accepts command-line arguments to specify the source code directory and documentation directory, validates that both paths exist and are directories, and then calls `retrofit_sidebar` to perform the sidebar replacement operation. The function returns an integer status code, with 0 indicating success and 1 indicating an error if either directory does not exist or is not a directory.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\retrofit_sidebar.py:retrofit_sidebar:ee4f7fab912a996c36451bfe863e9b01085e3a762e4ee5a07408b06c687aea9e:ee4f7fab912a996c36451bfe863e9b01085e3a762e4ee5a07408b06c687aea9e": "The function `retrofit_sidebar` updates HTML documentation files by replacing existing sidebars with a hierarchical list of modules. It takes the root directory of source code and the documentation directory as inputs. The function scans the source directory to identify module paths, constructs a tree structure from these paths, and then processes each HTML file in the documentation directory. For each HTML file, it locates the sidebar element, clears its contents, and populates it with a hierarchical unordered list generated from the module tree. The updated HTML content is then written back to the respective files.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\reviewer.py:4f9d422499a1acff78c67b05122179a409cbacd25a4c242442e0aef707dbeb81:4f9d422499a1acff78c67b05122179a409cbacd25a4c242442e0aef707dbeb81": "Module defines a documentation reviewer for HTML output generated by DocGen-LM. It identifies assistant-like phrasing, contradictions between summary and detected elements, and hallucinated content. The tool processes HTML files in a directory, reporting issues found. An optional autofix mode rewrites files to sanitize paragraph content using an external client function. Command-line interface accepts a directory path and an autofix flag.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\reviewer.py:_extract_tags:d11e30f1b579a1cba58ad48107f8870b4b8992d282f42451ba654a0b55f1089a:d11e30f1b579a1cba58ad48107f8870b4b8992d282f42451ba654a0b55f1089a": "The function `_extract_tags` extracts all text content enclosed within specified HTML tags from a given HTML string. It uses a regular expression pattern to match the opening and closing tags, capturing the content between them. The extracted content is returned as a list of strings, with the search being case-insensitive and capable of matching across multiple lines.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\reviewer.py:_find_line_number:14ef4f6251503da9824e032c9fc2b830138252f3dc0182d9280a0ba85647f278:14ef4f6251503da9824e032c9fc2b830138252f3dc0182d9280a0ba85647f278": "The function `_find_line_number` takes an HTML string and a search phrase as inputs. It iterates through each line of the HTML content, checking if the phrase (case-insensitively) is present in the line. If the phrase is found, it returns the line number (1-based indexing). If the phrase is not found after checking all lines, it returns -1.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\reviewer.py:_is_generated_html:6e3696415c36628134b6e49e3ac02f9f1609f7667a6d40e9109c97d5af602ad6:6e3696415c36628134b6e49e3ac02f9f1609f7667a6d40e9109c97d5af602ad6": "The function `_is_generated_html` determines whether a given HTML text appears to be output generated by DocGen-LM. It checks for the presence of specific markers within the text, including the string \"Generated by DocGen-LM\", the heading \"Project Documentation\", and patterns matching class and method headings with specific prefixes. The function returns `True` if any of these markers are found, indicating the text is likely generated documentation, and `False` otherwise.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\reviewer.py:_review_file:abdcab433a83b15723ac472be3abdc8f60f8610876f90212dc370c9db6067fd0:abdcab433a83b15723ac472be3abdc8f60f8610876f90212dc370c9db6067fd0": "The function `_review_file` takes a file path and an optional `autofix` flag, reads the file's HTML content, and checks if it was generated by examining its content. If not, it returns an empty list. Otherwise, it performs three types of checks on the HTML: assistant phrasing, contradictions, and hallucinations. Each detected issue is recorded with a corresponding label and file name. If the `autofix` flag is enabled and issues are found, the function sanitizes paragraph formatting in the HTML and writes the updated content back to the file. The function returns a list of strings describing any detected issues.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\reviewer.py:_sanitize_paragraphs:47e9a3655348e4acfaa3ed38cd91d359768f3ea8fafcef077b3694f5961e550f:47e9a3655348e4acfaa3ed38cd91d359768f3ea8fafcef077b3694f5961e550f": "The function `_sanitize_paragraphs` processes an HTML string to sanitize the content within paragraph tags. It uses a regular expression to find all paragraph elements, extracts their inner content, applies sanitization and stripping operations to that content, and then reconstructs the paragraph with the cleaned content. The function preserves the paragraph structure while ensuring the text inside is properly sanitized.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\reviewer.py:_strip_html:2ac8133fd108d6d88457bfd205a2297d5b304d3e8da21042ec29dc20e5dbbd59:2ac8133fd108d6d88457bfd205a2297d5b304d3e8da21042ec29dc20e5dbbd59": "The function `_strip_html` takes a string input `text` and removes all HTML tags from it using a regular expression. It matches any character sequence that starts with `<` and ends with `>`, including nested tags, and replaces them with an empty string, effectively stripping all HTML formatting from the input text.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\reviewer.py:check_assistant_phrasing:7f3d9ec77ef743d6318b031d1e6fb78f8a7a8dd24b56f6853a01a186c8f7a9c9:7f3d9ec77ef743d6318b031d1e6fb78f8a7a8dd24b56f6853a01a186c8f7a9c9": "The function `check_assistant_phrasing` analyzes HTML content to identify paragraphs containing assistant-like phrases. It takes an HTML string as input and returns a list of strings, each representing a found phrase along with its line number in the HTML. The function extracts all paragraph elements from the HTML, strips their HTML tags to obtain plain text, converts the text to lowercase, and checks for the presence of predefined assistant phrases. When a match is found, it records the original text and its line number in the HTML document.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\reviewer.py:check_contradictions:0b97f77e62563dafe3e392743c97f5ecc2cd648acc8c33ae64d2060c2a82145d:0b97f77e62563dafe3e392743c97f5ecc2cd648acc8c33ae64d2060c2a82145d": "The function `check_contradictions` analyzes HTML content to identify contradictions between summarized text and the actual structure of code elements. It extracts paragraphs, headings (h2 and h3), and checks for inconsistencies such as stating \"no methods\" while finding method headers, or similar mismatches for functions and classes. The function returns a list of strings describing each identified contradiction.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\reviewer.py:check_hallucinations:8ce100671fb0582505d29372c14b70634d58c45c7f06015e46bc5aad3fc22234:8ce100671fb0582505d29372c14b70634d58c45c7f06015e46bc5aad3fc22234": "The function `check_hallucinations` takes an HTML string as input and returns a list of hallucination phrases detected within the text. It extracts all paragraph elements from the HTML, strips the HTML tags from each paragraph, converts the text to lowercase, and checks for the presence of predefined terms (stored in `HALLUCINATION_TERMS`). If any of these terms are found within the text of a paragraph, they are added to the list of findings, which is then returned.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\reviewer.py:main:13c8665d9e29eb76cdd09b85afefae49d3b9c1771fc76a6896c7652ebefb6a9b:13c8665d9e29eb76cdd09b85afefae49d3b9c1771fc76a6896c7652ebefb6a9b": "The `main` function serves as the entry point for reviewing generated HTML documentation. It accepts an optional iterable of command-line arguments and uses `argparse` to parse the directory path containing the HTML output and an optional `--autofix` flag. The function calls `review_directory` with the specified directory path and the autofix option, then returns an integer status code of 0 upon completion.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\reviewer.py:repl:dbd0c5a7db5a859d86faeb6cea735946f467d4c1ead27cd7f0babbe628277225:dbd0c5a7db5a859d86faeb6cea735946f467d4c1ead27cd7f0babbe628277225": "The function `repl` takes a regex match object as input, extracts the first captured group, sanitizes it by removing HTML tags using `_strip_html`, and wraps the resulting cleaned text in an HTML paragraph tag `<p>`. It returns this formatted string.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\reviewer.py:review_directory:9fe85f43a7be764bd9d515971e7d708c17464aba7f5bdbba4e3a75c76ae94957:9fe85f43a7be764bd9d515971e7d708c17464aba7f5bdbba4e3a75c76ae94957": "The function `review_directory` processes all HTML files within a specified directory and its subdirectories. For each HTML file, it calls an internal function `_review_file` to analyze the content, optionally applying automatic fixes if the `autofix` parameter is set to True. If an error occurs while processing a file, it prints an error message and continues with the next file. The results from each file review are printed line by line.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\sanitize_docs.py:_sanitize_html:92528abda474d0ae09129afb7ed81dda5025d0e72c68db95ec0d6d60e32ce900:92528abda474d0ae09129afb7ed81dda5025d0e72c68db95ec0d6d60e32ce900": "The function `_sanitize_html` processes HTML strings to clean and sanitize content within specific HTML tags (`p`, `li`, and heading tags `h1` through `h6`). It uses a regular expression pattern to identify these tags and their content, removes nested HTML tags from the content, and applies a `sanitize_summary` function to further clean the inner text. The result is a modified HTML string where the content of the specified tags has been sanitized while preserving the tag structure.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\sanitize_docs.py:cbc2c687cd4c1464fbfe96caaeab835a5e5cff138095dc8ae251d79701b5b3d4:cbc2c687cd4c1464fbfe96caaeab835a5e5cff138095dc8ae251d79701b5b3d4": "The module provides functionality to sanitize HTML documentation files within a specified directory. It uses a regular expression pattern to identify specific HTML tags (p, li, h1-h6) and applies content cleaning through the `sanitize_summary` function from `llm_client`. The sanitized content replaces the original text within these tags. A command-line interface accepts a directory path and processes all HTML files found recursively within that directory, modifying them in place. The script exits with status code 0 upon successful completion.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\sanitize_docs.py:main:404f8fc0f1d71e0dea123df27a05e4649ba2a2492d6e3a173ea2df99a8ec8b76:404f8fc0f1d71e0dea123df27a05e4649ba2a2492d6e3a173ea2df99a8ec8b76": "The function `main` is the entry point for a command-line utility that sanitizes generated HTML documentation. It accepts an optional list of command-line arguments and uses `argparse` to define and parse a required positional argument, `directory`, which specifies the path to the HTML output directory. The function calls `sanitize_directory` with the provided directory path to perform the sanitization process. It returns an integer value of 0 upon successful completion.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\sanitize_docs.py:repl:7a4d7b1aa8095d3945b8e984966f56a72b6f490160450a12d51a0317dda9716b:7a4d7b1aa8095d3945b8e984966f56a72b6f490160450a12d51a0317dda9716b": "The function `repl` takes a regular expression match object and processes the matched groups to clean and reformat HTML content. It extracts the tag name and content from the match, removes any nested HTML tags from the content using a regular expression, sanitizes the cleaned content with the `sanitize_summary` function, and returns a new HTML tag with the sanitized content. The function is designed to be used as a replacement function in `re.sub` to process matched HTML tags and their contents.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\sanitize_docs.py:sanitize_directory:824ff0cfd5aa7a2e92364e3bdcb6834afb2021b182afd16db8bfd3a76e104de8:824ff0cfd5aa7a2e92364e3bdcb6834afb2021b182afd16db8bfd3a76e104de8": "The function `sanitize_directory` processes all HTML files within a specified directory and its subdirectories. It reads each HTML file's content, applies an HTML sanitization function `_sanitize_html` to the content, and then writes the sanitized content back to the same file, preserving the original file structure and encoding. The function operates in-place, modifying existing HTML files rather than creating new ones.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\scanner.py:_is_subpath:1c4581d8eba70832492563ec649d743913d3942fad15e09e91ecefc7a47e730a:1c4581d8eba70832492563ec649d743913d3942fad15e09e91ecefc7a47e730a": "The function `_is_subpath` determines whether a given path is equal to or located within a specified parent path. It takes two arguments: `path` and `parent`, both of type `Path`. The function attempts to compute the relative path from `parent` to `path` using the `relative_to` method. If this operation succeeds without raising a `ValueError`, it indicates that `path` is indeed a subpath of `parent`, and the function returns `True`. Otherwise, if a `ValueError` is raised, the function returns `False`.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\scanner.py:a6d2f1f5582a4ecc843b89dfb8f7747af779e8c3bbcef06f98d1c3bb16723167:a6d2f1f5582a4ecc843b89dfb8f7747af779e8c3bbcef06f98d1c3bb16723167": "Module implements source file discovery for DocGen-LM with recursive directory scanning and ignore rules. It identifies Python, MATLAB, C++, C, and Java files under a base directory while excluding specified paths and .git folders. The function accepts a base path, list of ignored relative paths, and optional progress bar display. Results are returned as sorted absolute paths to discovered source files. Includes a helper function to check if a path is within a parent directory and handles missing tqdm dependency gracefully.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\scanner.py:scan_directory:5267447659ea733c9c778cfa3be8abafd8b0699d62c1c286e8147d0046e6d1b7:5267447659ea733c9c778cfa3be8abafd8b0699d62c1c286e8147d0046e6d1b7": "The function `scan_directory` recursively searches for source code files with extensions `.py`, `.m`, `.cpp`, `.h`, and `.java` within a specified directory. It takes a base path, a list of paths to ignore, and an optional progress display flag. The function returns a sorted list of absolute paths to the discovered files, excluding those listed in the ignore parameter and skipping `.git` directories. It uses `os.walk` to traverse the directory tree and optionally displays a progress bar if requested.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\setup.py:501f48f7d373462af3d41b0caf7d7e23e2a79c5fe2886cf307b86c01a8b8d82f:501f48f7d373462af3d41b0caf7d7e23e2a79c5fe2886cf307b86c01a8b8d82f": "This module defines a setup configuration for packaging Python modules. It specifies three modules to be included in the distribution: \"explaincode\", \"parser_cpp\", and \"parser_java\". The setup function from setuptools is called with these modules listed in the py_modules parameter, indicating they should be installed as part of the package. The configuration is structured to execute only when the script is run directly as the main module.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\summarize_utils.py:4695202ac971832489d602c6dda9f1ab07cde64220a89fe58051be341bea87cc:4695202ac971832489d602c6dda9f1ab07cde64220a89fe58051be341bea87cc": "Module implements a chunked text summarization function using an LLM client and response caching. It handles large texts by splitting them into chunks when needed, summarizes each chunk, and then merges the partial summaries into a final summary. The implementation includes token budgeting to manage context window limits, fallback behaviors for failures during chunking or summarization, and recursive merging of summaries when the initial merge exceeds token limits. The function supports customizable system prompts and prompt types, with caching to avoid redundant processing of identical inputs.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\summarize_utils.py:_merge_recursive:520734ac4c5485025fc99fbe66646d882a8d2ba8118d73429ba2188b46d43073:520734ac4c5485025fc99fbe66646d882a8d2ba8118d73429ba2188b46d43073": "The function `summarize_chunked` recursively summarizes code elements by processing text in chunks, using a local LLM for summarization. It handles large inputs by breaking them into smaller parts, merging summaries, and managing token limits to ensure efficient processing. The function supports caching of responses and integrates with an LLM backend for generating documentation. It includes logic for nested merging of summaries and resumable progress tracking during documentation generation.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\summarize_utils.py:_summarize:bcb0676665e35afce5baab39c26d1206ece494e268d7d947a2f7b98c9d73a80a:bcb0676665e35afce5baab39c26d1206ece494e268d7d947a2f7b98c9d73a80a": "The function `_summarize` takes an LLM client, a response cache, a cache key, input text, a prompt type, and a system prompt as parameters. It first checks if a cached response exists for the given key. If so, it returns the cached response after sanitizing it. Otherwise, it generates a summary using the LLM client, stores the result in the cache, and then returns the generated summary.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\summarize_utils.py:summarize_chunked:e6ab32f71aa5f9b8494fca86c6fc0e9ec6734437488c33bde96ddd4312d6c9b2:e6ab32f71aa5f9b8494fca86c6fc0e9ec6734437488c33bde96ddd4312d6c9b2": "The function `summarize_chunked` generates a summary of input text by first checking if the text fits within a token budget. If it does, it directly summarizes the text using a provided LLM client and cache. If the text exceeds the token limit, it splits the text into chunks and summarizes each chunk individually. These partial summaries are then merged recursively into a final summary, ensuring that intermediate steps remain within token limits. The function handles potential errors during chunking, summarization, and merging by falling back to alternative strategies and returning sanitized output. It supports customizable prompts, system instructions, and token budgets for controlling the summarization process.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_cache.py:86aa81c1534bee80f7374373dc73e2b46ddbf6b59dc85f1dbb7004b4837537bf:86aa81c1534bee80f7374373dc73e2b46ddbf6b59dc85f1dbb7004b4837537bf": "Module defines tests for a ResponseCache class that handles caching of file summaries and progress tracking. Tests verify cache persistence through file I/O, retrieval of cached entries, handling of missing keys, and management of progress data including setting, retrieving, and clearing progress entries. The cache uses JSON file storage with key-based lookup for summaries and separate progress tracking functionality.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_cache.py:test_cache_get_missing:314426577058e41b3422c02166179d49b863087e0969a8ff2447947dd09001c6:314426577058e41b3422c02166179d49b863087e0969a8ff2447947dd09001c6": "The function `test_cache_get_missing` tests the behavior of a `ResponseCache` object when retrieving a non-existent key. It creates a `ResponseCache` instance using a temporary file path, then asserts that calling `get` with an unknown key returns `None`.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_cache.py:test_cache_round_trip:93103f509c2bf5598e123059e51c7dcc3263833ad8595ca3fcda38009ca280c5:93103f509c2bf5598e123059e51c7dcc3263833ad8595ca3fcda38009ca280c5": "The function `test_cache_round_trip` tests the round-trip functionality of a `ResponseCache` object. It creates a cache file in a temporary directory, initializes a `ResponseCache` with that file, stores a key-value pair (\"file.py\", \"content\" -> \"summary\"), and then verifies that a new `ResponseCache` instance reading from the same file can retrieve the stored value correctly. The test ensures that the cache persists data between instances and maintains data integrity.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_cache.py:test_progress_tracking:f60c01381d66e8bf29d994bed979c2f6cf6e022576adacc89079b5b54fc08dc4:f60c01381d66e8bf29d994bed979c2f6cf6e022576adacc89079b5b54fc08dc4": "The function `test_progress_tracking` tests the progress tracking functionality of the `ResponseCache` class. It creates a cache file in a temporary directory, initializes a `ResponseCache` object with that file, and sets a progress entry for a module with a specified path and summary. It then verifies that the progress entry can be retrieved correctly from a new instance of `ResponseCache` initialized with the same file. Finally, it clears the progress and confirms that the cache is empty. The test ensures that progress tracking persists across cache instances and can be cleared as expected.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_chunk_utils.py:eefe3cf76f5068de7a8511c465b25cf82a54fa62b999afa7871de7ddb1327afb:eefe3cf76f5068de7a8511c465b25cf82a54fa62b999afa7871de7ddb1327afb": "The module defines a set of tests for text tokenization and chunking functionality. It verifies that a tokenizer correctly encodes and decodes text, removing specific formatting tokens during decoding. It also tests the chunking utility to ensure it reconstructs content accurately, splits markdown headings properly, and preserves code block formatting across chunks. The tests use a consistent tokenizer obtained from a utility function and validate both tokenization behavior and chunking logic.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_chunk_utils.py:test_chunk_text_preserves_code_blocks:1b7331824fdb66b94bfbf5a1ca63e816bcc50e89c6eb4efa4a64adb7158f1a15:1b7331824fdb66b94bfbf5a1ca63e816bcc50e89c6eb4efa4a64adb7158f1a15": "The function `test_chunk_text_preserves_code_blocks` tests that text chunking preserves code blocks. It uses a tokenizer to split input text into chunks of a specified size while ensuring that code blocks enclosed in triple backticks remain intact. The test verifies that at least one chunk contains the complete code block and that each chunk either contains no backticks or exactly two backticks, maintaining the integrity of code block formatting during the chunking process.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_chunk_utils.py:test_chunk_text_reconstructs_content:91f9261c766955a22cf7ed3393ab2b0f33265a69cbb00d4ae5983f7c6dbefa2f:91f9261c766955a22cf7ed3393ab2b0f33265a69cbb00d4ae5983f7c6dbefa2f": "The function `test_chunk_text_reconstructs_content` tests the functionality of text chunking by verifying that when a text string is split into chunks using a specified token limit, the original content can be accurately reconstructed. It uses a tokenizer to process the text, splits it into chunks of 10 tokens each, and asserts that joining the chunks recreates the original stripped text. The test also ensures that the text is divided into more than one chunk.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_chunk_utils.py:test_chunk_text_splits_markdown_headings:13856d4caf377911c92ce1de63aee1a898f50adb69752f8d51a531cd4f519a2e:13856d4caf377911c92ce1de63aee1a898f50adb69752f8d51a531cd4f519a2e": "The function `test_chunk_text_splits_markdown_headings` tests the behavior of the `chunk_text` function when processing Markdown-formatted text containing headings. It verifies that the text is correctly split into chunks based on the specified token limit, ensuring each chunk begins with the appropriate heading. The test uses a tokenizer to determine token counts and asserts that the resulting chunks match the expected number and content.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_chunk_utils.py:test_get_tokenizer_roundtrip:005340408603c77f7a47370e26a5b71b1b2f777cc3bdcd06d4ccb277536f73f4:005340408603c77f7a47370e26a5b71b1b2f777cc3bdcd06d4ccb277536f73f4": "The function `test_get_tokenizer_roundtrip` tests the round-trip functionality of a tokenizer. It retrieves a tokenizer using `get_tokenizer()`, encodes the string \"hello world\" into tokens, verifies that the result is a list, then decodes the tokens back into text. Finally, it asserts that the decoded text, with whitespace stripped, matches the original input string \"hello world\".",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_chunk_utils.py:test_get_tokenizer_strips_fim_tokens:15e9a1513aae5b20f3266cf65cd4a48605e953f484ad5a32d0f1aeeaf6ca5832:15e9a1513aae5b20f3266cf65cd4a48605e953f484ad5a32d0f1aeeaf6ca5832": "Tests that the tokenizer removes FIM (Fill-In-the-Middle) tokens from encoded text. The function retrieves a tokenizer, encodes a string containing FIM tokens, decodes the resulting tokens, and verifies that the decoded output does not contain any FIM token markers and matches the expected clean text \"hello world\".",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_docgenerator.py:bd93d1343982129d654c006ec965a99e35d08b1cc647b7560f7fcc9a9e98b43b:bd93d1343982129d654c006ec965a99e35d08b1cc647b7560f7fcc9a9e98b43b": "Module defines test cases for a documentation generator tool. Tests cover handling of invalid Python files, generation of class and function summaries, skipping non-UTF8 files, sanitization of project summaries, use of README content, cleaning output directories, chunked text summarization, prompt overhead handling during chunking, recursive merging of long texts, atomic function chunking, splitting large classes by methods, subclass method processing, and support for C++ and Java file types. Tests utilize mocking of LLMClient and related functions to isolate functionality and verify correct behavior under various conditions.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_docgenerator.py:fake_sum:15d14219ba9a261bfcc6869fcb877409ee90af38e7860613092748715bb2e1b7:15d14219ba9a261bfcc6869fcb877409ee90af38e7860613092748715bb2e1b7": "The function `fake_sum` is designed to generate a fake summary for a given text argument based on the specified prompt type. It retrieves a template from `PROMPT_TEMPLATES` corresponding to the provided `prompt_type`, defaulting to the \"module\" template if the type is not found. The function calculates the number of available tokens by subtracting the token count of the system prompt and the template from the maximum context tokens. It asserts that the input text argument fits within the available token limit. If the prompt type is \"module\", it returns a long fake summary consisting of repeated \"long \" strings. For all other prompt types, it returns a short fake summary consisting of the string \"short\". The function uses a tokenizer to encode prompts and text for token count calculations.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_docgenerator.py:fake_sum:b15123bff2448891c3f2dcf3f3b5965522cfa2ecff4e06862d3b141f20544bb1:b15123bff2448891c3f2dcf3f3b5965522cfa2ecff4e06862d3b141f20544bb1": "The function `fake_sum` generates a fake summary for a given text argument based on the specified prompt type. It retrieves a prompt template from `PROMPT_TEMPLATES` using the `prompt_type`, calculates the token overhead of the system prompt and template, and determines the available tokens for the input text. It asserts that the input text fits within the available token limit. If the prompt type is \"module\", it returns a repeated string of \"summary \". Otherwise, it returns the string \"short\". The function appears to be a placeholder or mock implementation for testing purposes.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_docgenerator.py:test_chunking_accounts_for_prompt_overhead:29bf7b7155975734f8fd43f759aa9b64737245e2e4de366d5cdc61419cc69eb7:29bf7b7155975734f8fd43f759aa9b64737245e2e4de366d5cdc61419cc69eb7": "The function `test_chunking_accounts_for_prompt_overhead` tests that text chunking in the `summarize_chunked` utility accounts for prompt overhead when determining chunk sizes. It sets up a tokenizer, creates a sample text, and configures a cache. Using a mocked summary function, it verifies that the text is split into multiple chunks by checking that the mock is called more than once, ensuring that the prompt overhead is properly considered in the token budget calculation.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_docgenerator.py:test_clean_output_dir:79f93790086fcc19a988271efac7bf1a6f60ee8c1b411bfa3717614905ee75cd:79f93790086fcc19a988271efac7bf1a6f60ee8c1b411bfa3717614905ee75cd": "The function `test_clean_output_dir` tests the `clean_output_dir` function from the `docgenerator` module. It creates a temporary directory structure with an output folder containing files generated by DocGen-LM (marked with a specific comment) and other custom files. The test verifies that `clean_output_dir` removes only the files generated by DocGen-LM while preserving custom files and assets. The assertion confirms that the generated file is deleted, while the custom HTML and CSS files remain in the output directory.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_docgenerator.py:test_generates_class_and_function_summaries:fa2131509ee4bc4a64d8a3eed11151d6cb9211dbf750bea591f3339f11e72cee:fa2131509ee4bc4a64d8a3eed11151d6cb9211dbf750bea591f3339f11e72cee": "This function tests the generation of class and function summaries within a Python project documentation process. It creates a temporary project directory with a Python module containing a class and a function, then invokes the main documentation generation function with mocked LLM responses. The test verifies that the generated HTML output includes expected summary text for the class and function, as well as a module summary in the index page. The function asserts successful execution (return code 0) and checks that specific summary content appears in the generated documentation files.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_docgenerator.py:test_handles_class_without_docstring:dd83635b86f473740428af906aba414fe033820f0fd50460ef46067953d6f7aa:dd83635b86f473740428af906aba414fe033820f0fd50460ef46067953d6f7aa": "This function tests the handling of a class without a docstring during documentation generation. It creates a temporary project directory with a Python module containing a class named `Foo` that has no docstring. The test then invokes the main documentation generation function, simulating LLM responses for module, project, and class summaries. It verifies that the generated HTML output includes the class summary and that the main function returns successfully (exit code 0). The test uses mocking to simulate the LLM client behavior and ensures proper integration of the documentation generation process with the LLM-based summarization.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_docgenerator.py:test_merge_recurses_when_prompt_too_long:1fec231ff5600fe2005224e98a3a27747de75181f2725ae5b181b37f664a7afd:1fec231ff5600fe2005224e98a3a27747de75181f2725ae5b181b37f664a7afd": "This function tests the recursive merging behavior of the `summarize_chunked` function when the prompt exceeds the maximum context length. It sets up a mocked environment with a fake summarization function that enforces token limits, then verifies that multiple merge operations are performed by checking the number of calls made to the summarization function with the \"docstring\" prompt type. The test ensures that chunking and recursive merging occur correctly when the input text is long enough to require multiple processing steps.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_docgenerator.py:test_processes_cpp_file:9cfa9ec2f06c18267266f7e460ea2dbb9f6e86eca3525c9ccf9a4cd0775412c0:9cfa9ec2f06c18267266f7e460ea2dbb9f6e86eca3525c9ccf9a4cd0775412c0": "This function tests the processing of a C++ file by mocking the parsing and LLM client components. It creates a temporary project directory with a C++ source file, sets up expected parsed output for a class containing a variable, and mocks the `parse_cpp_file` function and `LLMClient` to simulate successful documentation generation. The test verifies that the main function executes without error, the parser is called once, and the resulting HTML documentation file is created in the specified output directory.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_docgenerator.py:test_processes_java_file:22aa2a7eb56582335c5e184218d7900e1f8d8e0b00750f7ca84e4fab55756545:22aa2a7eb56582335c5e184218d7900e1f8d8e0b00750f7ca84e4fab55756545": "The function `test_processes_java_file` tests the processing of a Java source file by the documentation generator. It creates a temporary project directory with a simple Java class `Foo` containing a public variable and method. The test mocks the `parse_java_file` function to return a predefined parsed structure and mocks the `LLMClient` to simulate successful communication and summarization. It then calls the main function with the project and output directories as arguments, asserting that the main function returns zero (indicating success), the parser is called once, and the resulting HTML documentation file (`Mod.html`) is created in the output directory.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_docgenerator.py:test_project_summary_is_sanitized:2d1669094774a4832780ecbce8a6aca9278163f9647c0db45a9f36482c91c042:2d1669094774a4832780ecbce8a6aca9278163f9647c0db45a9f36482c91c042": "This function tests that the project summary generated by the documentation generator is properly sanitized. It creates a temporary project directory with a Python module containing a function, then runs the main documentation generation process with a mocked LLM client. The test verifies that the resulting HTML output does not contain certain unsanitized strings (like \"You can run this\") and instead contains expected sanitized content (like \"It prints.\"), while also confirming that the LLM was called to summarize the project. The function ensures that the documentation generation process properly sanitizes output content before rendering it in the final HTML documentation.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_docgenerator.py:test_readme_summary_used:6c6f018b68e7384a2567e368946f132151519ca5a6250090dbf1e381ea631cd5:6c6f018b68e7384a2567e368946f132151519ca5a6250090dbf1e381ea631cd5": "",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_docgenerator.py:test_single_long_partial_is_recursively_chunked:a03cc084e0e71ae8d6bb47e28364759aa3fef1a538c0aba0e0b2f06384f780a3:a03cc084e0e71ae8d6bb47e28364759aa3fef1a538c0aba0e0b2f06384f780a3": "This function tests that a long text input is recursively chunked during the summarization process when the token limit is exceeded. It sets up a mock environment with a fake summarization function that enforces token limits, then calls `summarize_chunked` with a text that exceeds the context size. The test verifies that the `docstring` prompt type is used in multiple calls to the mock summarizer, indicating recursive chunking occurred.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_docgenerator.py:test_skips_invalid_python_file:f0b070149e4b34f8208a1adaf9a5f1facd3edf3b659087f90d33d2ef94770798:f0b070149e4b34f8208a1adaf9a5f1facd3edf3b659087f90d33d2ef94770798": "This function tests the handling of a Python file with invalid syntax during documentation generation. It creates a temporary project directory containing a file with a syntax error (leading zero in integer literal), then invokes the main documentation generation function with mocked LLM client responses. The test verifies that the process completes successfully (return code 0) and that only the index page is generated, while the invalid file's documentation page is skipped.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_docgenerator.py:test_skips_non_utf8_file:15d6a4d3d57e11ba43dc7ea4b1de36c684601eef4534713e8ff5f09aad4d993c:15d6a4d3d57e11ba43dc7ea4b1de36c684601eef4534713e8ff5f09aad4d993c": "This function tests that the documentation generator correctly skips files that are not UTF-8 encoded. It creates a temporary project directory with a non-UTF-8 file (`bad.py`) and runs the main documentation generation process. The test verifies that the process completes successfully (return code 0) and that the output directory contains an `index.html` file but does not contain a `bad.html` file for the invalid UTF-8 file. The test mocks the LLM client to simulate successful communication with the language model.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_docgenerator.py:test_structured_chunker_keeps_functions_atomic:553f179d6c63f24444519c13d0dbed5ea58fa86d5af80fdf988a913ebad37de2:553f179d6c63f24444519c13d0dbed5ea58fa86d5af80fdf988a913ebad37de2": "This function tests that the structured chunker maintains atomicity of functions when processing Python source code. It creates a temporary Python file containing two functions, parses the file, and then uses a mocked summarization function to verify that each function is processed as a separate chunk. The test ensures that the `_summarize_module_chunked` function correctly separates and processes individual functions without merging their content, by checking that the number of chunks matches the number of functions and that each chunk corresponds to the source of a function.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_docgenerator.py:test_structured_chunker_splits_large_class_by_method:e2a83b4631fee2e0e41e2d2d50037c7bf9c8a81dc720e7cd7829ea5c7d4b1122:e2a83b4631fee2e0e41e2d2d50037c7bf9c8a81dc720e7cd7829ea5c7d4b1122": "This function tests the behavior of `_summarize_module_chunked` when processing a Python class that exceeds the token budget for summarization. It creates a temporary Python file containing a class with two methods, parses the file, and then invokes the chunked summarization function with a limited token budget. The test verifies that the class is split into individual method chunks and that each method's source code is passed to the summarization function exactly once. The test uses a mocked version of `_summarize` to capture the arguments passed to it and ensures that the number of chunks matches the number of methods and that the content of the chunks corresponds to the methods' source code.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_docgenerator.py:test_subclass_methods_are_summarized:767bfdbd3bf2a2e6ac4d67668e3fab6a86ed722e81600fe0a945df135cfe0d6b:767bfdbd3bf2a2e6ac4d67668e3fab6a86ed722e81600fe0a945df135cfe0d6b": "This function tests that methods within nested subclasses are properly summarized during the documentation generation process. It creates a temporary Python project structure with a class `A` containing a nested class `B` with a method `m`. The test mocks the LLM client and summarization functions to simulate documentation generation, then verifies that the method `B:m` is included in the arguments of a call to `_summarize_chunked`, ensuring that nested subclass methods are processed for documentation.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_docgenerator.py:test_summarize_chunked_splits_long_text:b6f88fb8cb67ec0f5ba0d6aac5da684febe1770cdff961ab39c22892a0a6867b:b6f88fb8cb67ec0f5ba0d6aac5da684febe1770cdff961ab39c22892a0a6867b": "The function `test_summarize_chunked_splits_long_text` tests the behavior of the `summarize_chunked` utility when processing a long text input. It verifies that the text is properly split into chunks and that the summarization process is invoked multiple times, indicating chunking. The test uses a mocked summary function to ensure that the chunking logic is exercised without making actual LLM calls. It sets up a tokenizer, creates a long text string, initializes a response cache, and then calls `summarize_chunked` with specific parameters including a small token budget to force chunking. The assertion confirms that the mock summarization function was called more than once, demonstrating that the input text was split into multiple chunks for processing.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_docgenerator_subclasses.py:a9e56fb250c2146bacd150cd8d89d139b9ef4116bbde468ba21945e1b4b4b5b1:a9e56fb250c2146bacd150cd8d89d139b9ef4116bbde468ba21945e1b4b4b5b1": "Test function that verifies documentation generation for nested class methods. Creates a temporary project structure with a nested class containing a method, then runs the docgenerator main function to produce HTML documentation. The test checks that the generated HTML contains expected summary text for both the nested class and its method, confirming proper documentation extraction and formatting. Uses mocking to simulate LLM client behavior without external dependencies.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_docgenerator_subclasses.py:test_subclass_docs_and_method_summary:18c804623e4e8e28e0370dc74b7484e6cc687321a865adb91730bf6af984e715:18c804623e4e8e28e0370dc74b7484e6cc687321a865adb91730bf6af984e715": "This function tests the documentation generation for a nested class structure in a Python module. It creates a temporary project directory with a Python file containing a class `A` that includes a nested class `B`, which has a method `m`. The test uses a mocked LLM client to simulate summarization responses and runs the main documentation generation function on the project directory. It verifies that the generated HTML output correctly includes summaries for both the nested class `B` and its method `m`, ensuring proper handling of nested structures in the documentation process.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:810610c86fdad6781acb74ecd58be99f6da6b185b3eb5ed893fd2d2a572e7ebe:merge0:b8f788ce47e7afdaacdf8f2f1e6ae7a502af8d18357e3fe5d1fd0092ad2772ec": "This module defines a comprehensive test suite for a documentation generation tool, covering functionality across multiple document formats including markdown, HTML, DOCX, and Python files. The tests validate text extraction while preserving formatting, heading preservation in DOCX documents, HTML rendering with table of contents and sources, manual summary creation with LLM integration, PDF output generation, and graceful handling of missing dependencies. Key test areas include document collection with filtering, evidence mapping with priority and limits, placeholder detection, manual parsing with inferred sections, reference validation, section inference logic, snippet extraction with size limits, and code scanning that skips non-source directories. The test suite employs mocked LLM clients, temporary file structures, and various file formats while utilizing fixtures for creating test data and mocking external dependencies. Additional tests focus on code documentation generation functionality including snippet categorization, file ranking with language-specific patterns, LLM placeholder filling with logging, code scanning behavior with different flags, manual generation with fallback mechanisms, and output file handling such as index insertion. The suite also verifies automatic chunking and summarization logic in manual documentation generation, confirming multiple LLM calls during chunking, proper system prompts for chunk and merge operations, logging of chunking steps, application of post-processing hooks, parallel execution of chunk summaries, hierarchical merging with",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:810610c86fdad6781acb74ecd58be99f6da6b185b3eb5ed893fd2d2a572e7ebe:part0:5516db775b429103a40dd2a03a766cbe0e39e0bdb1b12007edef2db075c1950b": "Module defines test functions for a documentation generation tool. Tests cover markdown and HTML text extraction preserving formatting, DOCX heading preservation, HTML rendering with table of contents and sources, manual summary creation with LLM integration, PDF output generation, graceful handling of missing dependencies, custom output directory usage, document collection with filtering, evidence mapping with priority and limits, placeholder detection, manual parsing with inferred sections, reference validation, section inference logic, snippet extraction with size limits, and code scanning that skips non-source directories. Tests use mocked LLM client, temporary file structures, and various file formats including markdown, HTML, DOCX, and Python files. Test suite includes fixtures for creating test data and mocking external dependencies.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:810610c86fdad6781acb74ecd58be99f6da6b185b3eb5ed893fd2d2a572e7ebe:part1:f6168ffd0c53de3b16c7a9eebf313f1905a2585db880dd3c97d8a20c97080ce6": "Module defines test cases for code documentation generation functionality. Tests cover snippet categorization, file ranking with language-specific patterns, LLM placeholder filling with logging, code scanning behavior with various flags, manual generation with fallback mechanisms, and output file handling including index insertion. Tests validate behavior with mocked LLM clients, code extraction functions, and file system operations. Test scenarios include skipping code scans, forcing code analysis, custom naming, and inserting generated documentation into HTML indexes.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:810610c86fdad6781acb74ecd58be99f6da6b185b3eb5ed893fd2d2a572e7ebe:part2:5dfbe796adcac882bd0d312874f74c28a44bac3c22859ff2d0e1b88a8ca6b599": "Tests verify behavior of automatic chunking and summarization logic in manual documentation generation. Tests confirm multiple LLM calls during chunking, proper system prompts for chunk and merge operations, logging of chunking steps, application of post-processing hooks, parallel execution of chunk summaries, hierarchical merging with logging, reuse of cached chunk results, disabling of LLM calls when chunking is set to none, and sanitization of output before caching.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:Dummy:271bdb0dbdf5fa1ff318bf7cab2e2864a5b2545f19e9944109ed716f0abf38d6:271bdb0dbdf5fa1ff318bf7cab2e2864a5b2545f19e9944109ed716f0abf38d6": "The `Dummy` class provides a placeholder implementation of the `summarize` method that returns a fixed response format regardless of input. It is designed to mock or stub out the summarization functionality for testing or demonstration purposes. The method accepts text, prompt type, and an optional system prompt but ignores them in favor of returning a predetermined output.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:Dummy:28fe295d68ce94f7d01781f9dec603ab83dd0f6f7778a8aaa3cb4cea3500f012:28fe295d68ce94f7d01781f9dec603ab83dd0f6f7778a8aaa3cb4cea3500f012": "The `Dummy` class is designed to track method calls by storing information about each call in a list. Each call consists of a dictionary containing the text, prompt type, and optional system prompt. The class provides functionality to initialize this tracking list and append new call data through its `summarize` method.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:Dummy:2ba37a6815cf27a2a34009316d5fc96774bfd246474ba02212fe619af890f719:2ba37a6815cf27a2a34009316d5fc96774bfd246474ba02212fe619af890f719": "The `Dummy` class is designed to track and process documentation generation calls by storing details about each call in a list. It summarizes input text by either returning the first word or the string \"final\", depending on the system prompt used. The class serves as a simple mock implementation for testing or demonstration purposes within the documentation generation framework.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:Dummy:3313816b69c05354b8eb0673311163443306741bfb8558919092db189d12d86e:3313816b69c05354b8eb0673311163443306741bfb8558919092db189d12d86e": "The `Dummy` class is designed to track and respond to summarization requests by storing details of each request in an internal list. It evaluates the number of stored requests to determine whether to return a large or short response. The class serves as a mock implementation for testing or demonstration purposes within the documentation generation system.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:Dummy:73f90e08216a5bec2ce426a2d3870ca8fb3c12a743672c8fc5a2e8de4d3fae88:73f90e08216a5bec2ce426a2d3870ca8fb3c12a743672c8fc5a2e8de4d3fae88": "The `Dummy` class is designed to track method calls by storing information about each call in a list. Each call consists of a dictionary containing text, prompt type, and system prompt. The class provides a way to summarize these calls by returning a formatted response string based on the number of times the method has been invoked.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:Dummy:__init__:db3b131b0ba0f8c19da82c36415f2aba4b713baca985cf65bbd5285ae3759683:db3b131b0ba0f8c19da82c36415f2aba4b713baca985cf65bbd5285ae3759683": "Initializes an instance with an empty list to store call records.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:Dummy:__init__:f73a3a572424de85bb41637ddb7e178958076e112fc4185ac0cea64dae24f819:f73a3a572424de85bb41637ddb7e178958076e112fc4185ac0cea64dae24f819": "Initializes an instance with an empty list to store string calls.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:Dummy:a241afdfd1c3be3206f56cf7749c0fcbe1ed22a3153f404848ecd97eaadff7eb:a241afdfd1c3be3206f56cf7749c0fcbe1ed22a3153f404848ecd97eaadff7eb": "The `Dummy` class provides a stub implementation of a summarization method that returns a fixed, formatted summary string containing structured information about a demo project. The method takes text input and prompt parameters but does not perform actual summarization, instead returning a predefined template with sections like overview, purpose, and examples. This implementation is marked as a simple stub not subject to coverage analysis.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:Dummy:b694edfb03ff0db9bdc491ba07898de20cddfa99980aa43ff8919fe9d8d05313:b694edfb03ff0db9bdc491ba07898de20cddfa99980aa43ff8919fe9d8d05313": "The `Dummy` class processes input text through its `summarize` method, which behaves differently based on the system prompt content. When the system prompt contains \"How to Run\", it returns \"[[NEEDS_RUN_INSTRUCTIONS]]\". When the prompt contains \"enhancing a user manual\", it extracts manual text and replaces \"[[NEEDS_RUN_INSTRUCTIONS]]\" with \"use it\". For all other cases, it simply returns \"x\".",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:Dummy:bb1d68253c645c375951dc8b0eafb40acf6314696d250ca55dd260b3eaf2a147:bb1d68253c645c375951dc8b0eafb40acf6314696d250ca55dd260b3eaf2a147": "The `Dummy` class is designed to track and process call-related information through a list named `calls`. It includes functionality to summarize text by extracting manual section placeholders, replacing them with formatted section identifiers, and maintaining a record of processed inputs. The class supports parsing and manipulation of text containing \"Manual:\" markers and associated section identifiers for documentation generation purposes.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:Dummy:summarize:04a59d6003fc253b7f2d197a32f616e7ff915453a9f3c57ff82078a51f5298ad:04a59d6003fc253b7f2d197a32f616e7ff915453a9f3c57ff82078a51f5298ad": "Function that processes text input to extract and replace placeholders within manual content. Takes a text string, extracts manual text and section information using regular expressions, looks up a placeholder token based on the section, and returns the manual text with the placeholder replaced by a formatted string indicating the section was filled. Maintains a log of all processed texts in a calls list attribute.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:Dummy:summarize:1c3485ae9fe25b29483150d67603501ed1568172205d21f4e8e3ad17380a22ba:1c3485ae9fe25b29483150d67603501ed1568172205d21f4e8e3ad17380a22ba": "Function that returns a fixed summary template string for demonstration purposes, with parameters for text input, prompt type, and system prompt, though the implementation ignores these parameters and always returns the same hardcoded template.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:Dummy:summarize:217d7857c10f60dee6126555c95ee6d774f7a1b5efbbbdd871b2a614670d17b5:217d7857c10f60dee6126555c95ee6d774f7a1b5efbbbdd871b2a614670d17b5": "Function that takes text input, prompt type, and optional system prompt, then returns a fixed string response containing an overview and placeholder for run instructions.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:Dummy:summarize:627a4b48b32e053af1c9d6db437401aed7de4fd5255c5f50926bd373bb5437df:627a4b48b32e053af1c9d6db437401aed7de4fd5255c5f50926bd373bb5437df": "Function that records text input and associated metadata into a calls list, then returns a response identifier string.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:Dummy:summarize:78ccf80460220118714ea1885eb918e683c83a410b4d03b70aba859a0dca3596:78ccf80460220118714ea1885eb918e683c83a410b4d03b70aba859a0dca3596": "Function that processes text based on prompt type and system prompt content. Returns specific string values depending on whether the system prompt contains \"How to Run\" or \"enhancing a user manual\" keywords. When \"How to Run\" is present, returns \"[[NEEDS_RUN_INSTRUCTIONS]]\". When \"enhancing a user manual\" is present, extracts and processes manual text from the input using regex pattern matching. Returns \"x\" for all other cases.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:Dummy:summarize:ab3f0d9d1c4bec0b699e9e6bebc3161c380bb9121133d634c1d756b9c006db22:ab3f0d9d1c4bec0b699e9e6bebc3161c380bb9121133d634c1d756b9c006db22": "Function that records input parameters in a calls list and returns the string \"done\".",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:Dummy:summarize:ae1d725d03a5a0cb10695a524606bf4c5e3d8c46e6bdd9c322aaf858f0a24d53:ae1d725d03a5a0cb10695a524606bf4c5e3d8c46e6bdd9c322aaf858f0a24d53": "Function that processes text input by appending call details to an internal list and returns either a fixed string \"final\" or the first word of the input text, depending on whether the provided system prompt matches a specific merge prompt constant.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:Dummy:summarize:cf774a300e22d141c142741d0a158680f066f47fffaea7025f0b4ff13e3ff041:cf774a300e22d141c142741d0a158680f066f47fffaea7025f0b4ff13e3ff041": "Function that appends call information to an internal list and returns different string values based on the number of calls recorded.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:SlowClient:3c3d3ac72ae7142ff55f8f74818a8ea176ddb4b58845b2cd0920cda9fedfec1c:3c3d3ac72ae7142ff55f8f74818a8ea176ddb4b58845b2cd0920cda9fedfec1c": "The `SlowClient` class implements a method called `summarize` that introduces a delay when processing specific system prompts, likely for rate limiting or throttling purposes. The method checks if the provided system prompt matches a predefined constant and pauses execution accordingly before returning a fixed string value. This functionality suggests the class is designed to control the pace of documentation generation tasks.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:SlowClient:summarize:81215f77b5bdc963253a5febc2f86ef614ee2b32b6c5e3234bc2546fea2dcbc1:81215f77b5bdc963253a5febc2f86ef614ee2b32b6c5e3234bc2546fea2dcbc1": "Function that processes text summarization with conditional delay based on system prompt matching, returning a fixed string response.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:Stub:b58965aa3aa5602c02803318f8bda19e0be834c99081c6744c8eb027731fd385:b58965aa3aa5602c02803318f8bda19e0be834c99081c6744c8eb027731fd385": "The `Stub` class contains a placeholder implementation of the `summarize` method that currently returns the fixed string \"guessed\" regardless of input parameters. The method accepts a prompt string, prompt type string, and optional system prompt string but does not perform any actual summarization logic. This class serves as a temporary or dummy implementation within the documentation generation system.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:Stub:summarize:34289b97bd6fbcae70ecb22cbadd55985049de1c9d992c034e8b3c85990fb396:34289b97bd6fbcae70ecb22cbadd55985049de1c9d992c034e8b3c85990fb396": "This function accepts a prompt string, prompt type string, and an optional system prompt string as parameters, and returns the literal string \"guessed\" regardless of the input values provided.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:__init__:25de46e8b1f6afc5c9ffaf4ef65050082c0b988b087898bd9a6db6f15e896009:25de46e8b1f6afc5c9ffaf4ef65050082c0b988b087898bd9a6db6f15e896009": "The `__init__` method initializes an instance of the `Dummy` class. It sets up an attribute named `calls`, which is initialized as an empty list of strings. This list is intended to store call-related information as strings.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:__init__:506f65b8fa948103c159a770e71244d36107382b3bbaef63d9a14ffea716e91b:506f65b8fa948103c159a770e71244d36107382b3bbaef63d9a14ffea716e91b": "The `__init__` method initializes an instance of the `Dummy` class. It sets up an attribute named `calls`, which is initialized as an empty list. This list is intended to store dictionaries, although the specific structure of these dictionaries is not defined within this method. The method does not accept any parameters other than the implicit `self` reference.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:_create_fixture:11f93b4ff8717a802b4b16d0483f8404b66427fc1fcd8d67da6b049df0cc0fa8:11f93b4ff8717a802b4b16d0483f8404b66427fc1fcd8d67da6b049df0cc0fa8": "Creates a test fixture directory structure with nested subdirectories and sample files. The function generates a nested directory path, creates an HTML file containing a basic HTML document with a heading, writes a README.md file with structured documentation content including sections for overview, purpose, usage, inputs, outputs, requirements, and examples, and creates a sample JSON file with basic data. All files are written using UTF-8 encoding within the specified temporary path structure.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:_mock_llm_client:fd61e38a7165ad89f43e014fbae344a07746161b319ce57f45a8f472ef4fdca6:fd61e38a7165ad89f43e014fbae344a07746161b319ce57f45a8f472ef4fdca6": "The function `_mock_llm_client` returns a dummy object that simulates an LLM client for testing purposes. The returned object implements a `summarize` method which takes a text string, a prompt type, and an optional system prompt, and returns a fixed, formatted summary string. This stub implementation is used to avoid actual LLM calls during testing or development.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:fake_extract:8b67e77016ef5bf43402052cf6dc97dda833b3f6ce19b05fc190cb3962666e96:8b67e77016ef5bf43402052cf6dc97dda833b3f6ce19b05fc190cb3962666e96": "The function `fake_extract` takes an iterable of file paths, along with parameters limiting the number of files, time budget, and maximum bytes. It increments a counter in the global `tracker` dictionary under the key \"extract\", then returns a dictionary mapping the first file in the input iterable to the string \"code\". The function does not actually process or read the files; it provides a placeholder implementation for extraction.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:fake_extract:d3d6c4e23da33c6766892a1b45805674fbc5cb28e6f962e6da1b75db7d323ee6:d3d6c4e23da33c6766892a1b45805674fbc5cb28e6f962e6da1b75db7d323ee6": "The function `fake_extract` takes an iterable of file paths and returns a dictionary mapping each file path to the string \"run code\". It updates a global `tracker` object with extraction statistics, including the number of extractions, provided keyword arguments, and a list of scanned files up to the specified maximum. The function processes only the first `max_files` items from the input iterable, regardless of the total number of files provided.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:fake_extract:d543e0b4f27d27a199d21d5fa9a1261d8b58993296078f2fa931dce689aae070:d543e0b4f27d27a199d21d5fa9a1261d8b58993296078f2fa931dce689aae070": "The function `fake_extract` takes an iterable of file paths and several configuration parameters, then increments a counter in a global `tracker` dictionary under the key \"extract\" and returns an empty dictionary. It does not perform any actual file extraction or processing.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:fake_extract:ecfa4f2645d180dce173b1763fc9e9417bc1b52cf1c46426d5a1a7c8a5840864:ecfa4f2645d180dce173b1763fc9e9417bc1b52cf1c46426d5a1a7c8a5840864": "The function `fake_extract` takes an iterable of file paths and several configuration parameters, then returns a dictionary mapping the first three paths to predefined string descriptions. The parameters `max_files`, `time_budget`, and `max_bytes` are unused in the implementation. The returned dictionary maps each of the first three paths to a fixed description: \"read input from user\", \"write output\", and \"run the tool\".",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:fake_rank:36d1063043e9725b25dec1a9597fd395b26a0294c68316526167b921dc081157:36d1063043e9725b25dec1a9597fd395b26a0294c68316526167b921dc081157": "The function `fake_rank` takes a root path and a list of patterns as input parameters. It increments a global or shared counter tracked by `tracker[\"rank\"]` and returns a list containing a single Path object pointing to a file named \"script.py\" located within a temporary directory identified by `tmp_path`. The function appears to be a placeholder or mock implementation, likely used for testing or demonstration purposes, as it does not utilize the input parameters in its logic.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:fake_rank:5a21d7a772f12814d50b875812b79d1153f209d33858a769fabc03df1b43b3a4:5a21d7a772f12814d50b875812b79d1153f209d33858a769fabc03df1b43b3a4": "The function `fake_rank` takes a root path and a list of patterns as input parameters. It increments a global or shared counter `tracker[\"rank\"]` by one, then returns a list containing a single Path object pointing to a file named \"a.py\" located within a temporary directory `tmp_path`. The function appears to be a placeholder or mock implementation, as it does not utilize the provided `root` or `patterns` parameters in its logic.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:fake_rank:92cdf105db487c32971a7312953dd14b16541224a402b4c28540f1cea34a99ec:92cdf105db487c32971a7312953dd14b16541224a402b4c28540f1cea34a99ec": "The function `fake_rank` takes a `Path` object representing a root directory and a list of string patterns. It increments a global or shared counter variable `tracker[\"rank\"]` by one and returns an empty list of `Path` objects. The function appears to be a placeholder or mock implementation, as it does not perform any actual ranking or filtering of files based on the provided patterns.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:fake_rank:b205c79b67f655ba9bd96521449163deb9cc3cc7a3a72f5d86409dceca77093e:b205c79b67f655ba9bd96521449163deb9cc3cc7a3a72f5d86409dceca77093e": "The function `fake_rank` takes a root path and a list of patterns as input, increments a global or shared `tracker` dictionary's \"rank\" key by one, and returns a list of paths. The function appears to be a placeholder or mock implementation, as it does not utilize the provided `root` or `patterns` parameters in its logic.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:fake_summarize:7138f89b66cb8d53a7b09ad17d6b5a0bff040fba703c5d4e86655e8e22e1128b:7138f89b66cb8d53a7b09ad17d6b5a0bff040fba703c5d4e86655e8e22e1128b": "",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:hook:328c94238dbe15fbc22d9932d8f50e7c13533e2a6953c212fde80efb4799743d:328c94238dbe15fbc22d9932d8f50e7c13533e2a6953c212fde80efb4799743d": "The function `hook` takes a list of strings as input and returns a new list where each string has been converted to uppercase. It applies the `upper()` method to each element in the input list using a list comprehension.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:summarize:0782eea3c86a87e4aabe30d9f90f87fef894c84dbd2d70e57d17340a22bed2be:0782eea3c86a87e4aabe30d9f90f87fef894c84dbd2d70e57d17340a22bed2be": "The `summarize` method of the `Dummy` class appends a dictionary containing the input `text`, `prompt_type`, and `system_prompt` to the instance's `calls` list. If the provided `system_prompt` matches the constant `explaincode.MERGE_SYSTEM_PROMPT`, the method returns the string \"final\". Otherwise, it splits the input `text` into words and returns the first word as a summary.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:summarize:2c5d7d984258a949eaf5db31d67f69d0d30ae2dc111ee9484c8571763f69c3b1:2c5d7d984258a949eaf5db31d67f69d0d30ae2dc111ee9484c8571763f69c3b1": "The `summarize` method appends a dictionary containing the input `text`, `prompt_type`, and `system_prompt` to the `calls` list attribute of the `Dummy` class instance. It then returns a string in the format `\"resp{N}\"`, where `N` is the current length of the `calls` list, representing the number of calls made to the method.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:summarize:43c2f1e867de7dff1259119cbc0b44b2627d55f0a7ebd81b7c4df55170216646:43c2f1e867de7dff1259119cbc0b44b2627d55f0a7ebd81b7c4df55170216646": "The `summarize` method is a placeholder implementation within the `Dummy` class that takes a string input `text`, a `prompt_type`, and an optional `system_prompt`. It returns a fixed string response formatted as \"Overview: x\\\\nHow to Run: [[NEEDS_RUN_INSTRUCTIONS]]\", regardless of the input provided. This method appears to be a stub or mock implementation, likely intended for testing or demonstration purposes.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:summarize:c3fe6f0721c7b98a9092143015c456e4d327cc5eba74603acf68e3cf942d34a6:c3fe6f0721c7b98a9092143015c456e4d327cc5eba74603acf68e3cf942d34a6": "The `summarize` method is a stub implementation within the `Dummy` class that takes a text input, a prompt type, and an optional system prompt, and returns a fixed, formatted summary string. The returned string contains structured information about a demo project, including sections for overview, purpose, execution instructions, inputs, outputs, system requirements, and examples. The method uses `textwrap.dedent` to normalize whitespace and includes a pragma comment indicating it is a simple stub not subject to coverage analysis.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:summarize:d8a785f06bbe8342542c95e9fc5c4e5dd63f939e77b1d4f8923523448f96ec0c:d8a785f06bbe8342542c95e9fc5c4e5dd63f939e77b1d4f8923523448f96ec0c": "The `summarize` method is a stub implementation within the `Stub` class that takes a prompt string, a prompt type string, and an optional system prompt string as parameters. It currently returns the literal string \"guessed\" regardless of the input provided. This method appears to be intended for generating summaries but currently does not perform any actual summarization logic.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:summarize:dea46eb655e491718f5af99a41ea3cfbbc3bd3df8ebab9a2aa8cc223b0b1b75b:dea46eb655e491718f5af99a41ea3cfbbc3bd3df8ebab9a2aa8cc223b0b1b75b": "The function `summarize` is a method of the `Dummy` class that accepts a string `text`, a `prompt_type`, and an optional `system_prompt`. It appends a dictionary containing these parameters to the instance's `calls` list and returns the string `\"done\"`. This method appears to be used for tracking calls with associated text, prompt type, and system prompt, likely in the context of documentation generation or processing.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:summarize:e94a3db6c1487459eee7da80acdf9986c476dbb719522d66b7f5e0fa81537bf0:e94a3db6c1487459eee7da80acdf9986c476dbb719522d66b7f5e0fa81537bf0": "The function `summarize` is a method of the `SlowClient` class that takes a string input `text`, a `prompt_type` string, and an optional `system_prompt` string. It checks if the provided `system_prompt` matches a specific constant `explaincode.CHUNK_SYSTEM_PROMPT`. If there is a match, it pauses execution for a duration defined by the variable `delay`. Regardless of the condition, the function returns the string \"ok\". The implementation suggests that this method may be used in a context where delays are introduced for rate limiting or throttling purposes, and it always returns a fixed value.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:summarize:eda075d14d7253c15a023ed5469b54405955044adfd4186767f8ee68d7fdebc1:eda075d14d7253c15a023ed5469b54405955044adfd4186767f8ee68d7fdebc1": "The `summarize` method processes input text based on the specified prompt type and system prompt. If the system prompt contains \"How to Run\", it returns the string \"[[NEEDS_RUN_INSTRUCTIONS]]\". If the system prompt contains \"enhancing a user manual\", it extracts manual text from the input using a regular expression and replaces occurrences of \"[[NEEDS_RUN_INSTRUCTIONS]]\" with \"use it\" before returning the result. For all other cases, it returns the string \"x\".",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:summarize:f2d0bf976db47871d73878ea6569d353f9cf853379d796e452fe43d70b881585:f2d0bf976db47871d73878ea6569d353f9cf853379d796e452fe43d70b881585": "The `summarize` method of the `Dummy` class takes a string `text`, a `prompt_type`, and an optional `system_prompt` as inputs. It appends a dictionary containing these parameters to the `self.calls` list. If the length of `self.calls` is less than or equal to 2, the method returns the value of the variable `big`. Otherwise, it returns the string `\"short\"`.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:summarize:f755ec1b277fb907c08ae483780cf5f73a51ce48287a212c678884f008df52fb:f755ec1b277fb907c08ae483780cf5f73a51ce48287a212c678884f008df52fb": "The `summarize` method processes a given text string to extract and replace placeholders within a manual section. It appends the input text to a list of calls, uses regular expressions to identify and extract content marked as \"Manual:\" and the associated section identifier, retrieves a placeholder token corresponding to the section from a predefined mapping, and returns the manual text with the placeholder replaced by a formatted string indicating the section has been filled.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:test_cached_chunks_reused:33101b717dacb2699df1456fd5219e654162a6e4d1855d39ceaecab91507c99d:33101b717dacb2699df1456fd5219e654162a6e4d1855d39ceaecab91507c99d": "The function `test_cached_chunks_reused` tests the reuse of cached chunks during manual summarization. It creates a large text consisting of repeated paragraphs and uses a dummy client that tracks calls to a summarization method. The test verifies that when the same text is summarized twice with caching enabled, the second call reuses cached results and does not make additional calls to the summarization method. The test ensures that the `ResponseCache` correctly stores and retrieves responses, preventing redundant processing of identical input chunks. It confirms that the first summarization makes three calls and the second, using the cache, makes zero additional calls.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:test_chunk_edit_hook_applied:df79665dd0b5fb8f5b8b94326251040fdc24473bd329d3a725e77a5bf2fd4c7a:df79665dd0b5fb8f5b8b94326251040fdc24473bd329d3a725e77a5bf2fd4c7a": "This function tests the application of a chunk editing hook during manual summarization. It creates a test scenario with two long paragraphs of text, then defines a dummy client that tracks calls made during summarization. A hook function is defined to convert chunks to uppercase. The test invokes the `_summarize_manual` utility with automatic chunking and the defined hook, expecting the final result to be \"final\" and the last call's text to be \"AAA\\n\\nBBB\" after processing. The test verifies both the correct application of the hook and the expected output of the summarization process.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:test_chunking_none_no_llm_calls:3ead393d908b821244e9e6b926f3ded0446e5739c01c5b6472e221dff3c41470:3ead393d908b821244e9e6b926f3ded0446e5739c01c5b6472e221dff3c41470": "This function tests the chunking behavior of the documentation generation process when set to \"none\" and ensures no LLM calls are made. It creates a large text file, patches the `LLMClient` to capture calls, and verifies that the system prompt contains \"Overview\" in the first call. The test confirms that with `--chunking none`, the tool processes the content without invoking the language model.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:test_chunking_triggers_multiple_calls_and_logs:b8eb5a0683da53800004bb725729824df0639139bcafa868dc53ae2f274cf665:b8eb5a0683da53800004bb725729824df0639139bcafa868dc53ae2f274cf665": "This function tests the behavior of automatic chunking during manual summarization, ensuring that multiple calls are made to the LLM when text is split into chunks. It verifies that the correct system prompts are used for both chunking and merging operations, checks that the final result is correctly assembled, and confirms that logging messages are generated to indicate chunking and merging progress. The test uses a dummy client to simulate LLM interactions and a response cache to store results. It validates the sequence of calls, the content and prompts used in each call, and the output logged during the process.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:test_collect_docs_filters:1c76e2f415ad6a9960a543f3fd20603e2ab7bb03f05dc4e579474ca218cf44b9:1c76e2f415ad6a9960a543f3fd20603e2ab7bb03f05dc4e579474ca218cf44b9": "The function `test_collect_docs_filters` tests the `explaincode.collect_docs` functionality by creating a temporary directory structure with multiple files, including markdown and text files. It verifies that only files with the `.md` extension are collected while excluding those with other extensions, such as `.txt`. The test confirms that the collection process correctly filters files based on their extensions.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:test_custom_output_directory:4dedbf4d96beab58ff5afe55f4b071f166dfc8618f28403a661111137448d0e6:4dedbf4d96beab58ff5afe55f4b071f166dfc8618f28403a661111137448d0e6": "This function tests the functionality of generating documentation to a custom output directory. It creates a temporary test fixture, configures the LLM client to use a mock implementation, and invokes the main documentation generation process with specified input and output paths. The test verifies that the expected output files (`user_manual.html` and `user_manual_evidence.json`) are created in the designated output directory.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:test_custom_title_and_filename:f19add9c511d87e4b3e190d01df80da8c5fd8e08bb6898a3b6e42da600bbca21:f19add9c511d87e4b3e190d01df80da8c5fd8e08bb6898a3b6e42da600bbca21": "This function tests the generation of documentation with a custom title and filename. It creates a temporary test fixture, mocks the LLM client, and invokes the main documentation generation process with a specified title \"Fancy Guide\". It then verifies that the output HTML file and evidence JSON file are created in the temporary path, and checks that the generated HTML contains the expected heading tag with the custom title.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:test_detect_placeholders:031dc0a22a4a2760dfede26cae78cb9ee455d2246b9c31b489d6f6fc69492778:031dc0a22a4a2760dfede26cae78cb9ee455d2246b9c31b489d6f6fc69492778": "The function `test_detect_placeholders` tests the `detect_placeholders` function from the `explaincode` module. It verifies that the function correctly identifies placeholder strings in a given text, specifically detecting \"Overview\" and \"Outputs\" as missing sections from placeholders formatted as `[[NEEDS_<SECTION>]]`. The test ensures that the detected placeholders are returned as a set containing these two section names.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:test_docs_index_default_and_injection:e2b8284f02fa66aeb8cc27273885612e3c079e7c2ce4e31be702505a001a0089:e2b8284f02fa66aeb8cc27273885612e3c079e7c2ce4e31be702505a001a0089": "This function tests the default behavior and injection functionality of documentation indexing. It creates a temporary directory structure with a fixture, sets up an HTML index file with a navigation element, and mocks the LLM client. After running the main documentation generation process with the `--insert-into-index` flag, it verifies that the generated manual HTML file and evidence JSON file are created. The test also checks that the navigation element in the index file contains a link to the generated manual file.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:test_extract_snippets_skips_large_file:ea8881476eae5eea459a1198d71fd4362737b927bee90ef873fa57443c5f1f0a:ea8881476eae5eea459a1198d71fd4362737b927bee90ef873fa57443c5f1f0a": "The function `test_extract_snippets_skips_large_file` tests the behavior of `explaincode.extract_snippets` when processing a file that exceeds a specified size limit. It creates a large Python file filled with 210,000 bytes of data, then calls `extract_snippets` with parameters that limit the maximum file size to 200,000 bytes. The test verifies that the large file is excluded from the returned snippets and that an appropriate log message indicating the file size exceeded the limit is generated. The test uses pytest's `tmp_path` fixture to create a temporary directory and `caplog` to capture log output for validation.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:test_extract_text_docx_preserves_headings:f2a399b461bbde9620e0c951846ba0efb7d926bf4a1437d536cae0b64be938d7:f2a399b461bbde9620e0c951846ba0efb7d926bf4a1437d536cae0b64be938d7": "This function tests that the `extract_text` function correctly preserves headings when extracting text from a `.docx` file. It creates a Word document with a level 1 heading and a paragraph of text, saves it to a temporary path, extracts the text using `explaincode.extract_text`, and verifies that the extracted text starts with \"# Title\" (indicating the heading was properly converted) and that the paragraph text is present in the output. The test skips execution if the `python-docx` dependency is not installed.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:test_extract_text_html_preserves_headings_and_code:b674be840ebade1db009252766a9aa47621081349025e63d29dc3eddb8f70991:b674be840ebade1db009252766a9aa47621081349025e63d29dc3eddb8f70991": "This function tests the `extract_text` function from the `explaincode` module. It creates a temporary HTML file containing headings and code elements, then verifies that the extracted text preserves the heading structure (using Markdown-style headers) and formats code blocks with backticks. The test checks that the extracted text contains the expected heading markers and code block indicators.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:test_extract_text_markdown_preserves_headings_and_code:573d052bfc50911d1ce5013937854a09634b141a7af9b008a4f80a1cf54e7b71:573d052bfc50911d1ce5013937854a09634b141a7af9b008a4f80a1cf54e7b71": "This function tests that the `extract_text` function correctly preserves Markdown headings and code blocks when extracting text from a Markdown file. It creates a temporary Markdown file with a heading, some text, and a Python code block, then verifies that the extracted text contains the original heading and code block.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:test_force_code_flag_triggers_code_fallback:e1227d1727a64cf441ac3c93263dfa0b5f7ce97aa9602f8f1c3496855017de09:e1227d1727a64cf441ac3c93263dfa0b5f7ce97aa9602f8f1c3496855017de09": "This function tests that the `--force-code` flag correctly triggers a code fallback during documentation generation. It sets up a temporary test environment, patches functions to track execution, and verifies that the code scanning logic is invoked when the flag is used. The test ensures the correct logging messages are produced and that the expected number of file ranking and extraction operations occur.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:test_full_docs_no_code_scan:66c379d67c52bb1ad86b91142445a958eddd71ed24a78386ab8afc4bc313f282:66c379d67c52bb1ad86b91142445a958eddd71ed24a78386ab8afc4bc313f282": "This function tests the behavior of the documentation generation process when code scanning is explicitly disabled. It sets up a temporary directory with fixture files, patches functions responsible for ranking code files and extracting snippets to track their invocation, and configures logging to capture output. The test verifies that neither the ranking nor extraction functions are called when the `--scan-code-if-needed` flag is used, confirming that code scanning is skipped. It also checks that specific log messages indicating \"DOC PASS\" and \"Code scan skipped\" appear in the captured logs.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:test_graceful_missing_docx:a8cc2521eebb320ed94e85f23a78dd736b24e8dd8aa4c80110abc64267e82d54:a8cc2521eebb320ed94e85f23a78dd736b24e8dd8aa4c80110abc64267e82d54": "This function tests the graceful handling of a missing `docx` dependency during documentation generation. It creates a temporary fixture directory, attempts to create and save a `.docx` file if the `python-docx` library is available, then patches the `explaincode` module to simulate the absence of the `Document` class and replaces `LLMClient` with a mock implementation. After invoking the main documentation generation process with the temporary path, it verifies that the expected HTML manual and evidence JSON files are created in the directory.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:test_hierarchical_merge_logged:2b1dcf89059b390adc8ea9e73f8dc18755bcc2c7fc2a3299e33f451d99af813d:2b1dcf89059b390adc8ea9e73f8dc18755bcc2c7fc2a3299e33f451d99af813d": "The function `test_hierarchical_merge_logged` tests the hierarchical merging behavior of a manual summarization process. It creates a large text input composed of repeated content, then defines a dummy client class that tracks calls made during summarization. The test uses a `ResponseCache` to store and retrieve responses, configures logging to capture debug output, and invokes the `_summarize_manual` utility with automatic chunking. The test verifies that the final result is \"short\", indicating successful hierarchical merging, confirms multiple client calls were made, and ensures that the log output contains the phrase \"Hierarchical merge pass\".",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:test_html_summary_creation:d9f4d6ffc4178a5dc75ae8c641e66335f419912fcc095c334048cfaa73501d8d:d9f4d6ffc4178a5dc75ae8c641e66335f419912fcc095c334048cfaa73501d8d": "",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:test_infer_sections_infers_entries:e35247a7b124ecd88ea6f009531092b343a8eb1e11a746edd6268f9a9064bd94:e35247a7b124ecd88ea6f009531092b343a8eb1e11a746edd6268f9a9064bd94": "The function `test_infer_sections_infers_entries` tests the `infer_sections` function from the `explaincode` module. It verifies that when given a context string, the function returns a dictionary of sections where the \"Overview\" section contains the exact context string, and all required sections (defined in `explaincode.REQUIRED_SECTIONS`) have values ending with \"(inferred)\", except for \"Overview\". The test also ensures that the placeholder text \"No information provided.\" does not appear in any of the section values.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:test_infer_sections_no_context_defaults:47b3568f2912e5ade7a0ace48d4245cf5d3c433caa68ab542f2e68fcf9f274ea:47b3568f2912e5ade7a0ace48d4245cf5d3c433caa68ab542f2e68fcf9f274ea": "The function `test_infer_sections_no_context_defaults` tests the behavior of the `explaincode.infer_sections` function when called with an empty string. It verifies that all values in the returned dictionary from `infer_sections(\"\")` are set to the default value \"No information provided.\" This assertion ensures that the function handles empty input by returning a consistent default message for all sections.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:test_insert_into_index:8dc8fb09c513b98596fae1b9bff36d933fc99772dca9d301ded75ece48ba4c3e:8dc8fb09c513b98596fae1b9bff36d933fc99772dca9d301ded75ece48ba4c3e": "The function `test_insert_into_index` tests the functionality of inserting a link into an existing HTML index file during documentation generation. It creates a temporary directory structure with fixture files, initializes an output directory, and sets up a mock LLM client. The test then runs the main documentation generation process with the `--insert-into-index` flag, which should modify the index.html file to include a link to \"user_manual.html\". Finally, it verifies that the expected link is present in the modified HTML content.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:test_insert_into_root_index:528ffd6dd85909f868c296843d21955556cb95b72c44a2d1e705970d979330d8:528ffd6dd85909f868c296843d21955556cb95b72c44a2d1e705970d979330d8": "Tests the functionality of inserting a generated documentation file into the root index.html file. It creates a test fixture, sets up a mock LLM client, runs the main function with the --insert-into-index flag, and verifies that the user manual HTML and evidence files are created. It also checks that the navigation element in the index.html file contains a link to the generated documentation file.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:test_llm_fill_placeholders_per_section_logging:ccd142cef172d43b9a058bd0f724c4fd8ecc923dd4df4c99ec330eb46f321760:ccd142cef172d43b9a058bd0f724c4fd8ecc923dd4df4c99ec330eb46f321760": "The function `test_llm_fill_placeholders_per_section_logging` tests the behavior of `explaincode.llm_fill_placeholders` by simulating an LLM client and verifying that placeholders in a manual text are correctly replaced with content derived from evidence. It uses a dummy class to simulate LLM responses, checks that the correct number of calls are made, and verifies that log messages are generated indicating which sections were filled using specific code files. The test ensures that section-specific placeholders are replaced and that logging occurs as expected during the placeholder-filling process.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:test_llm_generate_manual_sanitizes_and_caches:de118b5e7317228c666d0960ee1c9c306ff922c6ed5d97692e427c9aaed5f61a:de118b5e7317228c666d0960ee1c9c306ff922c6ed5d97692e427c9aaed5f61a": "The function `test_llm_generate_manual_sanitizes_and_caches` tests the behavior of the `llm_generate_manual` function in the `explaincode` module. It verifies that the output from the LLM is sanitized by removing specific phrases and that the results are properly cached.\n\nThe test sets up a mock environment with:\n\n\nThe test then calls `llm_generate_manual` with these parameters, checks that the returned manual text does not contain the unwanted phrases, and verifies that:\n1. The output is sanitized by ensuring the phrases are absent from the result\n2. The generated prompt is correctly constructed for mapping evidence to sections\n3. The response is cached using a key derived from the section name and prompt\n4. The cached entry exists and also does not contain the unwanted phrases\n\nThe test ensures that both sanitization and caching functionality work as expected in the documentation generation pipeline.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:test_map_evidence_overview_priority_and_filters:d0db1e73794e3bbee7418d0cea2f9e2e92ad1bb1dba1008636aa307c67529d52:d0db1e73794e3bbee7418d0cea2f9e2e92ad1bb1dba1008636aa307c67529d52": "The function `test_map_evidence_overview_priority_and_filters` tests the behavior of `explaincode.map_evidence_to_sections` by evaluating how it processes a dictionary of markdown files and organizes their content under the \"Overview\" section. It verifies that certain files, such as those in test, example, and fixture directories, are excluded from the results, while files in README, docs, and src directories are included. The test ensures proper prioritization and filtering of documentation sources based on directory paths.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:test_map_evidence_snippet_limits:6ed57a84795246b6ebb0a0a5d6a8fa80f3c52c1dcf31da373b685f0f5e7f9284:6ed57a84795246b6ebb0a0a5d6a8fa80f3c52c1dcf31da373b685f0f5e7f9284": "The function `test_map_evidence_snippet_limits` tests the behavior of the `map_evidence_to_sections` function when processing documentation files with content that exceeds a maximum line limit. It creates two mock documentation files (`src/long.md` and `tests/short.md`) containing a specified number of lines, then processes them to verify that the resulting snippets respect the maximum line limit defined by `explaincode.MAX_SNIPPET_LINES`. The test ensures that lines beyond the limit are excluded from the output snippet for `src/long.md`, while the last allowed line is included, and that the `tests/short.md` file's snippet contains only the header \"# Inputs\".",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:test_missing_run_triggers_code_fallback_with_limits:ec5b6ac174e541a0be9072b0d51477a3217c5dcb6ac85faeb88dbb7ee2a407f3:ec5b6ac174e541a0be9072b0d51477a3217c5dcb6ac85faeb88dbb7ee2a407f3": "This function tests the behavior of the documentation generation process when run instructions are missing, ensuring that a fallback mechanism uses code snippets to fill in the missing information. It verifies that the system correctly identifies missing run instructions, extracts relevant code snippets, and substitutes placeholders in the generated manual with actual code-based content. The test confirms that the system respects configured limits on the number of files scanned and time budget, and logs appropriate messages during the process. It also checks that the final HTML output does not contain unresolved placeholders and that the internal tracking mechanisms function as expected.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:test_no_code_flag_skips_code_fallback:7cf41d3479b68a403eadc243dcbe7d6a054aa650ea0245929cdb17847c0a4fa9:7cf41d3479b68a403eadc243dcbe7d6a054aa650ea0245929cdb17847c0a4fa9": "The function `test_no_code_flag_skips_code_fallback` tests that the `--no-code` flag prevents code scanning and extraction during documentation generation. It sets up a temporary directory with a README file, mocks the `LLMClient`, `rank_code_files`, and `extract_snippets` functions to track their invocation, and verifies that these functions are not called when the `--no-code` flag is used. The test also confirms that a log message indicating the code scan was skipped is present and that the output contains expected content such as \"How to Run\". The test ensures the correct behavior of the documentation generation process when code processing is explicitly disabled.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:test_parallel_chunk_summarization:f58de09650675ea9db069468c987e301b890d9865296195db23d4a41698c11e4:f58de09650675ea9db069468c987e301b890d9865296195db23d4a41698c11e4": "This function tests the parallel chunk summarization functionality by creating a slow client that introduces a delay during summarization. It uses a large text input with repeated paragraphs and verifies that the summarization completes within a specified time threshold, ensuring that parallel processing is functioning correctly. The test checks that the duration of the summarization process is less than 1.5 times the delay introduced by the slow client, confirming that chunks are processed in parallel rather than sequentially. It utilizes a response cache and the `manual_utils._summarize_manual` function to perform the summarization with automatic chunking.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:test_parse_manual_infers_missing_sections:e33bb0010c5887c1259023686054519f4b1919d4ffb4b840ff499a5cdaa2393b:e33bb0010c5887c1259023686054519f4b1919d4ffb4b840ff499a5cdaa2393b": "The function `test_parse_manual_infers_missing_sections` tests the behavior of the `explaincode.parse_manual` function when parsing a string with missing sections. It creates a stub client that returns a fixed summary, then calls `parse_manual` with the input \"Overview: hi\". The test verifies that the parsed result correctly extracts \"hi\" as the value for the \"Overview\" section, infers a \"Inputs\" section ending with \"(inferred)\", and ensures that \"No information provided.\" does not appear in the \"Inputs\" section.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:test_pdf_summary_creation:0bf9b0f0efa3378919ed4fa56eedf24d44c580899043ab481fbe33f424c24ce2:0bf9b0f0efa3378919ed4fa56eedf24d44c580899043ab481fbe33f424c24ce2": "This function tests the creation of a PDF summary by verifying that the `reportlab` library is available, setting up a temporary directory with fixture data, mocking an LLM client, and executing the main documentation generation process with the PDF output format. It asserts that both the generated PDF file and an associated evidence JSON file are created in the specified output directory.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:test_rank_code_files_supports_cpp_h_java:23646f9a96707f178d25ca2c172e82ee6eaccd5938d1a1057cec18027806efc8:23646f9a96707f178d25ca2c172e82ee6eaccd5938d1a1057cec18027806efc8": "The function `test_rank_code_files_supports_cpp_h_java` tests the capability of the `explaincode.rank_code_files` function to identify and rank source code files with specific extensions (`.cpp`, `.h`, `.java`) within a given directory. It creates a temporary directory containing files with various extensions, including Python, C++, C++ header, Java, and a text file. The test verifies that `rank_code_files` correctly identifies and includes only the relevant code files in its output, excluding non-code files like the text file. The assertion confirms that the ranked list contains the expected code file names while ensuring the text file is excluded.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:test_render_html_includes_toc_and_sources_block:38bfbb0563be0480d46f34682937ddcc2a44e86941e86013c9a28a683d152df2:38bfbb0563be0480d46f34682937ddcc2a44e86941e86013c9a28a683d152df2": "The function `test_render_html_includes_toc_and_sources_block` tests the `render_html` function from the `explaincode` module. It verifies that the generated HTML includes a table of contents (TOC) with links to section headers and source code blocks referencing files mentioned in the evidence. The test creates mock data for sections and evidence, calls `render_html`, parses the resulting HTML using BeautifulSoup, checks for the presence of navigation links and sources blocks, and asserts that specific file names are included in the sources text.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:test_render_html_renders_markdown_headings_and_code:0774c6cc2cf92391edd5eb1e88089a8f4dfb444b3417e7a03f83d07910915f71:0774c6cc2cf92391edd5eb1e88089a8f4dfb444b3417e7a03f83d07910915f71": "This function tests the rendering of HTML output containing Markdown headings and code blocks. It creates a dictionary with a section titled \"Intro\" that includes a Markdown title and a Python code block. The `explaincode.render_html` function processes this input into HTML format. A BeautifulSoup parser then examines the resulting HTML to verify that an `<h1>` element with the text \"Title\" is present and that a code block containing `print('hi')` is correctly rendered within `<pre>` and `<code>` tags. The test ensures proper conversion of Markdown elements to HTML structure.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:test_scan_code_categorizes_snippets:7fa70ffa20f547924c81c7c1aff91bdfced40118d45dd2f642a1f889d4ba8ad1:7fa70ffa20f547924c81c7c1aff91bdfced40118d45dd2f642a1f889d4ba8ad1": "This function tests the `scan_code` function's ability to categorize code snippets into specified categories. It creates temporary Python files, patches several functions in the `explaincode` module to simulate behavior, and then calls `scan_code` with specific parameters. The test verifies that the returned dictionary correctly maps each category to the corresponding file and its extracted snippet content.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:test_scan_code_skips_non_source_dirs:9107d644c8ea819d09c01cb9ad4e4fea4e18e6b102d17ec682bd058646e03b2b:9107d644c8ea819d09c01cb9ad4e4fea4e18e6b102d17ec682bd058646e03b2b": "The function `test_scan_code_skips_non_source_dirs` tests that the `scan_code` function correctly ignores non-source directories (such as `tests` and `examples`) when scanning for code files. It creates a temporary directory structure with source, test, and example directories, writes sample Python files to each, and patches the `collect_docs` function to return an empty list. The test then calls `scan_code` with specific parameters and verifies that only the file from the `src` directory is included in the result under the \"How to Run\" key, confirming that non-source directories are skipped during the scanning process.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:test_validate_manual_references_flags_missing:aec2fbe3b086dff8afcd39fd9a994bb6cf105abc2ab3182934d6512e49a4c90d:aec2fbe3b086dff8afcd39fd9a994bb6cf105abc2ab3182934d6512e49a4c90d": "The function `test_validate_manual_references_flags_missing` tests the behavior of `validate_manual_references` when processing documentation sections that reference Python files. It creates a temporary directory with a file named \"exists.py\" and defines a section containing references to both existing and missing files. The function calls `validate_manual_references` to update the section text and evidence dictionary based on the existence of referenced files. The test verifies that the existing file reference remains unchanged, the missing file reference is appended with \"[missing]\", and the evidence dictionary correctly records the missing reference.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_html_writer.py:ed039a0da27df295cd81a8ab2de805295849fc310d9e7141db11366b1d14bd1b:ed039a0da27df295cd81a8ab2de805295849fc310d9e7141db11366b1d14bd1b": "Module defines tests for HTML documentation generation functions. Tests cover index page creation with nested module structures, module page rendering including classes, functions, variables, and their documentation, subfunction and subclass handling, and syntax highlighting for C++ and Java code snippets. Each test validates specific HTML output elements and formatting.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_html_writer.py:test_cpp_java_highlighting:366f7966e332cf6c75afb33e09eca70ea0104945faceb2771f1dd173abd1cf00:366f7966e332cf6c75afb33e09eca70ea0104945faceb2771f1dd173abd1cf00": "The function `test_cpp_java_highlighting` tests the highlighting functionality for C++ and Java code. It takes no parameters and returns no value. The function calls `_highlight` with C++ and Java code samples, then asserts that the resulting HTML output contains `<span` tags, indicating successful syntax highlighting.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_html_writer.py:test_subclass_rendering:aab370844bada0fb433edfa540bf30da09854047c5bae80943ca9d4a892478f2:aab370844bada0fb433edfa540bf30da09854047c5bae80943ca9d4a892478f2": "This function tests the rendering of a subclass within a module's HTML documentation. It creates a mock module structure containing a class `A` with a subclass `B`, where `B` includes a method `m`. The test invokes `write_module_page` to generate HTML output for the module and verifies that the resulting HTML contains expected elements such as a details section, class header, summary text, method signature, and a single code block. The function ensures proper HTML generation for nested subclass structures with associated documentation and source code.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_html_writer.py:test_subfunction_rendering:7410a74abf3f458be27233749d839e85eeb07883966457a52330a29b87779e3b:7410a74abf3f458be27233749d839e85eeb07883966457a52330a29b87779e3b": "The function `test_subfunction_rendering` tests the rendering of subfunctions within a module's HTML documentation. It creates a mock module structure containing an outer function with a nested inner function, then generates an HTML page using `write_module_page`. The test verifies that the generated HTML includes expected elements such as a details section, subfunction declaration, and summary text. It also checks that both the outer and inner function sources are properly highlighted with code blocks.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_html_writer.py:test_write_index:5d12b2cb1ff602b6f7b9b2dc456a495e33ac75ee0776a6ac48b3b4de2173e6e2:5d12b2cb1ff602b6f7b9b2dc456a495e33ac75ee0776a6ac48b3b4de2173e6e2": "The function `test_write_index` tests the `write_index` function by creating a mock directory structure and summary data, then verifying that the generated HTML index file contains expected content and formatting. It checks for proper escaping of special characters, correct inclusion of module links and summaries, accurate nesting of sections, and valid HTML structure including details elements and headers. The test ensures the index is generated with correct project title, module references, and hierarchical organization while validating the output against specific string patterns and positional relationships within the HTML content.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_html_writer.py:test_write_module_page:b61f88f8c7994640f84da7a6a526fe5db7f3065eb7969b7ef2ef5ce6c90dd6f6:b61f88f8c7994640f84da7a6a526fe5db7f3065eb7969b7ef2ef5ce6c90dd6f6": "The function `test_write_module_page` tests the generation of an HTML module page by verifying that the output HTML contains expected elements and content. It creates a mock module data structure and a file tree, then calls `write_module_page` to generate the HTML at a temporary path. The test checks for specific HTML elements such as comments, links, headers, code blocks, and properly escaped content to ensure correct formatting and inclusion of module summaries, class information, method details, variable descriptions, and function signatures. It also verifies that the generated HTML includes expected counts of code blocks and correctly escapes special characters in documentation strings.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_integration.py:7610cd2fce0cd37892fc17f69cefa5dc0c0897e6aab60df5a0bd194234f19d04:7610cd2fce0cd37892fc17f69cefa5dc0c0897e6aab60df5a0bd194234f19d04": "Module defines tests for the `docgenerator` tool, verifying HTML generation from code files in multiple languages including Python, MATLAB, C++, and Java. Tests check creation of HTML files with summaries inserted, and confirm static assets are copied correctly regardless of current working directory. The tests mock an LLM client to simulate documentation generation without external dependencies.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_integration.py:test_docgenerator_generates_html:f3a3ff1e18b97301e2ab859b5ce5a05422caf7917c19e1ee2d54c871f07b562c:f3a3ff1e18b97301e2ab859b5ce5a05422caf7917c19e1ee2d54c871f07b562c": "This function tests the HTML documentation generation capability of the docgenerator tool. It creates a temporary project directory containing sample source files in Python, MATLAB, C++, and Java, then invokes the main documentation generation function with specified input and output paths. The test mocks the LLMClient to simulate successful communication with a language model, ensuring that the summarization process returns a placeholder \"summary\" text. After execution, it verifies that HTML files are correctly generated for each source file and that the generated HTML content includes the expected summary text. The function confirms that the documentation generator produces navigable HTML output for multiple programming languages.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_integration.py:test_static_copied_from_any_cwd:e2c1041c9c8a99cde8a28dd94a6854789c7215d26cffcf2adcaafafc9f256de3:e2c1041c9c8a99cde8a28dd94a6854789c7215d26cffcf2adcaafafc9f256de3": "This function tests the static documentation generation capability of the tool when the working directory is changed. It creates a temporary project directory with a Python module, sets up a mock LLM client to simulate API responses, changes the working directory to the temporary path, and invokes the main documentation generation function. The test verifies that the process completes successfully (return code 0) and confirms that the expected static CSS file is generated in the output directory.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_llm_client.py:82628573795fc440ac97b2cf7aa97bb506079f91432da86bdb370078b9e5cc90:82628573795fc440ac97b2cf7aa97bb506079f91432da86bdb370078b9e5cc90": "Module defines tests for an LLM client including ping functionality, summary generation with retry logic, and prompt template usage. Tests cover success and failure scenarios for pinging, handling HTTP errors during summarization, and filtering output text. It verifies correct behavior when using different prompt templates based on input type and ensures proper sanitization of summary text. The tests utilize mocking to isolate the client's behavior from external dependencies.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_llm_client.py:test_ping_failure:d6966a64ae1a982cf3841e89eb298a5ed8108a00b95d1dd712734da5a519f97a:d6966a64ae1a982cf3841e89eb298a5ed8108a00b95d1dd712734da5a519f97a": "The function `test_ping_failure` tests the behavior of the `ping` method in the `LLMClient` class when a connection fails. It creates an `LLMClient` instance with a fake URL, patches the `requests.get` function to raise a `RequestException`, and then asserts that calling `client.ping()` raises a `ConnectionError`.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_llm_client.py:test_ping_success:1cd419531b4dbd5bc5c3f1436b2294e589e712ff75bc2fcab4c996aa595b73bb:1cd419531b4dbd5bc5c3f1436b2294e589e712ff75bc2fcab4c996aa595b73bb": "The function `test_ping_success` tests the successful ping functionality of an `LLMClient` object. It creates a mock HTTP client with a fake URL, configures a mock response object to simulate a successful HTTP request, and verifies that the client's `ping()` method returns `True`. The test ensures that the `requests.get` function is called with the correct URL and timeout parameters, and that `raise_for_status` is invoked on the response object.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_llm_client.py:test_prompt_varies_by_type:d940d8a6568c31d0c76eef329bb800593ae341e9c6215f17eae9bcaa032613a6:d940d8a6568c31d0c76eef329bb800593ae341e9c6215f17eae9bcaa032613a6": "The function `test_prompt_varies_by_type` tests that the `LLMClient` generates different prompts based on the type of code element being summarized. It verifies that when summarizing with types \"class\" and \"function\", the respective prompts are constructed using the correct template formatting and that the resulting prompts are distinct. The test mocks the HTTP POST request to simulate LLM responses and checks the content of the second message in the JSON payload sent to the LLM, ensuring it matches the expected formatted prompt for each element type.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_llm_client.py:test_readme_prompt_template_used:6c5523cf1ac89730cf606eb816d93c80266dd98697345972a40ee5212336f90b:6c5523cf1ac89730cf606eb816d93c80266dd98697345972a40ee5212336f90b": "The function `test_readme_prompt_template_used` verifies that the correct prompt template is applied when generating a README summary using the `LLMClient`. It creates a mock LLM client and response, then checks that the second message in the JSON payload sent to the client's `summarize` method uses the `readme` prompt template formatted with the input text \"foo\". The test ensures proper integration between the client's request construction and the predefined prompt templates.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_llm_client.py:test_sanitize_summary_filters_ai_language_model:6e305243c6315d7b82cb6dfe75d97bc83e46665364db6005043cbc4f7adbed8a:6e305243c6315d7b82cb6dfe75d97bc83e46665364db6005043cbc4f7adbed8a": "",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_llm_client.py:test_sanitize_summary_filters_altered_prompt_line:bbc77f4b228485c499ac3ec052401232d42765ac0d8511ed4b5a27bd4f9fb6dd:bbc77f4b228485c499ac3ec052401232d42765ac0d8511ed4b5a27bd4f9fb6dd": "",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_llm_client.py:test_sanitize_summary_filters_phrases:0757006b40014eac33ae72374cf7daf4159fcc04669cbda3c28169506eed08b9:0757006b40014eac33ae72374cf7daf4159fcc04669cbda3c28169506eed08b9": "The function `test_sanitize_summary_filters_phrases` tests the `sanitize_summary` function by providing a text string containing multiple phrases and asserting that the output of `sanitize_summary` contains only the phrases \"Defines a class.\" and \"It prints output.\". The test verifies that the `sanitize_summary` function filters out specific unwanted phrases from the input text, such as mentions of running code, disclaimers, and other non-essential content, while preserving relevant descriptive phrases.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_llm_client.py:test_sanitize_summary_filters_truncated_prompt_line:107890f1abfbec38c0db9d6e0a013e7416bbcf618b11b1f66e719c7c292ed760:107890f1abfbec38c0db9d6e0a013e7416bbcf618b11b1f66e719c7c292ed760": "The function `test_sanitize_summary_filters_truncated_prompt_line` tests the `sanitize_summary` function to ensure it removes a specific prompt line from the beginning of the input text. The test provides input text containing a prompt line \"Do not say what is or isn't included in the code\" followed by \"Defines a class.\" The expected output after sanitization is \"Defines a class.\", confirming that the function correctly filters out the initial prompt line.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_llm_client.py:test_sanitize_summary_removes_fim_tokens:b9d8ebd3678f930824baf4d73e7ef618f8ef3358f7af92f3c5b068af081fb213:b9d8ebd3678f930824baf4d73e7ef618f8ef3358f7af92f3c5b068af081fb213": "The function `test_sanitize_summary_removes_fim_tokens` tests that the `sanitize_summary` function removes FIM (Fix, Improve, Modify) reserved tokens from input text to prevent tokenizer errors. It asserts that when given the input string \"Defines \u3008a class.\", the output of `sanitize_summary` is \"Defines a class.\".",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_llm_client.py:test_sanitize_summary_removes_prompt_lines:b9b4ca7274e7f6ab666e0d1f6ea540cb76d34354c1ac8405560612af55535b92:b9b4ca7274e7f6ab666e0d1f6ea540cb76d34354c1ac8405560612af55535b92": "The function `test_sanitize_summary_removes_prompt_lines` tests the `sanitize_summary` function to ensure it removes prompt-related lines from input text. The test provides a string containing multiple lines including instructions and prompts, and verifies that the output of `sanitize_summary` contains only the core content \"Defines a class.\" The function successfully strips out lines that contain prompts or instructions, leaving only the essential summary information.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_llm_client.py:test_summarize_does_not_stream_on_http_error:2c44af84868cee14a3f422e6edb6de55b74d1124832aca838f3929f253173164:2c44af84868cee14a3f422e6edb6de55b74d1124832aca838f3929f253173164": "This function tests that the `summarize` method of the `LLMClient` class does not attempt to stream a response when an HTTP error occurs during the request. It creates a mocked `LLMClient` instance with a fake URL, sets up a mock response that raises an `HTTPError` and returns a text error message, and patches the `requests.post` call to return this mock response. The test verifies that calling `client.summarize` with sample inputs raises a `RuntimeError` with the expected error message and ensures that `iter_content` is not called on the mock response, confirming no streaming occurs on HTTP failure.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_llm_client.py:test_summarize_raises_runtime_error_with_message:1b0efb2a6dd57f690ca3a33898b1a3eded6f2c037dae72b22d634eb850e6a3a8:1b0efb2a6dd57f690ca3a33898b1a3eded6f2c037dae72b22d634eb850e6a3a8": "This function tests that the `summarize` method of the `LLMClient` class raises a `RuntimeError` with a specific error message when an HTTP request fails. It mocks an HTTP error response with the text \"server exploded\" and verifies that the exception is properly raised. The test patches the `requests.post` call to return the mock response and mocks `time.sleep` to avoid delays during testing.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_llm_client.py:test_summarize_retries_and_returns_summary:541be8710e64c685cb4402b76f304eda21085130c1611afea056bfffc7292ff4:541be8710e64c685cb4402b76f304eda21085130c1611afea056bfffc7292ff4": "The function `test_summarize_retries_and_returns_summary` tests the retry logic and response handling of the `summarize` method in the `LLMClient` class. It mocks an HTTP client to simulate a failed request followed by a successful one, verifies that the correct summary is returned, ensures the retry mechanism is invoked, checks that a delay occurs between attempts, and validates that the prompt sent to the LLM matches the expected format. The test confirms that the client properly handles transient failures during LLM requests and extracts the intended content from the response.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_manual_utils.py:_count:ba6eec941f7cca988d4350fb4e9a9befd7db485c80c18197417846484391e1d7:ba6eec941f7cca988d4350fb4e9a9befd7db485c80c18197417846484391e1d7": "The function `_count` takes a string input `text` and returns the number of tokens in the text by encoding it using `manual_utils.TOKENIZER` and calculating the length of the resulting token sequence.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_manual_utils.py:b152f93e4ae2356d36a0553ec3d878edb1db688524cfd71c19fb6ea54af90bc5:b152f93e4ae2356d36a0553ec3d878edb1db688524cfd71c19fb6ea54af90bc5": "Module defines tests for documentation utilities. Includes functions to count tokens in text and verify chunking behavior respects token limits. Tests validate placeholder identification in text strings.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_manual_utils.py:test_chunk_docs_respects_token_limit:1aca753d2212837f248112700b667482b2622d43da62c087737493ce47a978ee:1aca753d2212837f248112700b667482b2622d43da62c087737493ce47a978ee": "The function `test_chunk_docs_respects_token_limit` tests that the `chunk_docs` utility respects a specified token limit when processing a list of documentation strings. It creates three documentation strings, each consisting of 1000 repeated characters, and passes them to `chunk_docs` with a token limit of 2000. The test verifies that the resulting chunks match the expected number (3) and that each chunk contains no more than the specified token limit.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_manual_utils.py:test_find_placeholders:afe9b13f6bc0ba33fbf8f73d007157c04cd254b8c5acbbd055ab7980ecc57842:afe9b13f6bc0ba33fbf8f73d007157c04cd254b8c5acbbd055ab7980ecc57842": "The function `test_find_placeholders` tests the `find_placeholders` utility function by providing a sample text containing two placeholders formatted as `[[PLACEHOLDER_NAME]]`. It verifies that the `find_placeholders` function correctly identifies and returns both placeholders as a set containing `{\"[[NEEDS_OVERVIEW]]\", \"[[FOO]]\"}`.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_parser_cpp.py:7bf655540a7446dfdc4c0a3d20712a34c8c0cefe70fdce7aa5e2197a6cc58f87:7bf655540a7446dfdc4c0a3d20712a34c8c0cefe70fdce7aa5e2197a6cc58f87": "Test function that validates parsing of C++ source code into structured data. Reads a sample C++ file containing namespace, function, class, and member definitions with documentation comments. Verifies extraction of module docstring, namespace name, function details including name, docstring, and source code, and class structure with variables and methods. Checks that all parsed elements match expected values from the test input.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_parser_cpp.py:test_parse_cpp:7bd06284cbe0028c1016dee05ae7114c8b311c00f6266cf974984a177006f5b7:7bd06284cbe0028c1016dee05ae7114c8b311c00f6266cf974984a177006f5b7": "The function `test_parse_cpp` tests the parsing of a C++ source file by verifying that the `parse_cpp_file` function correctly extracts documentation strings, function details, class information, and member variables and methods. It creates a temporary C++ file with a namespace, function, and class containing docstrings, then asserts that the parsed result matches expected values for module docstring, namespace, function name and source, class name and docstring, variable name and docstring, and method name and docstring.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_parser_java.py:81c91b4467b1272b3aee2c23a686157de0d00112a71e34af42e7260d11e289fb:81c91b4467b1272b3aee2c23a686157de0d00112a71e34af42e7260d11e289fb": "Test function that verifies parsing of a Java source file. Creates a temporary Java file with package, class, field, and method documentation, then validates the parsed output contains expected docstrings, names, types, and source code snippets for each element. Uses the parse_java_file function from parser_java module to perform the parsing.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_parser_java.py:test_parse_java:cde6fdd143ae9a42eb1fc39085e2721c47caff16fb1c26351612bce0ae40c75f:cde6fdd143ae9a42eb1fc39085e2721c47caff16fb1c26351612bce0ae40c75f": "This function tests the parsing of a Java source file by creating a temporary Java file with a package, class, field, and method, then verifying that the parsed output matches expected values. It checks the module docstring, package name, absence of functions, presence and details of a single class, including its name, docstring, variable field (name, docstring, type, and source), and method (name, docstring, and source).",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_parser_matlab.py:d371df41f01bfadecc63c5f1bddb7b77eb2309a17405bffe247ca4a3e17973bd:d371df41f01bfadecc63c5f1bddb7b77eb2309a17405bffe247ca4a3e17973bd": "Module defines tests for parsing MATLAB files. Includes test cases for parsing a simple MATLAB file with one function and header comments, and another test case for parsing a file containing multiple functions. Uses `parse_matlab_file` function to process MATLAB source files and verifies parsed output structure including header text and function metadata such as names and argument lists. Tests utilize temporary files created in a provided test directory path.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_parser_matlab.py:test_parse_multiple_functions:59ebf6a946723ec23bb80c16132284e7b59396f3c4f3639ba898439e69528b3e:59ebf6a946723ec23bb80c16132284e7b59396f3c4f3639ba898439e69528b3e": "The function `test_parse_multiple_functions` tests the parsing of multiple MATLAB functions from a source file. It creates a temporary MATLAB file containing two functions, `compute` and `square`, with specified arguments and implementations. The test verifies that the parsed result contains an empty header, two functions in the expected order, and correct argument lists for each function. The test uses `parse_matlab_file` to process the file and asserts the structure and content of the resulting dictionary.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_parser_matlab.py:test_parse_simple_matlab:a6febbea232b34babcf85ef2ce15e500a1442617daa13f07d90748cd357cb4d1:a6febbea232b34babcf85ef2ce15e500a1442617daa13f07d90748cd357cb4d1": "Tests the parsing of a simple MATLAB file to ensure correct extraction of header comments and function definitions. The test creates a temporary MATLAB file with a header comment and a function definition, then verifies that the parsed result contains the expected header text and function details including name and arguments.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_parser_python.py:0656a74b22ae45e63880587901e7b10ae787467de6bd22083f6803af85bd3957:0656a74b22ae45e63880587901e7b10ae787467de6bd22083f6803af85bd3957": "Module defines test functions for parsing Python files. Tests cover simple modules with functions and classes, complex function signatures with positional-only and keyword-only parameters, nested class and function structures, deeply nested classes, and inner classes defined within methods. Each test creates a temporary Python file, parses it using `parse_python_file`, and asserts expected structure and content of parsed elements including docstrings, signatures, source code, and nested components. Tests validate extraction of module docstrings, class information with methods, function details including return types, and hierarchical structures of nested definitions.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_parser_python.py:test_class_inside_method:65632f6da22127e332649d9fd2b5d730d20691be9dfe5656c42f63384372327f:65632f6da22127e332649d9fd2b5d730d20691be9dfe5656c42f63384372327f": "The function `test_class_inside_method` tests the parsing of a Python file containing a nested class definition. It creates a temporary Python file with a class `A` that contains an outer method, which in turn defines a nested class `B` with a method `m`. The test verifies that the parser correctly identifies the nested class `B` as a subclass of `A` and that the method `m` is properly recognized as a method within class `B`. The test uses `parse_python_file` to parse the file and asserts the structure of the parsed result, ensuring that the nested class and its method are correctly represented in the output.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_parser_python.py:test_deeply_nested_classes:6773550c5e035ac15d1a6a11be1a87f0b254ded13c5c186c453a465f8efccdf0:6773550c5e035ac15d1a6a11be1a87f0b254ded13c5c186c453a465f8efccdf0": "This function tests the parsing of deeply nested class structures in Python source code. It creates a temporary Python file containing a class `A` with nested classes `B` and `C`, where class `C` contains a method `inner`. The function verifies that the parser correctly identifies the nested structure by asserting that the innermost class `C` has the expected name and that it contains the expected method `inner`. The test uses `parse_python_file` to process the file and validate the hierarchical structure of classes and methods.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_parser_python.py:test_parse_complex_signature:f25666f9dbc49b9e433240ba11cc2ace7c24b84b2f6dea5d2c12289fed7fe79f:f25666f9dbc49b9e433240ba11cc2ace7c24b84b2f6dea5d2c12289fed7fe79f": "Tests the parsing of a complex Python function signature and its associated documentation string. The test verifies that the parsed signature matches the expected format including positional-only, positional-or-keyword, keyword-only parameters, type hints, default values, and return type annotation. It also confirms that the docstring is correctly extracted from the function definition.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_parser_python.py:test_parse_nested_structures:b486741462793ece03718c052b1682ba6fb7af5117408b339a9949748c782372:b486741462793ece03718c052b1682ba6fb7af5117408b339a9949748c782372": "This function tests the parsing of nested structures in Python source code. It creates a temporary Python file containing a nested function and a nested class with a method, then parses the file using `parse_python_file`. The test verifies that the parser correctly identifies and extracts the nested function `inner` within the outer function `outer`, including its source code. It also checks that the nested class `B` within class `A` is properly recognized, along with its method `method`. The function ensures that the parsed result maintains the hierarchical structure of the source code, confirming accurate handling of nested functions and classes.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_parser_python.py:test_parse_simple_module:ebefdae800f2eee1f60d3a4bcf6eaeca1a32523d2dcaa89e0e3794c60933e2b6:ebefdae800f2eee1f60d3a4bcf6eaeca1a32523d2dcaa89e0e3794c60933e2b6": "This function tests the parsing of a simple Python module using the `parse_python_file` function. It creates a temporary Python file with a module docstring, a function `add`, and a class `Greeter` with a method `greet`. The test verifies that the parsed result correctly extracts:\n\n\nThe test ensures that all extracted elements match their expected values and that the source code snippets are correctly included in the parsed output.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_resume_progress.py:3378cf564c2528ac12231265bea97bb649e9510221272bb4eb3d44bdd0ec5d5d:3378cf564c2528ac12231265bea97bb649e9510221272bb4eb3d44bdd0ec5d5d": "Test function that verifies resume functionality of documentation generation with caching. Sets up a project with two Python modules and mocks various docgenerator functions to simulate processing. Configures a mock cache that raises an exception on the first progress update to simulate a failure. Executes main generation process which fails, then resumes it. Verifies that only the second module is processed after resuming, and that both HTML files are generated. Confirms cache progress tracking behavior and ensures all modules are eventually documented.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_resume_progress.py:crashing_set_progress:54cecd04994e619bf489231ea9d5f088c58de24f59d151ffa39b6498fa13bdf3:54cecd04994e619bf489231ea9d5f088c58de24f59d151ffa39b6498fa13bdf3": "The function `crashing_set_progress` is a wrapper around an original `set_progress` function that increments a call counter stored in the `calls` dictionary. When the counter reaches one, it raises a `RuntimeError` with the message \"boom\". This function appears to be designed to simulate or induce a failure on the first invocation while otherwise delegating its behavior to the original progress-setting functionality.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_resume_progress.py:fake_rewrite_docstring:ecab47604ed8746ff85e7f2e102414018b0bf04e86efee116b713311c58a63b9:ecab47604ed8746ff85e7f2e102414018b0bf04e86efee116b713311c58a63b9": "The function `fake_rewrite_docstring` is a placeholder implementation that accepts any number of positional and keyword arguments but always returns `None`. It does not perform any actual docstring rewriting or processing.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_resume_progress.py:fake_summarize_chunked:d545b99d15902c4e56d55efed4b421e95994dc7c952bec2c7368eabd4fa4d438:d545b99d15902c4e56d55efed4b421e95994dc7c952bec2c7368eabd4fa4d438": "The function `fake_summarize_chunked` is a placeholder implementation that takes parameters related to client configuration, caching, text processing, and prompting, but always returns the string \"summary\" regardless of the input. It appears to be a mock version of a chunked text summarization function, likely used for testing or demonstration purposes where actual LLM interaction is not required.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_resume_progress.py:fake_summarize_module:2e5c7e5bc736302f2865985d38062dffe77f71470bc39519e683e4bbf8576d33:2e5c7e5bc736302f2865985d38062dffe77f71470bc39519e683e4bbf8576d33": "The function `fake_summarize_module` is a placeholder implementation that simulates the process of summarizing a code module. It takes parameters including an LLM client, cache object, key prefix, module text, module name, tokenizer, maximum context tokens, and chunk token budget. The function extracts a path from the key prefix, appends it to a global list `module_calls`, and returns a static string \"summary\" without performing any actual summarization. This function appears to be used for testing or demonstration purposes where real LLM integration is not required.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_resume_progress.py:test_resume_progress:3a1a14403d90277a5e989ae14d2587610d00d20967d03666cf77b5f9a92ba963:3a1a14403d90277a5e989ae14d2587610d00d20967d03666cf77b5f9a92ba963": "The function `test_resume_progress` tests the resumable documentation generation feature of the tool. It creates a temporary project with two Python modules, `mod1.py` and `mod2.py`, each containing a single function. The test mocks various internal functions of the documentation generator to simulate summarization and docstring rewriting, and also simulates a failure during progress saving on the first run.\n\nOn the first execution without resume, the function raises a `RuntimeError` due to the mocked failure, and verifies that progress is saved only for the first module (`mod1.py`). On the second execution with the `--resume` flag, it verifies that the generation resumes from where it left off, processes the remaining module (`mod2.py`), and successfully generates HTML documentation for both modules. It also confirms that the cache progress is cleared after a successful resume run.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_retrofit_sidebar.py:1bf15c5133a6a7aec0257f049acf91d95813b55f0aa675712737cb388b83a26e:1bf15c5133a6a7aec0257f049acf91d95813b55f0aa675712737cb388b83a26e": "Module defines tests for `retrofit_sidebar` function and its command-line interface. Tests validate sidebar generation from Python source files, checking link creation for modules and submodules. Includes test cases for missing source or documentation directories, verifying error handling and exit codes. Uses `BeautifulSoup` for HTML parsing and manipulation.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_retrofit_sidebar.py:test_main_missing_docs:53a256c288e13975c1ffd93a2d23ab1d4a2a9fccbf86a613a9f2c29c30898f3b:53a256c288e13975c1ffd93a2d23ab1d4a2a9fccbf86a613a9f2c29c30898f3b": "This function tests the behavior of the `main` function when required documentation directories are missing. It creates a temporary source directory, sets up command-line arguments to point to non-existent documentation and source paths using `monkeypatch`, and verifies that the `main` function returns an error code (1) and outputs an error message indicating that the documentation directory is missing. The test uses `capsys` to capture standard error output for validation.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_retrofit_sidebar.py:test_main_missing_source:71a85d35da39f20f3f3fea79274955a3605a42e5e03ee6e9ea4a6ac3f0249d74:71a85d35da39f20f3f3fea79274955a3605a42e5e03ee6e9ea4a6ac3f0249d74": "The function `test_main_missing_source` tests the behavior of the `main` function when a specified source directory is missing. It creates a temporary directory structure, sets up command-line arguments to point to a non-existent source directory using `monkeypatch.setattr`, and asserts that the `main` function returns 1 (indicating an error). It also captures the error output and verifies that it contains the message \"source directory\".",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_retrofit_sidebar.py:test_retrofit_sidebar:c5d1ad19be02a117e8a2182c4dd2da989c95c876324999978bf44a70eb7bc1b0:c5d1ad19be02a117e8a2182c4dd2da989c95c876324999978bf44a70eb7bc1b0": "The function `test_retrofit_sidebar` tests the functionality of retrofitting a sidebar into an existing HTML documentation page. It creates a temporary directory structure with Python source files, writes an initial HTML document with a sidebar and content section, then calls `retrofit_sidebar` to update the sidebar with links to the source files. The test verifies that the updated sidebar contains correct hierarchical links for modules and submodules, and ensures the original content remains unchanged.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_reviewer.py:_make_module:c5be19aa7b0aa0a899f6982112ddbb374d905e51a539d605b05b4affb3f85ecc:c5be19aa7b0aa0a899f6982112ddbb374d905e51a539d605b05b4affb3f85ecc": "The function `_make_module` creates a module documentation page at a specified temporary path. It constructs a data dictionary containing the module name, summary, and empty lists for classes and functions. If methods are provided, it populates the classes list with a single class named \"Foo\" containing the methods. The function then writes the module page using `write_module_page` and returns the path to the generated HTML file for the module.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_reviewer.py:ee26fa5464fc70b28f10aacbe4841efa3653709226aabf0b93d13f159939e2db:ee26fa5464fc70b28f10aacbe4841efa3653709226aabf0b93d13f159939e2db": "Module defines tests for detecting specific phrases and issues in documentation. Tests check for assistant phrasing, contradictions, and hallucinations in module summaries and method definitions. Includes functionality to automatically remove assistant phrasing when using an autofix option. Tests use a temporary file path and capture console output to verify detection messages. The module generates HTML documentation pages and runs a main review function on them.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_reviewer.py:test_assistant_phrasing_detected:cffa4124b3c640fa62cbf7bd70bcea2dd4b85ff8558e347b189546b5ae5f95ca:cffa4124b3c640fa62cbf7bd70bcea2dd4b85ff8558e347b189546b5ae5f95ca": "This function tests whether assistant phrasing is detected during documentation generation. It creates a temporary module with specific content, runs the main documentation generation process on it, captures the output, and verifies that the output contains both \"[ASSISTANT]\" and \"mod.html\". The test ensures that the documentation tool correctly identifies and reports assistant-related phrasing in the generated content.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_reviewer.py:test_autofix_removes_phrasing:70b9d0ff0616177cac39ed8b4f90b3501b8e893cebe096dd143fe5b9bb5a48b6:70b9d0ff0616177cac39ed8b4f90b3501b8e893cebe096dd143fe5b9bb5a48b6": "The function `test_autofix_removes_phrasing` tests the removal of phrasing during automated fixing of documentation. It creates an HTML file containing the text \"You can call this.\" using a helper function `_make_module`, then runs the main documentation generation process with the `--autofix` flag. After processing, it reads the resulting HTML content and asserts that the phrase \"You can\" has been removed from the output.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_reviewer.py:test_contradiction_detected:ad99781f174b5da8000d18b1a8c157360e621f2fdad272fa5a158081605f1919:ad99781f174b5da8000d18b1a8c157360e621f2fdad272fa5a158081605f1919": "The function `test_contradiction_detected` tests for the detection of contradictions in documentation generation. It creates a module with a method named \"bar\" that has an empty docstring and source, then runs the main documentation generation process on the module. The test verifies that the output contains the string \"[CONTRADICTION]\", indicating that a contradiction was detected during the documentation process. The test uses `tmp_path` to create a temporary directory for the module and `capsys` to capture the output of the main function.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_reviewer.py:test_hallucination_detected:b548511d287477e1b8e379a8c581ccb32af5a9a8fda37ce18e06672fd839bf43:b548511d287477e1b8e379a8c581ccb32af5a9a8fda37ce18e06672fd839bf43": "This function tests whether a hallucination is detected during documentation generation. It creates a temporary module with a specific description, runs the main documentation generation process on it, captures the output, and asserts that the output contains the string \"[HALLUCINATION]\". This indicates that the system has identified a potential hallucination in the generated documentation.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_sanitize_docs.py:daf0cc4cb1542634a8ecb3a034b33efb1836feaeeec74e75b676987d2f6b2104:daf0cc4cb1542634a8ecb3a034b33efb1836feaeeec74e75b676987d2f6b2104": "Tests for the sanitize_docs utility that verify removal of AI disclaimers from HTML files in a directory. The tests check that text content within HTML elements is preserved while AI-related disclaimer text is removed. The first test validates removal of disclaimers from paragraph elements, and the second test validates removal from heading and list items while preserving their structural formatting.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_sanitize_docs.py:test_sanitize_directory_handles_headings_and_list_items:accc731d244dd7ddb02afb59c286370a9e0d0ffddbe84337c9442e26147a1c48:accc731d244dd7ddb02afb59c286370a9e0d0ffddbe84337c9442e26147a1c48": "This function tests the sanitization of HTML content within a directory by verifying that heading and list item text is properly processed. It creates an HTML file with specific content containing headings and list items that include unwanted text, runs the main documentation generation process on the directory, and then checks that the output HTML has been sanitized. The test confirms that the unwanted introductory phrases are removed from the headings and list items while preserving the core descriptive text, ensuring proper handling of text sanitization during documentation generation.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_sanitize_docs.py:test_sanitize_directory_removes_ai_disclaimer:dc209fdbca0315e8c790c511f87b3f050b0f60212561a33061d10bb2979b53c5:dc209fdbca0315e8c790c511f87b3f050b0f60212561a33061d10bb2979b53c5": "The function `test_sanitize_directory_removes_ai_disclaimer` tests the removal of an AI disclaimer from HTML content during documentation sanitization. It creates a temporary HTML file containing text with an AI disclaimer, invokes the main documentation generation process, and verifies that the disclaimer is removed while preserving relevant content. The test ensures that the sanitization process correctly filters out AI-generated disclaimers from the output HTML.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_scanner.py:9fb66b0d67a215b5195a4a239c0f088601d37be9f219b4e6b10e9a18e33b8b13:9fb66b0d67a215b5195a4a239c0f088601d37be9f219b4e6b10e9a18e33b8b13": "The module defines pytest functions to test the `scan_directory` function from the `scanner` module. It includes tests for ignoring specific directories, handling mixed file types, skipping `.git` folders, and supporting C++, C++, and Java file extensions. The tests use a helper function `create_files` to set up temporary file structures in a test directory. Each test validates the output of `scan_directory` against expected file paths, ensuring correct filtering and inclusion of files based on specified criteria.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_scanner.py:create_files:946d26157c3e7807cfdc5bd5b926468a47a1dd3d374ac5572290fea5abfa212b:946d26157c3e7807cfdc5bd5b926468a47a1dd3d374ac5572290fea5abfa212b": "Creates a list of files at the specified base path, ensuring that all parent directories are also created. Each file is initialized as an empty text file. The function takes a base directory path and a list of relative file paths, then creates each file in the specified location. If any parent directories in the file path do not exist, they are created recursively.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_scanner.py:test_scan_directory_ignore_folder:daf7ec47eb056d76d7a203b738be69085a92636f429b2b7d36eacb1f7b694685:daf7ec47eb056d76d7a203b738be69085a92636f429b2b7d36eacb1f7b694685": "The function `test_scan_directory_ignore_folder` tests the `scan_directory` functionality by creating a temporary directory structure with multiple files across nested folders, including a folder named \"ignore_me\" that should be excluded from the scan results. It verifies that `scan_directory` correctly identifies and returns only the paths of files in the root and subdirectories, excluding any files within the \"ignore_me\" directory. The test confirms that the returned file paths match the expected set of file paths, ensuring proper filtering behavior.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_scanner.py:test_scan_directory_mixed_file_types:1dc03bed4c275882650c5da6011387aaff1da644923d03c264365f7bed821b51:1dc03bed4c275882650c5da6011387aaff1da644923d03c264365f7bed821b51": "The function `test_scan_directory_mixed_file_types` tests the `scan_directory` function by creating a temporary directory structure containing files of various types (Python, MATLAB, text, Markdown) in both root and nested directories. It verifies that `scan_directory` correctly identifies and returns paths to only the specified file types (Python `.py` and MATLAB `.m` files), ignoring others like `.txt` and `.md`, and properly handles nested directory structures. The test ensures the returned file paths match the expected set of Python and MATLAB source files.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_scanner.py:test_scan_directory_skips_git_folder:43b1d28259a874749d4ba389702f5c6cbc7f2435f6a593a9ebd34de1cfb662f8:43b1d28259a874749d4ba389702f5c6cbc7f2435f6a593a9ebd34de1cfb662f8": "The function `test_scan_directory_skips_git_folder` tests that the `scan_directory` function correctly excludes files located within a `.git` folder from its results. It creates a temporary directory structure containing a Python file in the root and two Python files nested within a `.git` subdirectory. After calling `scan_directory` on the temporary path, it verifies that the path to the root file is included in the result and that no paths containing `.git` are present in the result.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_scanner.py:test_scan_directory_supports_cpp_h_java:29e6aed9a2e26e5fd1268a41145806759bab95f36b2ce5d6c6efe0b21af57af8:29e6aed9a2e26e5fd1268a41145806759bab95f36b2ce5d6c6efe0b21af57af8": "This function tests the `scan_directory` functionality to ensure it correctly identifies and returns paths of files with extensions `.cpp`, `.h`, and `.java` within a specified directory and its subdirectories. It creates a temporary directory structure containing these file types along with other file types that should be ignored. The test verifies that the `scan_directory` function returns only the expected file paths matching the supported extensions, confirming proper directory traversal and file filtering behavior.",
  "PROJECT:f6876f91ad9e64bfb86b9c836e5de2ac23255ffd739589ea4c99c74034ea5105:f6876f91ad9e64bfb86b9c836e5de2ac23255ffd739589ea4c99c74034ea5105": "This project provides tools for generating and managing documentation from source code. It includes modules for parsing various programming languages, chunking text for processing, summarizing code elements, and rendering HTML output. The system supports caching of responses, progress tracking, and integration with LLMs for automated documentation generation. It also offers functionality for reviewing generated content, sanitizing outputs, and building navigable documentation websites from source files.",
  "README:b0f4974ab84c7cc769a8bde4129f733f7dc545dcd5a7fd31c76ee876a2b1c447:b0f4974ab84c7cc769a8bde4129f733f7dc545dcd5a7fd31c76ee876a2b1c447": "DocGen-LM is a tool that generates static HTML documentation for Python, MATLAB, C++, and Java projects by analyzing source files and summarizing them with a local LLM, supporting nested structures like functions and subclasses. It includes features such as automatic progress saving, resumable documentation generation, and integration with LMStudio as the backend LLM server. The tool also provides a graphical user interface for easier interaction and additional utilities for sanitizing existing documentation and generating project summaries with customizable output formats.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\cache.py:ResponseCache:6e8c2e42633f49496cea58dcadcff0afbb62d6b1782009c6150f015775dc1c55:9b5a313b238d9e9df6d7f1f8612c9fb584df39f70a688b080a30b119baa79c33": "The `ResponseCache` class provides persistent storage for mapping stable keys to LLM responses using a JSON file. It supports retrieving and storing cached values, managing progress tracking for processed modules, and ensuring data durability through disk serialization. The class includes methods for key generation based on file paths and content hashes, as well as operations to clear or update progress information.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\cache.py:__init__:5c9c584978515136e73b349501d9f6cbd46ea5aee08da73c5a9da4b412922afb:fe60a96ec4ccd300618164885e578557fb1778cf0615301007ec95f23ddaa711": "Initializes the `ResponseCache` instance with a specified file path. Loads existing cache data from the file if it exists and is valid JSON; otherwise, initializes an empty cache. Ensures that a progress tracking dictionary (`__progress__`) exists within the cache data.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\cache.py:_save:9eb5a8449356e887f2ffe2ffa415438ec10b63760202c93a8ab935e6c6dfc1f7:291a5012af01444b027e0bc07597c237435919159e6fb71acf69bcc06cfbdc2a": "The `_save` method in the `ResponseCache` class serializes the cached data stored in `self._data` to a JSON-formatted string with indentation and sorted keys, then writes this content to a file specified by `self.file`. This ensures that the cache state is persisted to disk.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\cache.py:clear_progress:2a371c9cfcb958891d77366b4f59972fbbc5d53d32f087fc0d77a0195a2b8e43:e109f6c22ea930435660023c2d29ea48bb99229e1f5d06495601addb128ce24e": "The `clear_progress` method removes all saved progress information by resetting the `__progress__` key in the internal data dictionary to an empty dictionary. It then persists the change by calling the `_save` method.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\cache.py:get:ed68aea5eb0a3b770b1239e46239504e8d963296aeeef6127ff387be731d3902:c81ec706ed0fcf365111c0085ad5149edbb75de15165a5870541490e2c24abb0": "The `get` method retrieves a cached value associated with the specified key from the internal data storage of the `ResponseCache` instance. If the key exists in the cache, the corresponding value is returned; otherwise, None is returned. This method provides access to stored response data using a string key, enabling retrieval of previously computed or cached results.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\cache.py:get_progress:d74f17765426a2338f951d1cf48c69dffb91fc1de4f8ac22b7d4101861b1809a:721cfa89eff7505a884c063373f46bbe523b639f8df0dbe935edcf52013d5f9c": "The `get_progress` method retrieves and returns a shallow copy of the progress tracking data stored in the cache. This data maps processed module paths to their associated information, enabling the system to resume documentation generation from the point where it left off. The method accesses the `__progress__` key within the internal data structure and ensures that modifications to the returned dictionary do not affect the original data by returning a copy.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\cache.py:make_key:7be1f56e9cac7a9342b0fd78723c29e35bbc5dd4bc92ce1eda84176d18f6b163:9e3c141da272d4f423b48c3d2c8625157816e1e73c1c10bb25f875e9225f13b5": "The function `make_key` generates a deterministic cache key by combining a file path and the SHA-256 hash of the content. It takes two parameters: `file_path` (a string representing the path to a file) and `content` (a string containing the file's content). The function encodes the content in UTF-8, computes its SHA-256 hash, and returns a key in the format `file_path:digest`, where `digest` is the hexadecimal representation of the hash. This ensures that the same file path and content combination always produce the same key, enabling consistent caching behavior.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\cache.py:set:223ca54d8c1c030e6bf251921d6d53f77e1f1951a921d6b3dc9d6492de51a8f6:9d01971301ce71c8507f3bbc3ffbef8216abee634766d4294cc1f0d755785c96": "The `set` method stores a value under a specified key in the cache and persists the updated cache to disk. It takes a string key and a string value as parameters, updates the internal data dictionary with the key-value pair, and then calls the `_save` method to serialize the cache to a JSON file.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\cache.py:set_progress_entry:38dd2af76d5aa29f8ca086f9fb98edc8eb6e87fefeea440237577dc34677f548:c59e5d0fbe936adedf13ed7e7c7f8f85be95dc21c9f54c4a2dbf56d3a527e703": "The function `set_progress_entry` records module data associated with a given file path in the progress tracking map. It retrieves or initializes the progress dictionary from the internal data structure, stores the provided module data under the specified path, and persists the updated data by saving the cache to disk.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\chunk_utils.py:_split_blocks:99f8051c91a65d364d0d01c9c2e2f0999843dea56147edeeb34048d4c2b11271:ec9299b93d46a020b2cc0a7cef2486893d2eb6ceda3b6c194920c423670c170c": "The function `_split_blocks` takes a Markdown-formatted text string and splits it into distinct blocks, separating paragraphs, headings, and code fences. It processes the input line by line, tracking whether it is inside a code block (delimited by triple backticks) and appending lines to the appropriate block. The function handles transitions between regular text, headings (lines starting with `#`), and code blocks, ensuring that each block is properly separated and stripped of leading/trailing whitespace. Empty lines are used to separate paragraphs, and the resulting list of blocks excludes any empty strings.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\chunk_utils.py:_split_long_block:34d5f043bdb9a909b83319c24cd548ab34b23db6f2ebee109a3ae466afb75a12:7a0c3fdafa12c53272f6288f6a32a9fb8d9b549e348037c1dfa060952c7aaa5f": "The function `_split_long_block` splits a text block into smaller chunks based on a token limit using a character-based approximation when the token count exceeds the specified chunk size. It encodes the input block using a provided tokenizer, calculates an average character length per token, determines the maximum number of characters allowed per chunk, and then divides the block into segments of that size. If the block's token count is less than or equal to the chunk size, it returns the block as a single-element list.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\chunk_utils.py:chunk_text:487b06c411b006cd9ecb53b999755cdacb3e3d4e90d4daef136eddb9ac659b57:e43092d275e04d9bb261169256a5b630bbe8f04d625a2b3f196d6767f0dd9dd1": "The function `chunk_text` divides a given text into smaller segments, where each segment contains approximately a specified number of tokens. It processes the text by identifying natural breakpoints such as blank lines, Markdown headings, and code blocks to preserve structure. If a block exceeds the token limit, it is further divided based on character length. The function utilizes a tokenizer to calculate token counts and returns a list of text chunks that adhere to the specified token size constraint.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\chunk_utils.py:decode:319411865b4aba3239506d67277e1c4f58d2f9965bd810475f26a3149392e006:697a894246cdd6b06d7e40ef09e18de89f0cd2b7671a50eec07de8685a0097d3": "The `decode` method takes a list of tokens as input and returns a single string formed by joining the tokens with spaces. It performs the inverse operation of splitting text into tokens, reconstructing the original textual representation from its tokenized form.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\chunk_utils.py:encode:6d6417220e5db3a16e16c5618c49ec266880d641365d1b52365214cda43189d8:a3c312cc9ac261dcfe464afe38f0de1899474843544abea576fcc11d15a2b22a": "The `encode` method processes a input string by first removing FIM tokens using the `strip_fim_tokens` function, and then splits the resulting string into a list of words based on whitespace.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\chunk_utils.py:get_tokenizer:d7dc2e4f94ca4e3d380d8dd8f1417db1ae9d9adb75b7ee0fc776c31d3a29f05d:9e7d9bbca5a8e30518ebce42b12cda72541d33dd8647996df8c0a3cfec64c64c": "The function `get_tokenizer()` returns a tokenizer object for estimating token counts. It attempts to use the `tiktoken` library to load the `cl100k_base` encoding, with fallback to `gpt-3.5-turbo` if the former fails. To prevent network-related warnings during encoding loading, it temporarily suppresses unraisable exception hooks. If `tiktoken` is unavailable or fails to load, it provides a simple fallback tokenizer that splits text into tokens and joins them back. The returned tokenizer includes `encode` and `decode` methods, with `encode` stripping FIM tokens before processing.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\chunk_utils.py:strip_fim_tokens:e66eef84ef0acdd107c91b656abadff479928dc5832f108fc40ee015e51241f5:086173eee8f977f3a2005c7b05bc04e4fc148b05268c1d1f58c93d254325a2b9": "The function `strip_fim_tokens` removes FIM (Fix-It Merge) special tokens from the input string `text`. It uses a regular expression `FIM_RE` to identify and substitute these tokens with empty strings, effectively stripping them from the text. The function returns the modified string with the tokens removed.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\docgenerator.py:_build_function_prompt:d94e2c45b867db9af41a2f5f09b7f530c4d56634fecfaf2a83f2993740936ba7:e848503120386a83ccdf2cb40d2540565060f6acdb19bf9d23ea322dda3fe668": "The function `_build_function_prompt` generates a context-enriched prompt for summarizing a given function's source code. It accepts the function's source code and optional class and project context details. The prompt includes instructions for the summarization process, specifying that assistant phrasing, unrelated content, and external references should be omitted. The function's source code is embedded within a Python code block in the generated prompt.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\docgenerator.py:_chunk_module_by_structure:eabbc3229f6a720fc7669b8cc45190bc022d0a567a6ada7c1a6ace3720e6ff51:5a07ede6044b82e9b91695e5fad9a92d4b61930c472d901bd377f2f5eb868440": "The function `_chunk_module_by_structure` takes a parsed module dictionary, a tokenizer, and a maximum chunk size in tokens, and returns a list of text chunks derived from the module's structure. It processes the module's docstring, classes (including their methods and variables), and functions, organizing their source code into blocks. Each block is checked against the token limit; if it exceeds the limit, it is further split using the `chunk_text` function. The function builds chunks by combining blocks until adding another would exceed the token limit, ensuring each chunk respects the specified size constraint.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\docgenerator.py:_rewrite_docstring:a866e3e46eba4f124249bf53737c6e615f6b8f5524f944eadb2012ec4dbdf379:72f9f26a43331f5d2d8a9bcac4b3cae56a613513985afa48f4bebe65a75385b9": "The function `_rewrite_docstring` updates the docstring of a code item by rewriting it using a language model, with optional contextual information. It takes an LLM client, cache, file path, and item dictionary as inputs, along with optional class and project context. If the item lacks source or docstring content, it issues a warning and exits. It constructs a prompt based on whether contextual information is provided, generates a cache key, and uses `_summarize_chunked` to obtain a rewritten docstring from the language model. The resulting docstring is sanitized and stored back in the item dictionary. If no docstring exists initially, the function returns early without modification.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\docgenerator.py:_summarize_class_recursive:08043f021beff9facfc22a0025244ea32fa4c61c77b9fdac1bd835381e86baf0:09c0bbff5a2d7e0802d9f3733e1bf3eb00b9058a89c09dcf7a5b7f96336c86e0": "The function `_summarize_class_recursive` recursively summarizes a class and its members, including methods and variables, by generating documentation using an LLM. It first processes the class's members through `_summarize_members_recursive`, then constructs prompts for methods and variables, and uses `_summarize_chunked` to generate a class summary. The original docstring is preserved, and the function updates the class's summary and docstring fields. It also rewrites docstrings for each method and variable using `_rewrite_docstring`, and recursively processes any subclasses. The function integrates with a caching mechanism and respects token budget limits for LLM interactions.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\docgenerator.py:_summarize_function_recursive:bdb77c1a1fa2159685061222e64b0b47c566f108f8cf7ec83a308828a9aeb4ed:5edd2c934bd7ebd9e778e92acdc36576e9c93b64714d3bb11292e7bff0aaee71": "The function `_summarize_function_recursive` recursively summarizes a given function and its nested subfunctions and subclasses. It takes a dictionary representing the function, along with associated metadata and configuration parameters including an LLM client, cache, tokenizer, and token limits. The function constructs a prompt based on the function's source code and surrounding context, then uses a chunked summarization approach to generate a summary. If enabled, it also rewrites the function's docstring. After summarizing the current function, it recursively processes any subfunctions and subclasses contained within the function definition. The results are stored directly in the input `func` dictionary.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\docgenerator.py:_summarize_members_recursive:ddb16f464b59600b635f7ef7d6e2ddafe514b953fc47364a167d76ab127bed74:9724fa09c31ab24002abe7af178233ea727cddd829ef96aea334a70e263037d2": "The function `_summarize_members_recursive` recursively summarizes the methods and variables of a given class and its subclasses. For each method, it retrieves or constructs the source code, generates a cache key, and uses `_summarize_chunked` to produce a summary. The resulting summary is stored in the method's data under the keys \"summary\" and \"docstring\". It then calls `_summarize_function_recursive` to further process the method. Similarly, for each variable, it generates a summary and stores it in the variable's data. Finally, it recursively processes any subclasses present in the class data. The function operates with provided LLM client, cache, tokenizer, and token budget parameters to manage summarization and caching.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\docgenerator.py:_summarize_module_chunked:13b377ac8b7044efaf931e7d3548476714f55187ab4e5fb0f6cc5ce60dfce7e9:9c6562963f3662e377eee5e8ca0e7066cbc98ef01aa2eaa0d20e9b10d2e2a06b": "The function `_summarize_module_chunked` summarizes a module by using structure-aware chunking to manage token limits for LLM processing. It first calculates available tokens after accounting for system and template overhead, and if the module text fits within the limit, it summarizes the entire text directly. Otherwise, it chunks the module based on its structure and summarizes each chunk. If structure-based chunking fails, it falls back to summarizing the full module text. The partial summaries are then merged recursively into a single summary, respecting token budgets. If merging fails, it returns a concatenated version of the partial summaries. The final output is sanitized before being returned.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:Config:0b3ed3eff1c79c43fbe5d931fef9fce219dad2ae4a03975c80a50074ce4a92d9:594733ac4138c0c5ad11ce6e6840136f00c85e7c41a44ed0802b36201d93f5ba": "The `Config` class defines a configuration structure for parsing command-line interface arguments. It includes attributes for file paths, output formatting options, title settings, and various code processing parameters such as chunking strategies and time budgets. The class uses type hints to specify the expected types for each configuration parameter.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:_edit_chunks_in_editor:3a1132afcde238f518b02e7d538774ba17ea7a5201486525458f158319458258:c170e94e36b6fd5d9495dfaebb99e2311a07c52752cf31fa809d55bc2c2f0a02": "The function `_edit_chunks_in_editor` takes a list of strings (`chunks`) and opens them in a user's preferred text editor for modification. The chunks are joined with a separator line (`---`) and written to a temporary file. After the user edits and saves the file, the function reads the updated content, splits it back into chunks using the same separator, and returns a list of non-empty, stripped chunks. The editor used is determined by environment variables `EDITOR` or `VISUAL`, defaulting to `vi` if neither is set. Temporary files are automatically deleted after use.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:collect_docs:38b84cc617e91055f65c6f25e0f261ffa880fc99cb366175b974c7e0b50288d5:d741338c13555da1dee0e79952bf52bf1e05894942dc2aa878c3c606c2f70474": "The function `collect_docs` gathers documentation files located under a specified base directory. It identifies files matching certain patterns in two locations: the project root and a `docs` subdirectory. Specifically, it includes files with extensions `.md`, `.txt`, `.html`, and `.docx` in the root, as well as all `.html` and `.md` files recursively within the `docs` directory. The function ensures that each file is included only once by tracking seen paths and returns a list of unique documentation file paths.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:collect_files:1a8104b36aa996b6efdde4d2d31eee45f2e419d6d139c79d3d9750e042ee3f07:3e684c8a24a847c73ceee9fcbc331b98307c3808ce361139876a9167501433ed": "The function `collect_files` takes a base directory path and an optional iterable of additional file patterns, then returns an iterable of file paths relevant for summarization. It first collects files matching default patterns including README.md, text files, HTML files, DOCX files, CSV files, and JSON files. If extra patterns are provided, it extends the search to include those as well. The function ensures that only unique files are returned by tracking seen paths and filtering out duplicates.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:detect_placeholders:f61f420d930ca74cd80dce22df34ee5a1da7028c229d006b9f3dc1b8df9bc5c7:0e5d68781a1baf3ece7c75d096931146750fddfb95514a04bf9216ca144d61f1": "The function `detect_placeholders` takes a string input `text` and returns a list of section names that are still marked by placeholder tokens. It first identifies all placeholders present in the text using the helper function `find_placeholders`, then filters and returns the names of sections from `SECTION_PLACEHOLDERS` whose corresponding tokens are found in the identified placeholders.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:extract_snippets:4ff1c07b38c4e8467e9721ff525059da67709cf5ade03bc9d5b47aeba7686b00:8e68973fd57938f159d08cfb5028833a1858da96f819bee33297e568a0d48c05": "The function `extract_snippets` takes an iterable of file paths and extracts relevant code snippets from them based on specified limits. It processes each file up to a maximum number of files, within a time budget, and respecting a maximum file size. For Python files (`.py`), it parses the abstract syntax tree (AST) to extract module docstrings, class and function docstrings, I/O signatures for functions with specific argument names, CLI parser lines, and `__main__` blocks. For non-Python files, it includes the entire file content. The extracted snippets are returned as a dictionary mapping each file path to its corresponding snippet text.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:extract_text:4da878b9ae9b1f0fe27596cce6d283d77a91e05cacf2890e0ec934097ecd3251:10327891ba05ffffba26cfe70e855320eb3cc025764f6f32c98e7e5124d8da6f": "The function `extract_text` reads and extracts plain text from a file at the specified path, converting content to a standardized text format based on the file type. For HTML files, it processes headings by converting them to Markdown-style headers and code blocks into fenced code blocks, then returns the cleaned text. For Markdown files, it returns the raw text. For DOCX files, it extracts paragraphs, converts heading styles to Markdown headers, and appends other text as-is. For all other file types, it reads the file as plain text. If any error occurs during processing, it returns an empty string.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:infer_sections:3cee90565bd78451d1240aae1534a19ba5456f19145dd895cc6216084bd4c60c:6d8293aa54196554b4f20c7141b09f2fb65431537312581627b0e33f7f8f95f6": "The function `infer_sections` takes a string input `text` and returns a dictionary mapping section names to their corresponding content. If the input text is non-empty, it assigns the text to the \"Overview\" section and populates the remaining required sections with placeholder content indicating that the details are inferred. If the input text is empty, all required sections are assigned a default message stating that no information is provided. The function uses a predefined list `REQUIRED_SECTIONS` to determine which sections to include in the output dictionary.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:inject_user_manual:d64c8b9c283b5bac83eadd5f08759bda2f913e282ed4eb3b6861dbd0bfcc6928:d98b3c89371262fff9ec465f8b3b21bbada9a173358f501111a438351c8e0912": "The function `inject_user_manual` inserts a hyperlink to a user manual into an HTML file specified by `index_path`. The link, with the text defined by `title` and pointing to `filename`, is added as the first item in the first navigation element (`<nav>` or `<ul>`) found in the document. If no such elements exist, the link is inserted at the beginning of the first element within the `<body>` tag or the document root. The function uses BeautifulSoup to parse and modify the HTML content, ensuring the manual link is properly integrated into the document structure. If parsing fails, the function silently returns without making changes.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:insert_into_index:ddf3081f465b6ef25e63a71cf4fda6046a0047d1644ffc891826d8bdd5fdd28e:267aa0d0983a3d72b16c5370984b18588c990a259995bf50d6cd07acc763579f": "The function `insert_into_index` appends a navigation link to an HTML file. It takes the path to an index file, a title for the link, and the filename to link to. The function reads the HTML content of the index file, parses it with BeautifulSoup, and finds either a `<ul>` or `<nav>` element to insert the new link into. If a link with the same `href` already exists, it does nothing. Otherwise, it creates a new anchor tag with the provided title and filename, wraps it in a list item if inside a `<ul>`, and appends it to the container. Finally, it writes the modified HTML back to the index file. If any error occurs during parsing or writing, the function silently returns without making changes.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:llm_fill_placeholders:8180322c0c9b4d4f3f72bccec40261d0c7f622810e3b5caacfefee911ee3d6a7:70a17627a17f21a1e53c193b0167ca42e8073803ccfc67c617a6b658841342da": "The function `llm_fill_placeholders` replaces placeholders in a manual text with relevant code snippets using an LLM. It takes a manual text, a dictionary of code snippets organized by section, an LLM client, and a response cache. For each section, it constructs a prompt that includes the manual text and the corresponding code snippets. If the combined token count exceeds the maximum context size, it summarizes the snippets first. The function then calls the LLM to update the manual text with information from the code snippets, returning the updated manual after processing all sections.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:llm_generate_manual:9e8dd48fead956b7c4483e3245cb7a1c388d4a67a9b298ee931b950202e7e2ec:94658d4a01ef930d6780ec4adbac987688592006c56eb0f28404e611f7dbbf25": "The function `llm_generate_manual` generates a user manual from provided documentation snippets by mapping them to predefined sections, performing LLM-based summarization per section, and assembling the final manual text. It returns the complete manual text, a mapping of source files to their contributed sections, and an evidence map detailing the snippets used for each section.\n\nThe function first maps documentation snippets to manual sections using `map_evidence_to_sections`. For each required section, it checks if content was inferred (i.e., no snippets were provided). If so, it uses a placeholder. Otherwise, it constructs a prompt from the snippets and sends it to an LLM via `client.summarize`, with caching and chunking support for long inputs.\n\nThe result is parsed and sanitized, with placeholders replaced if necessary. The final manual text is assembled by joining all processed sections. Logging provides information on section generation, including source files and inferred status.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:map_evidence_to_sections:292e3c0b3505c81f99ef2bbbb436f05dbea9328dd460d077bee0ee1d2b1edb12:7e2971d002cf365799c989163f4aa9899a3f347a720235188b59f248bbbf06c4": "The function `map_evidence_to_sections` maps documentation snippets from source files to predefined manual sections based on keyword matching. It takes a dictionary of file paths and their content as input and returns a tuple containing:\n\n1. A dictionary (`section_map`) that maps each section name (from `SECTION_KEYWORDS`) to a list of tuples, where each tuple consists of a file path and a snippet of text belonging to that section. Each section retains only the top 10 snippets by length, except for \"Overview\" which is sorted differently.\n2. A dictionary (`file_map`) that maps each file path to the set of sections it contributed to.\n\nThe function excludes certain directories (\"tests\", \"examples\", \"fixtures\") from processing and limits snippet length based on whether the file resides in an excluded directory. Snippets are collected by identifying lines containing keywords associated with each section, and subsequent non-empty lines that are not comments or HTML headers are included until the maximum line limit is reached. For the \"Overview\" section, special sorting logic prioritizes README files and those in a \"docs\" directory.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:parse_manual:181d3d445eaa6cc95986244c7741f4ac7dd3e7decbfc35f004333f60facf69d8:48e29a62a6b3230fc18bd342e1186b0e4860eaa26c3c70d23ffed6d36d5b1b4e": "The function `parse_manual` takes a text input and parses it into structured sections based on colon-separated headings. It splits the input on lines containing a colon and stores the sections in order. If `infer_missing` is enabled and required sections are missing, it uses an LLM client to generate inferred content for those sections. The function returns a dictionary of section names mapped to their respective content, with inferred sections marked as \"(inferred)\".",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:rank_code_files:96da31fb85c1392261c6a7e0714bc54838ec83bc9f7dd676d9822cbb181b8623:94ea1ade637fca519292368dbf60da53cff5ff15fab013df304ceca62dffa032": "The function `rank_code_files` takes a root directory path and a list of patterns, and returns a sorted list of code file paths under the root directory. The files are ranked based on simple heuristics: files containing specific keywords in their relative path are given higher scores, as are files matching patterns provided in the input. The function supports Python (.py), MATLAB (.m), Jupyter notebook (.ipynb), C++ (.cpp), C header (.h), and Java (.java) file types. It skips certain directories such as virtual environments, version control folders, and common project directories like tests and examples. Files are sorted primarily by score (descending) and secondarily by path (ascending).",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:render_html:a73ed98676ca4dbe9de987eafbf86a672ebeb6298a7e68f6424632bca8385475:70bc8020c188661de09c8d7b7d7fafe5a7ce306b7e7c1b73a474e37c182c286f": "The `render_html` function generates an HTML document from a dictionary of sections, a title, and an optional evidence map. It creates a navigable HTML page with a table of contents, section headers, and content rendered from markdown or escaped text. If a section's content is empty or indicates \"no information provided,\" it includes supporting evidence snippets and source files from the evidence map. The function uses slugified section titles for anchors and applies basic styling to the output. It handles markdown rendering with fallback to HTML escaping if markdown is not available.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:scan_code:87bd39cdf3fe27087efdd7567425ecd3ab5e430e1eac6bfa50ab7bd4d9723b90:c8b141fa65ae105ee515aa023c9c66adc1e99e08867f0b4c5b9e176ca01f6062": "The function `scan_code` collects source code snippets from a specified base directory, organizing them by manual sections based on keyword matching. It takes a base path and optional parameters to limit the number of files, time budget, and maximum file size. The function identifies relevant files by analyzing documentation files for patterns and ranks them accordingly. It then extracts snippets from these files, and categorizes them into sections defined by `SECTION_KEYWORDS`. Only sections with matching snippets are included in the returned dictionary, which maps section names to dictionaries of relative file paths and their corresponding code content.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:slugify:1fa8adec3e1d148b1c143608a07daa33e1c0c00c9e4560c2510d0b70c580682d:caac45232c36676319c37242aa7c4716ea5d57cb8b9990cf4a816d8cf442edfc": "The function `slugify` converts a given string into a filesystem-friendly slug. It takes a string input, converts it to lowercase, replaces any sequence of non-alphanumeric characters with underscores, and removes leading or trailing underscores. If the resulting string is empty, it returns the default value \"user_manual\".",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:validate_manual_references:649c701325b0326ac454fba99493ab058b249719d8966a5d1951110881461a30:d34ba2aa8f5ea2d2f1ea6cfa375964cdc9fdfce43013722779f383fa15c59f7d": "The function `validate_manual_references` identifies and flags file references within a dictionary of section texts that do not correspond to existing files in a project. It scans each section's text for substrings matching file patterns (e.g., `.py`, `.m`, `.md`) and checks if the referenced paths or filenames exist under the specified project root. If a reference is missing, it appends `[missing]` to the reference in the text and optionally records the missing references in an evidence map. The input dictionary of sections is modified in place.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:write_pdf:66598c7b90ec631b87c7060cba4f613df2713777786390d19bd8b3a344b0ae14:8140a94bb0d7a2c13a4dcbbf155b54f0511322eb98711a3db41f5fd991ded752": "The function `write_pdf` converts HTML content into a PDF file. It takes an HTML string and a file path as inputs, and writes the HTML content as a PDF to the specified path. The function uses the `canvas` module to create the PDF, extracting text from the HTML using BeautifulSoup and writing it line by line. It returns `True` if the operation is successful, or `False` if the `canvas` module is not available.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:__init__:80dd76222ccac240ad43309f8235ded57d8e61983b485f05525c6db3a1b778b4:818d6c56e2540d18e5ca6b89ab783e78c2bb006b48ad8cc92041d56370854ad0": "The `__init__` method initializes a `PathLineEdit` instance. It calls the parent class constructor and enables drag-and-drop functionality by setting `acceptDrops` to `True`.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:__init__:94fb13c9d809765540be62092d264c6ecf41cd2f603238c81476a424719891ae:3b3483c2add2189eafa9b3028609cfef3346136866323ce6e330fea50519d3b6": "The `__init__` method initializes a `CollapsibleBox` instance with an optional title and parent widget. It creates a toggle button styled to display the title with a right-pointing arrow, sets up a content widget that is initially hidden, and arranges them vertically within the box using a `QVBoxLayout`. The toggle button's click event is connected to the `on_toggled` method to handle visibility changes of the content area.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:__init__:b4909347c3d221231a773df1987de78723075cfa1bfc9cde08a10ba3d5b3a507:feadaf28c121df2f3bf2e9df7f5a566fe1bdcfee04e30ff5dd74bab2fbd4cde6": "The `__init__` method initializes the `MainWindow` class, setting up the graphical user interface for the DocGen-LM documentation tool. It configures the window title and dark theme styling, creates a header with a logo and title, and sets up input fields for selecting project and output directories with browse buttons. It includes options for configuring documentation generation, such as including private functions and selecting supported programming languages (Python, MATLAB, C++, Java). The interface also provides settings for the ExplainCode feature, including output format selection and an option to include input data analysis. A log display area is included for showing program output, and buttons are provided to run DocGen, resume DocGen, run ExplainCode, or execute both tasks sequentially. All UI elements are organized into a main layout.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:__init__:d07f5d5fed56e6e8feaf4b410481b2d450cb5a24cb20e93cb4fe559e1055e127:61df613d662672d9fb7475c42f642c72623afd529a1c92d5ec1a22f650520d7a": "The `__init__` method initializes a `CommandRunner` instance with a sequence of shell commands. It inherits from a base class and stores the provided list of commands in the instance variable `self.cmds`.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:_reader:6e17f288f264895e0f202433d1a0ef67fd68e447b01ccfb653867901b4f5522e:cb0b59caf0bdae4a12d98072d9a272d8e8b25264d95add39cef0bbbe48d85ab5": "The `_reader` method reads from a given stream character by character and emits output chunks. It handles carriage returns and newlines specially, ensuring that buffered text is flushed when the stream ends. Carriage returns are emitted individually to allow GUI progress bar updates, while newlines cause the buffered text to be emitted followed by the newline character. Characters that are neither carriage returns nor newlines are appended to a buffer, which is emitted when a special character is encountered or when the stream ends.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:append_log:76d2778882036c679a2a0586ba5b4599da5460a1335edc30ee9fb103c0e17d2d:072692aafc4f488b0efb6185d64474ca7e849860bc178e7ccb84a21e470593b4": "The `append_log` function appends text to the log display in the `MainWindow` GUI. It manages the text cursor to ensure new content is added at the end of the log, handles line-ending characters by removing existing content on the current line before inserting new text, and automatically scrolls the log view to the newest entry. The function uses regular expressions to split the input text on carriage return characters and processes each part accordingly. It updates the vertical scroll bar to keep the latest log entry visible.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:build_docgen_cmd:58a7d148754b68a4085b1fadf1b43ef6955c7765037b848b7a31386a4f26bc3f:d2eb55f5669624096c61c64c177e8e4e2af14fc967a7e6a55dec830ebcc892ee": "The function `build_docgen_cmd` constructs a command list for executing the documentation generation process. It initializes the command with `pythonw` and the path to `docgenerator.py`, followed by the project directory from `self.project_edit` and the output directory from `self.output_edit`. If the `resume` parameter is True, it appends the `--resume` flag to the command. Additionally, if the checkbox `self.docgen_private_cb` is checked, it adds the `--include-private` flag. The function returns the constructed command list.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:build_explain_cmd:c2a42ad24b7aa47f4dfe33b872dddd0242ed30b7f1ca529910783599738c026b:ea7e28d7e95cf4e1dd2b3cb1beb6d5f16bacfdbf618476b27a911c7ee50253ec": "The function `build_explain_cmd` constructs and returns a command list for executing the `explaincode.py` script. The command includes arguments for the project path, output directory, and output format, sourced from the GUI input fields `self.project_edit`, `self.output_edit`, and `self.format_combo`. If the data inclusion checkbox is checked and a data path is provided, the command is extended with the data path argument. The function returns the constructed command as a list of strings.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:dark_style:177bbf95f6a17d96630a0e2d8be7c1b50bdbe78d23cab2399b18544fbf5864be:960c1a4f05bf7f0598cd7d22f8c8c46ffc951127f12cf7e1c8f03b7ef0c3e09d": "The `dark_style` function returns a CSS-style string that defines the visual appearance of UI elements in the `MainWindow` class. It sets a dark color scheme with specific colors for widgets, line edits, plain text edits, combo boxes, push buttons, and labels, ensuring consistent styling for the graphical user interface.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:dragEnterEvent:e5aa308d875cb533d22ceae07481de2d84f3cb97c4ceb60eb68ccbff89753e17:a4f0432e81772dfd48dfb526da9e62601552909b9f0dd0ca98685a650a1458b6": "The `dragEnterEvent` function accepts a drag event and checks if the dragged data contains URLs. If URLs are present, it accepts the proposed action, enabling the widget to handle drag-and-drop operations for file paths.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:dropEvent:3d4a603a73fd59c416d60394befce056363c7b56b31b6a0096cf588d552f9562:2c24171ad2e7013bcdccfb24a9631e3091bc02918bb8d27bde2daf0bc7cd5eed": "The `dropEvent` function handles the drop event for the `PathLineEdit` widget. It retrieves the URLs from the drag-and-drop operation's MIME data. If URLs are present, it extracts the local file path from the first URL and sets it as the text content of the line edit widget.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:on_finished:fcdd0b8dfbf56dafcab26b43c05abce431a3df38458eaaaad06e65772735c644:b3b7f03b38a752af2a96d81c51b4a86093ff9ad10155300254b9dc8f0411a75f": "The function `on_finished` is called when a process completes execution. It logs the exit code of the process to the interface's log display and updates the running state of the application to reflect that no process is currently active.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:on_toggled:9d6814d4c5c0c4aea2000e0105ed7ce4c84e51f4d2141b051259ccb46840c0c8:ea04c71eea1e1e17f19b4bd45030ffeb3c96bcf99879d4f31cea6dbab5886eb9": "The `on_toggled` method handles the visual update of a toggle button and the visibility of a content area when the button is clicked. It checks the state of the toggle button, sets the arrow direction of the button to indicate the current state (down for expanded, right for collapsed), and shows or hides the content area based on whether the button is checked.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:run:de35d1cd373b86d50f407292b373905e9ecfe09adda576e00acfaa060912916a:aaa9de243acc05f5ac1e38673958e6c8f8a059ce841612835ddb3b111518e40a": "The `run` method in the `CommandRunner` class executes a sequence of shell commands by spawning subprocesses and capturing their output in real-time. For each command, it emits the command line as a string to the `output` signal, then uses `subprocess.Popen` to start the process with piped stdout and stderr. Dedicated reader threads are created to handle the output streams, ensuring that chunks of output are emitted in real-time. The method waits for the process to complete and joins the reader threads. If any command returns a non-zero exit code, the execution stops and the method breaks out of the loop. In case of exceptions during process execution, the exception message is emitted and the return code is set to -1. Finally, the `finished` signal is emitted with the overall return code.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:run_both:99fae9293deba894e7e36ace14af27628cbb1d6eae32b057fb048a391f5c13bd:5d4f833d623b5f456c6b4891960aff2ea05b227550f29dab71601a06ccb714d1": "The `run_both` function clears the log display and executes a sequence of commands that generate documentation and explain code by calling `build_docgen_cmd()` and `build_explain_cmd()`.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:run_commands:aee4cfe0cdb84bcefa9665b9e79a37fbb569839e4da68cc9716bee60b027522d:ed3cbfe8b1609b1283d2ac1d350ef70b221c14bdc0ceb9d1d94fdc4fd0c41514": "The `run_commands` function initiates a documentation generation process by validating that both project and output directory paths are specified. If either path is missing, it logs an error message and exits. Otherwise, it configures the interface to reflect the running state, creates a `CommandRunner` instance with the provided commands, connects its signal handlers for output logging and completion handling, and starts the runner to execute the documentation tasks.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:run_docgen:ca320efefbe2b52aaa3dfcea62e470ababaa3c9219e24e02cf85938f77c5691e:103419abc01cce1c3760f27b52ac6d204401cb0d689f6058cc6fd0cea5f34c6a": "The `run_docgen` function clears the log display and executes the documentation generation command built by `self.build_docgen_cmd()`. It uses `self.run_commands()` to run the constructed command, initiating the documentation generation process.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:run_docgen_resume:0cc4d411a49846173291c82bbb5a00b863ae99c5354272ac8c69171383660c37:5c9b047e623f5c392196eb6431a145a0af568da8d51d0c770292ac03cf97c6cb": "The function `run_docgen_resume` clears the log display and executes a documentation generation command with the resume option enabled. It uses the `build_docgen_cmd` method to construct the command with `resume=True`, then runs this command through `run_commands`. This allows the tool to continue generating documentation from a previously saved progress state.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:run_explain:1b49d6c4a60867dcc1d42a9b885cf41fee7c49c456b726065ec5182d8fd133d4:abe290b1c002a987fc39d8bb9ee05ba218d90289ef28540d688857433cea3472": "The `run_explain` function clears the log display and executes a command to explain code by calling `build_explain_cmd()` and running it through `run_commands`.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:select_dir:e2990aa120a11f835ac6a91d5d20d62803f613db33250a3ce24f19c5870842ee:168e88d1d2e8fd965a13cd165b16f1344331efd6d2f561e4578292dd65cb0033": "The function `select_dir` enables the user to choose a directory through a file dialog interface. When a directory is selected, the path is set into the specified `line_edit` widget, which typically represents a text input field in the graphical user interface. If no directory is selected, the `line_edit` remains unchanged.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:select_file:5dfa084e5074bd07085f25daf3c1e835f12b120fc33eb41175a15948b3f777dd:8552e0039b85f8459ba7d9b8c234626f682f050fd0e5061cab20565d3e425be7": "The function `select_file` enables the user to choose a data file through a file dialog and updates a specified line edit widget with the selected file's path. It supports selection of JSON, CSV, and text files, along with all file types as a fallback option. If a file is selected, the path is set into the provided `line_edit` widget; otherwise, no action is taken.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:setContentLayout:86fbe02eafb5cc04762d1b7d70e1cdc400db8bda4da8953eaff08fc2c9a8f373:c24b146ea308c2c841ec4441d8d76bd31a1686ffe8c7e5a0710d8c0a3c7f8f16": "The `setContentLayout` method assigns a specified layout to the content area of the `CollapsibleBox` instance. It sets the provided layout object as the layout for the internal `content` widget, enabling flexible arrangement of widgets within the collapsible section.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:set_running:d5f501d99d57821cc2a28613ec3a944ce81ab3a81cb887771cf788631c889a3b:a2fd0ab88c069aaeb141860f6a7c6c6048a43dbe162b4bce213e82775ffa41ff": "The `set_running` function enables or disables specific UI buttons (`docgen_btn`, `resume_btn`, `explain_btn`, `both_btn`) based on the `running` state. When `running` is `True`, the buttons are disabled; when `False`, they are enabled. This prevents user interaction with these controls during documentation generation or related processes.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\html_writer.py:_highlight:1498a92c1a1628e05dd9ff934640b051cfdab6e1e452f8c60a8866302d83b81d:1f24cde23d3654dedda4304bfd7a17625c07fd65ab4f92d0d67b779bec71ab19": "The function `_highlight` takes a string of code and a language identifier as input, and returns the code formatted with syntax highlighting for the specified language using the Pygments library. It selects an appropriate lexer based on the language (supporting MATLAB, Python, C++, Java, or plain text), applies HTML formatting to the highlighted code, and wraps it in `<pre><code>` tags for proper display.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\html_writer.py:_render_class:51609158e04853fc3dc021ebcd86f4ea30f1647e78ca71435a1920b4abff09e0:a7e363db44f5ceb3d92545369e19b9874203d66474b70e6e40460f5efe8e46ac": "The function `_render_class` generates HTML content for a class and its nested elements, including variables, methods, and subclasses. It takes a dictionary representing the class, the programming language, and an optional heading level. The output is a list of HTML strings that define the class structure with appropriate headings, documentation, variable details, method summaries, and collapsible subclass sections. Variables and methods are rendered with their respective summaries and source code highlighting. Subclasses are displayed in collapsible `<details>` blocks with summary headers. The function supports hierarchical structuring using HTML heading tags (`h2` through `h6`) and ensures proper escaping of HTML content for safety.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\html_writer.py:_render_function:30711e4df652cc6e670ee9747f423fccfd3a7dd765b6a9fa24fc34ee041bc8e3:9428aa1dac5780360b9d84685761b1625b4cb0215a259b74ef456329bf0af40c": "The function `_render_function` generates HTML content for a given function and its nested subfunctions. It takes a dictionary representing the function, the programming language, an optional heading level, and an optional prefix. The output is a list of HTML string parts that include the function's signature, summary (from either `summary` or `docstring`), source code with syntax highlighting, and recursively processed subfunctions wrapped in `<details>` elements. Each subfunction is rendered with its own signature and nested content, maintaining hierarchical structure through increasing heading levels.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\html_writer.py:_render_nav_tree:3cd326f5177248c77bb0c6ed162de6b4880771d30dc5ba6de518f72ae66f0d5e:6dd37bc61e7a07a1a8c1866ef194161baa7b773d2fa3a2fce957b3d2b82f4744": "The function `_render_nav_tree` generates HTML code for a nested navigation tree from a dictionary structure. It accepts a dictionary `tree` representing the navigation hierarchy and an optional boolean `include_home` to determine whether to include a home link. The function uses a nested helper function `_render` to recursively process the tree structure, creating HTML list items for files and collapsible sections for directories. Files are rendered as links, while directories are shown as expandable summary elements with nested lists. The output is a complete HTML unordered list representing the navigation structure, with proper escaping of text for HTML safety.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\html_writer.py:write_index:21dde3b082404c96266472d034517e2fdef9906b083e2770af6747cb4285910b:f0009e08d6a4fde47f3223f0204e1ce2192693df927acf99906f669686cb5729": "The function `write_index` generates an `index.html` file in the specified output directory. It uses a project summary, a navigation tree, and optional module summaries to construct the page content. The navigation tree is rendered into HTML, and module links with optional summaries are listed under a \"Modules\" heading. The final HTML page includes a title, navigation sidebar, project summary, and a list of modules with their respective links and summaries. The resulting HTML is written to `index.html` in the output directory.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\html_writer.py:write_module_page:addb14ee1df2f1b831c2be45310bc29c949a0e345abdb9115a44c6eb1ee1a9be:66025b08f3f20be00602dd7efdb4c7222d82365118775f27734ce80ddab94aaf": "The function `write_module_page` generates an HTML documentation page for a given module. It takes an output directory path, module data containing information about the module such as its name, language, summary, classes, variables, and functions, and a navigation tree. The function creates the output directory if it does not exist, then constructs the HTML content by rendering the module's summary, classes, variables, and functions. It uses helper functions to render class and function details, and applies syntax highlighting to source code snippets. Finally, it writes the complete HTML page to a file named after the module in the specified output directory.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\llm_client.py:LLMClient:9086fe6d0aa4aad556d06744f699ce311e195429fe4c45bc9bd606ed6044b040:b119b81ce87856ab8f9a73d218c0a23edea1037962ac564ed23e34440ccc5293": "The `LLMClient` class provides a wrapper for interacting with the LMStudio HTTP API, offering methods to check API availability and generate text summaries using configured prompts and models. The `ping` method verifies connectivity to the API endpoint, raising a `ConnectionError` if the server is unreachable. The `summarize` method constructs a prompt from a template, checks token usage against a budget, sends a request to the API, and returns a sanitized summary while handling retries and errors.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\llm_client.py:__init__:ee78de896a76c503b3617e1aff8f2eaf9d64ebf6ba9f0644a3beca1ae91ad864:80f0c7559460d3c098551f13d1c4ba0de7e2b167b169ddc681d33fbf3dd067aa": "Initializes the `LLMClient` instance with a specified base URL and model name. Sets up the API endpoint for chat completions by constructing the full URL path, ensuring the base URL does not end with a forward slash. The model name is stored for use in API requests.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\llm_client.py:ping:902c4d468a3e7cbac0ebe54ad7d9aecd60e12158ef04c5da5fb8122d65b10ae0:d78e660a268ae2a3889eab28a6435ce3a93a7069f3b48cb28b74e96dfd6437e3": "The `ping` method checks the connectivity of the LLM API endpoint by sending an HTTP GET request to the server. It returns `True` if the server responds successfully within the specified timeout period. If the request fails or raises an exception, it raises a `ConnectionError` with a descriptive message indicating that the LMStudio server could not be reached. The method uses `requests.get` to perform the check and `response.raise_for_status()` to validate the HTTP response, ensuring that any HTTP error codes are treated as exceptions.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\llm_client.py:sanitize_summary:ae49d8d7fc4b5ea122e2c1da2d2120e835fc08f81b612fdd99e3ea6f46731c69:7dd73e4b23bbe0254ecdf6de874242d8af22d80d53d4961dfe5e99903b8623e8": "The function `sanitize_summary` processes a given text string to remove meta-commentary and unwanted content. It first checks if the input text is exactly \"project summary\" and returns \"It prints.\" in that case. It then strips FIM special tokens that could cause encoding issues downstream. The function filters out lines based on predefined lists of bad start phrases and substrings, as well as specific patterns that indicate meta-commentary or irrelevant content. Lines starting with bullet points or dashes are also removed. The resulting filtered lines are joined back into a single string and returned, with leading and trailing whitespace stripped.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\llm_client.py:summarize:b807923acde0ef21cdb00092718ea4055d246081dccc0d0a6122cc78a27fab21:12b192ad237c5f406900bbe5774d3789f16d8054ce9ef9b374fff1fd56b14536": "The `summarize` method of the `LLMClient` class generates a summary of input text using a specified prompt template. It constructs a prompt from the input text and a selected template, checks the token count against a budget, and sends a request to the LLM API endpoint with system and user messages. The method includes retry logic for handling request failures, processes streaming responses, and ensures the final summary is sanitized before returning. It supports configurable maximum tokens for the response and logs information and warnings during the process. If all retries are exhausted, it raises a `RuntimeError` with the last error message.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\manual_utils.py:_count_tokens:1cb08e9b69665c9eedd23bba0fb68b3c4258a7b5daf31a6df6ee95ebdf75484d:6e248e9c15157f87557fed2912e3c02139413c9bdcebbc63d1b677496f6ff521": "The function `_count_tokens` takes a string input `text` and returns an integer representing the approximate number of tokens in that text. It uses a global `TOKENIZER` object's `encode` method to convert the text into tokens and then counts the length of the resulting token list.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\manual_utils.py:_split_text:700e3df2a3d009cc1dcc17076ffc94b6883230fc3e680c3d2b1517a17d9de304:ca0c4346dc151d406dd1880de6b05cdb9dac3cac4e574d4c2c41bde6ccd3b53a": "The function `_split_text` splits a given text into chunks based on token and character limits. It takes a string `text`, and optional parameters `max_tokens` (default 2000) and `max_chars` (default 6000). The text is first split into paragraphs using double newlines as delimiters. Each paragraph is then evaluated for inclusion in the current chunk based on whether adding it would exceed the specified token or character limits. If a paragraph itself exceeds the limits, it is further divided using `chunk_text`. The function returns a list of text chunks that respect both the token and character constraints.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\manual_utils.py:_summarize_manual:f79c9adc7f8a5891cbecfaaafe4db055174880f07dc392a1fdc800a79646a67d:f472f46f7575293af983be4b59bf32f85ab50ed5658e9252ad26f8639891f5a1": "The function `_summarize_manual` generates a manual summary of input text using an LLM client, with support for chunking strategies and caching. It handles text splitting, caching of intermediate and final results, and hierarchical merging of summaries when content exceeds token or character limits. The function supports different chunking modes (\"manual\", \"auto\", \"none\") and applies a post-processing hook if provided. If chunking is disabled or not applicable, it summarizes the full text in one pass. It also includes error handling for failures during chunking, summarization, or caching, and sanitizes outputs to prevent reserved-token issues. The function integrates with `LLMClient` for LLM interactions and `ResponseCache` for caching responses.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\manual_utils.py:chunk_docs:4e0bedac621ee29e2a7790a307c0fd7c405a125ff2d6722751cca4ba075950bc:56ba7939486e0a21ed743a6444fe9d032ebba306d646dbfb66ff2b8b3de9213f": "The function `chunk_docs` takes a list of strings (`docs`) and an optional integer parameter `token_limit` (defaulting to 2000) as inputs. It concatenates the non-empty strings from the input list with double newlines, then splits the resulting text into chunks of approximately `token_limit` tokens using the helper function `_split_text`. Each chunk is returned as a string in a new list. If the concatenated text is empty, it returns an empty list.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\manual_utils.py:find_placeholders:0c83dcd38d41626b10847444139d7584389a55a23ca42777aeed9be57abd0a92:be40a2c4badd57a683022c7ffe0c7b7df8a23e181f1d22a81b062020504835e0": "The function `find_placeholders` takes a string input `text` and returns a set of unique placeholder tokens found within the text. These placeholders are defined as sequences matching the pattern `[[TOKEN]]`, where `TOKEN` represents the placeholder identifier. The function uses a regular expression `PLACEHOLDER_RE` to identify all occurrences of this pattern in the input text and returns them as a set, ensuring no duplicates.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\parser_cpp.py:_extract_block:c277865627743b457ebdaa7b7889cf05076fd5941a82313e3282683294f52cf8:af3e8790d90d1facdae27d429248e5845dded69613dd4be6b71e7d1ccf0b0937": "The function `_extract_block` extracts a contiguous block of text from a list of lines, starting at a specified index. It identifies the block by tracking the balance of curly braces `{` and `}`. The function returns the extracted text along with the index of the last line processed. The extraction continues until the brace count reaches zero, indicating the end of the block.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\parser_cpp.py:_get_preceding_comment:b8581ea290052d95de22dfffeef16211ac50a1380799f505a1426d556f27ebc9:45aababf613235060661168adcd246e0a0bf89f165423ec5af43f112342c006a": "The function `_get_preceding_comment` collects contiguous comment lines that appear before a specified index in a list of code lines. It handles both single-line comments (starting with `//`) and multi-line comments (enclosed between `/*` and `*/`). The function traverses the lines backward from the given index, extracting and formatting comment content while preserving the order of comments. It stops collecting when it encounters non-comment lines or reaches the beginning of the list. The result is a string containing all collected comments, with empty lines removed and leading/trailing whitespace stripped.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\parser_cpp.py:_parse_class_body:6dc778aef7490f1c7ce7499a768ca1efe8b95a9a540d00cfd6ed49c789b4b84b:5a7653d143e0644d0a259c14dd1462dbdec2788f32ba210bb618bfcfccfea587": "The function `_parse_class_body` parses the body of a class definition from a list of source code lines and extracts public methods and variables. It takes as input a list of strings representing lines of code, a starting index, and an ending index. The function returns a tuple containing two lists: one of dictionaries describing public methods and another of dictionaries describing public variables.\n\nEach method dictionary includes the method's name, signature, associated docstring, and source code block. Each variable dictionary includes the variable's name, type, associated docstring, and its source line. The function tracks access level (public, protected, private) and only processes elements that are marked as public. It identifies methods by detecting lines ending with a function signature followed by a block start (`{`), and variables by detecting lines ending with a semicolon (`;`) and not containing parentheses. Comments preceding each element are retrieved using the helper function `_get_preceding_comment`, and code blocks for methods are extracted using `_extract_block`.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\parser_cpp.py:parse_cpp_file:af06dc1d6a6bbe2be08e6d7c9dae68a590ef95173f722a77d57876c74c0ef347:f9da37c21d714e06577e971f50cbd52ced38702b9b1f1354f0392b5dd1fcf31e": "The function `parse_cpp_file` parses a C++ source file and returns structured information about its contents. It reads the file text, processes lines to identify and extract module-level documentation, namespaces, classes, and functions. For each class, it captures the class name, documentation string, methods, variables, and source code block. For each function, it extracts the function name, signature, documentation string, and source code block. The result is a dictionary containing the module's documentation string, lists of classes and functions, and an optional namespace. Helper functions `_get_preceding_comment`, `_extract_block`, and `_parse_class_body` are used to process comments, extract code blocks, and parse class bodies respectively.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\parser_matlab.py:parse_matlab_file:6398902490bd80bedb89d7ca4413cf3473d2e5623b84d77b9f2a3a996f72c042:e4ec051b07683415ca030c17d1096b4822dafca869af8eebdf457c2fdd6900cd": "The function `parse_matlab_file` reads a MATLAB `.m` file and extracts its structure, returning a dictionary with the file's header comments and any function declarations found. It identifies function names and their arguments from the file content. The header comments are collected from the beginning of the file until the first non-comment, non-blank line. Function declarations are matched using a regular expression that captures the function name and its input arguments, which are then parsed into a list. The result includes the header text and a list of dictionaries, each representing a function with its name and argument list.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\parser_python.py:_format_arg:0c34359d4a1557999e6dc6feab27dd853db4f2f30776d442cea66491a18117d9:aadeb9bf213cffd41d2a37d4a2dff4e9f614b1e2436231b7db76b7e679a5b39b": "The function `_format_arg` takes an `ast.arg` object and returns a string representation of the argument name, optionally including its type annotation if present. If the argument has an annotation, it appends the annotation to the argument name in the format `arg: annotation`. Otherwise, it simply returns the argument name.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\parser_python.py:_format_arguments:b39efe2eb208cbe51764dd4eb6d0e2a07241d1a98a7740aa5625dd2cc6791c41:56876f33708b1a29b47b39aa2fdd7ea18eb0331e5b75745290ba34c7c9664cf0": "The function `_format_arguments` generates a string representation of Python function arguments defined in an abstract syntax tree (AST). It processes positional-only arguments, regular arguments, default values, `*args`, keyword-only arguments, and `**kwargs`, formatting them according to Python syntax. The function handles argument defaults by using `ast.unparse` to convert default AST nodes into their string representations. It ensures proper separation of argument categories with appropriate markers like `/` for positional-only arguments and `*` for the start of keyword-only arguments. The result is a comma-separated string that reflects the signature of the function arguments as they would appear in Python code.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\parser_python.py:_format_signature:5c11b509654bef361b9c77535862e14f7411698cce3c3a7c462cfa43414a0281:65cd4e5ddf8405dded17f80cd7fbec7927fc1ef8a12112ebff10e5f1f333576d": "The function `_format_signature` generates a string representation of a function's signature from an abstract syntax tree (AST) node. It takes a function definition node (`func`) and returns a formatted string that includes the function name, its parameters, and optional return type annotation. The parameters are processed using the `_format_arguments` helper function, and if the function has a return type annotation, it is appended to the signature with an arrow (`->`) separator.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\parser_python.py:_parse_classes:fbb85eae03aef023cf5f09a13ea724ab1e81bc4d6561867a61c26e2b257aee9e:07b0b0db938deb74eab4f2acf090219353bcd1546385088be53d5b78c594d0a2": "The function `_parse_classes` recursively extracts all `ClassDef` nodes from a list of AST nodes and returns a list of dictionaries containing parsed class information. It processes each node in the input list, and if the node is a class definition, it calls `parse_class` to parse the class. If the node is a function definition, it recursively parses the function's body for nested class definitions. The function supports both synchronous and asynchronous function definitions.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\parser_python.py:parse_class:de3b30eae7beb344261c9aeb35cd7e62630c23df5f8af484f3bfd8ea447ebded:349abf9b64a9a954ad177a6b32c4af300d08a3d1e3785f3a9fe53c1e76958dd8": "The function `parse_class` takes an abstract syntax tree (AST) class definition node and the corresponding source code, and returns a dictionary containing information about the class. The dictionary includes the class name, its docstring, a list of methods defined within the class (parsed using `parse_function`), a list of nested subclasses (parsed using `_parse_classes`), and the source code segment corresponding to the class definition. The function processes the body of the class node, identifying function definitions and subclass definitions, and organizes them into the returned dictionary structure.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\parser_python.py:parse_classes:535b60242d459f68b3df4d740bba4fe9ef4e0c9d2ffbfa421f281a1707fd7b82:4c6b8bdae571ea3223dcd3ade313e6d7a8448d3930c190e025e186387a9a7b06": "The function `parse_classes` is a public wrapper that extracts class definitions from an abstract syntax tree (AST) node. It takes an AST node and the corresponding source code as input, and returns a list of dictionaries containing information about the parsed classes. The function delegates the actual parsing logic to the private helper function `_parse_classes`, using the `body` attribute of the provided AST node. If the node does not have a `body` attribute, it defaults to an empty list. The source code string is passed through to the underlying parsing function for context.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\parser_python.py:parse_function:0c6e5f76c879bdf014a9f507fb7bbc6f9dca32982ac93823551ffa1d9c970131:c49a2180edcd8ca572ab39049f31782c9c8451cd7cd116c749097bed122e688b": "The function `parse_function` takes an AST node representing a function or asynchronous function and the source code as input, and returns a dictionary containing information about the function. The dictionary includes the function's name, signature, return type, docstring, source code segment, and lists of nested subfunctions and subclasses. It recursively processes the function's body to identify and parse any nested functions and classes.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\parser_python.py:parse_python_file:ed3b48669196cff1ed188eda7447a60c70e2870e9c0fbed625e958e946699f1f:a2e25cfefe34c441a99613416becc49704135394e8fc4898d9dbfcf73562669e": "The function `parse_python_file` takes a file path as input and parses the Python source code into a structured dictionary. It reads the file content, uses the `ast` module to parse the abstract syntax tree, and extracts the module's docstring along with information about classes and functions defined in the file. The parsed classes and functions are processed using helper functions `parse_class` and `parse_function`, which are not shown here but are expected to handle the specific parsing of class and function nodes from the AST. The result is a dictionary containing the module docstring, a list of parsed classes, and a list of parsed functions.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\retrofit_sidebar.py:_paths_to_tree:338650c62d614dfd80aeff8c4423146afbd7e5aa009b153d9af43f15657a5cb9:ca749014ae8db3df3e4ddc8fb58e6354dfe726578a55d580f747f7c6e95bf676": "The function `_paths_to_tree` converts a list of file paths into a nested dictionary representing a directory tree structure. Each path is split into its constituent parts, and for each part except the last, a nested dictionary is created. The final part of each path is set as a key with a value of `None`. This creates a hierarchical representation where keys correspond to directory or file names and values represent either subdirectories (as dictionaries) or files (as `None`).",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\retrofit_sidebar.py:_tree_to_ul:d06aa23f72723b4794e5779a96b787e618cad9de0de49d9a0ebccce2846749d8:965b9c1537797aa41bdfe79b5efb5732c2b3f43d73345e48ea33d9f3417c5038": "The function `_tree_to_ul` recursively constructs an HTML unordered list (`<ul>`) from a nested dictionary structure (`tree`). It uses a `BeautifulSoup` object to create and manipulate HTML tags. Each key in the dictionary corresponds to a list item (`<li>`), with values determining whether the item is a parent node (recursively processed) or a leaf node (represented as a hyperlink). The `base` parameter tracks the current path to construct relative links to HTML files, with file extensions converted to `.html`. The function returns the constructed `<ul>` element.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\retrofit_sidebar.py:retrofit_sidebar:37ecfe8b75318285756d138d5fe0c4f0456e58453a92f589d50894aa1ca2e5b5:ee4f7fab912a996c36451bfe863e9b01085e3a762e4ee5a07408b06c687aea9e": "The function `retrofit_sidebar` updates HTML documentation files by replacing existing sidebars with a hierarchical list of modules. It takes the root directory of source code and the documentation directory as inputs. The function scans the source directory to identify modules, constructs a tree structure from their paths, and then processes each HTML file in the documentation directory. For every HTML file containing a sidebar div, it clears the existing content and populates it with a new hierarchical unordered list generated from the module tree. The updated HTML content is written back to the respective files.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\reviewer.py:_is_generated_html:15c87061543ca596160039d8c2341247aa96422d5e03a71be06abdce11b7af94:6e3696415c36628134b6e49e3ac02f9f1609f7667a6d40e9109c97d5af602ad6": "The function `_is_generated_html` determines whether a given HTML text appears to be output generated by DocGen-LM. It checks for the presence of specific markers within the text, including the string \"Generated by DocGen-LM\", the heading \"Project Documentation\", and patterns matching class and method headings with specific prefixes. The function returns `True` if any of these markers are found, otherwise it returns `False`.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\reviewer.py:check_assistant_phrasing:3904d16ed42d5f8fac4807c06d63718320555a5bb7f1a59749561671892b2bfe:7f3d9ec77ef743d6318b031d1e6fb78f8a7a8dd24b56f6853a01a186c8f7a9c9": "The function `check_assistant_phrasing` takes an HTML string as input and returns a list of strings. It identifies paragraphs in the HTML that contain phrases from a predefined set (`ASSISTANT_PHRASES`). For each matching paragraph, it extracts the text content, determines the line number within the HTML, and appends a formatted string including the text and line number to the results list. The function uses helper functions `_extract_tags` to isolate paragraph elements, `_strip_html` to remove HTML tags from the text, and `_find_line_number` to locate the line number of the text within the original HTML.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\reviewer.py:check_contradictions:a5a06ca59b5b4d1574b35fa05712eeeaf644475d1575bec4f945011d7b913790:0b97f77e62563dafe3e392743c97f5ecc2cd648acc8c33ae64d2060c2a82145d": "The function `check_contradictions` analyzes HTML content to identify contradictions between summary text and the presence of code elements. It extracts paragraphs and header tags from the HTML, then checks for inconsistencies such as statements claiming no methods, functions, or classes exist while finding corresponding headers. The function returns a list of strings describing each contradiction found.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\reviewer.py:check_hallucinations:99be4737993bf158f6a31acd351fe9d76ff3e79009678df38a1ac3d8c072feb0:8ce100671fb0582505d29372c14b70634d58c45c7f06015e46bc5aad3fc22234": "The function `check_hallucinations` takes an HTML string as input and returns a list of hallucination phrases detected within the text. It extracts all paragraph elements from the HTML, strips the HTML tags from each paragraph, converts the text to lowercase, and checks if any of the terms in `HALLUCINATION_TERMS` are present in the text. If a match is found, the matching term is added to the list of findings, which is then returned.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\scanner.py:_is_subpath:3ade6e5467b4804f17bdf27e538346074e6ab57923ea2c88cb42a9f306365afc:1c4581d8eba70832492563ec649d743913d3942fad15e09e91ecefc7a47e730a": "The function `_is_subpath` determines whether a given path is equal to or located within a specified parent path. It takes two arguments: `path` and `parent`, both of type `Path`. The function attempts to compute the relative path from `parent` to `path` using the `relative_to` method. If this operation succeeds without raising a `ValueError`, it indicates that `path` is indeed a subpath of `parent`, and the function returns `True`. Otherwise, if a `ValueError` is raised, the function returns `False`.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\scanner.py:scan_directory:27fe16e0f3b98e0776cd95dabc0e910822b4706c1299c3fac3b54d76074a817d:5267447659ea733c9c778cfa3be8abafd8b0699d62c1c286e8147d0046e6d1b7": "The function `scan_directory` recursively searches for source code files with extensions `.py`, `.m`, `.cpp`, `.h`, and `.java` within a specified directory. It takes a base path, a list of paths to ignore, and an optional progress display flag. The function returns a sorted list of absolute paths to the discovered files, excluding those specified in the ignore list and skipping `.git` directories. It uses `os.walk` to traverse the directory tree and optionally displays a progress bar if requested.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\summarize_utils.py:summarize_chunked:5d906c211659a9ca3dbabcc93bb05b180ce2dcac7b6027cdcc05a29d1957a95a:e6ab32f71aa5f9b8494fca86c6fc0e9ec6734437488c33bde96ddd4312d6c9b2": "The function `summarize_chunked` generates a summary of input text by either summarizing it directly or breaking it into chunks if the text exceeds token limits. It uses an LLM client and a response cache for efficient processing, and handles potential errors during chunking or summarization. If the text fits within the token budget, it directly summarizes the text. Otherwise, it splits the text into manageable chunks, summarizes each chunk, and then merges the partial summaries into a final consolidated summary. The merging process is recursive, ensuring that the combined summary remains within token limits. If any step fails, it falls back to returning sanitized text or partial results.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:__init__:188c4e152675be76a28d84727034c73b3f2f2fed0760a34dfc4cea953d724963:188b9296357eb9147d4f06ef20d38c4ea528585aef4a9fa5ce8fbd97d4253a98": "The `__init__` method initializes a `Dummy` class instance with an empty list to track method calls. Each call is stored as a dictionary containing details such as text, prompt type, and system prompt. The list `self.calls` accumulates this information over time.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:__init__:1d3be62230194dae4efb50175ffb2a515194fc9bfcfa3075f1bb2343c409a9a8:280fe77b6840cf62c29436a9c0812e701537cdb132b3436be2426c7f212ee358": "The `__init__` method initializes an instance of the `Dummy` class. It sets up an attribute called `calls`, which is initialized as an empty list. This list is intended to store details about documentation generation calls made to the class.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:__init__:58e3e8c12d0462c79a173794890801b12604732bffa0367dfa111b69c607f9e8:40ed43f6925b6c97fc6618637ad9faa01762040f3f8a2010f450f21cc64dad87": "The `__init__` method initializes an instance of the `Dummy` class. It establishes an attribute named `calls`, which is initialized as an empty list of strings. This list is intended to track call-related information throughout the object's lifecycle.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:__init__:8759ed00a338b20fe602147d1739f9f5fe84d9fdce68c2e811fec0d466a080e9:77ebac66d95d0e8d641e7d299afe1b4a0190f33b85997847d3d49072f5fce624": "The `__init__` method initializes an instance of the `Dummy` class. It sets up an empty list named `calls` to track method calls. Each entry in the list will be a dictionary containing information about a call, including the text, prompt type, and optional system prompt. This list is used to store the history of calls made to the `summarize` method.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:__init__:f6f58b0c0b2dae9191c2cc2967f7a9de6eecad85244e302388a843b947ceb48d:938c78e6b8244fd1935481842f5c3bdb5f260c8038dfd7f624c9c07ca18d6c8a": "The `__init__` method initializes an instance of the `Dummy` class. It establishes an internal attribute named `calls`, which is initialized as an empty list. This list is intended to store details of summarization requests made to the instance. Each entry in the list will be a dictionary containing information about a specific request. The method does not accept any parameters beyond the standard `self` parameter and returns nothing.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:summarize:004e97d73edf654ba87b24f273f6ca1337aecedc3c21ce4d324619ed21b7a995:0f84ecca6f60fef0e71a0fd4e8d4ab541a7b7271b7cae02ff1d0ff0b09845d17": "The `summarize` method of the `Dummy` class records details of a documentation generation call by appending a dictionary containing the input text, prompt type, and system prompt to the `self.calls` list. It returns either the first word of the input text or the string \"final\", depending on whether the provided system prompt matches a specific merge system prompt constant.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:summarize:02f1e8e0345011c3eed05f78a7df293a2afe106a4d43b4bed4904dd0b0f77c2c:117ebb0fce5b069a7a38f7d9342f65fad70ebaadb2e02778e0b845830ae76182": "The `summarize` method in the `Stub` class is a placeholder implementation that returns the fixed string \"guessed\" regardless of the input parameters. It accepts a prompt string, a prompt type string, and an optional system prompt string, but does not perform any actual summarization logic. This method serves as a dummy implementation within the documentation generation system.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:summarize:204d0cb76b12d6a1b7357e93389a18d7d7c7206cb380229d439e0c5834e61aba:0edac282ca27f0e1597f2c36fb241c7e23a917e797ad3f943abdc76c1e7e79eb": "The `summarize` method of the `Dummy` class appends a dictionary containing the provided `text`, `prompt_type`, and optional `system_prompt` to the `self.calls` list. It then returns the string `\"done\"`. This method is used to track information about method calls by storing their details in the list.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:summarize:235ad540a1dbdb8422bf9e6de03040ab3ebb974045af56faf8dec88d38f59b85:76eb1c01d6e0d305ad6d637f8795e18a4eefdb1920cd24643834798773570555": "The `summarize` method processes a given text string to extract and manipulate content related to manual sections. It appends the input text to the instance's `calls` list. The method identifies a manual section placeholder using a regular expression pattern that captures content between \"Manual:\" and \"Section:\", and extracts the associated section identifier. It retrieves a token from `explaincode.SECTION_PLACEHOLDERS` based on the extracted section identifier. Finally, it replaces the token within the captured manual text with a formatted string indicating the section has been filled, returning the modified text.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:summarize:27a6eb7045f736572c68d0b7366ec22af1036e31452666e5c9bd8c1e13943967:c2682f2c59058382b1c680ea11d6686eee11edf489b58503dde7a4c1699af324": "The `summarize` method of the `Dummy` class records summarization requests by appending details about each request to an internal list named `calls`. The method evaluates the number of stored requests to determine the response: if there are two or fewer requests, it returns the value `big`; otherwise, it returns the string `\"short\"`. The method takes three parameters: `text`, `prompt_type`, and `system_prompt`, which are used to construct the request record.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:summarize:4012b610a50cf67bf4d0c6f7280e285613784887b132aa5a150fa68c6827aa75:ba016490a72fbeeb52ff0100e58babbcea1fa2112d659f4f8cd093b2626c851c": "The `summarize` method is a stub implementation within the `Dummy` class that returns a fixed, formatted summary string. It accepts text input, a prompt type, and an optional system prompt but does not perform actual summarization. Instead, it provides a predefined template containing structured sections such as overview, purpose, running instructions, inputs, outputs, system requirements, and examples. The method is marked as a simple stub and is excluded from coverage analysis.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:summarize:4d0e9b5f4966b912e5261a7c701dbbb00b3d709dcbef0d35ce36adec66b093fa:9faf9ef3608a2a92cd493100ba397974d2b6a6f183ff90a6d82593b2a8f243b0": "The `summarize` method of the `Dummy` class processes input text and returns different outputs based on the content of the `system_prompt`. If the `system_prompt` contains \"How to Run\", it returns the string \"[[NEEDS_RUN_INSTRUCTIONS]]\". If the `system_prompt` contains \"enhancing a user manual\", it extracts specific manual text from the input `text` using a regular expression, then replaces occurrences of \"[[NEEDS_RUN_INSTRUCTIONS]]\" in that extracted text with \"use it\" and returns the result. For all other cases, the method returns the string \"x\".",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:summarize:78ef69f3e568b2272b34d9754d8aad6cbd15edc864b48ac97e0477ba9069bb30:bb5a82756fb287f03b5214d8c115fbf5cbc969b6eb920b325d1232142f7da05b": "The `summarize` method in the `SlowClient` class introduces a delay when the provided `system_prompt` matches a specific constant `explaincode.CHUNK_SYSTEM_PROMPT`. The delay is controlled by the variable `delay`, which is referenced but not defined within the provided code snippet. After potentially pausing execution, the method returns the string `\"ok\"`. This behavior suggests the method is used to enforce rate limiting or throttling during documentation generation tasks, particularly when processing certain types of system prompts.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:summarize:c11f4ec9cfa6e77cd2a488a84560a54eb63390e157420f2e225766e46ee4055c:075feee97579de71f34c7d6764c2f19c4be74a01f66e2587b4aaf1f2a542d150": "The `summarize` method in the `Dummy` class records information about a method call by appending a dictionary containing the provided `text`, `prompt_type`, and `system_prompt` to the `self.calls` list. It then returns a string formatted as `\"resp\"` followed by the current number of calls stored in the list, indicating the invocation count.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:summarize:e59a8d3e17b37b5af8ab0d48e26585e02a130a6680f16296e87809aa2fbf1220:5d23822bc127aca13fad35c9e2eac20a5b90ed8bf59841e107705bf62d47b9b4": "The `summarize` method in the `Dummy` class returns a fixed string response formatted as \"Overview: x\\\\nHow to Run: [[NEEDS_RUN_INSTRUCTIONS]]\", regardless of the input parameters. The method accepts `text`, `prompt_type`, and an optional `system_prompt` but does not utilize any of these inputs in its implementation. This placeholder implementation is intended for testing or demonstration purposes where actual summarization functionality is not required.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_llm_client.py:test_sanitize_summary_removes_fim_tokens:5d17810810a5e1f639f9cf0de67baf8c7794622fe8b05bcab8d96cd135676af8:b9d8ebd3678f930824baf4d73e7ef618f8ef3358f7af92f3c5b068af081fb213": "The function `test_sanitize_summary_removes_fim_tokens` tests that the `sanitize_summary` function removes FIM (Fill-In-Middle) reserved tokens from input text to prevent tokenizer errors. It asserts that when given the input string \"Defines \u3008a class.\", the output is \"Defines a class.\".",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_llm_client.py:test_summarize_does_not_stream_on_http_error:0e79b622313c786ae94e0f026e703dda4670b1d2691474215f4eef1a9208e3f3:2c44af84868cee14a3f422e6edb6de55b74d1124832aca838f3929f253173164": "This function tests that the `summarize` method of the `LLMClient` class does not attempt to stream a response when an HTTP error occurs. It creates a mock `LLMClient` instance with a fake URL, configures a mock HTTP response to raise an `HTTPError` and return a text body, and patches the `requests.post` call to return this mock response. The test verifies that calling `client.summarize` raises a `RuntimeError` with the expected error message and ensures that `iter_content` is not called on the mock response, confirming no streaming occurs during HTTP failures.",
  "__progress__": {}
}