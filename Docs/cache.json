{
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\cache.py:2e37ab4b52e9489ed2b2dc8e686dc29df25416d04f5b423c47ba2cc9aecf698c:2e37ab4b52e9489ed2b2dc8e686dc29df25416d04f5b423c47ba2cc9aecf698c": "A simple on-disk cache for storing and retrieving LLM (Large Language Model) responses. It uses a JSON file to persist mappings from stable keys to LLM responses. The `ResponseCache` class provides methods to get and set values in the cache, as well as a static method to generate deterministic keys based on file paths and content.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\cache.py:ResponseCache:8bea6244f455a7e6768250e12f890e4c3e0ace53c895481842f2d5a7f8ec8443:8bea6244f455a7e6768250e12f890e4c3e0ace53c895481842f2d5a7f8ec8443": "The `ResponseCache` class manages caching mechanisms for storing and retrieving parsed data from JSON files. It provides methods for initializing with a file path, generating deterministic keys based on file paths and content, retrieving cached values, setting new values and saving them back to disk, and writing the cache data to a file in JSON format.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\cache.py:ResponseCache:__init__:919483e1ff4b05cae685fcac27aa9458bc309d42dd717af59b0942962ccdf4e4:919483e1ff4b05cae685fcac27aa9458bc309d42dd717af59b0942962ccdf4e4": "Initializes an object with a file path. Reads the file if it exists and parses its content as JSON, storing it in `_data`. If the file does not exist or is not valid JSON, sets `_data` to an empty dictionary.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\cache.py:ResponseCache:_save:d6c96e0258c810e9fec48856af580533cfc0aa8f13ea666bb1d396aa4abe5e41:d6c96e0258c810e9fec48856af580533cfc0aa8f13ea666bb1d396aa4abe5e41": "Writes data to a file using JSON format with indentation and sorted keys.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\cache.py:ResponseCache:get:eeb84b4591575a8ed2767f4abac56f1f2dd0697e81322599734b8b31e94ddcce:eeb84b4591575a8ed2767f4abac56f1f2dd0697e81322599734b8b31e94ddcce": "Returns the cached value associated with a given key if it exists; otherwise, returns `None`.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\cache.py:ResponseCache:make_key:4f63c9f618b20a79035ed49cae07b9b800a46f352498e23dc8700f47c38fe96d:4f63c9f618b20a79035ed49cae07b9b800a46f352498e23dc8700f47c38fe96d": "The function `make_key` takes two parameters, `file_path` and `content`, both of type string. It returns a deterministic key by concatenating the file path with the SHA-256 hash of the content, encoded in UTF-8.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\cache.py:ResponseCache:set:0bc8af7637662ae14e3eca8604a4d7155ff442d423955a243d6b586ffee8d8ba:0bc8af7637662ae14e3eca8604a4d7155ff442d423955a243d6b586ffee8d8ba": "Function `set` stores a string value under a given key in an internal data structure `_data`. After storing the value, it calls another method `_save()` to persist the changes to disk.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\chunk_utils.py:6c5fb52965b9c830534a1a0e867741ffe867c9e43e8bfc85e5073585b38f3c88:6c5fb52965b9c830534a1a0e867741ffe867c9e43e8bfc85e5073585b38f3c88": "This module provides utility functions for text processing, specifically focusing on tokenization and text chunking. It includes:\n\n1. `get_tokenizer()`: Returns a tokenizer object used for estimating token counts. If the `tiktoken` library is available, it uses it; otherwise, it falls back to a simple character-based tokenizer.\n\n2. `_split_blocks(text: str) -> List[str]`: Splits Markdown text into paragraphs, headings, and fenced code blocks based on natural boundaries such as blank lines, Markdown headings, or fenced code blocks.\n\n3. `_split_long_block(block: str, tokenizer, chunk_size_tokens: int) -> List[str]`: A fallback splitter that uses a character-based approximation to split long blocks of text that exceed the desired token size.\n\n4. `chunk_text(text: str, tokenizer, chunk_size_tokens: int) -> List[str]`: Splits the input text into chunks roughly `chunk_size_tokens` each while respecting natural break points like blank lines, Markdown headings, and fenced code blocks. If a single block exceeds the token limit, it falls back to splitting by approximate character length.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\chunk_utils.py:_split_blocks:4421cab0ea388c77d510cd0b324808918f9775bf3caceca8f9322acde54aabfc:4421cab0ea388c77d510cd0b324808918f9775bf3caceca8f9322acde54aabfc": "The `_split_blocks` function takes a string of Markdown text and splits it into paragraphs, headings, and code blocks. It processes each line to identify the type of block and collects lines until a block boundary is reached. The function then appends each identified block to a list and returns this list after processing all lines.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\chunk_utils.py:_split_long_block:bb48f6a5c1db26d6a4c663438c349a74d955bc1020a60d49a420bc9d403699b3:bb48f6a5c1db26d6a4c663438c349a74d955bc1020a60d49a420bc9d403699b3": "This function `_split_long_block` takes a string `block`, a tokenizer, and an integer `chunk_size_tokens`. It encodes the block using the provided tokenizer. If the length of the encoded tokens is less than or equal to `chunk_size_tokens`, it returns the original block as a single element list. Otherwise, it calculates an average character size based on the number of tokens and the length of the block. It then determines a maximum character size for each chunk that does not exceed `chunk_size_tokens` times the average character size. The function splits the block into chunks of approximately this size and returns them as a list of strings.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\chunk_utils.py:chunk_text:e557554314c9ac88cc4bd33e21f4ed2a14347bfa83a80823e38dcd80167942e7:e557554314c9ac88cc4bd33e21f4ed2a14347bfa83a80823e38dcd80167942e7": "The `chunk_text` function splits a given text into chunks of approximately specified token size. It uses a tokenizer to count tokens and respects natural break points such as blank lines, Markdown headings, and fenced code blocks. If a single block exceeds the token limit, it falls back to splitting by character length. The function returns a list of chunked text sections.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\chunk_utils.py:get_tokenizer:3f7e10569427d9f96c1484bda7fb1b9809eb48b575ede10f4a282287f8297f0f:3f7e10569427d9f96c1484bda7fb1b9809eb48b575ede10f4a282287f8297f0f": "The `get_tokenizer` function returns a tokenizer object used for estimating token counts. It first attempts to import and use the `tiktoken` library to get an encoding for the \"cl100k_base\" model, which is then returned if successful. If `tiktoken` is not available or encounters an error, it falls back to using a simple tokenizer that splits text into words and joins them back together. This fallback tokenizer provides approximate token counts when precise tokenization is not possible.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\docgenerator.py:356567cd59a328063623f46fb50196a8d316868ab42769b9ae86e75a05f9f928:merge0:c0c59908f58a522604b37482df1c0565b5b8936cc996f70bfdf85b980cb238a3": "This module provides a command-line interface for generating HTML documentation using DocGen-LM. It scans a source tree for Python and MATLAB files, parses them, requests summaries from a running LLM, and writes the documentation to an output directory. The module includes functions for cleaning the output directory, summarizing text using an LLM client with caching, chunking modules by structure, summarizing module chunks, building function prompts, rewriting docstrings, recursively summarizing methods of classes and subclasses, and summarizing classes. It utilizes an LLM client (`LLMClient`), a response cache (`ResponseCache`), various prompts, and tokenization through a tokenizer object. The script supports parsing and summarizing Python and MATLAB files, ignoring specified paths, and customizing the LLM's base URL and model settings. It also handles reading README and Markdown files for additional context in the documentation.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\docgenerator.py:356567cd59a328063623f46fb50196a8d316868ab42769b9ae86e75a05f9f928:part0:8d5fa3017655aa21bfec429fe81d8bb373ed9e57fdd687c6c47815484389e168": "This module provides a command-line interface for generating HTML documentation using DocGen-LM. It scans a source tree for Python and MATLAB files, parses them, requests summaries from a running LLM, and writes the documentation to an output directory.\n\nThe module includes several functions:\n\n1. `clean_output_dir(output_dir: str) -> None`: Removes HTML files generated by DocGen-LM from the specified output directory.\n2. `_summarize(client: LLMClient, cache: ResponseCache, key: str, text: str, prompt_type: str) -> str`: Summarizes a given text using an LLM client, caching results to avoid redundant requests.\n3. `_chunk_module_by_structure(module: dict, tokenizer, chunk_size_tokens: int)`: Splits a module's source code into chunks based on its structure and token size.\n4. `_summarize_module_chunked(...) -> str`: Summarizes a module using structure-aware chunking.\n5. `_build_function_prompt(source: str, class_name: str | None = None, class_summary: str | None = None, project_summary: str | None = None) -> str`: Constructs a context-enriched prompt for summarizing a function.\n6. `_rewrite_docstring(...) -> None`: Rewrites the docstring of a given item using optional context and an LLM client.\n7. `_summarize_methods_recursive(class_data: dict[str, Any], path: str, client: LLMClient, cache: ResponseCache, tokenizer, max_context_tokens: int, chunk_token_budget: int) -> None`: Recursively summarizes methods of a class and its subclasses.\n8. `_summarize_class_recursive(...) -> None`: Recursively summarizes a class, its methods, and subclasses, rewriting their docstrings as needed.\n\nThe module uses an LLM client (`LLMClient`), a response cache (`ResponseCache`), and various prompts for generating summaries. It also handles tokenization using a tokenizer object.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\docgenerator.py:356567cd59a328063623f46fb50196a8d316868ab42769b9ae86e75a05f9f928:part1:04b963117c836b259d6d1e5139f32dbc2024588b2d93581173210710e7bfa9d9": "This Python script generates HTML documentation using a local Large Language Model (LLM) by processing source files from a specified directory. It supports parsing and summarizing Python and MATLAB files, ignoring specified paths, and customizing the LLM's base URL and model settings. The script also handles reading README and Markdown files for additional context in the documentation.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\docgenerator.py:_build_function_prompt:8a4516eaefda0c433a10d009761b7ba307092c80be1464c0c03ed048584f8042:8a4516eaefda0c433a10d009761b7ba307092c80be1464c0c03ed048584f8042": "This function `_build_function_prompt` constructs a context-enriched prompt for summarizing a given Python function's source code. It takes the function source as a required parameter and optionally accepts parameters for the class name, class summary, and project summary. The function returns a string that includes these contextual elements followed by instructions on how to summarize the function based solely on its source code, without including additional phrasing or unrelated information.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\docgenerator.py:_chunk_module_by_structure:58face9a228a01badae5d67d12d116f312c88c67e62651bb06e4f946cea0ce3a:58face9a228a01badae5d67d12d116f312c88c67e62651bb06e4f946cea0ce3a": "This function `_chunk_module_by_structure` processes a Python module's parsed structure to create text chunks suitable for documentation. It starts by adding the module's docstring, then iterates through each class and its methods, as well as individual functions, appending their source code to blocks. The function uses a tokenizer to determine if blocks exceed a specified chunk size in tokens. If a block is too large, it is further broken down using another function `chunk_text`. The resulting chunks are returned as a list, ensuring that no single chunk exceeds the token limit while maintaining logical separation between different parts of the module's structure.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\docgenerator.py:_rewrite_docstring:e148a37143ec761f4844cca453b746434aea57b29e45b667bc9326453ddc623a:e148a37143ec761f4844cca453b746434aea57b29e45b667bc9326453ddc623a": "This function `_rewrite_docstring` is designed to rewrite the docstring of a code item using optional context provided by class and project summaries. It uses an LLMClient for language model interaction, a ResponseCache for caching responses, and various parameters for customization such as file path, item details, and token budgets.\n\nThe function first checks if there is source or docstring available. If not, it prints a warning and returns. If only the docstring is missing, it also returns without making changes.\n\nDepending on whether class or project summaries are provided, it constructs a prompt for the language model using `_build_function_prompt` or a default `DOC_PROMPT`. It then creates a cache key based on the file path, item name, and combined content of source, docstring, class name, and project summary.\n\nThe function calls `_summarize_chunked` to generate a new docstring by summarizing the prompt using the language model. The result is sanitized and assigned back to the item's docstring field. If no summary can be generated, it defaults to \"No summary available.\"",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\docgenerator.py:_summarize:dcfe5c6bb5cf9b90c8ab0b9ffefa94d628e13de4df5ed4cc1b240bfe3b4c4068:dcfe5c6bb5cf9b90c8ab0b9ffefa94d628e13de4df5ed4cc1b240bfe3b4c4068": "The function `_summarize` takes an `LLMClient`, a `ResponseCache`, a `key`, a `text`, and a `prompt_type` as inputs. It attempts to retrieve a cached summary using the provided `key`. If a cached summary exists, it returns that; otherwise, it generates a new summary using the `client.summarize` method with the given `text` and `prompt_type`. The generated summary is then stored in the cache under the specified `key` before being returned.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\docgenerator.py:_summarize_class_recursive:d9eb3ee3756066a62b8556e6850319499a9858a74c96850909c899455edaece3:d9eb3ee3756066a62b8556e6850319499a9858a74c96850909c899455edaece3": "The function `_summarize_class_recursive` is designed to recursively summarize a class and its methods within a Python project. It takes several parameters including `class_data`, `path`, `project_summary`, `tokenizer`, `client`, `cache`, `max_context_tokens`, and `chunk_token_budget`. The function performs the following tasks:\n\n1. Calls `_summarize_methods_recursive` to summarize all methods in the class.\n2. Constructs a list of method summaries.\n3. Formats these summaries into a single string, which is then used as part of a larger prompt (`class_prompt`) for summarizing the class itself.\n4. Generates a cache key based on the path and class name.\n5. Uses `_summarize_chunked` to generate a summary for the class using the `client`, `cache`, and `class_prompt`.\n6. Sanitizes the generated summary.\n7. Updates the `class_data` dictionary with the new summary, replacing both the original docstring and the newly created summary.\n8. If an original docstring exists, it rewrites the docstring for the class using `_rewrite_docstring`.\n9. Recursively calls itself for each subclass of the current class.\n\nThe function ensures that all methods within a class are summarized and their summaries are included in the overall class summary. It also handles subclasses by calling itself recursively to ensure comprehensive documentation generation.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\docgenerator.py:_summarize_methods_recursive:2e61893e897dc755d2631ad02f582fe0f88fac06b73d879ce7d7c91517399cbc:2e61893e897dc755d2631ad02f582fe0f88fac06b73d879ce7d7c91517399cbc": "This function recursively summarizes methods within a given class and its subclasses. It iterates through each method, constructs a unique key for caching purposes, and then uses the `_summarize_chunked` function to generate a summary of the method's source code. The summary is stored in both the `summary` and `docstring` fields of the method dictionary. After processing all methods, it recursively calls itself for each subclass to ensure all nested classes are also summarized.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\docgenerator.py:_summarize_module_chunked:5b57f9065d92357d6988a1a94bb82311420a4d0ba8797a2a19ce1641f2d9af8b:5b57f9065d92357d6988a1a94bb82311420a4d0ba8797a2a19ce1641f2d9af8b": "This function `_summarize_module_chunked` is designed to summarize a Python module using structure-aware chunking. It takes several parameters including an LLM client, response cache, key prefix, module text, module dictionary, tokenizer, maximum context tokens, and chunk token budget.\n\nThe function first calculates the available tokens based on the overhead of system prompts and template usage. If the module text can fit within these available tokens, it summarizes the module directly. Otherwise, it attempts to chunk the module by structure using `_chunk_module_by_structure`. If successful, it recursively summarizes each chunk and combines them into a single technical paragraph following specific instructions.\n\nThe function handles potential errors during chunking or summarization by printing warnings and attempting alternative methods. It uses caching to avoid redundant processing of the same text. The final summary is sanitized before being returned.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\docgenerator.py:clean_output_dir:1a3fe854bf0a54b17140dbff83754da00650d9408c793124060d6a9c132371d5:1a3fe854bf0a54b17140dbff83754da00650d9408c793124060d6a9c132371d5": "The function `clean_output_dir` takes a string `output_dir` representing the path to a directory and iterates through all files within that directory. If a file has an `.html` extension, it reads the first line of the file. If the first line contains the string \"Generated by DocGen-LM\", the file is deleted. If any exceptions occur during this process, a warning message is printed indicating which file could not be checked or removed.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\docgenerator.py:main:afc715067e4053bf51853530ac8f6fe73294142c5b6454f13d44fdc4cec29749:afc715067e4053bf51853530ac8f6fe73294142c5b6454f13d44fdc4cec29749": "The `main` function serves as the entry point for generating HTML documentation using a local language model (LLM). It handles command-line arguments to specify the source directory, output directory, and various options like ignored paths, LLM URL, model name, and maximum context tokens. The function initializes an LLM client, sets up a tokenizer, and creates necessary directories for output.\n\nIt then scans the source directory for Python and MATLAB files, parses them, and summarizes each module using the LLM. For each module, it processes classes and functions to generate summaries and rewrite docstrings with project context. Finally, it writes an index page and individual pages for each module in HTML format.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:Config:03aa66f608f321bbfd82f1ea9151659de5337362d8122468db338e17f5a8b25c:03aa66f608f321bbfd82f1ea9151659de5337362d8122468db338e17f5a8b25c": "The `Config` class in DocGen-LM is designed to manage configuration settings for generating static HTML documentation from Python and MATLAB projects. It supports nested functions, subclasses, and complex code structures by rendering them as expandable sections in the output. The class does not define any specific methods but is integral to the overall functionality of the tool, which includes caching responses, chunking text, summarizing code, interacting with language models, parsing languages, reviewing documentation, scanning directories, and writing HTML output.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:_edit_chunks_in_editor:5e56a9afabe955e799da8e661d57a7646758dc1a20a7e7130e0571d2b903e544:5e56a9afabe955e799da8e661d57a7646758dc1a20a7e7130e0571d2b903e544": "The function `_edit_chunks_in_editor` takes a list of code chunks as input, joins them into a single string with separators, writes the string to a temporary file, opens the file in the user's default editor for modification, reads the edited content back from the file, and returns the modified chunks. Empty chunks are discarded.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:collect_docs:2ffd16de5ed46a8f5f0c76ed1bfe538f0dc50062f23db630580f2644916bceb1:2ffd16de5ed46a8f5f0c76ed1bfe538f0dc50062f23db630580f2644916bceb1": "The function `collect_docs` takes a directory path as input and returns a list of paths to documentation files within that directory. It searches for specific file types (`README.md`, `.md`, `.txt`, `.html`, `.docx`) in the project root and within a subdirectory named \"docs\". The function ensures that only unique files are returned by using a set to track seen files.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:collect_files:463d1b88ab58cf86fd8d475ad6fff2150c7ec24444c0cb56da25e98849c557f8:463d1b88ab58cf86fd8d475ad6fff2150c7ec24444c0cb56da25e98849c557f8": "The `collect_files` function returns a list of file paths from the specified base directory that are relevant for summarization. It starts with predefined patterns for common documentation and text files, then adds any additional patterns provided by the user. The function ensures that only unique files are returned by using a set to track seen files.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:detect_placeholders:fdff1ce5bed990e626ba70bb0cf3330d8bfdeaa94cb2aaf798661d83480734a3:fdff1ce5bed990e626ba70bb0cf3330d8bfdeaa94cb2aaf798661d83480734a3": "The function `detect_placeholders` takes a string `text` as input and returns a list of section names that are still marked by placeholder tokens. It uses the helper function `find_placeholders` to identify all placeholders in the text. Then, it filters these placeholders against a predefined dictionary `SECTION_PLACEHOLDERS`, which maps section names to their corresponding placeholder tokens. The function collects and returns the names of sections where the placeholder token is found in the input text.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:extract_snippets:f15f7b97643e4c53c3e83a57410fa06d6834e585169965e150275cc2ae672080:f15f7b97643e4c53c3e83a57410fa06d6834e585169965e150275cc2ae672080": "The function `extract_snippets` processes a list of Python files to extract relevant code snippets. It filters files based on the number of files processed (`max_files`), time spent processing (`time_budget`), and file size (`max_bytes`). For each file, it reads up to `max_bytes` of text and extracts:\n- Module docstrings\n- Docstrings from classes, functions, and async functions\n- Function signatures containing terms like \"path\", \"file\", \"config\", or \"io\"\n- Lines related to command-line interface (CLI) parsing\n- The content of the `__main__` block if present\n\nThe extracted snippets are stored in a dictionary with file paths as keys.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:extract_text:4a85f0cc059b83d85966060a1eea000bd53422b57ae7782cdb442722b6e66102:4a85f0cc059b83d85966060a1eea000bd53422b57ae7782cdb442722b6e66102": "The function `extract_text` reads and processes the content of a file located at the given `path`. It determines the file type based on its suffix (extension) and extracts plain text accordingly. For HTML files, it uses BeautifulSoup to clean and modify the content by replacing headings with Markdown-style headers and code blocks with fenced code blocks. Markdown files are read directly. For `.docx` files, if the `Document` class from the `python-docx` library is available, it reads the document and converts headings to Markdown-style headers while preserving other text. If any exceptions occur during processing, an empty string is returned.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:f356f99c1dad1ce9a1a3fe0007b9cc48a07e8b967e360ac9b551f11c2442691b:merge0:5da67ef9449a8c6c72560d544df01c9b3f4caa15bed1b9b944b6aa38066a316a": "This module defines a comprehensive project summary generator from existing documentation and sample files. It includes classes and functions for parsing configuration, collecting relevant files, slugifying text, inserting navigation entries into an index file, extracting plain text from various file types, detecting placeholders, mapping evidence to sections, ranking code files based on heuristics, and more. The module also defines functions to extract relevant code snippets from files, collect these snippets based on sections, and generate a manual using an LLM client. It includes utilities for rendering HTML, parsing text into structured sections, validating references, inferring missing sections, and writing the rendered output as a PDF. Additionally, it provides a `main` function that sets up argument parsing for summarizing project documentation, processes command-line arguments to configure parameters, collects documentation files, extracts text, initializes an LLM client, and generates a manual, handling placeholders and rendering the final output in specified formats.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:f356f99c1dad1ce9a1a3fe0007b9cc48a07e8b967e360ac9b551f11c2442691b:part0:8e0aa5cc5130e20eb0fb2d8a0c1a22484128117919a628d4585c5548c48a1959": "This module defines a project summary generator from existing documentation and sample files. It includes classes and functions to parse configuration, collect relevant files, slugify text, insert navigation entries into an index file, extract plain text from various file types, detect placeholders, map evidence to sections, rank code files based on heuristics, and more.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:f356f99c1dad1ce9a1a3fe0007b9cc48a07e8b967e360ac9b551f11c2442691b:part1:8f10a64afd7e2fd32e707110d894fffc2905f5f7961dc4bce28b5eeab79d573d": "The module defines functions to extract relevant code snippets from files, collect these snippets based on sections, and generate a manual using an LLM client. It includes:\n\n1. `extract_snippets`: Extracts code snippets from files based on file size, time budget, and specific conditions.\n2. `scan_code`: Collects source code snippets from a base directory grouped by manual sections.\n3. `llm_generate_manual`: Generates a manual from documentation snippets using an LLM client, mapping snippets to sections and assembling the final text.\n4. `llm_fill_placeholders`: Fills placeholder tokens in a manual with relevant information from code snippets.\n5. `_edit_chunks_in_editor`: Opens chunks of text in the user's editor for optional modification.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:f356f99c1dad1ce9a1a3fe0007b9cc48a07e8b967e360ac9b551f11c2442691b:part2:728ef003d9b9cf619f2797bd3f130e29e504e38c3a5e8a9633d300640b8df8a4": "This module provides functions to render HTML from structured sections of a manual, parse text into structured sections, validate references within those sections, infer missing sections, and write the rendered HTML as a PDF. It includes utilities for slugifying text, escaping HTML, and handling Markdown conversion. The module also interacts with an LLMClient for inferring missing sections based on provided text.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:f356f99c1dad1ce9a1a3fe0007b9cc48a07e8b967e360ac9b551f11c2442691b:part3:a9277aadc6312b031707b1eddb8a882d73e638ba5c39005838093b1f6829288b": "This module defines a function `main` that sets up argument parsing for summarizing project documentation. It processes command-line arguments to configure parameters such as the target directory, output format, and various options related to code scanning and manual generation.\n\nThe function initializes an argument parser with several options, including paths, formats, titles, and behaviors for inserting links into index files or skipping code scans. It then parses these arguments and constructs a configuration object.\n\nUsing this configuration, the function collects documentation files, extracts text from them, and logs the start of a document generation pass. It initializes an LLM client and response cache, then attempts to generate a manual using the `llm_generate_manual` function. If placeholders are missing in the generated manual, it scans code if necessary and fills these placeholders.\n\nFinally, the function renders the HTML or PDF output based on the specified format, injects a link into the index file if required, and saves evidence data to a JSON file before returning 0.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:infer_sections:26aedd73c1f47069cf6290b04255a92eeaa53eda617dc3933ce8f8fe667a8678:26aedd73c1f47069cf6290b04255a92eeaa53eda617dc3933ce8f8fe667a8678": "The function `infer_sections` takes a string `text` as input and returns a dictionary where keys are section names and values are the content of those sections. If the input text is non-empty, it places the entire text under an \"Overview\" section and generates placeholder content for other required sections labeled \"(inferred)\". If the input text is empty, it initializes all required sections with a default message indicating no information is available.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:inject_user_manual:f3eb297b5389751359053ae4aca0e7d913c46e0e40636a88f628b97ad3b096c2:f3eb297b5389751359053ae4aca0e7d913c46e0e40636a88f628b97ad3b096c2": "Inserts a top-level link to a user manual into an HTML file specified by `index_path`. The link is added to the first `<nav>` or `<ul>` element if present; otherwise, it is inserted at the start of the first `<body>` element or the document root.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:insert_into_index:0837aea55ee406bfc18408c5a355d8c47461eb910cc1ad8abbd25431dc7cff88:0837aea55ee406bfc18408c5a355d8c47461eb910cc1ad8abbd25431dc7cff88": "The function `insert_into_index` appends a navigation entry linking to a specified file into an HTML index file. It reads the existing content of the index file using BeautifulSoup, finds or creates a `<ul>` or `<nav>` container element, and checks if an entry for the given filename already exists. If not, it creates a new anchor tag with the provided title and appends it to the container. Finally, it writes the updated HTML back to the index file.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:llm_fill_placeholders:d20fe4d2f5725bbce315a9a7b7d976826e3a8ca2731eabd6faaeaf1ddb130d16:d20fe4d2f5725bbce315a9a7b7d976826e3a8ca2731eabd6faaeaf1ddb130d16": "The function `llm_fill_placeholders` processes a manual text by filling placeholders with relevant code snippets. It uses an LLM client to interact with a language model and a response cache for efficient reuse of responses. The function handles the following steps:\n\n1. **Tokenization**: It initializes a tokenizer to measure token usage.\n2. **Chunk Token Budget Calculation**: If not provided, it calculates a chunk token budget as 75% of the maximum context tokens.\n3. **Iterate Over Sections**: For each section in `code_snippets`, it constructs a snippet text by joining code snippets from different files.\n4. **Token Usage Check and Summarization**: It checks if the combined length of the manual text and snippet text exceeds the maximum context tokens. If so, it summarizes the snippet text to fit within the token limit.\n5. **Prompt Construction**: It constructs a prompt that includes the manual text, section title, and code snippets.\n6. **Update Manual**: It updates the manual by replacing placeholders with information from the code snippets using the LLM client and response cache.\n7. **Logging**: It logs which section was updated and which files were used.\n\nThe function returns the updated manual text after processing all sections.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:llm_generate_manual:d26654943fa1c4d05b52cc11075940ea3bb4982b08888206225be8ad47c65e7f:d26654943fa1c4d05b52cc11075940ea3bb4982b08888206225be8ad47c65e7f": "The function `llm_generate_manual` generates a user manual from provided documentation snippets by interacting with a language model (LLM). It maps the snippets to manual sections, performs LLM calls per section, and assembles the final manual text. The function returns the manual text, a mapping of source files to the sections they contributed, and an evidence map capturing the snippets used for each section.\n\nThe process involves:\n1. Mapping documentation snippets to manual sections using `map_evidence_to_sections`.\n2. Iterating over required sections, collecting entries from the snippet map.\n3. For each section, checking if entries are inferred or provided.\n4. Creating a context string from the collected snippets.\n5. Generating a prompt and system prompt for the LLM call.\n6. Handling chunking of the prompt if it exceeds token limits using `summarize_chunked`.\n7. Caching results to avoid redundant calls to the LLM.\n8. Parsing the LLM response to extract the section text.\n9. Replacing placeholders with actual content if necessary.\n10. Logging information about each section's generation process.\n11. Assembling the final manual text from the generated sections.\n\nThe function returns a tuple containing the manual text, a file map, and an evidence map.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:main:c8e029e95e786f74478c1313f96a4071959377426c1f524d933f129e2f12bad5:c8e029e95e786f74478c1313f96a4071959377426c1f524d933f129e2f12bad5": "The `main` function serves as the entry point for generating project documentation. It parses command-line arguments to configure settings such as the target project directory, output format, and various options related to code scanning and chunking. The function initializes a configuration object based on these arguments and proceeds with the following steps:\n\n1. Collects documentation files from the specified path.\n2. Reads and processes the text content of these files.\n3. Initializes logging based on the chunking mode.\n4. Generates an initial summary using a language model client, handling exceptions if summarization fails.\n5. If placeholders are detected in the initial response, it optionally scans project code to fill these placeholders.\n6. Renders the final HTML or PDF output based on the configured format.\n7. Optionally inserts a link to the generated manual into an index file.\n8. Saves evidence data related to the documentation process.\n\nThe function returns an integer status code indicating success (0) or failure (non-zero).",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:map_evidence_to_sections:e34667ee2bf6214007d2e3cd765b26b18f3715c231e65c180128d128ac9aa577:e34667ee2bf6214007d2e3cd765b26b18f3715c231e65c180128d128ac9aa577": "The function `map_evidence_to_sections` processes a dictionary of documentation snippets indexed by file paths and maps them to sections based on predefined keywords. It returns a tuple containing two dictionaries: `section_map`, which maps section names to a list of tuples (file path, snippet), and `file_map`, which maps each file path to the set of sections it contributes to. The function ensures that only the top 10 snippets per section are kept, with an exception for the \"Overview\" section in excluded directories. It also handles sorting based on priority and snippet length.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:parse_manual:006789af6e7a09cef843ddb16a641967e98e552295f6a2993f8d9c25e104a12d:006789af6e7a09cef843ddb16a641967e98e552295f6a2993f8d9c25e104a12d": "The function `parse_manual` takes a string of text, an optional language model client, and a boolean flag to infer missing sections. It parses the input text into structured sections based on lines containing a colon. If required sections are missing and inference is enabled, it uses the provided language model client to generate summaries for these sections and marks them as inferred in the output. The function returns a dictionary where keys are section titles and values are their corresponding content.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:rank_code_files:88ff8b5c8d1d482fb02322c5fa3de6d119e683aeba4dc8659513782c6a29198a:88ff8b5c8d1d482fb02322c5fa3de6d119e683aeba4dc8659513782c6a29198a": "The function `rank_code_files` ranks Python and MATLAB code files within a specified directory based on their relevance to documentation. It uses a combination of file extensions, directory names, and keyword patterns to assign scores to each file. The ranking is determined by the highest score, with ties broken by lexicographical order of the file paths.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:render_html:ad4b67f68a230da889bf36c745d2a6d92b4bdb5888ba4cc10ca8d4262f10151e:ad4b67f68a230da889bf36c745d2a6d92b4bdb5888ba4cc10ca8d4262f10151e": "The function `render_html` generates HTML documentation from a dictionary of sections, a title, and an optional evidence map. It slugifies section titles for navigation links, constructs navigation items, and processes content to include evidence snippets when available. The function supports rendering Markdown content and includes styles for the output.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:scan_code:90aee619c645387efa6e22803da3d2858c4686319672892fbb7fa9997b10699d:90aee619c645387efa6e22803da3d2858c4686319672892fbb7fa9997b10699d": "The `scan_code` function collects source code snippets from a specified directory (`base`) and groups them by manual section. It searches for keywords associated with given sections (defaulting to all known sections) within the text extracted from source files. The function returns a dictionary mapping section names to another dictionary of relative file paths and their corresponding snippet texts.\n\nKey steps include:\n1. Collecting patterns from documentation using `collect_docs` and extracting text.\n2. Ranking code files based on these patterns using `rank_code_files`.\n3. Extracting snippets from the ranked files within specified limits (`max_files`, `time_budget`, `max_bytes_per_file`).\n4. Categorizing collected snippets by section, filtering out unwanted sections if provided.\n\nThe function uses regular expressions to identify relevant patterns and tqdm for progress tracking during snippet collection.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:slugify:0d1441c2f5b7a7eb318652256cb5089be8e42f023232bc54bf8471906e08d616:0d1441c2f5b7a7eb318652256cb5089be8e42f023232bc54bf8471906e08d616": "The `slugify` function takes a string `text` and returns a filesystem-friendly slug. It removes all characters except lowercase letters and digits, replaces them with underscores, strips leading and trailing underscores, and ensures the result is not empty by defaulting to `\"user_manual\"` if the input is invalid or empty.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:validate_manual_references:289ebeda061417ff55af373b672accbc192e38e4e747fc8a663d3567b015517f:289ebeda061417ff55af373b672accbc192e38e4e747fc8a663d3567b015517f": "This function `validate_manual_references` checks for missing file references in documentation sections. It scans each section's text for substrings that resemble file paths or module names and flags those that cannot be found under the specified project root directory. If a reference is missing, it appends \"[missing]\" to the reference in the section text. Additionally, if an `evidence_map` is provided, it records the missing references under the corresponding section in a list called `missing_references`. The function modifies the `sections` dictionary in place.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:write_pdf:09908aa871fd98094e2a2a0c5bfacf87be2dfd0a247415fbc85425bfe278ba38:09908aa871fd98094e2a2a0c5bfacf87be2dfd0a247415fbc85425bfe278ba38": "The function `write_pdf` takes an HTML string and a file path as input. It checks if the `canvas` module is available; if not, it returns `False`. Otherwise, it converts the HTML to plain text, creates a PDF canvas, writes the text to the PDF, saves the PDF to the specified path, and returns `True` on success.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:5d50ba49c5671a2e830adf7defdabc64df1f3c27570cab0f7f0e39e9d50edbfe:5d50ba49c5671a2e830adf7defdabc64df1f3c27570cab0f7f0e39e9d50edbfe": "This code defines a PyQt5 application for running documentation and explanation generation tools. It includes:\n\n- A `PathLineEdit` class for file path input with drag-and-drop functionality.\n- A `CollapsibleBox` class for creating collapsible sections in the UI.\n- A `CommandRunner` class that runs shell commands asynchronously, emitting output and completion signals.\n- A `MainWindow` class that sets up the GUI, handles user interactions, and manages running commands.\n\nThe main window includes:\n- Fields for selecting project and output directories.\n- Options for DocGen and ExplainCode tools, including language selection and data inclusion.\n- A log area to display command output.\n- Buttons to run DocGen, ExplainCode, or both.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:CollapsibleBox:9e9222bf363276a563550eee7aa31fb3d6839a690b0e2a53e88db636d444ecb8:9e9222bf363276a563550eee7aa31fb3d6839a690b0e2a53e88db636d444ecb8": "The `CollapsibleBox` class defines a custom widget for creating expandable sections in graphical user interfaces, suitable for rendering nested functions and subclasses as collapsible boxes. It includes methods for initializing the widget with a toggle button and content area, toggling the visibility of the content based on the state of the toggle button, and setting the content layout of an object.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:CollapsibleBox:__init__:3872795cd50f67882abd634cee89722f78baef841dae8e915249543f655adece:3872795cd50f67882abd634cee89722f78baef841dae8e915249543f655adece": "A class constructor that initializes a custom widget with a toggle button and content area. The toggle button is styled to have no border, light gray text, and bold font weight. It displays the provided title and has an arrow icon on its right side. When clicked, it triggers the `on_toggled` method. Initially, the content area is hidden. The widget uses a vertical layout to arrange the toggle button at the top and the content area below it.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:CollapsibleBox:on_toggled:f90ec87aaa91989724254207a4e933efac34041b0616a24b2d270248eb906904:f90ec87aaa91989724254207a4e933efac34041b0616a24b2d270248eb906904": "Toggles the appearance and visibility of a content area based on the state of a toggle button. When the toggle button is checked, it displays a downward arrow and makes the content visible; when unchecked, it shows a rightward arrow and hides the content.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:CollapsibleBox:setContentLayout:ac9bfe1723225a787e6fed8f56df1803aac7bf21a8460cdab57bb446c2364b27:ac9bfe1723225a787e6fed8f56df1803aac7bf21a8460cdab57bb446c2364b27": "Sets the content layout of an object.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:CommandRunner:5dd45d773c1ef49e460735029a354b2ca832917fb7da7bd8dd42afd2a3a8115d:5dd45d773c1ef49e460735029a354b2ca832917fb7da7bd8dd42afd2a3a8115d": "The `CommandRunner` class initializes with a list of commands and provides methods to execute these commands sequentially, capturing their output and handling exceptions. It includes a `_reader` function for reading from streams and emitting text chunks, ensuring proper progress bar updates in GUI applications. The `run` method manages the execution flow, waits for subprocesses to complete, and handles errors gracefully by breaking on non-zero exit codes or exceptions.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:CommandRunner:__init__:e101f462c35c5d2aea35db85e4ee5dd50b4513aa99b522541dc82c8e27a017f4:e101f462c35c5d2aea35db85e4ee5dd50b4513aa99b522541dc82c8e27a017f4": "Initializes an object with a list of commands.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:CommandRunner:_reader:8cbfd3ce114ed1c88228963326a3e4e5c43e87fbd062a6965099f60e48b826d6:8cbfd3ce114ed1c88228963326a3e4e5c43e87fbd062a6965099f60e48b826d6": "The function `_reader` reads characters from a stream one by one and emits chunks of text. It handles carriage returns to update progress bars in the GUI, flushes any buffered text when the stream ends, and ensures that new lines are properly emitted with the accumulated buffer content.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:CommandRunner:run:c94857cc54e41729c04041a0a02b8ef637ddeb94d917c5048d30a4c9036c500a:c94857cc54e41729c04041a0a02b8ef637ddeb94d917c5048d30a4c9036c500a": "The function `run` executes a list of commands sequentially. For each command, it outputs the command string, starts subprocesses to capture standard output and standard error, reads from these streams in separate threads, waits for the subprocess to finish, and then joins the reading threads. If any subprocess returns a non-zero exit code or an exception occurs, the function breaks out of the loop and emits the final exit code.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:MainWindow:__init__:1da23725535c31140c4fdd3e8bd0a1c242da37272b89cb4d53c5aa803892f18f:1da23725535c31140c4fdd3e8bd0a1c242da37272b89cb4d53c5aa803892f18f": "A PyQt5 window for a documentation tool named \"DocGen-LM Documentation Tool\". The window includes:\n- A header with a logo and title.\n- Fields to select project and output directories with browse buttons.\n- Checkboxes to include private functions and specify languages (Python, MATLAB).\n- Options for output format (HTML, PDF) and including input data analysis with a file selector.\n- A log area for displaying messages.\n- Buttons to run DocGen, ExplainCode, or both.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:MainWindow:append_log:479035b003afdc113e4797fee7c099619ef8d0c73b903f780a2ffa361feaaf55:479035b003afdc113e4797fee7c099619ef8d0c73b903f780a2ffa361feaaf55": "The function `append_log` appends text to a log widget. It uses a regular expression to split the input text into parts, handling carriage return characters (`\\r`) by moving the cursor to the beginning of the line and removing any existing text before inserting new text. After appending all parts, it scrolls the log widget to the bottom.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:MainWindow:build_docgen_cmd:aa405669828c941197e5ebc761b74680661f1d13446b43d905554dd073085192:aa405669828c941197e5ebc761b74680661f1d13446b43d905554dd073085192": "Constructs a command for running a document generator script with specified parameters, including project and output paths, optional private inclusion flag, and selected programming languages.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:MainWindow:build_explain_cmd:7b8696f7337008622c6bc5488b4fc92413596481c1750330bdc72564631f2cb5:7b8696f7337008622c6bc5488b4fc92413596481c1750330bdc72564631f2cb5": "Constructs a command list to execute the `explaincode.py` script with specified parameters, including project path, output file, format, and optional data.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:MainWindow:d5b084773b6d4d432360402218defc057777186a27815bdf82d4976dac5ee182:d5b084773b6d4d432360402218defc057777186a27815bdf82d4976dac5ee182": "The `MainWindow` class defines a PyQt5 window for generating static HTML documentation for Python and MATLAB projects using DocGen-LM. It includes functionalities for selecting project and output directories, choosing languages, specifying output formats, and running document generation or explanation commands. The class also handles logging messages and managing button states during the execution of these commands.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:MainWindow:dark_style:024d23387b641216e7d149e6c045b026f1a451318d781be0d3d84d51867f51ef:024d23387b641216e7d149e6c045b026f1a451318d781be0d3d84d51867f51ef": "The function `dark_style` returns a string containing CSS styles for various Qt widgets, including QWidget, QLineEdit, QPlainTextEdit, QComboBox, QPushButton, and QLabel. The styles define the appearance of these widgets in a dark theme, with specific colors for backgrounds, borders, fonts, and padding.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:MainWindow:on_finished:c98dd27bd106b89d8d5059a01d5a7c208db9c09ee3836ee9d932c0f5bdb99f8b:c98dd27bd106b89d8d5059a01d5a7c208db9c09ee3836ee9d932c0f5bdb99f8b": "The function `on_finished` logs the exit code of a process and sets the running state to False.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:MainWindow:run_both:123251ea533aa28d4fb511b62f853998d3769fcced0962a00cdc1cb16c3cfef0:123251ea533aa28d4fb511b62f853998d3769fcced0962a00cdc1cb16c3cfef0": "Clears the log and runs both the document generation command and the explanation command.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:MainWindow:run_commands:259d9e78ac20ac9cd282474591a8079c54a2e042ef9670b77335a47dad9adaff:259d9e78ac20ac9cd282474591a8079c54a2e042ef9670b77335a47dad9adaff": "The function `run_commands` is designed to execute a series of commands within a project environment. It first checks if both the project and output directories are set; if not, it logs an error message and returns without executing any commands. If the directories are set, it proceeds by setting its running state to true, creating an instance of `CommandRunner` with the provided commands, connecting the runner's output signal to a method for appending log messages, and connecting the finished signal to a method handling completion. Finally, it starts the command execution.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:MainWindow:run_docgen:0249c14aca7d5d21ff6d3b7929c59f2dbc05b970b05e9329f97566991188ecf6:0249c14aca7d5d21ff6d3b7929c59f2dbc05b970b05e9329f97566991188ecf6": "The function `run_docgen` clears the log and runs a command to generate documentation.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:MainWindow:run_explain:aaae3953f6dfd026db21ab5cd9b5c637f7a8e0fee01ae706e4db035bf9a67663:aaae3953f6dfd026db21ab5cd9b5c637f7a8e0fee01ae706e4db035bf9a67663": "Clears the log and runs a command to explain something.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:MainWindow:select_dir:2a0195f8b02fa1d0340ed30e33775539f64b5ddf0498a2fae1d7426f16c229f5:2a0195f8b02fa1d0340ed30e33775539f64b5ddf0498a2fae1d7426f16c229f5": "This function `select_dir` takes a `line_edit` object as an argument. It opens a file dialog to allow the user to select an existing directory. If a directory is selected, it sets the text of the `line_edit` object to the path of the selected directory.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:MainWindow:select_file:eefcbb0d572a55989ebf1a954aae8e90553ec7f2c5c165ee8e6029c3df4770d3:eefcbb0d572a55989ebf1a954aae8e90553ec7f2c5c165ee8e6029c3df4770d3": "The function `select_file` opens a file dialog to allow the user to select a data file. If a file is selected, it sets the text of a provided `QLineEdit` widget to the path of the selected file.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:MainWindow:set_running:d3acbd2de6100d567839296867ec1053032418777abacda408081e46f5c8e826:d3acbd2de6100d567839296867ec1053032418777abacda408081e46f5c8e826": "The function `set_running` takes a boolean parameter `running`. It iterates over three buttons (`docgen_btn`, `explain_btn`, and `both_btn`) and sets their enabled state to the opposite of the `running` parameter. If `running` is `True`, the buttons are disabled; if `running` is `False`, the buttons are enabled.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:PathLineEdit:3c01f98491720fa4be798e4ffe86a26302dbb70b32be29404094f2f511a73542:3c01f98491720fa4be798e4ffe86a26302dbb70b32be29404094f2f511a73542": "The `PathLineEdit` class is designed for use in graphical user interfaces within a documentation tool that generates static HTML documentation for Python and MATLAB projects. It handles drag-and-drop events, specifically accepting URLs and updating the widget's text with the local file path of the first URL dropped onto it.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:PathLineEdit:__init__:c9e8a7be9ec3c7638ba891fb56438f32b028d50d553e3cf05183fab3aa0b6309:c9e8a7be9ec3c7638ba891fb56438f32b028d50d553e3cf05183fab3aa0b6309": "Initializes a new instance of the class with an optional parent object. Sets the widget to accept drag-and-drop events.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:PathLineEdit:dragEnterEvent:362f23d15259d38f2384b97d4fe0df74d022e537eb20da5aa442f957d48d0d35:362f23d15259d38f2384b97d4fe0df74d022e537eb20da5aa442f957d48d0d35": "The function `dragEnterEvent` checks if the incoming drag-and-drop event contains URLs. If it does, it accepts the proposed action for the event.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:PathLineEdit:dropEvent:2bae52494ea3b00064a9fc268f5338cc663c0b954be820963c807172bd13b7cf:2bae52494ea3b00064a9fc268f5338cc663c0b954be820963c807172bd13b7cf": "The function `dropEvent` handles a drop event in a graphical user interface. It extracts URLs from the dropped data and sets the text of the widget to the local file path of the first URL.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\html_writer.py:9c67880c807b6c13cd855d095c53d4913d92121b20e917e7adb6a440a8708ca4:9c67880c807b6c13cd855d095c53d4913d92121b20e917e7adb6a440a8708ca4": "This module provides utilities for rendering documentation pages using simple template substitution. It includes functions to highlight code snippets and render HTML content based on project summaries and module data. The module supports Python and MATLAB languages. It can generate `index.html` and individual module documentation pages, complete with navigation links and highlighted source code.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\html_writer.py:_highlight:fa3372ca04d6540f0abb146de7bf99b44a4519e41c559aa3142f212e7ac09741:fa3372ca04d6540f0abb146de7bf99b44a4519e41c559aa3142f212e7ac09741": "The `_highlight` function takes a string of code and a language identifier as input. It uses the Pygments library to highlight the code based on the specified language. If the language is MATLAB or Python, it selects the appropriate lexer (MatlabLexer or PythonLexer). For other languages, it defaults to using the TextLexer. The highlighted code is then formatted with HTML, wrapped in `<pre><code>` tags, and returned as a string.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\html_writer.py:_render_class:cacdb879f5456aab6edbd02a7f2ddbd82630beef3dff6341497341b4dd9bf036:cacdb879f5456aab6edbd02a7f2ddbd82630beef3dff6341497341b4dd9bf036": "This function `_render_class` takes a dictionary representing a class, a programming language string, and an optional level integer (defaulting to 2). It returns a list of HTML strings that represent the class and its subclasses. The function uses recursion to handle nested subclasses. It generates HTML tags for the class name and documentation, and it iterates over methods and subclasses within the class, rendering them using helper functions `_render_function` and `_render_class`, respectively.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\html_writer.py:_render_function:f28f0d26ca76698cb1d6bda862dcd8fadcc9e68f343db32472ae79b78062c155:f28f0d26ca76698cb1d6bda862dcd8fadcc9e68f343db32472ae79b78062c155": "This function `_render_function` generates HTML parts for a given Python or MATLAB function and its nested subfunctions. It takes a dictionary representing the function, the programming language (either \"python\" or \"matlab\"), an optional heading level (default is 3), and an optional prefix string.\n\nThe function constructs HTML elements based on the provided function data:\n1. It creates an HTML header tag (`<h1>` to `<h6>`) with the function's signature or name, using the specified level.\n2. If a summary or docstring is available, it adds a paragraph element containing the escaped text.\n3. If source code is present, it calls `_highlight` to syntax-highlight the code and appends the result.\n4. For each nested subfunction, it creates a `<details>` element with a `<summary>` for the subfunction's signature or name, then recursively renders the subfunction using the same parameters.\n\nThe function returns a list of HTML string parts that can be joined to form the complete HTML representation of the function and its subfunctions.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\html_writer.py:_render_html:c7e30b6e3bd2e76b9e7d993281974166d64c4f8e36b28b2c31f3e4089bc90f6a:c7e30b6e3bd2e76b9e7d993281974166d64c4f8e36b28b2c31f3e4089bc90f6a": "The function `_render_html` takes four parameters: `title`, `header`, `body`, and `nav_html`. It reads a template file located at `_TEMPLATE_PATH`, which is expected to contain placeholders for the title, header, body, navigation, and static path. The function then formats these placeholders with the provided values and returns the resulting HTML string, prefixed with a comment indicating that it was generated by DocGen-LM.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\html_writer.py:write_index:a1d6d84089e3c4daf08c859abd6e144abaf9f4cbe2b377ae9c51662ab867e95a:a1d6d84089e3c4daf08c859abd6e144abaf9f4cbe2b377ae9c51662ab867e95a": "The `write_index` function generates the content for an `index.html` file in a specified output directory. It takes three required parameters: `output_dir`, `project_summary`, and `page_links`. Optionally, it accepts a dictionary `module_summaries`.\n\nThe function creates the destination directory if it doesn't exist. It constructs navigation links from the provided `page_links` and escapes any HTML content to prevent injection attacks.\n\nIt then builds the body of the HTML document by combining the project summary, a horizontal rule, and a list of modules with their summaries (if available). Each module is linked to its respective page.\n\nFinally, it uses a helper function `_render_html` to format these elements into a complete HTML structure and writes this content to `index.html` in the specified output directory.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\html_writer.py:write_module_page:65a853e1460d5307b922ded64b5564d3c628d896c8e59daab3938c8ad0cdddfd:65a853e1460d5307b922ded64b5564d3c628d896c8e59daab3938c8ad0cdddfd": "This function `write_module_page` generates an HTML documentation page for a Python or MATLAB module. It takes three parameters: `output_dir`, which is the directory where the output HTML file will be saved; `module_data`, a dictionary containing information about the module, including its name, summary, classes, and functions; and `page_links`, an iterable of tuples representing navigation links.\n\nThe function first constructs the destination directory for the HTML file and ensures it exists. It then extracts the module's name and language from `module_data`. Navigation items are created for the project overview and any additional page links provided.\n\nThe body of the HTML page is built by concatenating sections for the module summary, classes, and functions. Each class and function is rendered using helper functions `_render_class` and `_render_function`, respectively. The final HTML content is generated by combining the navigation and body parts, and then written to a file named after the module in the specified output directory.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\llm_client.py:8f5b5f0b0df904ebe69c30d4e90b99dac958762ddee3adcb12e8b64107e13bf6:8f5b5f0b0df904ebe69c30d4e90b99dac958762ddee3adcb12e8b64107e13bf6": "This module provides an interface to communicate with a local language model server (LMStudio) using its HTTP API. It includes:\n\n- A `SYSTEM_PROMPT` and `_COMMON_RULES` for defining guidelines for documentation generation.\n- A `README_PROMPT` for summarizing README files.\n- A dictionary `PROMPT_TEMPLATES` containing different prompt templates for summarizing modules, classes, functions, READMEs, projects, docstrings, and user manuals.\n- A `sanitize_summary` function to clean up generated summaries by removing unwanted phrases.\n- An `LLMClient` class that:\n- Initializes with a base URL and model name.\n- Includes a `ping` method to check if the LMStudio server is reachable.\n- Implements a `summarize` method to send text and prompt type to the LMStudio API, retrying up to three times on failure.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\llm_client.py:LLMClient:__init__:700c23b8c0716a1aaf00c10fbc2e056bef4f6e1dca9c72b739185f920ef55cf8:700c23b8c0716a1aaf00c10fbc2e056bef4f6e1dca9c72b739185f920ef55cf8": "Initializes an object with a base URL and a model. The base URL is stripped of any trailing slashes, and the endpoint for chat completions is constructed using this base URL. The model type can be specified; if not provided, it defaults to \"local\".",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\llm_client.py:LLMClient:aa6f060a38b4bdb78db5d8413b51103cb393134afb2fbf6ee9123321ebfff782:aa6f060a38b4bdb78db5d8413b51103cb393134afb2fbf6ee9123321ebfff782": "The `LLMClient` class is designed for interacting with a language model to generate summaries of code. It includes methods for initializing the client, checking API reachability, and summarizing text using specified prompts. The class handles potential errors during requests and provides a structured way to interact with the language model for documentation purposes.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\llm_client.py:LLMClient:ping:3fe5655e89accd067c6ddc9c1cc323c9dd9eac2dea9be6646ea4d470b3e0a436:3fe5655e89accd067c6ddc9c1cc323c9dd9eac2dea9be6646ea4d470b3e0a436": "Function `ping` checks if the API is reachable. It sends a GET request to the server's base URL with an optional timeout parameter. If the response status code indicates success, it returns `True`. If there is any exception during the request (e.g., network issues), it raises a `ConnectionError` with a message indicating that the server cannot be contacted.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\llm_client.py:LLMClient:summarize:340953c686eb58c465b342c01876eeee10acc4d018b2970e5b107bcfedab0633:340953c686eb58c465b342c01876eeee10acc4d018b2970e5b107bcfedab0633": "The function `summarize` takes three parameters: `text`, `prompt_type`, and an optional `system_prompt`. It returns a summary of the provided `text` using a template specified by `prompt_type`. The function uses a payload to send a request to an endpoint, handling potential errors up to three times before raising a `RuntimeError` with the last error message.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\llm_client.py:sanitize_summary:92191cc63f77372d6dbc232f61e3e74c0c75419d3e9b05d0bcdc158d99ce09a5:92191cc63f77372d6dbc232f61e3e74c0c75419d3e9b05d0bcdc158d99ce09a5": "The function `sanitize_summary` processes a given text string by removing lines that start with specific phrases or contain certain keywords related to summaries, outputs, responses, and code descriptions. It also handles a special case where the input is exactly \"project summary\" by returning \"It prints.\" The function uses regular expressions for pattern matching and list comprehensions for filtering lines.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\manual_utils.py:_count_tokens:0e582c22bfd6c81b0de29f3b8c150052146844a0f4b6941fd49087c50fc44fa5:0e582c22bfd6c81b0de29f3b8c150052146844a0f4b6941fd49087c50fc44fa5": "This function `_count_tokens` takes a string `text` as input and returns an integer representing the approximate number of tokens in the text. It uses a tokenizer to encode the text, which converts it into a sequence of tokens, and then calculates the length of this sequence to determine the token count.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\manual_utils.py:_split_text:2b13e33c75b6ddb3c08c5c21221e30adc8bcb78ad83eb4909bdc30b295d47949:2b13e33c75b6ddb3c08c5c21221e30adc8bcb78ad83eb4909bdc30b295d47949": "This function `_split_text` splits a given text into chunks while respecting specified maximum token and character limits. It first splits the input text into paragraphs, then iterates through each paragraph to determine if it fits within the token and character constraints. If a paragraph exceeds these limits, it is further chunked using another function `chunk_text`. The resulting chunks are collected in a list and returned.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\manual_utils.py:_summarize_manual:361dd12ae23d56426255ee6a413902459477408bb167fe539b4e3b01303ebbbb:361dd12ae23d56426255ee6a413902459477408bb167fe539b4e3b01303ebbbb": "The function `_summarize_manual` generates a manual summary for the provided text using a specified chunking strategy. It interacts with an LLM client to perform summarization and utilizes a response cache to store previously generated summaries for efficiency. The function handles different chunking modes: \"manual\", \"auto\" (with automatic chunking if text exceeds certain limits), and \"none\" (disabling chunking if text is too large). It also supports a post-chunk hook for additional processing of summarized parts. The function ensures that the final summary does not exceed token or character limits by performing hierarchical merges if necessary.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\manual_utils.py:ca45f47ddbb3006a8bf59dd1857385df96e5bfaf41681af7c2da178cba05f5ca:ca45f47ddbb3006a8bf59dd1857385df96e5bfaf41681af7c2da178cba05f5ca": "This module provides functions for splitting text into chunks and generating summaries using a language model. It includes:\n\n- `_count_tokens`: Counts the number of tokens in a given text.\n- `_split_text`: Splits a text into chunks based on token and character limits.\n- `chunk_docs`: Splits multiple documents into roughly equal-sized chunks.\n- `find_placeholders`: Finds placeholder tokens in a text.\n- `_summarize_manual`: Generates a manual summary for a given text using a specified chunking strategy. It handles both automatic and manual chunking, caching responses to avoid redundant requests.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\manual_utils.py:chunk_docs:1f8b2200ed05e89f754b26bc1f83a97ec3eaa1c53c7e3fd57b4a4781a64caa20:1f8b2200ed05e89f754b26bc1f83a97ec3eaa1c53c7e3fd57b4a4781a64caa20": "The function `chunk_docs` takes a list of strings (`docs`) and an integer (`token_limit`) as input. It joins the non-empty strings in `docs`, separated by double newlines, into a single string. If the resulting string is empty, it returns an empty list. Otherwise, it calls `_split_text` with the joined string, using both `max_tokens` and `max_chars` set to `token_limit`. The function's purpose is to split the input text into chunks that do not exceed the specified token limit.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\manual_utils.py:find_placeholders:5a9c41ac0f7838c38590fc8b64f8f75137cb48a2f664a4e7526cb6ad7a8d317e:5a9c41ac0f7838c38590fc8b64f8f75137cb48a2f664a4e7526cb6ad7a8d317e": "The function `find_placeholders` searches for placeholder tokens enclosed in double backticks followed by two square brackets, such as ``[[TOKEN]]``, within a given string `text`. It returns a set of these placeholder tokens found in the text. The placeholders are identified using a regular expression defined in `PLACEHOLDER_RE`.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\parser_matlab.py:15cf90e58e5b33528fe0fc6fa2e48fa77e43bd0fed902a29ea22b67a2f78ff68:15cf90e58e5b33528fe0fc6fa2e48fa77e43bd0fed902a29ea22b67a2f78ff68": "This module provides a function `parse_matlab_file` that parses MATLAB `.m` files and extracts basic structure. It reads the file content, identifies leading comment lines as the file header, and uses regular expressions to find and extract function declarations along with their arguments. The result is returned as a dictionary containing the file header comments and a list of functions, each represented by its name and arguments.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\parser_matlab.py:parse_matlab_file:5c05ec1e3627d0e24532e05a7e82b15a564336af16a078936103928c6e3894f4:5c05ec1e3627d0e24532e05a7e82b15a564336af16a078936103928c6e3894f4": "The function `parse_matlab_file` reads and parses a MATLAB `.m` file to extract basic structure. It returns a dictionary containing the file's header comments and any function declarations found. Each function entry includes the function name and a list of arguments. The function handles leading comment lines as the file header, identifies function declarations using regular expressions, and organizes them into a structured dictionary format for further processing or documentation generation.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\parser_python.py:9b7a83be6356666450a5a1a457ffe2e114b6726c1c43053f6e27962b7ce8f0aa:9b7a83be6356666450a5a1a457ffe2e114b6726c1c43053f6e27962b7ce8f0aa": "This module provides a parser for Python files using the `ast` module. It extracts structured information according to the Software Requirements Specification (SRS). The parser can handle classes and functions, including their signatures, docstrings, returns types, and nested definitions. It also supports asynchronous functions and methods. The main function, `parse_python_file`, reads a Python source file and returns a dictionary containing the module's docstring, classes, and functions.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\parser_python.py:_format_arg:f5c1927180d9a82ef6032ee19968860c3f53e310b405bae325c4419271b42a75:f5c1927180d9a82ef6032ee19968860c3f53e310b405bae325c4419271b42a75": "Formats a function argument by appending its type annotation, if available.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\parser_python.py:_format_arguments:d47400b97f050df86fa5e0f9459f1a98f6684e3b7d971eb3d516870ae612c104:d47400b97f050df86fa5e0f9459f1a98f6684e3b7d971eb3d516870ae612c104": "This function `_format_arguments` takes an `ast.arguments` object as input and returns a string representation of the arguments it contains. The function handles positional-only arguments, regular arguments, variable positional arguments (`*args`), keyword-only arguments, and variable keyword arguments (`**kwargs`). It constructs the string by iterating through each type of argument, formatting them using `_format_arg`, and appending any default values if provided. The resulting parts are joined with commas to form a complete string representation of the function's arguments.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\parser_python.py:_format_signature:c9cfde31ba7d3e857c9c8ac83d9e9b25235c41d88e2cff9f3674e8c4329a74a6:c9cfde31ba7d3e857c9c8ac83d9e9b25235c41d88e2cff9f3674e8c4329a74a6": "This function `_format_signature` takes a Python `ast.FunctionDef` or `ast.AsyncFunctionDef` object as input and returns a string representing the signature of the function. It constructs the signature by formatting the function's name, arguments, and return type (if specified). The function uses another helper function `_format_arguments` to format the parameters of the function. If the function has a return type, it appends this to the signature using `ast.unparse` to convert the AST node representing the return type back into a string.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\parser_python.py:_parse_classes:bfeec03d6fbf4c4c09a3c61cf9abde58a1e7718251db45e3ecb907fe6ca91aa3:bfeec03d6fbf4c4c09a3c61cf9abde58a1e7718251db45e3ecb907fe6ca91aa3": "This function recursively parses all `ClassDef` nodes within a list of AST nodes. It iterates through each node and checks if it is an instance of `ClassDef`. If so, it calls the `parse_class` function to process the class and adds the result to the `classes` list. If the node is an instance of `FunctionDef` or `AsyncFunctionDef`, it recursively calls `_parse_classes` on the body of the function to parse any nested classes. The function returns a list of dictionaries, each representing a parsed class.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\parser_python.py:parse_class:8352efdd45f9656deaf80ce2fd99fa9bf3e181d42c760911ac0886d2f288c246:8352efdd45f9656deaf80ce2fd99fa9bf3e181d42c760911ac0886d2f288c246": "The function `parse_class` takes an AST node representing a class and the source code as input. It returns a dictionary containing information about the class, including its name, docstring, methods, subclasses, and source code segment. The function iterates through the body of the class to identify and parse any nested functions (methods) and subclasses, recursively calling `parse_function` for each method and `_parse_classes` for each subclass.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\parser_python.py:parse_classes:fa87b1e34abbbe9b16ca1a02eec6d3e67a3ddaa6583797d5d1e1d0ebdfc9a173:fa87b1e34abbbe9b16ca1a02eec6d3e67a3ddaa6583797d5d1e1d0ebdfc9a173": "The `parse_classes` function is a public interface for parsing classes within a Python abstract syntax tree (AST). It takes two parameters: `node`, which represents the AST node to be parsed, and `source`, a string containing the source code. The function calls an internal helper function `_parse_classes`, passing it the body of the given node (or an empty list if the node has no body) and the source code. This allows for recursive parsing of nested structures within the AST.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\parser_python.py:parse_function:60fdbe430fd3a5a61ad1d4836b6a25ce5bb22f87b8d206be85dee198aae2f42f:60fdbe430fd3a5a61ad1d4836b6a25ce5bb22f87b8d206be85dee198aae2f42f": "This function `parse_function` takes an AST node representing a Python function or async function (`ast.FunctionDef` or `ast.AsyncFunctionDef`) and the source code as input. It returns a dictionary containing details about the function, including its name, signature, return type, docstring, source code snippet, subfunctions, and subclasses.\n\nThe function initializes a dictionary `func_info` with keys for these attributes. It then populates this dictionary by extracting relevant information from the AST node using methods like `_format_signature`, `ast.unparse`, `ast.get_docstring`, and `ast.get_source_segment`.\n\nFor each item in the body of the function, if it is another function or async function, the function recursively calls itself to parse the nested function and appends the result to the `subfunctions` list.\n\nAdditionally, the function calls `_parse_classes` to extract any subclasses defined within the function's body and appends them to the `subclasses` list.\n\nFinally, the function returns the populated `func_info` dictionary.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\parser_python.py:parse_python_file:08f3f9ea27d229bd32b36d5d3c426423aa1756ef429d3747ccb351ec30423edf:08f3f9ea27d229bd32b36d5d3c426423aa1756ef429d3747ccb351ec30423edf": "The function `parse_python_file` reads a Python source file and extracts structured information. It takes the file path as input and returns a dictionary containing the module docstring, classes, and functions defined in the file. The function uses the `ast` module to parse the source code and iterates through its nodes to identify and extract class and function definitions, which are then processed by helper functions `parse_class` and `parse_function`.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\reviewer.py:4f9d422499a1acff78c67b05122179a409cbacd25a4c242442e0aef707dbeb81:4f9d422499a1acff78c67b05122179a409cbacd25a4c242442e0aef707dbeb81": "This module provides a tool for reviewing HTML documentation generated by DocGen-LM. It includes functions to check for assistant-like phrases, contradictions, and hallucinations in the HTML content. The `review_directory` function processes all `.html` files in a specified directory, applying these checks and optionally fixing issues using the `sanitize_summary` function from the `llm_client` module. The `main` function sets up command-line arguments to specify the directory to review and whether to enable autofixing of detected issues.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\reviewer.py:_extract_tags:b2deda915d71e97b2eaa421c91ae4c4ece3d09c0a27d74f40d059c735c332a91:b2deda915d71e97b2eaa421c91ae4c4ece3d09c0a27d74f40d059c735c332a91": "The function `_extract_tags` is designed to extract all occurrences of a specified HTML tag and its content from a given HTML string. It uses a regular expression pattern to match the opening and closing tags, capturing the text between them. The `re.findall` method is used to find all matches in the input HTML string, returning a list of strings where each string represents the content within a pair of matching tags.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\reviewer.py:_find_line_number:aa22c6902c8c45b28fc8302c2e97c085a7b095e32212ea3a53239c454614d64e:aa22c6902c8c45b28fc8302c2e97c085a7b095e32212ea3a53239c454614d64e": "The function `_find_line_number` searches for a specific phrase within an HTML string and returns the line number where the phrase is found. If the phrase is not present, it returns -1. The search is case-insensitive.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\reviewer.py:_is_generated_html:6d48abca382a7294aaeac8813854a5ee887624400872e126ac403a28250d68e1:6d48abca382a7294aaeac8813854a5ee887624400872e126ac403a28250d68e1": "The function `_is_generated_html` checks if a given string of text appears to be output from DocGen-LM, a documentation generator for Python and MATLAB projects. It returns `True` if the text contains specific markers indicating it was generated by DocGen-LM: the phrase \"Generated by DocGen-LM\", an HTML header for project documentation, headers for classes and methods in HTML format.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\reviewer.py:_review_file:df54a34dfcaaa6ea6abf91c5d35409e55791522bfead3b97b68984f62d1d2ce5:df54a34dfcaaa6ea6abf91c5d35409e55791522bfead3b97b68984f62d1d2ce5": "The function `_review_file` takes a file path and an optional boolean flag `autofix`. It reads the content of the file as HTML. If the HTML is not generated by the tool, it returns an empty list. Otherwise, it checks for assistant phrasing, contradictions, and hallucinations in the HTML content. Each issue found is appended to a results list with a specific prefix indicating the type of issue (assistant, contradiction, or hallucination). If `autofix` is True and there are issues, it sanitizes the paragraphs in the HTML and writes the updated content back to the file. Finally, it returns the list of issues found.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\reviewer.py:_sanitize_paragraphs:37c305f0123407cfbfeb7c349d12e3427d7e66f8ed06fc5d76bfe90bf2df47de:37c305f0123407cfbfeb7c349d12e3427d7e66f8ed06fc5d76bfe90bf2df47de": "The `_sanitize_paragraphs` function takes an HTML string as input and processes it to ensure that each paragraph is properly sanitized. It uses a regular expression to identify paragraphs within the HTML and applies a replacement function `repl` to each one. The replacement function strips any HTML from the content of the paragraph, sanitizes the remaining text using another function `sanitize_summary`, and then wraps the sanitized content back in `<p>` tags. This ensures that all paragraphs in the input HTML are clean and properly formatted.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\reviewer.py:_strip_html:c11a96912b378d3ef63054be8e11899da9a3e1ab2df3ff4b3ddf3f3285a111b4:c11a96912b378d3ef63054be8e11899da9a3e1ab2df3ff4b3ddf3f3285a111b4": "The function `_strip_html` takes a string `text` as input and returns a new string with all HTML tags removed. This is achieved using the `re.sub` function from the `re` module, which substitutes all occurrences of the regular expression pattern `<[^>]+>` (which matches any sequence starting with `<`, followed by one or more non-`>` characters, and ending with `>`) with an empty string.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\reviewer.py:check_assistant_phrasing:f1b43e2f89f2197bc0af7466c4d1a8c8aa079b3fd42ad5aa48d1fea725b0cbe5:f1b43e2f89f2197bc0af7466c4d1a8c8aa079b3fd42ad5aa48d1fea725b0cbe5": "The function `check_assistant_phrasing` takes a string of HTML as input and returns a list of phrases that appear to be assistant-like. It does this by extracting all paragraph (`<p>`) tags from the HTML, stripping any HTML from the text within these tags, converting the text to lowercase for case-insensitive comparison, and checking if any predefined assistant phrases are present in the text. If an assistant phrase is found, it appends a string containing the original text and its line number in the HTML to the findings list.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\reviewer.py:check_contradictions:cbd43078b8b91a4f981c05373e1687fe32dc354c5ad9c644fdcc969c85456e66:cbd43078b8b91a4f981c05373e1687fe32dc354c5ad9c644fdcc969c85456e66": "The `check_contradictions` function analyzes HTML documentation to identify contradictions between the text content and the presence of specific elements. It returns a list of contradiction descriptions based on the following checks:\n\n1. If the summary text contains \"no methods\" but method headers are found in the HTML.\n2. If the summary text contains \"no functions\" but function headers are found in the HTML.\n3. If the summary text contains \"no classes\" but class headers are found in the HTML.\n\nThe function extracts paragraphs, methods, functions, and classes from the HTML using helper functions `_extract_tags` and `_strip_html`. It then compares the presence of these elements with the claims made in the summary text to detect contradictions.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\reviewer.py:check_hallucinations:dbd588a899f01eda498f02f873a8d983fca403244a6bede65d9a7176be4a5037:dbd588a899f01eda498f02f873a8d983fca403244a6bede65d9a7176be4a5037": "The function `check_hallucinations` analyzes HTML content to detect the presence of hallucination phrases. It takes a string `html` as input and returns a list of detected hallucination terms. The function uses `_extract_tags` to extract paragraph (`<p>`) tags from the HTML, then processes each tag's text by stripping HTML and converting it to lowercase. It checks if any predefined hallucination terms are present in the processed text and appends matching terms to the `findings` list. Finally, it returns the list of detected hallucination phrases.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\reviewer.py:main:2e856d63285b8b1c6313b68d48efd8191242b4c567b3cb1316a25f2a7ade84aa:2e856d63285b8b1c6313b68d48efd8191242b4c567b3cb1316a25f2a7ade84aa": "The `main` function serves as the entry point for reviewing generated HTML documentation. It accepts command-line arguments specifying the directory containing the HTML files and an optional flag to enable automatic fixing of issues in those files. The function uses Python's `argparse` module to parse these arguments, then calls `review_directory` with the provided path and autofix setting before returning 0 to indicate successful execution.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\reviewer.py:review_directory:3ab4736c08c5421ad53dfbb6a3fb4d5b15ec794f60fddb01a91282850ca3f05b:3ab4736c08c5421ad53dfbb6a3fb4d5b15ec794f60fddb01a91282850ca3f05b": "The function `review_directory` iterates through all `.html` files within a specified directory and its subdirectories. For each file, it attempts to review the content using `_review_file`, which takes an optional `autofix` parameter. If an error occurs during the review process, it prints an error message and continues with the next file. The results of the review are printed line by line.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\scanner.py:_is_subpath:7f6a844801deea4f93dd5532710db8caa4a2dd9ecf67fbcf914c847e43302b43:7f6a844801deea4f93dd5532710db8caa4a2dd9ecf67fbcf914c847e43302b43": "This function checks whether a given `path` is either the same as or a subdirectory of another `parent` directory. It uses Python's `Path` object to perform this check by attempting to compute the relative path from `parent` to `path`. If successful, it returns `True`, indicating that `path` is indeed a subpath of `parent`. If a `ValueError` is raised during this process, it means that `path` is not within `parent`, and the function returns `False`.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\scanner.py:fd7e0f952dd35ca841116789b2d99cfc36e1d26a7cf0ee616028fe9532c20347:fd7e0f952dd35ca841116789b2d99cfc36e1d26a7cf0ee616028fe9532c20347": "This module provides a function to recursively discover Python (``.py``) and Objective-C (``.m``) source files within a specified directory. It includes an ignore mechanism based on relative paths, allowing certain directories or files to be excluded from the search. The function returns a list of absolute paths to the discovered source files, sorted alphabetically.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\scanner.py:scan_directory:3f5c14462322b096d60d6132046197dcec396a320dafffc77a64c443f620828a:3f5c14462322b096d60d6132046197dcec396a320dafffc77a64c443f620828a": "The `scan_directory` function recursively discovers Python (``.py``) and MATLAB (``.m``) files within a specified directory. It skips directories listed in the `ignore` parameter. The function returns a list of absolute paths to discovered source files, ensuring that ignored paths are not included in the results.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\setup.py:ef7b23c3468c8130483cd7578c14e977b39b372fd088f0e163b47be196d1291e:ef7b23c3468c8130483cd7578c14e977b39b372fd088f0e163b47be196d1291e": "A Python module that uses the `setuptools` library to define and execute a package setup.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\summarize_utils.py:_summarize:fbb35ec2d2e28b1711eb043a5449f2760634ba108c57bb2fc507a026f1cb14f7:fbb35ec2d2e28b1711eb043a5449f2760634ba108c57bb2fc507a026f1cb14f7": "The function `_summarize` takes a language model client, a response cache, a key, the text to be summarized, and a prompt type as inputs. It attempts to retrieve a cached summary using the provided key. If a cached summary is found, it returns that; otherwise, it generates a new summary using the language model client with the given text and prompt type, caches this new summary under the specified key, and then returns it.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\summarize_utils.py:dfc94899d582f733d44e86f9d4150162786fe35452be561882e6039626bba1de:dfc94899d582f733d44e86f9d4150162786fe35452be561882e6039626bba1de": "This module provides functions for summarizing text using a language model client and caching the results. It includes:\n\n1. `_summarize`: A helper function that summarizes text by calling the LLMClient and caching the result.\n2. `summarize_chunked`: A main function that handles chunking large texts if necessary, then summarizes each chunk and merges them into a single summary.\n\nThe module uses utilities from `cache`, `chunk_utils`, and `llm_client` modules to manage caching, text chunking, and interacting with the language model.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\summarize_utils.py:summarize_chunked:331b15798db47b7698a7736cf0449ec089d4ce6a49d348368673f8d1e3fae209:331b15798db47b7698a7736cf0449ec089d4ce6a49d348368673f8d1e3fae209": "This function, `summarize_chunked`, is designed to summarize a given text by chunking it if necessary. It uses an LLM client for summarization and a response cache to store previously generated summaries. The function handles the following steps:\n\n1. **Tokenization**: It tokenizes the input text using a tokenizer.\n2. **Prompt Template**: It selects a prompt template based on the `prompt_type`.\n3. **Overhead Tokens Calculation**: It calculates the number of tokens used by the system prompt and the empty template, subtracting this from the maximum context tokens to determine how many tokens are available for the text itself.\n4. **Chunking**: If the text is too large to fit within the available tokens, it chunks the text into smaller parts based on a `chunk_token_budget`.\n5. **Summarization of Chunks**: It summarizes each chunk individually and stores the results in a list.\n6. **Merging Summaries**: If there are multiple summaries, it combines them into a single technical paragraph using another recursive function `_merge_recursive`. This function ensures that the combined summary does not exceed the available tokens by recursively merging smaller groups of summaries.\n7. **Error Handling**: The function includes error handling to manage cases where chunking or summarization fails.\n\nThe final result is sanitized and returned as a string.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_cache.py:97b2ae8f04e70da29a7fb5d7cb91652ea871818ccc183154b3320347b5835642:97b2ae8f04e70da29a7fb5d7cb91652ea871818ccc183154b3320347b5835642": "The module defines two functions for testing a response cache. The first function, `test_cache_round_trip`, tests setting and retrieving a value from the cache. It creates a temporary cache file, sets a key-value pair in the cache, and then retrieves it to ensure the value is correctly stored and retrieved.\n\nThe second function, `test_cache_get_missing`, tests retrieving a non-existent key from the cache. It creates an empty cache file and attempts to retrieve a value for a non-existent key, expecting `None` as the result.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_cache.py:test_cache_get_missing:0a7e873d3f059f9f2861a04f52107fb156c6d2736aafd1d4f7a4beb23a03623a:0a7e873d3f059f9f2861a04f52107fb156c6d2736aafd1d4f7a4beb23a03623a": "This function tests the `get` method of a `ResponseCache` object. It creates a temporary directory, initializes a `ResponseCache` instance with a path to a JSON file in that directory, and asserts that calling `get` with a key (\"unknown\" in this case) returns `None`, indicating that the cache does not contain an entry for that key.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_cache.py:test_cache_round_trip:40b799e394e97f4c16f4f5ca6680d8614e5c76d36ca6baafab4238a5602cd607:40b799e394e97f4c16f4f5ca6680d8614e5c76d36ca6baafab4238a5602cd607": "The function `test_cache_round_trip` tests the caching mechanism of a response cache by writing a summary to a cache file and then reading it back to ensure the data is correctly stored and retrieved. It uses a temporary path for the cache file, creates a cache instance, sets a key-value pair in the cache, and then verifies that the value can be retrieved using the same key from a new cache instance created with the same file.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_chunk_utils.py:d2a16b3c3609200d2d6d0ef21f64bf5274294b26300f2f0821797948f0587063:d2a16b3c3609200d2d6d0ef21f64bf5274294b26300f2f0821797948f0587063": "The module defines unit tests for functions `get_tokenizer` and `chunk_text`. The tests verify that the tokenizer encodes and decodes text correctly, that the text is reconstructed from chunks without loss, that markdown headings are split appropriately, and that code blocks are preserved across chunk boundaries.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_chunk_utils.py:test_chunk_text_preserves_code_blocks:985267914d569ccad72f071d6224328aa30f4dc6c050315e6496b56b776a9b9c:985267914d569ccad72f071d6224328aa30f4dc6c050315e6496b56b776a9b9c": "The function `test_chunk_text_preserves_code_blocks` tests the functionality of a text chunking mechanism. It uses a tokenizer to split a given text into chunks while ensuring that code blocks are not broken across chunks. The test checks if any chunk contains the specific Python code block and ensures that each chunk has an even number of backticks, indicating proper preservation of code formatting.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_chunk_utils.py:test_chunk_text_reconstructs_content:87fa445cee3dbfdac0909c9c1d724d66b12155987c11b6e32940b864e10c6931:87fa445cee3dbfdac0909c9c1d724d66b12155987c11b6e32940b864e10c6931": "The function `test_chunk_text_reconstructs_content` tests the functionality of the `chunk_text` method. It uses a tokenizer to split a long string into chunks, ensuring that the original content is reconstructed when the chunks are joined together. The test asserts that the concatenated chunks match the original text and that more than one chunk was created, indicating successful splitting.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_chunk_utils.py:test_chunk_text_splits_markdown_headings:83cf089a5c7be9141e62fd3789f0e6290bbb4b95d02f3c7cfa7f1e4fdc8f5337:83cf089a5c7be9141e62fd3789f0e6290bbb4b95d02f3c7cfa7f1e4fdc8f5337": "This function tests the `chunk_text` function to ensure it correctly splits text into chunks based on markdown headings. It uses a tokenizer obtained from `get_tokenizer()` and specifies a maximum chunk size of 4 tokens. The test asserts that the text is split into two chunks, with each chunk starting with a markdown heading (`# H1` and `# H2`).",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_chunk_utils.py:test_get_tokenizer_roundtrip:d428541dc24465e6cb00ba8ebbbdaba5a1721b4e0ac667b4d1cedfacf6ec68a3:d428541dc24465e6cb00ba8ebbbdaba5a1721b4e0ac667b4d1cedfacf6ec68a3": "This function tests the round-trip functionality of a tokenizer. It retrieves a tokenizer instance using `get_tokenizer()`, encodes a sample text \"hello world\" into tokens, and then decodes those tokens back to text. The assertions ensure that the decoded text matches the original input after encoding and decoding processes.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_docgenerator.py:235674255b56177afff3ad2e8a38479602a043c227a8d379e464d9d6bd17c0c3:235674255b56177afff3ad2e8a38479602a043c227a8d379e464d9d6bd17c0c3": "This module contains unit tests for a Python script that generates documentation from source code using an LLM (Large Language Model). The tests cover various scenarios, including:\n\n1. Skipping invalid Python files.\n2. Generating summaries for classes and functions.\n3. Handling non-UTF8 encoded files.\n4. Summarizing modules without docstrings.\n5. Sanitizing project summaries.\n6. Using README content as a summary.\n7. Cleaning the output directory before generating new documentation.\n8. Splitting long texts into chunks to fit within context token limits.\n9. Recursively chunking text when prompt overhead exceeds available tokens.\n10. Keeping functions atomic during structured chunking.\n11. Splitting large classes by method during structured chunking.\n12. Summarizing methods in subclasses.\n\nThe tests use the `unittest.mock` library to patch dependencies and verify that the main function (`docgenerator.main`) behaves as expected under different conditions.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_docgenerator.py:test_chunking_accounts_for_prompt_overhead:2e6bcbef5878e983717667aae6b1e9bd38eebcf3bd70a47e72850a3d85d3734a:2e6bcbef5878e983717667aae6b1e9bd38eebcf3bd70a47e72850a3d85d3734a": "This function tests the `summarize_chunked` utility by simulating a scenario where the system is prompted to summarize text. It uses a mock object for summarization and calculates the token overhead for the system prompt and template. The function asserts that the summarization method was called more than once, indicating that the text was chunked appropriately to account for the prompt overhead.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_docgenerator.py:test_clean_output_dir:8282c6057e75019f82e6b1813a12524db2459ef3374ac8f8d6c3a7bbdd956352:8282c6057e75019f82e6b1813a12524db2459ef3374ac8f8d6c3a7bbdd956352": "The function `test_clean_output_dir` is designed to test the behavior of a hypothetical `clean_output_dir` function from the `docgenerator` module. It creates a temporary directory structure with files and subdirectories, simulating an output directory for documentation generation. The function then calls `clean_output_dir` on this temporary path.\n\nThe purpose of `test_clean_output_dir` is to ensure that `clean_output_dir` correctly removes files that are considered \"generated\" by the tool (in this case, files containing a specific comment) while preserving other files. After calling `clean_output_dir`, it asserts that the generated file has been deleted (`generated.exists()` returns `False`), but the custom and asset files still exist (`custom.exists()` and `asset.exists()` return `True`). This test helps verify that the function behaves as expected in managing the output directory for documentation generation.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_docgenerator.py:test_generates_class_and_function_summaries:af901adedf01dd0bcd654ca8bad70f5cb2f23dae8a690a851de333f01725c42b:af901adedf01dd0bcd654ca8bad70f5cb2f23dae8a690a851de333f01725c42b": "This function `test_generates_class_and_function_summaries` is designed to test the generation of summaries for classes and functions within a Python project. It creates a temporary directory structure with a Python module containing a class and a function, then invokes the main documentation generation process using a mock language model client. The test asserts that the output HTML files contain the expected summaries for the class and function, as well as the module level summary.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_docgenerator.py:test_handles_class_without_docstring:63a7ca778ed9eccb701db71648db63224e80baae18ebac0029a9b194cd71086f:63a7ca778ed9eccb701db71648db63224e80baae18ebac0029a9b194cd71086f": "The function `test_handles_class_without_docstring` is a unit test for a documentation generation tool. It checks if the tool correctly handles Python classes without docstrings by verifying that the generated HTML output includes a summary for the class.\n\nHere's a breakdown of what the function does:\n\n1. **Setup**:\n- Creates a temporary project directory (`tmp_path / \"proj\"`) and a module file (`mod.py`) within it.\n- The module contains a simple Python class `Foo` without any docstring.\n\n2. **Output Directory**:\n- Specifies an output directory (`tmp_path / \"docs\"`).\n\n3. **Mocking Language Model Client**:\n- Uses the `patch` decorator to mock the `LLMClient` from the `docgenerator` module.\n- Configures the mock client to return a successful ping and predefined summaries for different parts of the project.\n\n4. **Running the Main Function**:\n- Calls the `main` function with the path to the project directory and the output directory as arguments.\n- Asserts that the main function returns 0, indicating success.\n\n5. **Verification**:\n- Reads the generated HTML file (`mod.html`) from the output directory.\n- Asserts that the summary for the class `Foo` is present in the HTML content.\n\nThis test ensures that the documentation generation tool can handle Python classes without docstrings and correctly include summaries in the generated documentation.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_docgenerator.py:test_merge_recurses_when_prompt_too_long:36d89d71cc261a6e76a9843182157b00c7bab46a19bed89e61382537cf629421:36d89d71cc261a6e76a9843182157b00c7bab46a19bed89e61382537cf629421": "This function `test_merge_recurses_when_prompt_too_long` tests the behavior of merging and recursing during documentation generation when the prompt exceeds a certain length. It uses mocks to simulate the summarization process, ensuring that the system handles long prompts by breaking them into smaller chunks and recursively processing each chunk. The test checks if the merging logic is invoked multiple times for docstring prompts, indicating successful handling of large input sizes.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_docgenerator.py:test_project_summary_is_sanitized:1b9cbf4547000cd3dea86e8c174010097fcd55ef7fd8bbaa243d5c54fec1bb85:1b9cbf4547000cd3dea86e8c174010097fcd55ef7fd8bbaa243d5c54fec1bb85": "This function, `test_project_summary_is_sanitized`, tests the process of generating a project summary using the DocGen-LM tool. It creates a temporary project directory with a Python module and an output directory for documentation. The function uses a mock language model client to simulate responses for summarizing modules, projects, functions, and improving function documentation. After running the main function with the specified project and output directories, it checks that the generated HTML file does not contain certain phrases (\"You can run this\" and \"It prints.\") and that the language model was called with the correct arguments for summarizing a project.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_docgenerator.py:test_readme_summary_used:fbc6d6aae3a10251412065ca164ad9dcb20b5fe7a9e6570c6562422240b1cd0c:fbc6d6aae3a10251412065ca164ad9dcb20b5fe7a9e6570c6562422240b1cd0c": "This function `test_readme_summary_used` is designed to test the functionality of a documentation generation tool, specifically focusing on how it handles README files. It creates a temporary project directory with a Python module and a README file, then simulates the execution of the main documentation generation script using a mock language model client.\n\nThe function sets up a mock environment where the language model client is configured to return a summary for any text input, specifically targeting the \"readme\" type. It then runs the main documentation generation function with the project directory and an output directory specified.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_docgenerator.py:test_single_long_partial_is_recursively_chunked:2eacf2a06046d33b55b3eca3113cc8cacba7a62cde53803cb20032462d7d7f3e:2eacf2a06046d33b55b3eca3113cc8cacba7a62cde53803cb20032462d7d7f3e": "The function `test_single_long_partial_is_recursively_chunked` tests the recursive chunking of a long text into smaller parts suitable for summarization. It uses a mock function to simulate the behavior of the actual summarization process, ensuring that the text is split correctly based on token budget and prompt type. The test checks if the number of calls made with the \"docstring\" prompt type is greater than one, indicating successful recursive chunking.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_docgenerator.py:test_skips_invalid_python_file:10f11c16bbcd7c6eb309d4e850fed6e96ec76fe1c4b6a5d32bfb4b6f90ef1f12:10f11c16bbcd7c6eb309d4e850fed6e96ec76fe1c4b6a5d32bfb4b6f90ef1f12": "The function `test_skips_invalid_python_file` is designed to test the behavior of a documentation generation tool when encountering an invalid Python file. It sets up a temporary project directory with a single Python file that contains invalid syntax due to a leading zero in an integer literal (`x = 08`). The function then calls the `main` function of the documentation generator, passing the path to the project directory and specifying an output directory for the generated documentation.\n\nThe test uses a mock object for the language model client (`LLMClient`) to simulate responses. It asserts that the main function returns successfully (exit code 0) and checks that only the index page is generated in the output directory, while no HTML file is created for the invalid Python file.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_docgenerator.py:test_skips_non_utf8_file:e6d66000bb6a39a814f684c13dd492f1d4b041d3cdfbecc37c99457db0b2010b:e6d66000bb6a39a814f684c13dd492f1d4b041d3cdfbecc37c99457db0b2010b": "The function `test_skips_non_utf8_file` tests the behavior of a documentation generation tool when encountering non-UTF-8 encoded files. It creates a temporary project directory with a file that contains non-UTF-8 bytes, mocks an LLM client to simulate successful responses, and then runs the main documentation generation function. The test asserts that the non-UTF-8 file is skipped during processing and that only valid UTF-8 files are included in the output directory.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_docgenerator.py:test_structured_chunker_keeps_functions_atomic:f04b7d946bc336ef3d37daab2d6c5c82764e0a4f35b3fe52822a299c495296b0:f04b7d946bc336ef3d37daab2d6c5c82764e0a4f35b3fe52822a299c495296b0": "This function, `test_structured_chunker_keeps_functions_atomic`, tests the functionality of a structured chunker that processes Python functions. It ensures that each function is treated as an atomic unit during chunking. The test involves creating a temporary file with two functions, parsing it using a Python parser, and then simulating the chunking process with a mock summarization function. The assertions verify that the chunking results in separate chunks for each function, maintaining their atomicity.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_docgenerator.py:test_structured_chunker_splits_large_class_by_method:2a183231b7cb4639fb734de5843239b64af1a7f0b83e05ec3dfd25812c488529:2a183231b7cb4639fb734de5843239b64af1a7f0b83e05ec3dfd25812c488529": "This function tests the `test_structured_chunker_splits_large_class_by_method` function. It creates a Python class with two methods, writes it to a temporary file, and parses it using the `parse_python_file` function from the `parser_python` module. The function then uses a tokenizer and a response cache to simulate summarizing the class methods. It asserts that the number of chunks generated matches the number of methods in the class and that each chunk corresponds to one of the method sources.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_docgenerator.py:test_subclass_methods_are_summarized:2ef220faf82a50a4fa94cfcd051face4c8a213eeb470970528fa745e42ecc72f:2ef220faf82a50a4fa94cfcd051face4c8a213eeb470970528fa745e42ecc72f": "The function `test_subclass_methods_are_summarized` is designed to test the documentation generation process, specifically focusing on subclass methods. It creates a temporary project directory with a nested class structure and uses mocks to simulate interactions with an LLM client and summarization functions. The function asserts that the method of a subclass is included in the calls made to the chunked summarization function during the documentation generation process.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_docgenerator.py:test_summarize_chunked_splits_long_text:b84c748bc1e15486fa6e30097cd566b9d96555e87df21cb40ef395b0672982a9:b84c748bc1e15486fa6e30097cd566b9d96555e87df21cb40ef395b0672982a9": "The function `test_summarize_chunked_splits_long_text` tests the `summarize_chunked` function by mocking its behavior to return a summary. It uses a tokenizer, a cache, and patches the `_summarize` method to ensure it is called multiple times during the execution of the test. The test checks if the `_summarize` method is called more than once, indicating that the long text has been successfully chunked and summarized.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_docgenerator_subclasses.py:77a42c49a04297507d96ac281add639b0c5692b2d65f55a79c7ca6a88ffafbb8:77a42c49a04297507d96ac281add639b0c5692b2d65f55a79c7ca6a88ffafbb8": "The module defines a test function `test_subclass_docs_and_method_summary` that uses the `unittest.mock.patch` decorator to mock an `LLMClient` class from the `docgenerator` module. It sets up a temporary project directory with a Python file containing a subclass and a method, then calls the `main` function from `docgenerator` with the project directory path and an output directory path. The test asserts that the return value of `main` is 0, indicating success. It also checks that the generated HTML file contains summaries for the class and method, as specified by the mock client's side effect.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_docgenerator_subclasses.py:test_subclass_docs_and_method_summary:e00b25947d3da2436aae6f0f82602de49a96659213c49dfb932f0936f27ac51c:e00b25947d3da2436aae6f0f82602de49a96659213c49dfb932f0936f27ac51c": "This function `test_subclass_docs_and_method_summary` is designed to test the generation of documentation for subclasses and methods within a Python project. It uses a temporary directory (`tmp_path`) to create a mock project structure with a nested class `B` inside class `A`, containing a method `m`.\n\nThe function then sets up a mock language model client using `patch` from the `unittest.mock` module, which simulates responses for summarization requests. The `main` function is called with the path to the project directory and an output directory for documentation.\n\nAfter running the main function, the test checks if the return value is 0, indicating successful execution. It then reads the generated HTML file from the output directory and searches for specific strings related to the subclass and method summaries. The presence of these strings confirms that the documentation was correctly generated for the nested class and its method.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:9f0d37bcbc57a013c11fd908528d6ce6ecd27c9db6d5f4746e019d3fcdaf8461:merge0:38f5fbf01eb5baaede70490b20de5ee00eaaa9790708ea6706088a04b0ee1c75": "The module defines several functions and tests for creating documentation summaries, extracting text from files, rendering HTML, and handling different file formats. It includes a fixture creation function `_create_fixture`, a mock language model client `_mock_llm_client`, and various test cases to ensure functionality across Markdown, HTML, and DOCX files. The module also handles the extraction of snippets, code scanning, and evidence mapping for documentation sections.\n\nThe module contains several test functions for a code documentation tool using `pytest` fixtures like `tmp_path`, `monkeypatch`, and `caplog`. It mocks various functions in the `explaincode` module to simulate different scenarios, such as collecting documentation, ranking files, extracting snippets, and interacting with an LLM client. The tests cover categorizing code snippets into sections, filling placeholders in a manual using evidence from code snippets, generating full documentation without scanning code if not needed, triggering code fallback when specific sections are missing, handling the `--no-code` and `--force-code` flags, customizing the title and filename of the output, inserting generated documentation into an existing index file, and ensuring proper insertion of the documentation into a root index file. The tests validate that the tool behaves as expected under various conditions, including mocking external dependencies and handling different user inputs and configurations.\n\nAdditionally, this module contains several test functions for a summarization process, each testing different aspects of the summarization logic, such as chunking, merging, caching, and handling system prompts.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:9f0d37bcbc57a013c11fd908528d6ce6ecd27c9db6d5f4746e019d3fcdaf8461:part0:5516db775b429103a40dd2a03a766cbe0e39e0bdb1b12007edef2db075c1950b": "The module defines several functions and tests for creating documentation summaries, extracting text from files, rendering HTML, and handling different file formats. It includes a fixture creation function `_create_fixture`, a mock language model client `_mock_llm_client`, and various test cases to ensure functionality across Markdown, HTML, and DOCX files. The module also handles the extraction of snippets, code scanning, and evidence mapping for documentation sections.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:9f0d37bcbc57a013c11fd908528d6ce6ecd27c9db6d5f4746e019d3fcdaf8461:part1:48d5e534383e6abde583f21f176a27405bece94f1b5b81cf84364e3c67b29752": "The module contains several test functions for a code documentation tool. It uses `pytest` fixtures like `tmp_path`, `monkeypatch`, and `caplog`. The tests mock various functions in the `explaincode` module to simulate different scenarios, such as collecting documentation, ranking files, extracting snippets, and interacting with an LLM client.\n\nThe tests cover:\n1. Categorizing code snippets into sections.\n2. Filling placeholders in a manual using evidence from code snippets.\n3. Generating full documentation without scanning code if not needed.\n4. Triggering code fallback when specific sections are missing.\n5. Handling the `--no-code` and `--force-code` flags.\n6. Customizing the title and filename of the output.\n7. Inserting generated documentation into an existing index file.\n8. Ensuring proper insertion of the documentation into a root index file.\n\nThe tests validate that the tool behaves as expected under various conditions, including mocking external dependencies and handling different user inputs and configurations.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:9f0d37bcbc57a013c11fd908528d6ce6ecd27c9db6d5f4746e019d3fcdaf8461:part2:6bbe7d26a85f376316a924b9f7e5d33cb08b1ccb650e5cc867902d439ce763e3": "This module contains several test functions for a summarization process. Each function tests different aspects of the summarization logic, including chunking, merging, caching, and handling of system prompts.\n\n- `test_chunking_triggers_multiple_calls_and_logs`: Tests that chunking triggers multiple calls to the client and logs the progress.\n- `test_chunk_edit_hook_applied`: Tests that a post-chunk hook is applied correctly during summarization.\n- `test_parallel_chunk_summarization`: Tests that chunk summarization can be performed in parallel, ensuring it completes within expected time.\n- `test_hierarchical_merge_logged`: Tests that hierarchical merging is logged and behaves as expected.\n- `test_cached_chunks_reused`: Tests that cached chunks are reused when possible, reducing the number of calls to the client.\n- `test_chunking_none_no_llm_calls`: Tests that when chunking is set to \"none\", no LLM calls are made.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:_create_fixture:78d2842289fdfc1508cb9a847472dabe015a5bf7ba6aa6a927455162519b6c18:78d2842289fdfc1508cb9a847472dabe015a5bf7ba6aa6a927455162519b6c18": "The function `_create_fixture` creates a temporary directory structure and files for testing purposes. It generates a nested subdirectory with an HTML file and writes a README.md file containing structured content about the project, including sections for overview, purpose, problem solving, usage instructions, inputs, outputs, system requirements, and examples. Additionally, it creates a sample JSON file with some input data.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:_mock_llm_client:c6956d6a3d192dfb7bd11aca285a349112f8a2faf388508ad7e6c75359b4d251:c6956d6a3d192dfb7bd11aca285a349112f8a2faf388508ad7e6c75359b4d251": "The function `_mock_llm_client` returns an object that simulates a language model client. This mock client has a method `summarize` which takes three parameters: `text`, `prompt_type`, and an optional `system_prompt`. The `summarize` method returns a predefined string formatted using `textwrap.dedent`, providing a simple summary of the project, including its purpose, problem-solving approach, execution instructions, inputs, outputs, system requirements, and examples.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:test_cached_chunks_reused:bab6da5e4d947dc4ed21f2de3d4b6693950736d20907648e86c0970115327d2d:bab6da5e4d947dc4ed21f2de3d4b6693950736d20907648e86c0970115327d2d": "The function `test_cached_chunks_reused` tests the caching mechanism in the documentation generation system. It creates a dummy client with a `summarize` method that records its calls. The function then uses this client to summarize a large text by chunking it automatically, using both a direct call and a cached call. The first call successfully summarizes the text and records three calls (one for each chunk). The second call retrieves the result from the cache without making additional calls, as expected.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:test_chunk_edit_hook_applied:f9b0706887aad54bd1edc8eedd365b58562f05f596dd65309ee3dc18e5ada20d:f9b0706887aad54bd1edc8eedd365b58562f05f596dd65309ee3dc18e5ada20d": "This function `test_chunk_edit_hook_applied` tests the integration of a hook function with the `_summarize_manual` utility. It creates a dummy client that records calls to its `summarize` method and simulates a cache. The function then processes a large text by chunking it, applying an uppercase transformation via a post-chunk hook, and using a custom system prompt for summarization. The test asserts that the final result is \"final\" and that the last call to the dummy client's `summarize` method has its text transformed to uppercase.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:test_chunking_none_no_llm_calls:d19bcd94628c7e152534ebf8f2eacf62543444dc79cd1f3a33ce1103ceaf2db7:d19bcd94628c7e152534ebf8f2eacf62543444dc79cd1f3a33ce1103ceaf2db7": "The function `test_chunking_none_no_llm_calls` tests the behavior of a documentation generation tool when chunking is disabled and no language model calls are expected. It creates a large text file, initializes a mock language model client that records its calls, and then runs the main documentation generation function with specific arguments. The test asserts that the mock language model was called five times and that the first call includes the system prompt containing \"Overview\".",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:test_chunking_triggers_multiple_calls_and_logs:fb5c8e0d16c2d89bb9be3acb0b24fb695c9cfc0787282a3c34b89a42b37e7b6b:fb5c8e0d16c2d89bb9be3acb0b24fb695c9cfc0787282a3c34b89a42b37e7b6b": "This function tests the chunking and summarization process for a given text. It creates two large paragraphs, joins them with newlines, and then uses a dummy client to simulate language model calls. The client records each call it receives, distinguishing between chunking and merging prompts. The function asserts that the final result is \"final\", that three calls were made (two chunking and one merging), and that the system prompts are correctly identified as chunking for the first two calls and merging for the last. Additionally, it checks that output captured by `capsys` includes messages indicating chunk processing and merged response length.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:test_collect_docs_filters:08a78fe25003cbc8974a6f16286bbd27135ea218d163825d097e326e37382b3a:08a78fe25003cbc8974a6f16286bbd27135ea218d163825d097e326e37382b3a": "The function `test_collect_docs_filters` is designed to test the functionality of collecting documentation files while applying filters based on file extensions. It creates a temporary directory structure with various files, including Markdown and text files, some of which are intended to be kept and others skipped. The function then calls `explaincode.collect_docs` with this temporary path and asserts that only the files intended to be kept (those with `.md` extension) are collected, while those intended to be skipped (`.txt`) are not included in the result.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:test_custom_output_directory:2f95f14613cd026ac287b297bdc1e3b72b479a610ef5dde4f7898294d614949b:2f95f14613cd026ac287b297bdc1e3b72b479a610ef5dde4f7898294d614949b": "This function, `test_custom_output_directory`, is designed to test the functionality of generating documentation in a custom output directory. It uses a temporary path provided by `tmp_path` and a monkeypatch to mock an LLM client for testing purposes. The function creates a fixture using `_create_fixture`, sets up an output directory named \"dist\" within the temporary path, and then calls the `main` function with specified arguments to generate documentation. Finally, it asserts that two files, `user_manual.html` and `user_manual_evidence.json`, exist in the custom output directory, indicating successful documentation generation.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:test_custom_title_and_filename:01c5b512630efa065cd6a5c0603b060b56c8ff507fa2a1267a4fcfef9a27cb05:01c5b512630efa065cd6a5c0603b060b56c8ff507fa2a1267a4fcfef9a27cb05": "This function tests the generation of documentation with a custom title and filename. It creates a fixture, mocks an LLM client, runs the main function with specified path and title, and asserts that the output file and evidence file exist. The output HTML file contains the specified custom title.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:test_detect_placeholders:142d1277640fbabb3537d9ff7b22e351f6ed5cffa662a1f49b3d5fb0e3962860:142d1277640fbabb3537d9ff7b22e351f6ed5cffa662a1f49b3d5fb0e3962860": "The function `test_detect_placeholders` is designed to test the capability of detecting placeholders within a given text. It takes a string `text` as input, which contains placeholders in the format `[[NEEDS_XXX]]`. The function uses the `explaincode.detect_placeholders` method to identify these placeholders and returns a set of placeholder names found in the text. In this specific test case, the input text includes two placeholders: \"Overview\" and \"Outputs\". The function asserts that the set of missing placeholders matches the expected set containing \"Overview\" and \"Outputs\", indicating that the placeholder detection is working as intended.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:test_docs_index_default_and_injection:3cda5e3134f997ead3bce5e1d5f39924ccc07c323153dc2af5f7b400f8446e85:3cda5e3134f997ead3bce5e1d5f39924ccc07c323153dc2af5f7b400f8446e85": "This function `test_docs_index_default_and_injection` tests the generation of documentation index with default settings and code injection. It creates a temporary directory, sets up a mock language model client, and runs the main documentation generation script with specified options. The test checks if the user manual HTML file and evidence JSON file are created in the output directory. It also verifies that the navigation section of the index.html contains a link to the user manual.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:test_extract_snippets_skips_large_file:0dac960da063cab8d9afb5c69c7a163a5d7fce2c1197d1f3624e60d8cf7cbdb7:0dac960da063cab8d9afb5c69c7a163a5d7fce2c1197d1f3624e60d8cf7cbdb7": "This function tests the `extract_snippets` function from the `explaincode` module. It creates a temporary file named \"big.py\" with 210,000 bytes of data. The function is called with this file as input, setting a maximum file size limit of 200,000 bytes and a time budget of 5 seconds. The test asserts that the big file is not included in the snippets returned by the function. Additionally, it checks that an informational log message indicating the file size exceeds the limit is present in the captured logs.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:test_extract_text_docx_preserves_headings:37e13560322c93744e5027d3eaa5768a1d3b8a70833de8fe961fc191ab4c644d:37e13560322c93744e5027d3eaa5768a1d3b8a70833de8fe961fc191ab4c644d": "The function `test_extract_text_docx_preserves_headings` is designed to test the ability of a hypothetical `explaincode` module to extract text from a DOCX file while preserving headings. It uses the `python-docx` library to create a sample DOCX document with a heading and a paragraph, saves it to a temporary directory, and then attempts to extract the text using the `extract_text` function from the `explaincode` module. The test asserts that the first line of the extracted text is \"# Title\", indicating that the heading has been preserved, and that the text \"Text\" is present in the extracted content.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:test_extract_text_html_preserves_headings_and_code:d59cd78d8565ffb329de582ed542c982a2c7da24d78fe284457c67d6b06ed70e:d59cd78d8565ffb329de582ed542c982a2c7da24d78fe284457c67d6b06ed70e": "The function `test_extract_text_html_preserves_headings_and_code` is designed to test the ability of a hypothetical `extract_text` function from the `explaincode` module to correctly extract and preserve headings (`<h1>`, `<h2>`) and code blocks (`<pre><code>...</code></pre>`) from HTML files. It uses a temporary file path provided by `tmp_path` to create an HTML file named \"page.html\" with specific content including headings and a code block. The function then reads this HTML file, extracts the text using the `extract_text` method, and asserts that the extracted text contains the preserved headings (`# Main`, `## Section`) and the code block (with triple backticks and the code `print('hi')`).",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:test_extract_text_markdown_preserves_headings_and_code:44caf9438ad4b5f8776d793bf7ccf6921ec0df3cdab7307e47633ba62dd65337:44caf9438ad4b5f8776d793bf7ccf6921ec0df3cdab7307e47633ba62dd65337": "This function tests the `extract_text` method from the `explaincode` module to ensure it correctly preserves headings and code blocks when reading Markdown files. It creates a temporary Markdown file with a heading and a Python code block, then reads the content using `extract_text`. The test asserts that the extracted text contains the original heading and code block, verifying that the extraction process maintains the structure of the input Markdown file.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:test_force_code_flag_triggers_code_fallback:1809427e40bd62510daa4814186f20acbd7ed07cdfc8f4ceeb24f0e83b96d5f0:1809427e40bd62510daa4814186f20acbd7ed07cdfc8f4ceeb24f0e83b96d5f0": "This function `test_force_code_flag_triggers_code_fallback` is designed to test the behavior of a documentation generation tool when the `--force-code` flag is used. It sets up a temporary directory, mocks certain functions from the `explaincode` module, and then runs the main function with the specified path and force code flag. The test checks that the mocked functions are called once each, logs the appropriate messages indicating that the code scan was triggered and that no sections were missing, and asserts that the expected log messages are present in the captured output.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:test_full_docs_no_code_scan:1b3bc1d6624e51ac31040b029a83ee0c9c22e3ec8a58ea13fc9d1a80b535e795:1b3bc1d6624e51ac31040b029a83ee0c9c22e3ec8a58ea13fc9d1a80b535e795": "The function `test_full_docs_no_code_scan` is a unit test for a documentation generation process. It uses the `pytest` framework and mocks several functions from the `explaincode` module to simulate the behavior of the actual code during testing.\n\nHere's what the function does:\n\n1. **Setup**:\n- Creates a temporary directory using `tmp_path`.\n- Initializes a tracker dictionary to keep track of how many times certain functions are called.\n- Defines two mock functions: `fake_rank` and `fake_extract`. These mocks increment the tracker values and return predefined results.\n\n2. **Monkeypatching**:\n- Replaces the actual implementations of `LLMClient`, `rank_code_files`, and `extract_snippets` with the mock functions using `monkeypatch`.\n\n3. **Logging Configuration**:\n- Sets the logging level to `INFO` for capturing log messages during the test.\n\n4. **Test Execution**:\n- Calls the `main` function with specific arguments (`--path` pointing to the temporary directory and `--scan-code-if-needed`).\n- Asserts that the `fake_rank` and `fake_extract` functions were not called, indicating that the code scan was skipped.\n- Verifies that the log output contains the strings \"DOC PASS\" and \"Code scan skipped\", confirming that the test passed without performing a code scan.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:test_graceful_missing_docx:4888453f8f65192fa2bb38a739351e3d97a347faf165ef33f7a25e891632181d:4888453f8f65192fa2bb38a739351e3d97a347faf165ef33f7a25e891632181d": "The function `test_graceful_missing_docx` is a test case designed to verify the behavior of the `explaincode` module when the `python-docx` library, which is used for creating and manipulating Word documents, is not available. It uses the `monkeypatch` fixture from the `pytest` framework to temporarily replace the `Document` class with `None` and mock the `LLMClient`. The function then calls the `main` function with a specified path to generate documentation. Finally, it asserts that the output files for the user manual and evidence exist in the temporary directory.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:test_hierarchical_merge_logged:51399103fb8296aa30411e4f9c468d75d4605f04d4ed46bdae3d406a33f6d437:51399103fb8296aa30411e4f9c468d75d4605f04d4ed46bdae3d406a33f6d437": "The function `test_hierarchical_merge_logged` is a unit test for a code summarization process. It uses a mock client with predefined behavior to simulate interactions with a language model, a response cache to store previous results, and logging to capture output. The test constructs a large text input by repeating a string multiple times, simulating a scenario where the summarization process might be applied to a large codebase.\n\nThe function then calls `manual_utils._summarize_manual` with the mock client, cache, and text input. It asserts that the result returned by the summarization function is \"short\", indicating that the summarization process has successfully reduced the input text. Additionally, it checks that the mock client's `calls` list contains more than three entries, suggesting that multiple summarization passes were performed as part of the hierarchical merge process.\n\nFinally, the test reads the captured output from the logging system and asserts that a specific log message \"Hierarchical merge pass\" is present in the output, indicating that the hierarchical merge logic was executed during the test.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:test_html_summary_creation:b441903cd12f9091eced494110f82511824914da09e05bbbeeba5b32769096ae:b441903cd12f9091eced494110f82511824914da09e05bbbeeba5b32769096ae": "",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:test_infer_sections_infers_entries:99cfe87fb9135925a9134a5b8dd8984f16fbe8891d8d630a3b65bea880d693ff:99cfe87fb9135925a9134a5b8dd8984f16fbe8891d8d630a3b65bea880d693ff": "The function `test_infer_sections_infers_entries` tests the `infer_sections` function from the `explaincode` module. It asserts that the returned dictionary contains an \"Overview\" key with the value \"Some context\". For all other keys defined in `REQUIRED_SECTIONS`, it checks that their values end with \"(inferred)\". Finally, it ensures that the string \"No information provided.\" is not present in any of the section values combined.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:test_infer_sections_no_context_defaults:68b5a08146281718943164adfb6bb45f063b11973c1067c9ea9297d18070e342:68b5a08146281718943164adfb6bb45f063b11973c1067c9ea9297d18070e342": "The function `test_infer_sections_no_context_defaults` is designed to test the behavior of a hypothetical module named `explaincode` when it attempts to infer sections from an empty string. The function asserts that if no context is provided (i.e., an empty string is passed), all values in the returned dictionary `sections` are equal to \"No information provided.\"",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:test_insert_into_index:4a5bd3738b9ccfa7475bbbd1260c7b473d7f571eb9a2398d393b61725f7b674a:4a5bd3738b9ccfa7475bbbd1260c7b473d7f571eb9a2398d393b61725f7b674a": "The function `test_insert_into_index` is designed to test the functionality of inserting a new link into an existing HTML index file. It uses temporary directory and monkeypatching for simulation. The test creates a fixture, sets up an output directory with an initial index.html file, mocks an LLMClient, runs the main function with specified arguments, and then checks if the expected link is present in the updated index.html file.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:test_insert_into_root_index:bb0bdf682fa7565781e353d63e70fff1ba2059a6dde7193e7a10cb29c9e62957:bb0bdf682fa7565781e353d63e70fff1ba2059a6dde7193e7a10cb29c9e62957": "This function tests the insertion of a generated user manual into an existing HTML index file. It uses a temporary path to create a fixture, writes an initial HTML structure with a `<nav>` element, and then calls the `main` function with specific arguments to insert the documentation. The test checks if the user manual and evidence files are created in the expected directory, and verifies that the navigation link points to the correct location of the user manual within the index file.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:test_llm_fill_placeholders_per_section_logging:952f0c8bdfc56c7594ddd42dde37a599fcba5c0b5d7bb049b50fb982bac0f373:952f0c8bdfc56c7594ddd42dde37a599fcba5c0b5d7bb049b50fb982bac0f373": "This function `test_llm_fill_placeholders_per_section_logging` is designed to test the functionality of filling placeholders in a manual string with evidence from a dictionary. It uses a dummy class `Dummy` that simulates an LLM client, which summarizes text and replaces placeholders based on section names. The function also uses a response cache and logs the process using `pytest.LogCaptureFixture`. The test asserts that the placeholders are correctly filled and that the logging captures the correct file references used to fill each placeholder.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:test_map_evidence_overview_priority_and_filters:a8775bd1bc0901746a11391e53f0956ececcd4d150f3e14e41feccd1ef33df3e:a8775bd1bc0901746a11391e53f0956ececcd4d150f3e14e41feccd1ef33df3e": "This function, `test_map_evidence_overview_priority_and_filters`, tests the functionality of mapping evidence to sections within a documentation project. It uses a dictionary `docs` that simulates file paths and their corresponding content. The function calls `explaincode.map_evidence_to_sections(docs)` to map these files to sections based on their content.\n\nThe test checks if certain files are excluded from the \"Overview\" section, specifically those under the \"tests\", \"examples\", and \"fixtures\" directories. It also verifies that the first two files in the \"Overview\" section are \"README.md\" and \"docs/guide.md\", and that the third file is \"src/other.md\".",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:test_map_evidence_snippet_limits:7b0625094f874de68f6dcfb79c4e6857d9956d14129ffcfdd2b62ec43969029b:7b0625094f874de68f6dcfb79c4e6857d9956d14129ffcfdd2b62ec43969029b": "This function tests the `map_evidence_to_sections` method from the `explaincode` module. It creates a dictionary of file paths and their corresponding content, where one file contains more lines than the specified maximum snippet length (`MAX_SNIPPET_LINES`). The function then maps evidence to sections and extracts snippets. The test asserts that lines outside the maximum snippet limit are not included in the snippets for the long file, while all lines up to the maximum limit are included. Additionally, it checks that the short file's content is correctly mapped as a single section.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:test_missing_run_triggers_code_fallback_with_limits:4e12351106b408da8f5684b9d1d30de6fc4af0cee434ed0ad82580ab9e0310b7:4e12351106b408da8f5684b9d1d30de6fc4af0cee434ed0ad82580ab9e0310b7": "This function, `test_missing_run_triggers_code_fallback_with_limits`, tests the behavior of a documentation generation system when certain sections are missing. It uses a temporary directory (`tmp_path`) and a mock object (`Dummy`) to simulate the behavior of language model interactions and code extraction. The test ensures that if the \"How to Run\" section is missing, it falls back to using code snippets for instructions. The function also checks that the system correctly handles limits on the number of files and time budget during code extraction.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:test_no_code_flag_skips_code_fallback:cd07a87abb9841c82b25cbdf11d2df6a973c6f2f6778dfd529c75b51b27f2670:cd07a87abb9841c82b25cbdf11d2df6a973c6f2f6778dfd529c75b51b27f2670": "This function `test_no_code_flag_skips_code_fallback` is a test case for the `main` function, which generates documentation. The test checks that when the `--no-code` flag is provided, the code scanning and summarization processes are skipped. It sets up a temporary directory with a README file, mocks the necessary functions to simulate the behavior of the `explaincode` module, and uses `monkeypatch` to replace these functions with dummy implementations that do not perform any actual work. The test then calls the `main` function with the `--no-code` flag and verifies that the code scanning and summarization processes are indeed skipped by checking the values in a tracker dictionary and the log output.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:test_parallel_chunk_summarization:9c606a650affc63fc205960826b786b7bd78e823b84a2c5e59caa2352017fb12:9c606a650affc63fc205960826b786b7bd78e823b84a2c5e59caa2352017fb12": "This function `test_parallel_chunk_summarization` tests the parallel summarization of text using a slow client and a response cache. It creates a large text by repeating a paragraph, simulates a slow server response with a delay, and measures the time taken to summarize the text. The test asserts that the total duration is less than 1.5 times the delay, ensuring that the parallel processing works as expected.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:test_parse_manual_infers_missing_sections:460a24acda483f3c90558aeaf2efd67ae55eb160928ddb7a8245d45df6c60acd:460a24acda483f3c90558aeaf2efd67ae55eb160928ddb7a8245d45df6c60acd": "This function tests the `parse_manual` function from the `explaincode` module. It uses a stub class to simulate the behavior of a language model client, which provides a summary for a given prompt. The test checks if the `Overview` section is correctly parsed and if the `Inputs` section is inferred when no information is provided.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:test_pdf_summary_creation:4190eef188a0029d6258890d026dd0d96a316b7d5408ceed2af74f471520e793:4190eef188a0029d6258890d026dd0d96a316b7d5408ceed2af74f471520e793": "This function `test_pdf_summary_creation` is designed to test the creation of a PDF summary for project documentation. It performs the following steps:\n\n1. Checks if the `reportlab` package is installed. If not, it skips the test.\n2. Creates a fixture using `_create_fixture` with the provided temporary path.\n3. Mocks the `LLMClient` from the `explaincode` module using `_mock_llm_client`.\n4. Calls the `main` function with specified arguments to generate documentation in PDF format.\n5. Asserts that the generated PDF file (`user_manual.pdf`) and evidence JSON file (`user_manual_evidence.json`) exist in the temporary path.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:test_render_html_includes_toc_and_sources_block:c4427cc5abf31dddf792b91b6ddcbbf4d7c490932cb604e9ecc7cd6ef1778304:c4427cc5abf31dddf792b91b6ddcbbf4d7c490932cb604e9ecc7cd6ef1778304": "This function `test_render_html_includes_toc_and_sources_block` is designed to test the rendering of HTML documentation by the `explaincode.render_html` function. It checks if the generated HTML includes a table of contents (TOC) and source code blocks.\n\nThe function starts by defining two sections, \"Overview\" and \"How to Run\", each with empty content. It then creates evidence for these sections, specifying snippets from different files: \"info\" from \"readme.md\" and \"run\" from \"run.py\".\n\nNext, it calls `explaincode.render_html` with the sections and evidence to generate HTML output. The generated HTML is parsed using BeautifulSoup.\n\nThe function asserts that the HTML contains a `<nav>` element with an anchor (`<a>`) linking to the \"Overview\" section. It also checks for the presence of source code blocks (`<div class=\"sources\">`) containing text from both \"readme.md\" and \"run.py\".",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:test_render_html_renders_markdown_headings_and_code:892d404224110528c0bace64c2f7109180ce340b5541efcff810b683c12d45dd:892d404224110528c0bace64c2f7109180ce340b5541efcff810b683c12d45dd": "The function `test_render_html_renders_markdown_headings_and_code` tests the `render_html` function from the `explaincode` module. It creates a dictionary of sections, where each section contains a Markdown heading followed by Python code. The function then renders these sections into HTML using `explaincode.render_html`. The rendered HTML is parsed using BeautifulSoup to check if the Markdown headings and code are correctly converted to HTML elements (`<h1>` for headings and `<pre><code>` for code blocks). The assertions ensure that the title \"Title\" is present as an `<h1>` element and that the Python code `print('hi')` is included within a `<code>` block inside a `<pre>` tag.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:test_scan_code_categorizes_snippets:2494f218a9a8392cdc085e73a18ec7f00b79b514808ec4277404757b21552278:2494f218a9a8392cdc085e73a18ec7f00b79b514808ec4277404757b21552278": "The function `test_scan_code_categorizes_snippets` is a test case designed to verify that the `explaincode.scan_code` function correctly categorizes code snippets based on specified patterns. It uses temporary files and monkeypatching to simulate the behavior of the `collect_docs`, `rank_code_files`, and `extract_snippets` functions from the `explaincode` module.\n\nThe test creates three empty Python files in a temporary directory and sets up mock implementations for the mentioned functions. The `fake_extract` function returns predefined snippets categorized as \"Inputs\", \"Outputs\", and \"How to Run\". When `explaincode.scan_code` is called with these patterns, it should return a dictionary where each key corresponds to a category and the value is another dictionary mapping file paths to their respective snippets.\n\nThe assertions in the test case check that the function correctly categorizes the snippets as expected.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:test_scan_code_skips_non_source_dirs:552fb2bba0aa1b686edc7fe7218d74acb563e7eb9948b9813a116d59c9018168:552fb2bba0aa1b686edc7fe7218d74acb563e7eb9948b9813a116d59c9018168": "This function `test_scan_code_skips_non_source_dirs` is designed to test the behavior of a code scanning utility, specifically focusing on its ability to skip non-source directories during the scan process. The function uses a temporary directory structure with subdirectories for source files (`src`), tests (`tests`), and examples (`examples`). It writes Python scripts into these directories.\n\nThe `monkeypatch.setattr` is used to mock the `collect_docs` function from the `explaincode` module, which is presumably responsible for collecting documentation. The mocked function returns an empty list, indicating that no documentation should be collected.\n\nThe `scan_code` function is then called with parameters specifying the temporary path, a title (\"How to Run\"), and various limits on file handling. The function is expected to scan the directories and collect relevant source files.\n\nThe test asserts that after scanning, only the `src/main.py` file is included in the result under the \"How to Run\" key, indicating that non-source directories (`tests` and `examples`) were skipped during the scan process.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:test_validate_manual_references_flags_missing:59a533de33698d49fb97399ade89c0477c92d04d3f54ebdc61a62777a7ab0ad5:59a533de33698d49fb97399ade89c0477c92d04d3f54ebdc61a62777a7ab0ad5": "This function tests the validation of manual references within project documentation. It creates a temporary directory with a Python file named `exists.py` containing a simple pass statement. The function then defines a dictionary `sections` with an \"Overview\" section that refers to both `exists.py` and another non-existent file `missing.py`. An empty dictionary `evidence` is also provided.\n\nThe function calls `explaincode.validate_manual_references` with the `sections`, `tmp_path`, and `evidence` as arguments. After execution, it asserts that:\n1. The \"Overview\" section now includes a reference to `exists.py`.\n2. The \"Overview\" section includes a reference to `missing.py` with a \"[missing]\" tag.\n3. The `evidence` dictionary contains a list of missing references under the key `missing_references`, specifically including `missing.py`.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_html_writer.py:a1aeaba6fec7461888e75a51cdc213dbeb5d81eaf06741979e1d495b15314fc9:a1aeaba6fec7461888e75a51cdc213dbeb5d81eaf06741979e1d495b15314fc9": "The module defines functions to generate HTML documentation for projects and modules. It includes tests to ensure the HTML output is correct, covering various cases such as rendering summaries, classes, methods, functions, subfunctions, and subclasses in a structured format.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_html_writer.py:test_subclass_rendering:7c34827b1900299fe0705885273b65576c68c0fc9a1ee9c1800312be5525f271:7c34827b1900299fe0705885273b65576c68c0fc9a1ee9c1800312be5525f271": "This function, `test_subclass_rendering`, is designed to test the rendering of subclass information in HTML documentation. It uses a temporary directory (`tmp_path`) to create a mock module data structure representing a Python class hierarchy with nested subclasses and methods. The function then calls `write_module_page` to generate an HTML file for this module, which includes details about the classes and their methods.\n\nThe test checks that the generated HTML contains specific elements:\n- It verifies that `<details>` tags are present, indicating expandable sections in the documentation.\n- It confirms that the class \"B\" is included in the HTML output.\n- It ensures that the method `m` within subclass \"B\" is correctly represented.\n- Finally, it checks that exactly one `<pre><code>` tag is present, which likely contains the source code of the method.\n\nThis function serves as a unit test to ensure that the documentation generation process correctly handles and displays subclass relationships in Python projects.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_html_writer.py:test_subfunction_rendering:2504d9ba9320b74e5d04562108d11c0014fdc4b89c1dfc7a11bb67470483a1e6:2504d9ba9320b74e5d04562108d11c0014fdc4b89c1dfc7a11bb67470483a1e6": "The function `test_subfunction_rendering` is designed to test the rendering of subfunctions within a module's documentation. It takes a temporary path as an argument, which is used for generating and storing the HTML output.\n\nThe function creates a mock module data dictionary that includes a nested structure with an outer function and an inner subfunction. It then calls `write_module_page` with this mock data and the temporary path to generate the HTML documentation.\n\nAfter generating the HTML, the function reads the content of the generated `mod.html` file and asserts that certain elements are present in the HTML output:\n- The presence of `<details>` tags indicates that the subfunction is rendered as an expandable section.\n- The text \"Subfunction: def inner(y)\" confirms that the subfunction's name is correctly displayed.\n- The count of `<pre><code>` tags being two suggests that both the outer and inner functions' source code are highlighted in the HTML output, indicating proper syntax highlighting.\n\nThis test ensures that the documentation generation process correctly handles nested function structures and renders them appropriately in the final HTML output.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_html_writer.py:test_write_index:9a774d91f3b45a7043cbf079831716a9b317d938ab59c054c8b2a34459586a62:9a774d91f3b45a7043cbf079831716a9b317d938ab59c054c8b2a34459586a62": "The function `test_write_index` is designed to test the functionality of writing an index file for project documentation. It takes a temporary path as input and creates an HTML index file with specified links and summaries. The function asserts that the generated HTML contains specific elements such as the generator comment, project summary, module links, and summaries. It also checks that only one summary is rendered in the HTML output.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_html_writer.py:test_write_module_page:12d55589ddd973d7fa2d2ce258f0a14959359be6f8e3fae154df15ca8e6dfc16:12d55589ddd973d7fa2d2ce258f0a14959359be6f8e3fae154df15ca8e6dfc16": "The function `test_write_module_page` is designed to test the generation of a module page for documentation. It takes a temporary path as input and creates a mock module data dictionary with details about classes, functions, and their summaries and docstrings. The function then calls `write_module_page` with this data to generate an HTML file in the specified temporary path.\n\nThe test checks that the generated HTML file contains specific elements such as a project overview link, links to other modules, class and method summaries, and code snippets. It also verifies that the HTML is correctly formatted and includes the expected content from the module data.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_integration.py:e977cba7f0b91bc157a456c9b49e68be4ca45d263b578fcfe7b372ef54d38deb:e977cba7f0b91bc157a456c9b49e68be4ca45d263b578fcfe7b372ef54d38deb": "The module defines two test functions for a documentation generator. The first function, `test_docgenerator_generates_html`, tests the generation of HTML files from Python and MATLAB files in a project directory using a mock LLMClient. It asserts that the correct HTML files are created and contains the expected summary text.\n\nThe second function, `test_static_copied_from_any_cwd`, tests the copying of static files (e.g., style.css) to the output directory regardless of the current working directory. It uses a mock LLMClient and asserts that the static file is correctly copied to the output directory.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_integration.py:test_docgenerator_generates_html:8d5609c62cacb94909d44f6253af855e423d6ae1509f3611b55f875f5d38994e:8d5609c62cacb94909d44f6253af855e423d6ae1509f3611b55f875f5d38994e": "This function, `test_docgenerator_generates_html`, is designed to test the functionality of a documentation generator tool. It creates a temporary project directory with Python and MATLAB files, simulates interactions with a language model using a mock client, and then verifies that HTML output files are generated correctly.\n\nThe function performs the following steps:\n1. Creates a temporary project directory.\n2. Writes a simple Python file (`hello.py`) and a simple MATLAB file (`util.m`) to the project directory.\n3. Sets up a mock client for the language model, which simulates responses to ping and summarize requests.\n4. Calls the `main` function with the project directory path and an output directory path.\n5. Asserts that the return value of the `main` function is 0, indicating successful execution.\n6. Verifies that HTML files for the project, its modules, and functions are created in the output directory.\n7. Reads the content of the generated HTML file for the Python module (`hello.html`) and asserts that it contains a summary string.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_integration.py:test_static_copied_from_any_cwd:b2fe014e83642338adc4f32551329137feac647b33f7f81ffdf57179c94432ff:b2fe014e83642338adc4f32551329137feac647b33f7f81ffdf57179c94432ff": "This function `test_static_copied_from_any_cwd` is designed to test the generation of static HTML documentation for a Python project. It creates a temporary directory structure with a sample Python module, sets up a mock language model client using `monkeypatch`, and then invokes the main documentation generation function `main`. The test asserts that the output directory contains a static CSS file named \"style.css\", indicating successful documentation generation.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_llm_client.py:ff8a0c5e5d3895b53e3efd3ac0badb2dca6ba723a90e55d61bc0a3a56cb89180:ff8a0c5e5d3895b53e3efd3ac0badb2dca6ba723a90e55d61bc0a3a56cb89180": "The module defines a test suite for an `LLMClient` class, which interacts with a language model. It includes tests for the `ping`, `summarize`, and `sanitize_summary` methods of the client. The tests use mocking to simulate HTTP requests and responses, ensuring that the client behaves as expected under various conditions, including successful and failed connections, retries, and error handling. Additionally, it verifies that prompts sent to the language model vary based on the type of content being summarized (e.g., class, function, readme).",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_llm_client.py:test_ping_failure:53a4ff195bd1b2654a6b832b19d6e3b1990d85dcd7af35ad85863839dd9b2674:53a4ff195bd1b2654a6b832b19d6e3b1990d85dcd7af35ad85863839dd9b2674": "This function `test_ping_failure` tests the behavior of an `LLMClient` when a connection error occurs during a ping operation. It uses the `patch` context manager from the `unittest.mock` module to simulate a request exception being raised by the `requests.get` method, which is called within the `client.ping()` method. The function asserts that a `ConnectionError` is raised as expected when attempting to ping the client with a fake URL.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_llm_client.py:test_ping_success:a70528662c36f89429f54d2d2c017bd575641be51c97b69fa0146f11e7b1a4b1:a70528662c36f89429f54d2d2c017bd575641be51c97b69fa0146f11e7b1a4b1": "This function tests the `ping` method of an `LLMClient` class to ensure it returns `True` when a successful HTTP GET request is made. It uses a mock object for the response and patches the `requests.get` function to return this mock object. The test checks that the `raise_for_status` method of the mock response is called once, indicating that no exceptions were raised during the request.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_llm_client.py:test_prompt_varies_by_type:477e7a9b78a614aa66046c2e684eb31a3d1d873bcb9315d909f76dc6bb1ccabb:477e7a9b78a614aa66046c2e684eb31a3d1d873bcb9315d909f76dc6bb1ccabb": "The function `test_prompt_varies_by_type` tests the behavior of an `LLMClient` when summarizing different types of code elements (classes and functions). It uses a mock response to simulate interactions with a language model. The function asserts that prompts for classes and functions are generated differently based on their type, using predefined templates stored in `PROMPT_TEMPLATES`.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_llm_client.py:test_readme_prompt_template_used:30c6fb8e388993907ffa4c01a81922904b75c255956ce34477f5c4d77ce469e1:30c6fb8e388993907ffa4c01a81922904b75c255956ce34477f5c4d77ce469e1": "The function `test_readme_prompt_template_used` tests whether the README prompt template is correctly used when summarizing text with a language model client. It sets up a mock response from an LLMClient, simulating a successful request that returns a JSON object containing a message content \"x\". The function then asserts that the second message in the POST request's JSON payload matches the expected format of the README prompt template applied to the input text \"foo\".",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_llm_client.py:test_sanitize_summary_filters_phrases:9c49fec2f65598f5e349f887dfd3dd7f33bafc46b47f5e54f78a9623c3c731d4:9c49fec2f65598f5e349f887dfd3dd7f33bafc46b47f5e54f78a9623c3c731d4": "",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_llm_client.py:test_summarize_raises_runtime_error_with_message:fec7e9a0bb748732d7d1b837177ad9bcd2cc8bb63ea22b2ea2f0b4f8ad94c871:fec7e9a0bb748732d7d1b837177ad9bcd2cc8bb63ea22b2ea2f0b4f8ad94c871": "The function `test_summarize_raises_runtime_error_with_message` tests the behavior of the `summarize` method in an `LLMClient` class when it encounters errors during HTTP requests. It uses mocking to simulate a scenario where the `requests.post` call raises an `HTTPError` and a subsequent JSON parsing error, causing the server to \"explode.\" The test asserts that a `RuntimeError` is raised with the message \"server exploded\" when calling the `summarize` method under these conditions.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_llm_client.py:test_summarize_retries_and_returns_summary:934825d42b133ee468b116cb79b20c3f88b19f3bff01c3f9548269bdffdecaae:934825d42b133ee468b116cb79b20c3f88b19f3bff01c3f9548269bdffdecaae": "This function tests the `summarize` method of an `LLMClient` class. It mocks an HTTP client to simulate a request failure and a successful response. The test asserts that the `summarize` method retries on failure, waits for 1 second before retrying, and returns the expected summary text.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_manual_utils.py:79194c18898c3be5fd9b77410afeef01c9f0a1405b52a64720962e71b081ca75:79194c18898c3be5fd9b77410afeef01c9f0a1405b52a64720962e71b081ca75": "The module defines two functions: `_count` and `test_chunk_docs_respects_token_limit`, `test_find_placeholders`. The `_count` function calculates the number of tokens in a given text using a tokenizer from the `manual_utils` module. The `test_chunk_docs_respects_token_limit` function tests the `chunk_docs` function from `manual_utils` to ensure it respects a token limit by splitting documents into chunks and verifying their sizes. The `test_find_placeholders` function tests the `find_placeholders` function from `manual_utils` to ensure it correctly identifies placeholders in a text.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_manual_utils.py:_count:6caa8affce45685b1b583fd3be5732eb74a75fe379bb9dd004006b5e5c82ad08:6caa8affce45685b1b583fd3be5732eb74a75fe379bb9dd004006b5e5c82ad08": "Counts the number of tokens in a given text using a tokenizer from `manual_utils`.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_manual_utils.py:test_chunk_docs_respects_token_limit:890811a019a4d1cba519a4aadccc646d25ebad453bdd6f4aded91c5cf3fddfa6:890811a019a4d1cba519a4aadccc646d25ebad453bdd6f4aded91c5cf3fddfa6": "The function `test_chunk_docs_respects_token_limit` tests the `chunk_docs` function from the `manual_utils` module to ensure it respects a specified token limit. It creates a list of three strings, each containing 1000 characters repeated 'a', 'b', and 'c' respectively. The `chunk_docs` function is then called with these documents and a token limit of 2000. The test asserts that the resulting chunks list contains exactly two elements and that the number of tokens in each chunk does not exceed the specified limit.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_manual_utils.py:test_find_placeholders:11b90e5e042b0deb0457297dae28d41f88fbdfd9133eb3ee939bff76c2db30a3:11b90e5e042b0deb0457297dae28d41f88fbdfd9133eb3ee939bff76c2db30a3": "The function `test_find_placeholders` is designed to test the functionality of a method named `find_placeholders` from a module called `manual_utils`. This method is expected to identify and extract placeholder tokens enclosed in double square brackets (`[[ ]]`) from a given text string. The function asserts that the output of `find_placeholders(text)` matches the set of placeholders found in the provided text, which are `\"[[NEEDS_OVERVIEW]]\"` and `\"[[FOO]]\"`.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_parser_matlab.py:d371df41f01bfadecc63c5f1bddb7b77eb2309a17405bffe247ca4a3e17973bd:d371df41f01bfadecc63c5f1bddb7b77eb2309a17405bffe247ca4a3e17973bd": "The module defines two test functions to verify the functionality of a MATLAB file parser. The `test_parse_simple_matlab` function checks if the parser correctly extracts the header and a single function from a simple MATLAB file. The `test_parse_multiple_functions` function tests the parser's ability to handle multiple functions within a MATLAB file, verifying both the presence of all functions and their argument lists.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_parser_matlab.py:test_parse_multiple_functions:a83742dccfcbbc28aa6f016f770e556872b015e23674204aafbe741c7c11c5b4:a83742dccfcbbc28aa6f016f770e556872b015e23674204aafbe741c7c11c5b4": "This function, `test_parse_multiple_functions`, is designed to test the parsing of a MATLAB file containing multiple functions. It creates a temporary file with two MATLAB functions: `compute` and `square`. The function then parses this file using `parse_matlab_file` and asserts that the parsed result contains the correct information about the functions.\n\nSpecifically, it checks:\n- That the header of the file is empty.\n- That there are exactly two functions in the parsed result.\n- That the names of the functions are \"compute\" and \"square\".\n- That the arguments for each function match their definitions: `compute` takes two arguments (`a`, `b`) and `square` takes one argument (`x`).",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_parser_matlab.py:test_parse_simple_matlab:ca48aa88d028b039b439cd7037c48a74c4a047dab0f693d6a998b99dfb2681f4:ca48aa88d028b039b439cd7037c48a74c4a047dab0f693d6a998b99dfb2681f4": "This function tests the parsing of a simple MATLAB file. It creates a temporary file with MATLAB code, then uses `parse_matlab_file` to parse it. The test checks that the header is correctly extracted and that there is one function defined in the file. The function's name and arguments are also verified.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_parser_python.py:0656a74b22ae45e63880587901e7b10ae787467de6bd22083f6803af85bd3957:0656a74b22ae45e63880587901e7b10ae787467de6bd22083f6803af85bd3957": "The module defines several test functions to verify the functionality of a `parse_python_file` function. Each test function creates a temporary Python file with different structures (simple modules, complex signatures, nested classes) and asserts that the `parse_python_file` function correctly parses these structures into a dictionary containing information about modules, classes, methods, and functions.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_parser_python.py:test_class_inside_method:bb29d93ae4c5116f2c6c313957cd2b904cb1a955c8e73f59c8908e3455ef5937:bb29d93ae4c5116f2c6c313957cd2b904cb1a955c8e73f59c8908e3455ef5937": "This function, `test_class_inside_method`, tests the parsing of a Python file containing a class inside another method. It uses a temporary path to create a source file named \"inner.py\" with the specified content. The function then parses this file using the `parse_python_file` function and asserts that:\n1. There is one top-level class (`A`) in the parsed result.\n2. Class `A` has one subclass (`B`).\n3. Subclass `B` has one method named `m`.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_parser_python.py:test_deeply_nested_classes:445f1dd22bd6f89c6aeb0c95504b0dd4f687737acf61dec4e81286ea21af2149:445f1dd22bd6f89c6aeb0c95504b0dd4f687737acf61dec4e81286ea21af2149": "The function `test_deeply_nested_classes` tests the parsing of Python files containing deeply nested classes. It creates a temporary file with nested class definitions and uses the `parse_python_file` function to parse this file. The test then checks if the nested classes are correctly identified and their methods are properly listed.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_parser_python.py:test_parse_complex_signature:17b4f8d70088f169542a4444fc479249bd450c6c38ac8c4b0e86575136ba21a8:17b4f8d70088f169542a4444fc479249bd450c6c38ac8c4b0e86575136ba21a8": "This function `test_parse_complex_signature` is designed to test the parsing of a Python file containing a complex function signature. It uses a temporary directory provided by `tmp_path` to create a sample Python file named `sample.py`. The function writes a specific Python code snippet into this file, which includes a docstring and a complex function definition.\n\nThe function then calls `parse_python_file` with the path of the created file as an argument. This function is expected to parse the Python source code and return a dictionary containing information about the parsed file, including its functions.\n\nIn the test case, it specifically checks the signature of the first function in the parsed result, which should match the string `\"complex(a/, b, *, c: int=1, **kw) -> None\"`. It also verifies that the docstring of the function is correctly extracted and matches `\"Complex function.\"`, and that this docstring is present in the source code.\n\nThe assertions ensure that the parsing functionality works as expected for complex Python function signatures.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_parser_python.py:test_parse_nested_structures:8b43227fd0b3bce2444a988fa3e00d9cd4d74fac0729543f03674dd96cf7236a:8b43227fd0b3bce2444a988fa3e00d9cd4d74fac0729543f03674dd96cf7236a": "This function `test_parse_nested_structures` tests the parsing of nested structures in Python code. It creates a temporary file with a Python script containing nested functions and subclasses, then uses the `parse_python_file` function to parse this file. The test asserts that the parsed result correctly identifies the outer function, its inner function, and the classes and methods within them.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_parser_python.py:test_parse_simple_module:707024e8f826a79ffbba578cf2681216f93a7824b6d8617dcaba595b3821163c:707024e8f826a79ffbba578cf2681216f93a7824b6d8617dcaba595b3821163c": "This function `test_parse_simple_module` tests the parsing of a Python module using the `parse_python_file` function. It creates a temporary file with a simple Python module containing a class and a function, then parses the file to extract information about the module, classes, and functions. The test checks that the parsed data matches the expected values for the module docstring, class name, class docstring, method signature, method docstring, and function details.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_reviewer.py:83233473a3bb44ee0c5e26502caa85ad29205c84af0e40280e3fd12a3f730505:83233473a3bb44ee0c5e26502caa85ad29205c84af0e40280e3fd12a3f730505": "This module defines several functions and tests for a code review tool. It includes:\n\n1. `_make_module`: Creates a temporary module with specified summary and methods, writes an HTML page for it, and returns the path to the HTML file.\n2. `test_assistant_phrasing_detected`: Tests if the assistant phrasing is detected in the module's summary.\n3. `test_contradiction_detected`: Tests if a contradiction is detected when methods are defined but not described.\n4. `test_hallucination_detected`: Tests if a hallucination is detected when the module claims to implement features that are not present.\n5. `test_autofix_removes_phrasing`: Tests if the autofix option removes phrasing from the HTML output.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_reviewer.py:_make_module:45f51efd86860490a82558e4c6f968e2197a5cbf7eca5ac6e7f623f693cee785:45f51efd86860490a82558e4c6f968e2197a5cbf7eca5ac6e7f623f693cee785": "This function `_make_module` generates a module documentation page. It takes a temporary path (`tmp_path`), a summary string, and an optional list of methods as arguments. The function creates a dictionary `data` with keys for the module's name, summary, classes, and functions. If methods are provided, it adds a class named \"Foo\" to the data dictionary with empty docstrings and summaries, and assigns the provided methods to this class. It then writes the module page using the `write_module_page` function, passing the temporary path, data, and a list of tuples specifying the index file and its name. Finally, it returns the path to the generated module HTML file (`mod.html`).",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_reviewer.py:test_assistant_phrasing_detected:4ea3b5588d3482767595943b7508aff81eb539da92c3fac9c4ec95ca20ec102f:4ea3b5588d3482767595943b7508aff81eb539da92c3fac9c4ec95ca20ec102f": "The function `test_assistant_phrasing_detected` is designed to test the detection of assistant phrasing during documentation generation. It creates a temporary module with specific content, runs the main function with the path to this module, and captures the output. The function then asserts that the string \"[ASSISTANT]\" appears in the output and that \"mod.html\" (presumably the name of the generated HTML file) is also present. This test ensures that the system correctly identifies and processes assistant phrasing within the documentation process.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_reviewer.py:test_autofix_removes_phrasing:b2c44fc856cbf689306b53dd50baea2df314b372f2a1ca435d7406f0a71dd704:b2c44fc856cbf689306b53dd50baea2df314b372f2a1ca435d7406f0a71dd704": "This function tests the `--autofix` option of a documentation generation tool. It creates a temporary directory with a Python module containing a specific phrase, runs the tool with the `--autofix` flag on this directory, and then checks if the specified phrase has been removed from the generated HTML file.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_reviewer.py:test_contradiction_detected:9172fbe11ab142960bb61dad16eb94bacd09180ae3de5d3418f74ab0f8611104:9172fbe11ab142960bb61dad16eb94bacd09180ae3de5d3418f74ab0f8611104": "The function `test_contradiction_detected` is designed to test the detection of contradictions during documentation generation. It takes two parameters: `tmp_path`, which is a temporary directory path, and `capsys`, which captures standard output.\n\nThe function creates a module with a single method named \"bar\" but without any docstring or source code. It then calls `_make_module` to create this module in the specified temporary path. After that, it invokes the `main` function with the path of the temporary directory as an argument.\n\nFinally, it reads the captured standard output using `capsys.readouterr().out` and asserts that the string \"[CONTRADICTION]\" is present in the output, indicating that a contradiction was detected during the documentation generation process.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_reviewer.py:test_hallucination_detected:575d573d6b1edcd4451ec48d917538be819a760ea1a9aa83be1af42b26398285:575d573d6b1edcd4451ec48d917538be819a760ea1a9aa83be1af42b26398285": "This function `test_hallucination_detected` is designed to test for the detection of hallucinations during the documentation generation process. It creates a temporary directory, generates a module with specific content using `_make_module`, and then runs the main function with the path to this directory as an argument. The output is captured using `capsys`. Finally, it asserts that the string \"[HALLUCINATION]\" is present in the captured output, indicating that the test has detected a hallucination.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_scanner.py:3ec32c624e4312ae44349511245ebc4be1d33ae9233f8c4ba760f4c5f65f37f1:3ec32c624e4312ae44349511245ebc4be1d33ae9233f8c4ba760f4c5f65f37f1": "The module defines a test suite for the `scan_directory` function from the `scanner` module. It includes three tests:\n\n1. **test_scan_directory_ignore_folder**: Creates a directory structure with files and a subdirectory named \"ignore_me\". Calls `scan_directory` with this path and a list containing \"ignore_me\" to ignore it. Asserts that only non-ignored files are returned.\n\n2. **test_scan_directory_mixed_file_types**: Creates a directory structure with various file types (Python, Objective-C, text). Calls `scan_directory` without ignoring any folders. Asserts that all non-hidden files of supported types are returned.\n\n3. **test_scan_directory_skips_git_folder**: Creates a directory structure including a hidden `.git` folder and its contents. Calls `scan_directory` without ignoring any folders. Asserts that the `.git` folder and its contents are not included in the result.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_scanner.py:create_files:cb94027e7028acfd0df208ac624993de8fc42b65d68d8adc5f2aed20175ccb0e:cb94027e7028acfd0df208ac624993de8fc42b65d68d8adc5f2aed20175ccb0e": "The function `create_files` takes a base directory and a list of relative file paths. It iterates over the list, creating any necessary parent directories for each file using `path.parent.mkdir(parents=True, exist_ok=True)`, and then writes an empty string to each file using `path.write_text(\"\")`.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_scanner.py:test_scan_directory_ignore_folder:8fd087bbdbc64df4a43e60c6f845ceb725b3d27676a4f2c4b47d748f407fd442:8fd087bbdbc64df4a43e60c6f845ceb725b3d27676a4f2c4b47d748f407fd442": "The function `test_scan_directory_ignore_folder` is designed to test the functionality of scanning a directory while ignoring specified subdirectories. It creates a temporary directory with various files and subdirectories, including some that should be ignored. The function then calls `scan_directory` with the path of the temporary directory and a list of directories to ignore. The result is compared against an expected set of file paths, ensuring that only the non-ignored files are included in the output.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_scanner.py:test_scan_directory_mixed_file_types:6edfb89a11d789152971bbf4c1c241f6102ac7171a7d54e708a89901a1053bd6:6edfb89a11d789152971bbf4c1c241f6102ac7171a7d54e708a89901a1053bd6": "The function `test_scan_directory_mixed_file_types` tests the functionality of scanning a directory for files with mixed file types. It creates a temporary directory using `tmp_path`, populates it with various files including Python, MATLAB, and text files, and nested directories containing different file types. The function then calls `scan_directory` with the path to this temporary directory and an empty list as arguments. The expected result is a set of file paths for all Python and MATLAB files found in the directory and its subdirectories. The test asserts that the actual result matches the expected set of file paths, ensuring that the directory scanning works correctly for mixed file types.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_scanner.py:test_scan_directory_skips_git_folder:fda2fe63b4682397d1825bdbea71afdd836a24726b56eb2cd36971c09920bd42:fda2fe63b4682397d1825bdbea71afdd836a24726b56eb2cd36971c09920bd42": "The function `test_scan_directory_skips_git_folder` tests the behavior of a directory scanning utility, ensuring that it skips files and directories within the `.git` folder. It creates a temporary directory with specified files, including those inside a `.git` subdirectory, then scans the directory using the `scan_directory` function. The test asserts that the path to the file outside the `.git` directory is included in the scan results, while no paths containing `.git` are present.",
  "PROJECT:7ccbc41643685004d87ee38085517aca5bf79e7099f28dc21f516eb15acdc90a:7ccbc41643685004d87ee38085517aca5bf79e7099f28dc21f516eb15acdc90a": "This project appears to be a comprehensive tool for generating and managing documentation. It includes modules for caching responses, chunking text, summarizing code, interacting with language models, parsing different programming languages, reviewing generated documentation, scanning directories, and writing HTML output. The system seems designed to handle various aspects of documentation generation, from initial parsing and summarization to final rendering and review.",
  "README:8b9df51e2684c3cfe30847232a448543c2f5ec53ab002b31832c982b5b497aa2:8b9df51e2684c3cfe30847232a448543c2f5ec53ab002b31832c982b5b497aa2": "DocGen-LM generates static HTML documentation for Python and MATLAB projects by analyzing source files with a local LLM. It supports nested functions and subclasses, rendering complex structures as expandable sections in the output. The tool includes both command-line and graphical user interface options for project documentation generation and provides utilities like `explaincode.py` for generating lightweight project summaries with optional code analysis.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\cache.py:ResponseCache:4bf39f0ddf33468e133fc0de74e4b5ffcc04454990de01f6d9556f317e81e88f:bb8c5e04ff12539d13e7ca41ecbd56f704e29527621cb046143ffeb35745f4a7": "The `ResponseCache` class implements a caching mechanism for storing and retrieving language model (LLM) responses associated with stable keys. It initializes by loading existing data from a specified file path, or creating an empty cache if the file does not exist. The class provides methods to generate deterministic keys based on file paths and content, retrieve cached values using keys, and store new key-value pairs while persisting the cache to disk.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\cache.py:__init__:43745bc8db8c413f8bdd1025baf86c5811dd4d11d216c33429f357e23380d42c:88f9b6978596b3597d36126d12c3b8332f91aa85a9e6c6a069cbd7893ecee85c": "The `__init__` method initializes a new instance of the `ResponseCache` class. It takes a file path as an argument and sets it to the `file` attribute. If the file exists, it attempts to read its contents and parse them as JSON into the `_data` dictionary. If the file does not exist or contains invalid JSON, it initializes `_data` as an empty dictionary.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\cache.py:_save:48d4727d4c372d0761d9d3554a4ce1e5f635ed3b2a456d22b1093a024259e471:5cf1431d6e19317d0ff2af3addf96075501d72f9daf2d10d386f639ecdee3a39": "The `_save` method in the `ResponseCache` class writes the current cache data to a file. It converts the cache dictionary (`self._data`) into a JSON string using `json.dumps`, with an indentation of 2 spaces and sorted keys for readability. The method then writes this JSON string to the file specified by `self.file`.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\cache.py:get:4c3c798a96c8faf499ea3b7d153275b2daa3632c5bad67cdaa8bc41677f29309:dc6a07ee9033b9d581cf6cd6a8c97d7cae55bf386301f79cd994bfcdef51a109": "The `get` method in the `ResponseCache` class retrieves a cached value associated with a given key. If the key exists in the cache, it returns the corresponding value; otherwise, it returns `None`.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\cache.py:make_key:7f33bedc8214123e6e8b1a6b93edb81bc1a9c2662365f7ed957ffb8f5b74a2cd:5801d27b674088b69462d75399198d5d67bb5fb23f842d344b6f4aac9a336e3e": "The `make_key` function in the `ResponseCache` class generates a deterministic key based on a file path and its content. It uses SHA-256 hashing to create a unique digest for the content, then combines this digest with the file path using a colon as a separator. This key can be used to store and retrieve cached data associated with specific files and their contents in a consistent manner.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\cache.py:set:862bb00c4bbc26e4ad9edb32eef6f47f2d87e541a40dec697a6ef7db3789a0db:2f4bcd9c856592fc92d6b65279f9521c03817c0d0277279e97841617f207b686": "The `set` method in the `ResponseCache` class stores a value under a specified key and persists this change to disk. It takes two parameters: `key`, which is a string representing the cache key, and `value`, which is also a string representing the data to be stored. After setting the value in the internal `_data` dictionary, it calls the `_save` method to ensure that the updated cache is written back to the disk.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\chunk_utils.py:_split_blocks:dde1263408ab99b2b57ea15a95db5d412f7d87050895af3036c72de19c06c3d0:4421cab0ea388c77d510cd0b324808918f9775bf3caceca8f9322acde54aabfc": "The function `_split_blocks` takes a string of Markdown text and returns a list of blocks, where each block is either a paragraph, a heading, or a code fence. It processes the input line by line, identifying transitions between different types of blocks and collecting lines into appropriate lists. The function handles opening and closing code fences, as well as empty lines and headings prefixed with `#`.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\chunk_utils.py:_split_long_block:47bc2212d3105f18fd5025a98b49ffb85e09140016726cb40d11815f10d4ed35:bb48f6a5c1db26d6a4c663438c349a74d955bc1020a60d49a420bc9d403699b3": "This function `_split_long_block` takes a string `block`, a tokenizer, and an integer `chunk_size_tokens`. It encodes the block into tokens using the provided tokenizer. If the number of tokens is less than or equal to `chunk_size_tokens`, it returns the original block as a single-element list. Otherwise, it calculates an average character length per token and determines a maximum chunk size in characters based on this average. The function then splits the block into chunks of approximately `max_chars` characters and returns these chunks as a list.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\chunk_utils.py:chunk_text:e594aa5045f1b0dda29d3100e96c1a6206af2a2be1a12113b4d03dc17f391058:e557554314c9ac88cc4bd33e21f4ed2a14347bfa83a80823e38dcd80167942e7": "The `chunk_text` function splits a given text into smaller chunks based on the specified number of tokens. It uses a tokenizer to determine the number of tokens in each block and ensures that natural break points like blank lines, Markdown headings, and fenced code blocks are respected. If a single block exceeds the token limit, it falls back to splitting that block by approximate character length. The function returns a list of chunks, each containing roughly `chunk_size_tokens` tokens.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\chunk_utils.py:get_tokenizer:52d642c3c40ea9ec13c3be04949a1f29a39078bc59e1615467a7fa48c342756d:3f7e10569427d9f96c1484bda7fb1b9809eb48b575ede10f4a282287f8297f0f": "The function `get_tokenizer` returns a tokenizer object used for estimating token counts. It first attempts to import and use the `tiktoken` library with the encoding \"cl100k_base\". If successful, it returns this tokenizer. If `tiktoken` is not available or fails, it falls back to using a simple tokenizer that splits text into words and joins them back together. This fallback tokenizer provides basic functionality but may not be as accurate for token counting in complex texts.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\docgenerator.py:_build_function_prompt:13db84a269556b2db3c8cefdb1d2a109f9a8cc130f68a13c9207430981a0b957:8a4516eaefda0c433a10d009761b7ba307092c80be1464c0c03ed048584f8042": "The function `_build_function_prompt` constructs a prompt for summarizing Python functions. It takes the source code of the function, along with optional parameters for class name and summaries of the class and project. The function generates a multi-line string that includes context about the function's location within a class or project, followed by instructions on how to summarize the function based solely on its source code.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\docgenerator.py:_chunk_module_by_structure:ecb6f9a2df645b0bd4faa43d6f62ae8bd2d2d46c1ba09b1dd13b4a3ea35d57fd:58face9a228a01badae5d67d12d116f312c88c67e62651bb06e4f946cea0ce3a": "This function `_chunk_module_by_structure` processes a Python module's parsed structure to create text chunks suitable for documentation. It starts by extracting the module's docstring and adding it to the blocks list if present. Then, it iterates through each class in the module, checking if the class source code is within the specified token limit. If not, it further breaks down the class methods into smaller chunks. For standalone functions, their source code or signature is added directly.\n\nThe function then aggregates these blocks into larger chunks that do not exceed the given token size. It ensures that each chunk ends with a newline for separation and handles cases where a single block exceeds the token limit by splitting it accordingly. Finally, any remaining blocks are added to the chunks list, which is returned as the result.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\docgenerator.py:_rewrite_docstring:612f1488eb0f437dd3b39229b5a111da81cfdb3b5fbe7fc88628fbf75cceee4e:e148a37143ec761f4844cca453b746434aea57b29e45b667bc9326453ddc623a": "This function `_rewrite_docstring` is designed to rewrite the docstring of a Python code item using optional context. It takes several parameters including an LLMClient, ResponseCache, file path, and item dictionary. The function checks if there is source code or a docstring in the item; if not, it prints a warning and returns. If only a docstring exists, it uses it directly. If additional context such as class name, class summary, or project summary is provided, it constructs a prompt using `_build_function_prompt`. The function then generates a unique key based on the file path, item name, and combined content of source code and context. Using this key, it calls `_summarize_chunked` to generate a new docstring, which is sanitized and assigned back to the item's docstring field. If no summary can be generated, it defaults to \"No summary available.\"",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\docgenerator.py:_summarize_class_recursive:236de1e35856b13d5c5d729764706b7db43aa05a84d8b502e330c80007163e8e:d9eb3ee3756066a62b8556e6850319499a9858a74c96850909c899455edaece3": "The function `_summarize_class_recursive` is designed to recursively summarize a class and its methods in a Python or MATLAB project. It takes several parameters including `class_data`, `path`, `project_summary`, `tokenizer`, `client`, `cache`, `max_context_tokens`, and `chunk_token_budget`. The function first summarizes the methods within the class using `_summarize_methods_recursive`. It then constructs a prompt for summarizing the class itself, which includes the class name, project summary, and method summaries. Using this prompt, it fetches or generates a summary of the class's docstring through `_summarize_chunked` and sanitizes it with `sanitize_summary`. The function updates the class data with the new summary and docstring. It also rewrites the docstrings of methods within the class using `_rewrite_docstring`, passing along the updated class summary and project summary. Finally, if the class has subclasses, it recursively calls itself to summarize each subclass.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\docgenerator.py:_summarize_methods_recursive:ac9d0c4de7ab7808a01a4fd15648453b3db2602bcf21b5130bd81993af2dffa6:2e61893e897dc755d2631ad02f582fe0f88fac06b73d879ce7d7c91517399cbc": "The function `_summarize_methods_recursive` is designed to recursively summarize methods within a class and its subclasses. It takes several parameters including `class_data`, which contains information about the class and its methods; `path`, which represents the directory path of the project; `client`, an instance of `LLMClient` for interacting with a language model; `cache`, an instance of `ResponseCache` for caching responses; `tokenizer`, presumably used for tokenization tasks; and `max_context_tokens` and `chunk_token_budget` for managing text chunking.\n\nThe function iterates over each method in the class, constructs a unique key using the path, class name, and method name, and then calls `_summarize_chunked` to generate a summary of the method. The summary is stored back into the method dictionary under both \"summary\" and \"docstring\" keys.\n\nAfter processing all methods of the current class, the function recursively calls itself for each subclass listed in `class_data`, ensuring that all methods across the entire class hierarchy are summarized.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\docgenerator.py:_summarize_module_chunked:1643223a68971aa9faf6442765ad402ef7e4b159c6b33328f649af0b20e6ad41:5b57f9065d92357d6988a1a94bb82311420a4d0ba8797a2a19ce1641f2d9af8b": "This function `_summarize_module_chunked` is designed to summarize a Python module using structure-aware chunking. It takes several parameters including an LLM client, response cache, key prefix, module text, module dictionary, tokenizer, maximum context tokens, and chunk token budget.\n\nThe function first calculates the available tokens for summarization after accounting for overhead from system prompts and template usage. If the module text is within this budget, it directly summarizes the module. Otherwise, it attempts to chunk the module based on its structure using `_chunk_module_by_structure`. If successful, it recursively summarizes each chunk and combines them into a single technical paragraph.\n\nThe process involves:\n1. Calculating available tokens.\n2. Directly summarizing if text fits within budget.\n3. Chunking the module by structure if it doesn't fit.\n4. Summarizing each chunk individually.\n5. Combining summaries using a recursive merging function `_merge_recursive`.\n6. Handling exceptions and printing warnings for failures.\n\nThe final summary is sanitized before being returned.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:Config:0b3ed3eff1c79c43fbe5d931fef9fce219dad2ae4a03975c80a50074ce4a92d9:594733ac4138c0c5ad11ce6e6840136f00c85e7c41a44ed0802b36201d93f5ba": "The `Config` class represents configuration settings parsed from command-line interface arguments. It includes properties such as file paths, output format, title, and various flags controlling behavior like code scanning, chunking, and limits on file size and number.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:_edit_chunks_in_editor:f8b0301b03bad85e7c9abaa4b5991c18ef6118cd8cf07aed6c6910b3cb4614d4:5e56a9afabe955e799da8e661d57a7646758dc1a20a7e7130e0571d2b903e544": "The function `_edit_chunks_in_editor` takes a list of code chunks, each separated by lines containing `---`, and opens them in the user's default editor for optional modification. After editing, it reads the modified content back into memory, discards any empty chunks, and returns the edited chunks as a list of strings.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:collect_docs:bb945a489cde45a908de1a7514c78bdd6cd2b7d7a6f2b0844300bcfdc0721ce7:2ffd16de5ed46a8f5f0c76ed1bfe538f0dc50062f23db630580f2644916bceb1": "The `collect_docs` function takes a directory path (`base`) as input and returns a list of paths to documentation files found within that directory and its subdirectories. It includes specific patterns for Markdown, HTML, text, and document files in the project root and within a `docs` subdirectory. The function ensures that only unique file paths are returned by using a set to track seen files.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:collect_files:620beca0129e51a6f4fcc2573206806ec070bd13eedbe7c215219ec43de616ab:463d1b88ab58cf86fd8d475ad6fff2150c7ec24444c0cb56da25e98849c557f8": "The `collect_files` function collects files from a specified base directory that are relevant for summarization. It starts with a list of default patterns to match common document and data file types, such as Markdown, text, HTML, DOCX, CSV, and JSON files. The function then recursively searches the base directory using these patterns.\n\nIf additional patterns are provided through `extra_patterns`, it includes those in the search as well. To ensure uniqueness, the function filters out duplicate files that have already been collected. It returns a list of unique file paths that match any of the specified patterns.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:detect_placeholders:b1aa4ad4c26084bc80a0edcd186eca74e84e68337cf7646e3165701115edbff8:fdff1ce5bed990e626ba70bb0cf3330d8bfdeaa94cb2aaf798661d83480734a3": "This function `detect_placeholders` takes a string `text` as input and returns a list of section names that are still marked by placeholder tokens. It uses another function `find_placeholders` to identify the placeholder tokens present in the text. The function then filters these tokens against a dictionary `SECTION_PLACEHOLDERS`, which maps section names to their corresponding placeholder tokens. Only those sections whose placeholders are found in the input text are included in the output list.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:extract_snippets:190a1577564f1fe723dffd3043aa1a9aee7e75b1e41871f1585fb88663efd09e:f15f7b97643e4c53c3e83a57410fa06d6834e585169965e150275cc2ae672080": "The function `extract_snippets` processes a list of Python and MATLAB files to extract relevant code snippets. It iterates over the specified files, applying various filters based on file size, elapsed time, and content criteria. For each file, it reads up to a maximum number of bytes and attempts to parse the text as Python source code using the `ast` module. If successful, it extracts docstrings from modules, classes, functions, and async functions, identifying those that may involve I/O operations based on argument names. It also looks for command-line interface (CLI) parser definitions and the main execution block. The extracted snippets are stored in a dictionary with file paths as keys.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:extract_text:6a1a1d5b5f1b7a1f055212b1776cab8d9e2467d6e1c8d4d484a7b24a5f16e71e:4a85f0cc059b83d85966060a1eea000bd53422b57ae7782cdb442722b6e66102": "The function `extract_text` reads and processes the content of a file located at the given `path`. It determines the file type based on its suffix (extension) and extracts plain text accordingly. For HTML files, it uses BeautifulSoup to clean and format the text by converting headings into Markdown-style headers and preserving code blocks. For Markdown files, it simply reads the content. For DOCX files, if the `Document` class from the `python-docx` library is available, it parses the document, converts headings into Markdown-style headers, and extracts plain text while ignoring empty paragraphs. If any other file type or an error occurs during processing, the function returns an empty string.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:infer_sections:e31446b43a924ee14f09d5e45d8d4d6ebb6f8eaad9c52398bef90b23ca8decf6:26aedd73c1f47069cf6290b04255a92eeaa53eda617dc3933ce8f8fe667a8678": "This function `infer_sections` takes a string `text` as input and returns a dictionary where keys are section names and values are the content of those sections. If the input text is non-empty, it places the entire text in an \"Overview\" section and generates placeholder content for other required sections labeled \"(inferred)\". If the input text is empty, it initializes all required sections with a default message indicating no information is provided.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:inject_user_manual:06084988d0cb9c693969314f2021d245c67fedcc54155dbb4b63e95d1905565b:f3eb297b5389751359053ae4aca0e7d913c46e0e40636a88f628b97ad3b096c2": "This function `inject_user_manual` inserts a top-level link to a user manual into an HTML file specified by `index_path`. It uses the BeautifulSoup library to parse the HTML content. The function attempts to find a `<nav>` or `<ul>` element to insert the link into; if neither is found, it defaults to inserting the link at the start of the first element in `<body>` or the document root.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:insert_into_index:fcdc88fdeec4ea010f8fc255fa549d5629137423c661bd44e109c98392be8b2b:0837aea55ee406bfc18408c5a355d8c47461eb910cc1ad8abbd25431dc7cff88": "This function `insert_into_index` appends a navigation entry linking to a specified file into an HTML index file. It reads the existing content of the index file using BeautifulSoup, finds either an unordered list (`ul`) or a navigation element (`nav`), and checks if a link with the given filename already exists. If not, it creates a new anchor tag (`a`) with the provided title and filename, wraps it in a list item (`li`) if necessary, and appends it to the container. Finally, it writes the updated HTML content back to the index file.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:llm_fill_placeholders:330a702c9f3dd95b5c7edb095172a1eb61a81fca8aff56727d1ef0ba18ee0c12:d20fe4d2f5725bbce315a9a7b7d976826e3a8ca2731eabd6faaeaf1ddb130d16": "The function `llm_fill_placeholders` processes a manual text and integrates relevant code snippets into it. It uses an LLM client to update the manual by replacing placeholders with information from provided code snippets. The function handles long snippets by summarizing them before sending them to the model to ensure they fit within the model's context window. It logs the sections filled with their corresponding code files.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:llm_generate_manual:0f95f43b854ffc6472473744104f99f450e9147b69db8e482f123f7c7a104816:d26654943fa1c4d05b52cc11075940ea3bb4982b08888206225be8ad47c65e7f": "The function `llm_generate_manual` takes a dictionary of documentation snippets, an LLM client, a response cache, and an optional chunking strategy as input. It maps the documentation snippets to manual sections, performs an LLM call per section, and assembles the final manual text. The function returns the manual text, a mapping of source files to the sections they contributed, and an evidence map capturing the snippets used for each section.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:map_evidence_to_sections:13af563d940f9970917c13fad73376dff621f0a5c5c07df75350f467e7e4e8d9:e34667ee2bf6214007d2e3cd765b26b18f3715c231e65c180128d128ac9aa577": "The function `map_evidence_to_sections` processes a dictionary of documentation snippets, mapping them to specific sections based on predefined keywords. It returns two dictionaries: one that maps section names to lists of source paths and snippets, and another that maps each source path to the set of sections it contributes to. The function filters out snippets from excluded directories, such as \"tests\", \"examples\", and \"fixtures\". For each snippet, it identifies relevant sections by searching for keywords in both the snippet text and its surrounding lines. It then constructs a snippet by combining the initial line with subsequent non-empty, non-comment, and non-header lines up to a maximum length. The function sorts snippets within each section based on their relevance and length, keeping only the top 10 snippets per section.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:parse_manual:d8abbd408c02c90c320d49de39188e4f8ee179deb26c8a83469e92fdf08895e0:006789af6e7a09cef843ddb16a641967e98e552295f6a2993f8d9c25e104a12d": "The function `parse_manual` takes a string of text and an optional LLMClient object, along with a boolean flag to infer missing sections. It parses the text into structured sections based on lines containing a colon. If required sections are missing and inference is enabled, it uses the language model to generate these sections and marks them as inferred. The function returns a dictionary where keys are section titles and values are their corresponding content.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:rank_code_files:553e36f6009ebd5ff458b66f52e489f2203189b9cf1e0439854e9b093d74840b:88ff8b5c8d1d482fb02322c5fa3de6d119e683aeba4dc8659513782c6a29198a": "The function `rank_code_files` ranks Python, MATLAB, and Jupyter Notebook files under a specified root directory based on simple heuristics. It skips certain directories and considers file paths containing specific keywords or patterns as more relevant. The ranking is determined by a score that increases for paths containing keywords like \"run\", \"main\", etc., and for paths matching given patterns. The function returns a list of `Path` objects representing the files, sorted by their scores in descending order.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:render_html:1e34c0c3e0529b80187ce1aeed64af3edf150f2fff85ab17b9514e88332fa181:ad4b67f68a230da889bf36c745d2a6d92b4bdb5888ba4cc10ca8d4262f10151e": "The `render_html` function generates HTML content based on a dictionary of sections, a title, and an optional evidence map. It processes each section to create HTML headers and paragraphs, using Markdown for rendering if available. If a section is empty or lacks information, it substitutes with evidence snippets from the evidence map. The function also constructs a navigation menu linking to each section. The final output is a complete HTML document with styled sections and navigation.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:scan_code:dc5e83bd14370607a6a0e08c78963f3e6d7c1c1e1f034eb23921f04b138acbaf:90aee619c645387efa6e22803da3d2858c4686319672892fbb7fa9997b10699d": "The `scan_code` function collects source code snippets from a specified base directory, grouped by manual sections. It searches for keywords associated with the provided sections (or all known sections if none are specified) and returns a dictionary mapping section names to dictionaries of relative file paths and their corresponding snippet texts. The function uses various utilities such as `collect_docs`, `extract_text`, `rank_code_files`, and `extract_snippets` to achieve this, applying filters based on file size and time budget.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:slugify:56b753cc068b9b4dfd7434e66aeb05e5cace3253ee4233bde99e635f570ef925:0d1441c2f5b7a7eb318652256cb5089be8e42f023232bc54bf8471906e08d616": "Converts a given string into a filesystem-friendly slug by replacing non-alphanumeric characters with underscores and ensuring the result is lowercase. If the resulting slug is empty, it defaults to \"user_manual\".",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:validate_manual_references:4dcc1956e89c46af60f73fc1bdbfa5b4e8f213becdc09ca3eb57fa12e129f454:289ebeda061417ff55af373b672accbc192e38e4e747fc8a663d3567b015517f": "The function `validate_manual_references` checks for references to files or modules in the provided documentation sections that do not exist within a specified project root directory. It uses regular expressions to identify file-like substrings and compares them against existing files found under the project root. If a reference is not found, it appends \"[missing]\" to the section text. Additionally, if an `evidence_map` is provided, it records each missing reference under the corresponding section title in a list of missing references. The function modifies the input `sections` dictionary in place with updated text and updates the `evidence_map` accordingly when necessary.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:write_pdf:60a25a18a22b89e79d07828ef0e94a203488a0696661f22cdc91ec2ccfa9a32b:09908aa871fd98094e2a2a0c5bfacf87be2dfd0a247415fbc85425bfe278ba38": "The `write_pdf` function takes an HTML string and a file path as input. It checks if the `canvas` module is available; if not, it returns `False`. The function then converts the HTML to plain text, splits it into lines, and uses the `canvas` module to create a PDF document with the specified content at the given path. If successful, it saves the PDF and returns `True`.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:__init__:3b3e8ce86245976f0d82058a94254a8d187fbe202fb7d903c8ac4eba6e4c167e:da5285617fb5cc5bcb5c4220ab1aed389c24c8fb49876ee5d711c995ee96c523": "The `__init__` method initializes a new instance of the `CollapsibleBox` class. It sets up a toggle button with optional text and makes it checkable. The button is styled to have no border, a light gray color, and bold font weight. The arrow type is set to right, and a click event handler (`on_toggled`) is connected to the button's `clicked` signal.\n\nA content widget is created and initially hidden. A vertical layout is set up for the main widget, with zero margins. The toggle button and content widget are added to this layout in that order.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:__init__:9302796bf8bd2bb4cc82421b57d17c45901dd64885343a879b823c5c8f9947f8:f9bfda3d33c2312d61982358fd9de0bd1ffdbb5da0ab07929a12dd2bc9a9b8ac": "The `__init__` method initializes the user interface for the `MainWindow` class. It sets up a PyQt5 window with various components for selecting project and output directories, choosing languages, specifying output formats, and running document generation or explanation commands. The UI includes checkboxes for including private functions and language options, combo boxes for selecting output formats, and buttons to run DocGen and ExplainCode. A log area is provided to display messages during the execution of these commands.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:__init__:d9223145c769f07949a3f41d92bc53fbb3196de6d19bd70c2d099f1aacc8db8b:5fbfb66491d04d5160978d1fd6b132321eedac22027affad6cb781a5d2fd23bf": "The `__init__` method initializes a new instance of the `PathLineEdit` class. It calls the constructor of its superclass and sets the widget to accept drag-and-drop events.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:__init__:dbdf434e8233e8153f1384eab01f77160c4d89559625806be54c6267598cbaa7:a48fe04ee0c84e98704c1689a89a300bf9ae12ebdaf887096169af0c946693c2": "The `__init__` method of the `CommandRunner` class initializes a new instance with a list of commands. It calls the superclass constructor and stores the list of commands in an instance variable named `cmds`.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:_reader:0536983ef99c8b6605d890ec337a4361eea79ee8a53e1d1a7052aa86e8a4ec1c:25b95eb686aa7b93f1752bc2d2548e7527b162855836eaebd103a16bc49dc387": "The `_reader` function reads from a stream character by character, emitting text chunks to an output. It handles carriage returns and newlines to ensure proper progress bar updates in GUI applications. Buffered text is flushed when the stream ends.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:append_log:304f8a05b813962029844e3483a0b1feae7d60bc674330711227466b5d6fa502:7a581439530e9ec09876398baf24e9901912f472f3808aaec0dc86a312f10608": "The `append_log` function in the `MainWindow` class appends text to a log widget. It uses a regular expression to split the input text into parts, handling carriage return characters (`\\r`) by moving the cursor to the start of the line and removing any existing text before inserting new parts. The function ensures that the log widget's vertical scrollbar is always at the bottom after appending text.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:build_docgen_cmd:deb5f4e9cfe6665c972b770d6cdff683bfa7592e1636b7f93bc383c73fcd30c8:82a6916ebf42010cf724941bad5dbbf75376d9c36a4984d4b06394440f55416a": "The `build_docgen_cmd` function constructs a command list for running the DocGen-LM tool to generate static HTML documentation. It starts with the Python interpreter (`pythonw`) and the main script (`docgenerator.py`). It then appends the project directory and output directory specified in the GUI elements `project_edit` and `output_edit`, respectively. If the \"Include Private\" checkbox is checked, it adds the `--include-private` flag to the command. The function also collects selected programming languages from checkboxes (`lang_py_cb` for Python and `lang_matlab_cb` for MATLAB) and appends them as a comma-separated string with the `--languages` flag if any are selected. Finally, it returns the constructed command list.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:build_explain_cmd:435128b77ea5a81ef54ac6c838fae78935eaa1470e0e63f5def19ea8222ee36f:b2c537d55f7120caf7a64e2d3c22519276dab4da0982601a2d9b1d85b2319eed": "The `build_explain_cmd` function constructs a command to run the `explaincode.py` script for generating lightweight project summaries. It collects parameters from the user interface elements such as project path, output directory, and output format. If specified, it also includes additional data for analysis. The function returns a list representing the command that can be executed to perform the documentation generation task.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:dark_style:4c14bd77dfa9f772a4dca78398581e32d99aaac61b9d3945f0513ac40d47182e:5382b8811b79fb6df89249ef6b338b6c2241bbde194b320abf8618131a1df543": "The `dark_style` method in the `MainWindow` class returns a string containing CSS styles for various widgets used in the PyQt5 window. These styles define the appearance of the window and its components, including background colors, text colors, fonts, borders, padding, and hover effects. The style is designed to provide a dark theme with a monochrome color palette, enhancing contrast and readability against a black background.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:dragEnterEvent:024368c570119e2d8c7756702a37c73f412e56395c2c54fa8428fabbb442babb:5a9c3fd4f75b5b1bfea814bf6a930a2b0eed95627f0a1121b5982a32c54e530f": "The `dragEnterEvent` method in the `PathLineEdit` class handles drag-and-drop events by accepting URLs that are dragged onto the widget. If the event contains URLs, it accepts the proposed action to allow the drop operation.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:dropEvent:5857bfdeda642d30476167a4a11f06efe90ee124ab31c01866a03acd3949722b:18d8916653a543e2b65d495a72a71011c2df287285e5cd75cd48c6adb2c3e970": "The `dropEvent` method handles drag-and-drop events in a `PathLineEdit` widget. When a URL is dropped onto the widget, it extracts the local file path from the first URL and sets this path as the text of the widget.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:on_finished:fe9134c88484245b93c69b3e3985f44dadd8d8486c26744ac0485a13f6246103:94df2946485f6230d0f0c3718118933c8f4c7fa364e4591375f2a28acd4af4be": "The `on_finished` method in the `MainWindow` class handles the completion of a process by appending a log message indicating the exit code and disabling the running state of the application.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:on_toggled:41b6de0a980c3aa5a6d0125cdbb234413f54635dad9580fd1e51d079f6611355:17fa3b791681221ada00cf9effd3de4eb8360f1226cc27c648cd15c497d79d0a": "The `on_toggled` method in the `CollapsibleBox` class handles the toggle state of a button and updates the visibility of a content area accordingly. When the toggle button is checked, it sets an arrow icon to indicate that the content is visible (down arrow) and makes the content area visible. If the toggle button is unchecked, it sets an arrow icon to indicate that the content is hidden (right arrow) and hides the content area.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:run:732cf419adda6af32f424936ef43114f307c10fddd030911cdcfc87fef19d854:c252c772861b1ec619e10b0b20690261019a268f0b9feb0c6099ca04d8e9fa83": "The `run` method of the `CommandRunner` class executes a list of commands sequentially. It captures and outputs the standard output and standard error of each command using separate threads to ensure that both streams are read concurrently, allowing for proper progress bar updates in GUI applications. The method handles exceptions gracefully by breaking on non-zero exit codes or exceptions, emitting any errors encountered during execution. Finally, it emits a signal indicating the completion of the run with an exit code.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:run_both:eb5d66ea598268357cf08181cf52791cb0dced0287de61b7dbb3361b8031f917:ab7b111603168e75c2ef3051af11e71d3adbf6fabdae5a714ffb5d27335b573d": "The `run_both` method in the `MainWindow` class clears the log and then runs two commands: one for building documentation using DocGen-LM and another for explaining code.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:run_commands:4ebe293bc63d454c5a50a539d51605fae7377f9788c5ad08569df2ce2901fdc8:e2d6d91e730f816d860c56b64ca25c897d047645736f3ac3c2fd74d641470225": "The `run_commands` method in the `MainWindow` class is designed to execute a list of commands for generating or explaining Python and MATLAB project documentation. It checks if both the project directory and output directory are set; if not, it logs an error message and returns without executing any commands. If the directories are valid, it sets the application state to running, initializes a `CommandRunner` object with the provided commands, connects the runner's output signal to the `append_log` method for logging messages, and connects the finished signal to the `on_finished` method. Finally, it starts the command execution process.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:run_docgen:57bc0d5b5c7c23ed5ea8ec17fe276f18624043dfd7c04703c320facbdae06acb:bff59e3ffa09303216f264e5859053bea393d4e2566c07405eee22365f312c68": "The `run_docgen` method in the `MainWindow` class is responsible for executing the document generation process. It first clears any existing log messages using `self.log.clear()`. Then, it runs a command generated by the `build_docgen_cmd` method and stores it in a list. This list is passed to the `run_commands` method, which presumably executes the commands sequentially.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:run_explain:60633d8ca442aabbc5e9def5644837201d1025986e57bbab1782d6d74692aa8d:6bc41c8ededd297cc7b0cec9806e5dd8bbc53c98961311f5b77473627468bd25": "The `run_explain` method in the `MainWindow` class clears any existing log messages and then executes a command to generate lightweight project summaries using the `explaincode.py` utility. This method is part of the functionality for managing documentation generation, specifically handling the execution of commands related to code summarization.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:select_dir:66bba3d3f1e0f79bbee904f2715e8374ff62f6f48bdbd2e93cb68adfb0f59930:86b3ea2f10cbb46c12e9ee9be6e6891454344ea859e717398cce69c4917e7547": "The `select_dir` method in the `MainWindow` class is designed to open a file dialog for selecting an existing directory. When called, it prompts the user to choose a directory and updates the text of the provided `QLineEdit` widget with the selected directory path if one is chosen. This functionality allows users to specify project or output directories interactively through the graphical interface.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:select_file:3de70860004139f45945768f40425a81a198d3d72039919afe3dd416ac855675:56cc15474db13575b70de399689d832e967ac8c62b5d4100b92eef2ea6053a74": "The `select_file` method in the `MainWindow` class is designed to open a file dialog for selecting data files such as JSON, CSV, or TXT files. When a user selects a file, the path of the selected file is set as the text of the provided `QLineEdit` widget.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:setContentLayout:a36c136120e2c6319b58d09e0ce5f16775baf0c831d29dab21fd004fbd10b6c2:dd8324b373d1767dba9bbb0f7410d76f041323a7d6f87decd86b90e611b2e64f": "The `setContentLayout` method in the `CollapsibleBox` class sets the content layout of an object. It takes a `layout` parameter and assigns it to the `content` attribute's `setLayout` method. This allows for dynamic changes to the layout within the collapsible box, enabling flexibility in how content is organized and displayed.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:set_running:2781083be4f8449cf2553945d45fac28411b1530bb2ead1c026eb66364693837:e37ba8759ec69f06788dd160c1f8acce8441185a9cf5502fb726ed20727f5e65": "The `set_running` method of the `MainWindow` class enables or disables three buttons (`docgen_btn`, `explain_btn`, and `both_btn`) based on a boolean parameter `running`. When `running` is `True`, all buttons are disabled, and when `running` is `False`, all buttons are enabled. This method is likely used to manage the state of user interface elements during the execution of document generation or explanation commands, ensuring that users cannot interact with these controls while a process is ongoing.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\html_writer.py:_highlight:3bbbc063f6b58e633c2b854a16615ec37bbd4f9f0a12b68da302d73c6ab1ab5d:fa3372ca04d6540f0abb146de7bf99b44a4519e41c559aa3142f212e7ac09741": "The `_highlight` function takes a string `code` and a string `language` as input. It uses the Pygments library to highlight the code based on the specified language. If the language is \"matlab\", it uses the MatlabLexer; if \"python\", it uses the PythonLexer; otherwise, it defaults to the TextLexer. The function then formats the highlighted code using HtmlFormatter with no classes and nowrap options. Finally, it wraps the formatted code in `<pre><code>` tags and returns the result.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\html_writer.py:_render_class:a2f2c4334f1fcf43a7c5188d815830a2cbdb06f886f601df642305235b6d3687:cacdb879f5456aab6edbd02a7f2ddbd82630beef3dff6341497341b4dd9bf036": "This function `_render_class` generates HTML parts for a Python class and its subclasses. It takes three parameters: `cls`, which is a dictionary representing the class; `language`, a string indicating the programming language (though it's not used within the function); and `level`, an integer that determines the heading level of the class name in the generated HTML.\n\nThe function starts by creating an empty list `parts` to store HTML elements. It then defines a variable `tag` which is set to an HTML heading tag based on the `level` parameter, ensuring it does not exceed `<h6>`.\n\nIt retrieves the class name from `cls` and appends an HTML header element with the class name to `parts`. If the class has a docstring or summary, it appends a paragraph containing this documentation.\n\nThe function then iterates over any methods associated with the class, calling `_render_function` for each method and appending the resulting HTML parts to `parts`.\n\nNext, it iterates over any subclasses of the current class. For each subclass, it appends an opening `<details>` tag, followed by a summary element containing the subclass name. It then recursively calls `_render_class` on the subclass, appending its HTML parts to `parts`. Finally, it appends a closing `</details>` tag.\n\nThe function returns the list of HTML parts representing the class and its subclasses.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\html_writer.py:_render_function:ba06809fce0a3021fa4f77f308aeb1945646ab7d3c980fd11818a31e112abee0:f28f0d26ca76698cb1d6bda862dcd8fadcc9e68f343db32472ae79b78062c155": "This function `_render_function` takes a dictionary representing a function (`func`), the programming `language`, an optional `level` for HTML headings (default is 3), and an optional `prefix`. It returns a list of HTML strings that represent the function and any nested subfunctions.\n\nThe function starts by creating an HTML heading tag based on the provided `level`, using the function's signature or name as the content. It then adds a paragraph containing the function's summary or docstring, if available. If the function has source code, it calls `_highlight` to format the source code and appends it to the parts list.\n\nFor each subfunction of the current function, it creates an expandable HTML `<details>` element with a `<summary>` tag for the subfunction's signature. It then recursively calls `_render_function` on the subfunction, increasing the heading level by 1, and appends the resulting HTML parts to the main list.\n\nFinally, the function returns the complete list of HTML strings representing the function and its nested subfunctions.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\html_writer.py:write_index:9c90ccf355f4be30280b6a345e7c263da998ccd92c5fafe8a250ff05e9941b4c:a1d6d84089e3c4daf08c859abd6e144abaf9f4cbe2b377ae9c51662ab867e95a": "This function `write_index` generates the content for an `index.html` file in a specified output directory. It takes three required parameters: `output_dir`, `project_summary`, and `page_links`. The optional parameter `module_summaries` allows for additional summaries of modules.\n\nThe function creates the destination directory if it doesn't exist. It constructs navigation links from `page_links` and project summary text, formatting them with HTML. If module summaries are provided, they are included in a list format below the main content. The final HTML is rendered using `_render_html`, which takes the title, description, body, and navigation HTML as arguments. This rendered HTML is then written to `index.html` in the specified output directory.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\html_writer.py:write_module_page:b9ab9edafe758f9cf2f1a5abc173a643acc2af4698b2368ac72f15ec931ea1c3:65a853e1460d5307b922ded64b5564d3c628d896c8e59daab3938c8ad0cdddfd": "This function `write_module_page` generates HTML documentation for a Python or MATLAB module. It takes an output directory, module data, and page links as input. The function creates the necessary directories if they don't exist, constructs navigation items based on provided links, and builds the body of the HTML page by summarizing the module's content, rendering classes, and listing functions. Finally, it writes the generated HTML to a file named after the module in the specified output directory.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\llm_client.py:LLMClient:dfa601b20cf4db8e9418337c45ddf1e6e1a5c6668c152a915397bf43d6b050b2:009ca49135e5578004b3773e87124769f683d1c0f26d61e417667c66d0f69bf5": "- `LLMClient` class provides a thin wrapper for interacting with the LMStudio HTTP API.\n- It includes methods to ping the API and generate summaries using specified prompts.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\llm_client.py:__init__:09c4844e86f09b112a2f6bcbe8ca085d1619dc97a2d554c3a23d6bff19e70760:905b61da9e3e137b16fd7ee5a46b95b55ce37fa661f5c9264898032f29b25614": "Initializes an instance of the `LLMClient` class with a specified base URL and language model. The base URL is set to \"http://localhost:1234\" by default, and the model is set to \"local\". The endpoint for sending requests is constructed using these values.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\llm_client.py:ping:5cb6a1a003e9919e3daae5d03f59d3c2b8b09d383a7b8b62d96c12b793475190:aa1a77f2f9ec78073d5645de83379639bf8f3a34b0e77f9786a21f3aee8ac27e": "The `ping` method checks if the language model API is reachable. It sends a GET request to the base URL with an optional timeout parameter. If the server responds successfully, it returns `True`. If there is any issue during the request, such as a connection error or timeout, it raises a `ConnectionError` with a message indicating that the server cannot be contacted.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\llm_client.py:sanitize_summary:5e35c7dbd6dd01896dbc13ca975ee40316102a589083939897e76324f290ed99:92191cc63f77372d6dbc232f61e3e74c0c75419d3e9b05d0bcdc158d99ce09a5": "",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\llm_client.py:summarize:045bfcd7114389257431e3dcd9204933100337f415707940671464c518969ef1:9528f8944ced88ba526fd07188c02a8afddda48d072ef115ebb2cc076ddf2735": "The `summarize` method in the `LLMClient` class is designed to generate a summary for a given text using a specified prompt type. It uses a template based on the prompt type, formats it with the provided text, and sends a POST request to an endpoint with the formatted prompt and system prompt. The method handles potential errors during the request by retrying up to three times before raising a `RuntimeError` with the error message.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\manual_utils.py:_count_tokens:3e697cc472477019f71dd2816e8a7bc7cdb9864d5aba6edfe988e3527ab0987c:0e582c22bfd6c81b0de29f3b8c150052146844a0f4b6941fd49087c50fc44fa5": "Returns the approximate number of tokens in a given text by encoding it with a tokenizer and counting the resulting list length.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\manual_utils.py:_split_text:baca4a8a6823eb1ce0ca4bffda5e7719b1e05f0deceb9c9c4fa681f061204ace:2b13e33c75b6ddb3c08c5c21221e30adc8bcb78ad83eb4909bdc30b295d47949": "The function `_split_text` is designed to split a given text into manageable chunks based on specified maximum token and character limits. It first splits the text into paragraphs, then iterates through each paragraph, checking if it exceeds the token or character limit. If a paragraph does not exceed the limits, it is added to the current chunk. If it does, any existing chunk is finalized and the new paragraph is processed separately. The function uses regular expressions to identify paragraphs and helper functions `_count_tokens` and `chunk_text` for token counting and further text chunking if necessary. Finally, any remaining content in the current chunk is added to the list of chunks, which is then returned.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\manual_utils.py:_summarize_manual:99b8f29e2c8ffaff85f10ed48bf371344663b94f973aa118a99c957def18d78c:361dd12ae23d56426255ee6a413902459477408bb167fe539b4e3b01303ebbbb": "The `_summarize_manual` function generates a manual summary for the provided text using a specified chunking strategy. It interacts with an LLM client to summarize text and utilizes a response cache to store and retrieve previously summarized content. The function handles different chunking strategies: \"manual\", \"auto\", and \"none\". For \"auto\" and \"manual\" strategies, it splits the text into chunks if necessary, summarizes each chunk, and then merges them back together. It also supports an optional post-chunk hook for further processing of the summarized parts. The function ensures that the final summary does not exceed token or character limits by performing hierarchical merging if needed.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\manual_utils.py:chunk_docs:d40081198d6bce58ed29fa78f7792a332a5757345787d92eb3293fc6123d1f58:1f8b2200ed05e89f754b26bc1f83a97ec3eaa1c53c7e3fd57b4a4781a64caa20": "This function `chunk_docs` takes a list of strings (`docs`) and an integer (`token_limit`) as input. It joins the non-empty strings in `docs`, separating them with double newlines, and then splits the resulting text into chunks that do not exceed `token_limit` tokens or 3 times `token_limit` characters. The function returns a list of these chunks.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\manual_utils.py:find_placeholders:fe4f1d30071b588e3c7dd13d7a0bbbe88eae0b7b23b6465a9add7d55285de20d:5a9c41ac0f7838c38590fc8b64f8f75137cb48a2f664a4e7526cb6ad7a8d317e": "The function `find_placeholders` takes a string `text` as input and returns a set of placeholder tokens. These placeholders are identified using a regular expression defined by `PLACEHOLDER_RE`, which matches tokens enclosed in double square brackets, such as ``[[TOKEN]]``. The function extracts all occurrences of these tokens from the input text and returns them as a set.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\parser_matlab.py:parse_matlab_file:7d3beb4ce0fb2a952ad91b3e30b278723ea2cdd0648a970cbf9f3a95b40938ce:5c05ec1e3627d0e24532e05a7e82b15a564336af16a078936103928c6e3894f4": "The function `parse_matlab_file` reads a MATLAB `.m` file and extracts its basic structure. It returns a dictionary containing the file's header comments and any `function` declarations found. Each function entry includes the function name and a list of arguments. The function uses regular expressions to identify and parse function declarations from the file content.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\parser_python.py:_format_arg:e694d06487de6d785bc93655ffdf4f65ab23da2f58c1cd34897baa5ab3cdb3f1:f5c1927180d9a82ef6032ee19968860c3f53e310b405bae325c4419271b42a75": "Formats a function argument by appending its type annotation, if available.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\parser_python.py:_format_arguments:17395f36271e1396c25d7da2fbef9a072e0d05d34fb6fa0ee255026a07e4a702:d47400b97f050df86fa5e0f9459f1a98f6684e3b7d971eb3d516870ae612c104": "The function `_format_arguments` takes an `ast.arguments` object as input and returns a string representation of the function arguments. It handles positional-only, regular, variable positional, keyword-only, and variable keyword arguments, including their default values if provided. The function constructs a list of formatted argument strings and joins them with commas to form the final output.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\parser_python.py:_format_signature:c77389551cd41ee53a68de29289bab88624d7441859c5ab096359da1b7978b35:c9cfde31ba7d3e857c9c8ac83d9e9b25235c41d88e2cff9f3674e8c4329a74a6": "This function `_format_signature` takes an abstract syntax tree (AST) node representing a function or asynchronous function (`func`) and returns a formatted string signature for that function. The signature includes the function name, its parameters as formatted by `_format_arguments`, and optionally the return type if specified in the AST.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\parser_python.py:_parse_classes:469d3b1cb2b076cb0027b6a6d6b922ae2b5a5d3ebd99102eba3f874e109024e9:bfeec03d6fbf4c4c09a3c61cf9abde58a1e7718251db45e3ecb907fe6ca91aa3": "This function recursively parses all `ClassDef` nodes within a list of AST nodes. It iterates through each node in the input list and checks if it is an instance of `ast.ClassDef`. If so, it calls another function `parse_class` to parse the class and appends the result to the `classes` list. If the node is an instance of `ast.FunctionDef` or `ast.AsyncFunctionDef`, it recursively calls itself with the body of the function as the new set of nodes to parse. The function returns a list of dictionaries, each representing a parsed class.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\parser_python.py:parse_class:66ec229851c679f411f1a0e801be9c3ea348622629e22add5e3bafc122722137:8352efdd45f9656deaf80ce2fd99fa9bf3e181d42c760911ac0886d2f288c246": "This function `parse_class` takes an AST node representing a class definition and the source code as input. It returns a dictionary containing information about the class, including its name, docstring, methods, subclasses, and source code segment. The function iterates through the body of the class node, identifying method definitions (both synchronous and asynchronous) and recursively parsing any nested classes.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\parser_python.py:parse_classes:30bde375c52ba25148cb33c8a12aa43505c00a3ff9864608ed058cb3652a75d1:fa87b1e34abbbe9b16ca1a02eec6d3e67a3ddaa6583797d5d1e1d0ebdfc9a173": "The `parse_classes` function is a public wrapper that calls the private `_parse_classes` function. It takes two parameters: `node`, which is an abstract syntax tree (AST) node, and `source`, which is a string containing the source code. The function extracts the body of the AST node using `getattr(node, \"body\", [])` and passes it along with the source code to `_parse_classes`.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\parser_python.py:parse_function:a841112b0f658117161e7dd5f82ea14f54897518ac9191f12998bc028a5f78cb:60fdbe430fd3a5a61ad1d4836b6a25ce5bb22f87b8d206be85dee198aae2f42f": "The function `parse_function` takes an AST node representing a Python function or asynchronous function and the source code as input. It returns a dictionary containing information about the function, including its name, signature, return type, docstring, source code, subfunctions, and subclasses.\n\n- The function initializes a dictionary `func_info` with keys for the function's name, signature, return type, docstring, source code, subfunctions, and subclasses.\n- It sets the function's name from the node.\n- The signature is formatted using `_format_signature`.\n- The return type is extracted from the node if it exists, otherwise set to `None`.\n- The docstring is retrieved using `ast.get_docstring`.\n- The source code segment corresponding to the function is obtained using `ast.get_source_segment`.\n- It iterates through the body of the function and checks for nested functions or asynchronous functions. If found, it recursively calls `parse_function` on each nested item and appends the result to the `subfunctions` list.\n- Subclasses are parsed from the body of the function using `_parse_classes`, which is then added to the `func_info` dictionary.\n\nThe function returns the populated `func_info` dictionary containing details about the function and its components.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\parser_python.py:parse_python_file:4dd4cd9d8556c87322fed6f318d13e6ccebd0f7142e2f352f8664b5cf0021ee1:08f3f9ea27d229bd32b36d5d3c426423aa1756ef429d3747ccb351ec30423edf": "The function `parse_python_file` reads a Python source file and extracts structured information including the module docstring, classes, and functions. It uses the `ast` module to parse the source code and iterates through the nodes to identify and extract relevant details for each class and function. The extracted information is returned as a dictionary.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\reviewer.py:_is_generated_html:1d341f6817316bf00d4a3c2fea9c7a949cc46e10d039589fda1c518159d32c67:6d48abca382a7294aaeac8813854a5ee887624400872e126ac403a28250d68e1": "The function `_is_generated_html` checks whether a given string `text` appears to be output from DocGen-LM, a tool for generating static HTML documentation. It returns `True` if the text contains specific markers that indicate it was produced by DocGen-LM, such as the phrase \"Generated by DocGen-LM\", an `<h1>` heading titled \"Project Documentation\", and headings for classes and methods formatted as `<h2>` and `<h3>`, respectively.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\reviewer.py:check_assistant_phrasing:83ab738d95de00de1e377d53af1adb0bb0e61e2946a40445b11f6648b94c14a6:f1b43e2f89f2197bc0af7466c4d1a8c8aa079b3fd42ad5aa48d1fea725b0cbe5": "This function `check_assistant_phrasing` analyzes an HTML string to identify and list occurrences of assistant-like phrases. It extracts paragraph tags from the HTML, strips away any HTML formatting, converts the text to lowercase for case-insensitive comparison, and checks each phrase against a predefined list of assistant-like phrases (`ASSISTANT_PHRASES`). If a match is found, it records the exact text and the line number where it appears in the original HTML. The function returns a list of these findings.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\reviewer.py:check_contradictions:c552a1b37e8701a18ea6ab21769de77051ecea20b1ee29fa54d5f885130b54f6:cbd43078b8b91a4f981c05373e1687fe32dc354c5ad9c644fdcc969c85456e66": "The `check_contradictions` function analyzes an HTML string to identify contradictions between the text content and the presence of specific elements. It returns a list of contradiction descriptions.\n\n- **Parameters**:\n- `html`: A string containing HTML content to be analyzed.\n\n- **Returns**:\n- A list of strings, each describing a contradiction found in the HTML.\n\n- **Process**:\n1. Extracts all paragraph (`<p>`) tags from the HTML and converts their text content to lowercase.\n2. Joins the first two paragraphs into a summary text.\n3. Extracts headers (`<h3>`) that start with \"Method:\", \"Function:\", and \"Class:\".\n4. Checks for contradictions:\n- If the summary text states \"no methods\" but method headers are found, it appends a description of this contradiction.\n- If the summary text states \"no functions\" but function headers are found, it appends a description of this contradiction.\n- If the summary text states \"no classes\" but class headers are found, it appends a description of this contradiction.\n5. Returns the list of contradictions.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\reviewer.py:check_hallucinations:495e6377d7b0ce953ef20d34eb9b698edfbf4f35b6cb0756b4d0d6f6f20fdcec:dbd588a899f01eda498f02f873a8d983fca403244a6bede65d9a7176be4a5037": "The function `check_hallucinations` analyzes an HTML string to detect the presence of hallucination phrases. It returns a list of detected terms that match predefined hallucination terms. The function iterates over paragraph tags (`<p>`) in the HTML, strips out any HTML tags, converts the text to lowercase, and checks for the presence of each hallucination term. If a term is found, it is added to the list of findings.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\scanner.py:_is_subpath:2c52aae2a76851771edb0a17ff3d8541fd537c15cfe490ca2b7d6229b7de7cd9:7f6a844801deea4f93dd5532710db8caa4a2dd9ecf67fbcf914c847e43302b43": "The function `_is_subpath` checks whether a given `path` is a subpath of another `parent` path. It returns `True` if `path` is equal to or inside `parent`, and `False` otherwise. This is determined by attempting to calculate the relative path from `parent` to `path`. If successful, it means `path` is indeed a subpath of `parent`; if a `ValueError` is raised during this calculation, it indicates that `path` is not a subpath of `parent`.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\scanner.py:scan_directory:6f40516c6c3dc239c92973db36e87e11d5bd4fe043b9dbaf87ce672a5d9fa4d0:3f5c14462322b096d60d6132046197dcec396a320dafffc77a64c443f620828a": "The `scan_directory` function recursively discovers Python (``.py``) and MATLAB (``.m``) files under a specified base directory. It ignores paths listed in the `ignore` parameter, which can include both directories and specific files. The function returns a list of absolute paths to discovered source files, sorted alphabetically.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\summarize_utils.py:summarize_chunked:246827e806131cf8d63d1e61bbc2cf5587834d4dc6ab1d7742d74b3171f4df83:331b15798db47b7698a7736cf0449ec089d4ce6a49d348368673f8d1e3fae209": "The function `summarize_chunked` is designed to summarize large blocks of text by breaking them into smaller chunks if necessary. It uses a language model client (`LLMClient`) and a response cache (`ResponseCache`) to store and retrieve summaries efficiently. The function handles the following steps:\n\n1. **Tokenization**: It tokenizes the input text using a tokenizer.\n2. **Prompt Construction**: Constructs a prompt based on the provided `prompt_type` or a default template.\n3. **Available Tokens Calculation**: Calculates the available tokens for summarization after accounting for overhead from the system prompt and template.\n4. **Chunking**: If the text is larger than the available tokens, it attempts to chunk the text into smaller parts that fit within the token budget.\n5. **Summarization of Chunks**: For each chunk, it generates a summary using the language model client and caches the result.\n6. **Merging Summaries**: Combines the summaries of individual chunks into a single technical paragraph by recursively merging them if necessary.\n7. **Error Handling**: Includes error handling for chunking, summarization, and merging processes to ensure robustness.\n\nThe function ensures that the final summary is within the token limit and handles potential errors gracefully by logging warnings and using fallback mechanisms."
}