{
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\cache.py:2e37ab4b52e9489ed2b2dc8e686dc29df25416d04f5b423c47ba2cc9aecf698c:2e37ab4b52e9489ed2b2dc8e686dc29df25416d04f5b423c47ba2cc9aecf698c": "A simple on-disk cache for LLM responses. Implements methods to initialize the cache from a file, generate deterministic keys based on file paths and content, retrieve cached values, store new values with persistence to disk, and save the current state of the cache to a file.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\cache.py:ResponseCache:__init__:919483e1ff4b05cae685fcac27aa9458bc309d42dd717af59b0942962ccdf4e4:919483e1ff4b05cae685fcac27aa9458bc309d42dd717af59b0942962ccdf4e4": "Initializes an object with a file path. If the file exists, reads its content as JSON and stores it in `_data`. If the file does not exist or is not valid JSON, initializes `_data` as an empty dictionary.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\cache.py:ResponseCache:_save:d6c96e0258c810e9fec48856af580533cfc0aa8f13ea666bb1d396aa4abe5e41:d6c96e0258c810e9fec48856af580533cfc0aa8f13ea666bb1d396aa4abe5e41": "Saves data to a file using JSON format. The data is formatted with an indentation of 2 spaces and sorted keys. The file is written in UTF-8 encoding.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\cache.py:ResponseCache:c53602a52f74d448301da4454ff65379627902f6be563c671fb01fb67f078943:c53602a52f74d448301da4454ff65379627902f6be563c671fb01fb67f078943": "The `ResponseCache` class manages caching of responses from an LLM based on file paths and content. It provides methods for initializing with a cache file, generating deterministic keys using SHA-256 hashing, retrieving cached data, storing new data, and persisting changes to disk in JSON format.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\cache.py:ResponseCache:get:eeb84b4591575a8ed2767f4abac56f1f2dd0697e81322599734b8b31e94ddcce:eeb84b4591575a8ed2767f4abac56f1f2dd0697e81322599734b8b31e94ddcce": "Returns the cached value associated with a given key if it exists in the cache. If the key is not found, returns `None`.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\cache.py:ResponseCache:make_key:4f63c9f618b20a79035ed49cae07b9b800a46f352498e23dc8700f47c38fe96d:4f63c9f618b20a79035ed49cae07b9b800a46f352498e23dc8700f47c38fe96d": "Function `make_key` takes two parameters: `file_path` (a string) and `content` (a string). It returns a deterministic key by concatenating the file path with the SHA-256 hash of the content, both encoded as UTF-8.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\cache.py:ResponseCache:set:0bc8af7637662ae14e3eca8604a4d7155ff442d423955a243d6b586ffee8d8ba:0bc8af7637662ae14e3eca8604a4d7155ff442d423955a243d6b586ffee8d8ba": "Stores a value under a specified key in an internal data structure and persists the changes to disk.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\chunk_utils.py:6c5fb52965b9c830534a1a0e867741ffe867c9e43e8bfc85e5073585b38f3c88:6c5fb52965b9c830534a1a0e867741ffe867c9e43e8bfc85e5073585b38f3c88": "The module provides utility functions for tokenization and text chunking. It includes:\n\n1. `get_tokenizer()`: Returns a tokenizer object used for estimating token counts, defaulting to a simple character-based tokenizer if `tiktoken` is not installed or fails.\n\n2. `_split_blocks(text: str) -> List[str]`: Splits Markdown text into paragraphs, headings, and fenced code blocks.\n\n3. `_split_long_block(block: str, tokenizer, chunk_size_tokens: int) -> List[str]`: Fallback splitter that splits a block by approximate character length if it exceeds the specified token size.\n\n4. `chunk_text(text: str, tokenizer, chunk_size_tokens: int) -> List[str]`: Splits text into chunks roughly of the specified token size, honoring natural break points like blank lines, Markdown headings, and fenced code blocks. Falls back to character-based splitting for blocks exceeding the token size.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\chunk_utils.py:_split_blocks:9815324cad488edaf3bc42e36b508da87afc1dc018c4cdf39a81af233bd5a79b:9815324cad488edaf3bc42e36b508da87afc1dc018c4cdf39a81af233bd5a79b": "The function `_split_blocks` takes a string of Markdown text and splits it into paragraphs, headings, and code blocks. It processes the text line by line, identifying and separating different types of content based on specific markers like paragraph breaks, heading prefixes (`#`), and code block fences (```). The resulting list contains non-empty blocks of text, each representing a distinct type of Markdown element.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\chunk_utils.py:_split_long_block:b292ad755883833303f341843a3089b972947d1d32694b290ac7710eb80102f5:b292ad755883833303f341843a3089b972947d1d32694b290ac7710eb80102f5": "This function `_split_long_block` takes a string `block`, a tokenizer, and an integer `chunk_size_tokens`. It encodes the block using the tokenizer and checks if the length of the tokens is less than or equal to `chunk_size_tokens`. If so, it returns the original block as a single-element list. Otherwise, it calculates an average character size based on the token count and chunk size, ensuring at least one character per chunk. It then splits the block into chunks of characters up to `max_chars` in length and returns these chunks as a list.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\chunk_utils.py:chunk_text:1a939eb51fa3d82f1487fc249c307d4b7fbab316a801d3471b7eae01cf0f6726:1a939eb51fa3d82f1487fc249c307d4b7fbab316a801d3471b7eae01cf0f6726": "The function `chunk_text` splits a given text into chunks of approximately specified token size. It uses a tokenizer to determine the number of tokens in each block and ensures natural break points such as blank lines, Markdown headings, and fenced code blocks are respected. If a single block exceeds the token limit, it falls back to splitting that block by approximate character length. The function returns a list of chunks.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\chunk_utils.py:get_tokenizer:dd5bb0463be79f85832d5d12ddfb54f4889201e595a303e66f3edcb342697879:dd5bb0463be79f85832d5d12ddfb54f4889201e595a303e66f3edcb342697879": "The function `get_tokenizer` returns a tokenizer object used for estimating token counts. It first attempts to import and use the `tiktoken` library with the encoding \"cl100k_base\". If successful, it returns this tokenizer. If `tiktoken` is not available or fails, it tries to use the encoding for the \"gpt-3.5-turbo\" model. If both attempts fail, it prints a warning message and returns a simple tokenizer that splits text into tokens by whitespace and joins them back together. This fallback tokenizer provides approximate token counts when precise tokenization is not available.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\docgenerator.py:_build_function_prompt:60df5102ec1d9f381e8a8991884bd7692acfb83c856d2727cf6965036a5e3ff0:60df5102ec1d9f381e8a8991884bd7692acfb83c856d2727cf6965036a5e3ff0": "This function, `_build_function_prompt`, constructs a prompt for summarizing a given Python function's source code. It enriches the prompt with context from the class name, class summary, and project summary if provided. The prompt is designed to guide an LLM in generating a concise documentation summary of the function based solely on its source code.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\docgenerator.py:_chunk_module_by_structure:b105b4a4deddf1afd2cd7fa33dfbf788f82840d6802fb2a2a0e8b48f0260e511:b105b4a4deddf1afd2cd7fa33dfbf788f82840d6802fb2a2a0e8b48f0260e511": "This function `_chunk_module_by_structure` takes a dictionary representing a module, a tokenizer, and an integer `chunk_size_tokens`. It returns a list of text chunks for the module based on its parsed structure. The function first extracts the module's docstring if available and adds it to the blocks list. Then, it iterates through classes, methods, variables, and functions within the module, adding their source code to the blocks list. If a block exceeds the `chunk_size_tokens`, it is further chunked using another function `chunk_text`. The function then combines these blocks into chunks that do not exceed the specified token size, ensuring that each chunk contains complete structures or individual elements from the module.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\docgenerator.py:_rewrite_docstring:247b5cfa20c44dfeccfd2d8886528949ac6a46879ecb7f73f00ed861276ef743:247b5cfa20c44dfeccfd2d8886528949ac6a46879ecb7f73f00ed861276ef743": "The function `_rewrite_docstring` rewrites the docstring of a code item using optional context provided by class and project summaries. It constructs a prompt based on the source code, optionally including class and project information, and then uses an LLM client to generate a new docstring summary. The result is cached and sanitized before being updated in the `item` dictionary.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\docgenerator.py:_summarize:067869e6981d719df05e7d89bb5d1042741300b014fbb66ee1aef458eb9ad289:067869e6981d719df05e7d89bb5d1042741300b014fbb66ee1aef458eb9ad289": "The function `_summarize` takes an `LLMClient`, a `ResponseCache`, a `key`, a `text`, and a `prompt_type` as arguments. It checks if the summary for the given `key` is already cached. If it is, it returns the cached summary. Otherwise, it uses the `client` to generate a summary of the `text` based on the `prompt_type`. The generated summary is then stored in the cache under the provided `key` and returned.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\docgenerator.py:_summarize_class_recursive:cb8f024ef06e55f03d8deba9d874220627849e2723289340e2a45bd0b9591568:cb8f024ef06e55f03d8deba9d874220627849e2723289340e2a45bd0b9591568": "This function `_summarize_class_recursive` is designed to recursively summarize a class and its members within a Python project. It takes several parameters including the class data, path, project summary, tokenizer, LLM client, response cache, maximum context tokens, and chunk token budget.\n\nThe function performs the following tasks:\n1. Recursively summarizes all members (methods and variables) of the class using `_summarize_members_recursive`.\n2. Constructs a prompt for summarizing the class based on its name, project summary, methods, and variables.\n3. Caches and retrieves a summary for the class using the provided LLM client and cache.\n4. Sanitizes the retrieved summary.\n5. Updates the class data with the new summary and docstring.\n6. Rewrites the docstrings of the class and its members (methods and variables) using `_rewrite_docstring`.\n7. Recursively calls itself for each subclass of the current class.\n\nThis function is part of a larger system that processes Python projects to generate documentation by summarizing code structures and interacting with an LLM to enhance summaries.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\docgenerator.py:_summarize_members_recursive:6fdaef32ec19a2a34aae05dd7aea562d22390ba92c611c62cd14bc349bab57fe:6fdaef32ec19a2a34aae05dd7aea562d22390ba92c611c62cd14bc349bab57fe": "This function recursively summarizes methods and variables within a class, including those of its subclasses. It uses an LLMClient to generate summaries for each method and variable, caching results using ResponseCache to avoid redundant requests. The summaries are stored in the `summary` and `docstring` fields of the respective entries.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\docgenerator.py:_summarize_module_chunked:d9e13ce7fee3a107f9c98e4991a958f9ef7d935813f4c620accbeb6818ebb823:d9e13ce7fee3a107f9c98e4991a958f9ef7d935813f4c620accbeb6818ebb823": "This function `_summarize_module_chunked` is designed to summarize a module of code using structure-aware chunking. It takes parameters including an LLM client, response cache, key prefix, module text, module dictionary, tokenizer, maximum context tokens, and chunk token budget.\n\nThe function first calculates the available tokens for summarization after accounting for overhead from system prompt and template encoding. If the module text fits within these available tokens, it directly summarizes the module. Otherwise, it attempts to structure-awarely chunk the module into smaller parts based on its structure.\n\nIf successful in chunking, it recursively summarizes each part and combines them into a single technical paragraph using another recursive function `_merge_recursive`. This process ensures that the final summary does not exceed the available tokens while maintaining a coherent structure. If any step fails due to exceptions (e.g., network issues), it handles these gracefully by logging warnings and attempting alternative summarization methods.\n\nThe function returns a sanitized summary of the module, ensuring that only explicitly defined code is summarized without speculation or evaluation.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\docgenerator.py:clean_output_dir:d5ec326d25118c815938451ab03e4cb69d4b0bc80b3cb2c35b80ad048bbfd7b4:d5ec326d25118c815938451ab03e4cb69d4b0bc80b3cb2c35b80ad048bbfd7b4": "The function `clean_output_dir` takes a string representing the path to an output directory and iterates through all files within that directory. If a file has a `.html` extension, it reads the first line of the file. If the first line contains the string \"Generated by DocGen-LM\", the file is deleted. Any exceptions encountered during this process are caught and printed as warnings.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\docgenerator.py:ec7cf4708df93faa09dcf18f77027753ffd0b7ba93d4d133aa08caa2b123f2fd:merge0:81ad5b7dba5c2c1010fb93383212679395e8cef4233d87cb98964c4630b68819": "The script defines a process to generate HTML documentation using a local language model (LLM). It includes functions such as `clean_output_dir` to clean up existing HTML files, `_summarize` to summarize text with caching, `_chunk_module_by_structure` and `_summarize_module_chunked` for handling token limits by chunking module text, `_build_function_prompt` to create context-enriched prompts for summarizing code, `_rewrite_docstring` to update docstrings using optional context, and `_summarize_members_recursive` to recursively summarize methods and variables within classes and subclasses. The script utilizes a cache to store previously generated summaries to avoid redundant requests to the LLM. It processes files in a specified source directory, summarizes modules, and generates project-level summaries, ultimately writing HTML documentation pages for each module and updating docstrings with context from the project summary.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\docgenerator.py:ec7cf4708df93faa09dcf18f77027753ffd0b7ba93d4d133aa08caa2b123f2fd:part0:c212fe737e0f067c7615a7610c287588b0ac14da8d669f23f0eb60938f84a3ef": "The script includes several functions:\n- `clean_output_dir`: Cleans up existing HTML files in the output directory if they were generated by DocGen-LM.\n- `_summarize`: Summarizes text using a client (LLM) with caching.\n- `_chunk_module_by_structure`: Chunks module text based on its structure to fit within token limits.\n- `_summarize_module_chunked`: Summarizes a module using structure-aware chunking and combines summaries.\n- `_build_function_prompt`: Builds a context-enriched prompt for summarizing code.\n- `_rewrite_docstring`: Rewrites docstrings using optional context.\n- `_summarize_members_recursive`: Recursively summarizes methods and variables within classes and subclasses.\n\nThe script uses a cache to store previously generated summaries to avoid redundant requests to the LLM. It also handles token limits by chunking text appropriately.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\docgenerator.py:ec7cf4708df93faa09dcf18f77027753ffd0b7ba93d4d133aa08caa2b123f2fd:part1:5e002abc0784d40f25aac385833dfb10630ffd81a34c5713b2158278233dba86": "The code defines a script to generate HTML documentation using a local language model (LLM). It includes functions to recursively summarize classes and methods, rewrite docstrings, and parse different programming languages. The script also handles command-line arguments for source directory, output directory, and LLM configuration. It processes files in the specified source directory, summarizes modules, and generates project-level summaries. Finally, it writes HTML documentation pages for each module and updates docstrings with context from the project summary.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\docgenerator.py:main:d51c53398dd3d1d809fa3887073a2799d33119d4d2274cb6ebb580da5e60fde2:d51c53398dd3d1d809fa3887073a2799d33119d4d2274cb6ebb580da5e60fde2": "The `main` function serves as the entry point for generating HTML documentation using a local LLM. It accepts command-line arguments to specify the source directory, output directory, and various options such as ignored paths, LLM URL, model name, and token limits.\n\nThe function initializes an argument parser to handle user inputs, creates an instance of `LLMClient` to interact with the local LLM, and sets up a tokenizer for text processing. It then scans the source directory for files, parses them based on their extensions (Python, C++, Java, MATLAB), and generates summaries using the LLM.\n\nThe summaries are stored in a cache to avoid redundant requests. The function also handles project documentation by reading `README.md` files and summarizing project structure. After generating initial summaries, it recursively summarizes classes and functions within each module, incorporating project context into these summaries.\n\nFinally, the function writes the generated HTML pages to the output directory, including an index page and individual pages for each module and class. The process ensures that all code structures are rendered as expandable sections in the documentation output.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:48c5a9d39dc2bae1fbcbb94b7e9f2c6c4534722694cacb917d12cf1d41536b3f:merge0:5732db58945659a7d9d4df1c2ae61dd6dac5b126b8b2e0f3654ecf7850b28646": "This module defines a `Config` class for holding configuration settings parsed from CLI arguments. It includes functions for collecting documentation and code files from a project directory, as well as utilities for slugifying text, inserting links into an index file, and extracting plain text from various file types. The module also provides logic to detect placeholders in text and map evidence snippets to manual sections.\n\nThe core functionality involves:\n1. Extracting relevant code snippets from files using `extract_snippets`, categorizing them by sections with `scan_code`.\n2. Generating a manual from documentation snippets using an LLM client with `llm_generate_manual`.\n3. Filling placeholder tokens in the manual text with code snippets using `llm_fill_placeholders`.\n4. Optionally editing chunks of text in the user's editor with `_edit_chunks_in_editor`.\n\nAdditionally, this module offers functions for rendering HTML from structured sections of a manual (`render_html`), parsing text into structured sections (`parse_manual`), validating references within those sections (`validate_manual_references`), inferring missing sections (`infer_sections`), and writing the rendered HTML as a PDF using ReportLab with `write_pdf`.\n\nThe main function, `main`, serves as the entry point for summarizing project documentation. It processes command-line arguments to create a `Config` object, collects documentation files, extracts text, logs the process, initializes an LLM client, generates a manual, fills placeholders, parses sections, validates references, renders output in HTML or PDF format, inserts links into an index file if requested, and saves evidence data. It handles exceptions gracefully and returns 0 upon successful completion.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:48c5a9d39dc2bae1fbcbb94b7e9f2c6c4534722694cacb917d12cf1d41536b3f:part0:cad03170c79ae4f0d1d2f36c57f3909c62a26464f20a175abadc08436cee8417": "- Defines a `Config` class to hold configuration settings parsed from CLI arguments.\n- Implements functions to collect documentation and code files from a project directory.\n- Provides utilities to slugify text, insert links into an index file, and extract plain text from various file types.\n- Includes logic to detect placeholders in text and map evidence snippets to manual sections.\n- Offers a function to rank code files based on heuristics.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:48c5a9d39dc2bae1fbcbb94b7e9f2c6c4534722694cacb917d12cf1d41536b3f:part1:8f10a64afd7e2fd32e707110d894fffc2905f5f7961dc4bce28b5eeab79d573d": "The module defines functions to extract relevant code snippets from files, categorize them by sections, and generate a manual using an LLM client. It includes:\n\n1. `extract_snippets`: Extracts code snippets from files based on file size, time budget, and content filters.\n2. `scan_code`: Collects source code snippets from a base directory grouped by manual sections.\n3. `llm_generate_manual`: Generates a manual from supplied documentation snippets using an LLM client.\n4. `llm_fill_placeholders`: Fills placeholder tokens in the manual text using provided code snippets.\n5. `_edit_chunks_in_editor`: Opens chunks of text in the user's editor for optional modification.\n\nThese functions work together to automate the process of creating a structured manual from unstructured source code and documentation.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:48c5a9d39dc2bae1fbcbb94b7e9f2c6c4534722694cacb917d12cf1d41536b3f:part2:728ef003d9b9cf619f2797bd3f130e29e504e38c3a5e8a9633d300640b8df8a4": "This module provides functions to render HTML from structured sections of a manual, parse text into structured sections, validate references within those sections, infer missing sections, and write the rendered HTML as a PDF. The `render_html` function takes sections, a title, and an optional evidence map to create an HTML document with navigation links and formatted content. The `parse_manual` function splits input text into sections based on headings. The `validate_manual_references` function checks for missing file references within sections and updates them accordingly. The `infer_sections` function creates a basic structure with an \"Overview\" section if the input text is non-empty, or placeholder sections otherwise. Finally, the `write_pdf` function converts HTML to a PDF using the ReportLab library.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:48c5a9d39dc2bae1fbcbb94b7e9f2c6c4534722694cacb917d12cf1d41536b3f:part3:a9277aadc6312b031707b1eddb8a882d73e638ba5c39005838093b1f6829288b": "This module defines a `main` function that serves as the entry point for summarizing project documentation. It uses command-line arguments to configure various options such as input path, output format, and chunking mode. The function parses these arguments, sets up logging based on chunking mode, and initializes configuration settings.\n\nThe main steps include:\n1. Parsing command-line arguments to create a `Config` object.\n2. Determining the target directory and output directory for the documentation.\n3. Collecting documentation files from the target directory.\n4. Extracting text from these files.\n5. Logging the start of the document generation process.\n6. Initializing an LLM client and response cache.\n7. Generating a manual using the LLM client, handling missing sections by scanning code if necessary.\n8. Filling placeholders in the generated manual with code context.\n9. Parsing the final manual sections and validating references.\n10. Rendering the HTML or PDF output based on the specified format.\n11. Inserting a link to the generated manual into an index file if requested.\n12. Saving evidence data to a JSON file.\n\nThe function handles exceptions gracefully, providing fallbacks in case of LLM summarization failures. It returns 0 upon successful completion.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:Config:b678743aec68babe35aa53676e3047be673ff164147d440f6363d654fa399372:b678743aec68babe35aa53676e3047be673ff164147d440f6363d654fa399372": "The `Config` class in the project is designed to manage configuration settings for generating static HTML documentation using DocGen-LM. It supports both command-line interface (CLI) and graphical user interface (GUI) options, allowing users to specify project directories, output locations, and other parameters necessary for documentation generation.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:_edit_chunks_in_editor:c9b62e5a61f703013a6c793a8d075682f700bd2b156e07c33b746db2b54972b3:c9b62e5a61f703013a6c793a8d075682f700bd2b156e07c33b746db2b54972b3": "The function `_edit_chunks_in_editor` takes a list of strings (`chunks`) as input, where each chunk is separated by lines containing `---`. It opens these chunks in the user's default editor (determined by environment variables `EDITOR` or `VISUAL`, falling back to \"vi\" if neither are set). After editing, it reads the modified content from a temporary file, splits it back into chunks based on the separator, and returns a list of non-empty edited chunks.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:collect_docs:d0eb6765d029de21a4003dd22387d8b2d57ae7dc00de19ee3a1b18ca10ea6eea:d0eb6765d029de21a4003dd22387d8b2d57ae7dc00de19ee3a1b18ca10ea6eea": "The `collect_docs` function takes a base directory path as input and returns a list of paths to documentation files. It searches for specific file types (`.md`, `.txt`, `.html`, `.docx`) in the project root directory and within a subdirectory named \"docs\". The function uses glob patterns to match these file types and ensures that each file is only included once in the result by maintaining a set of seen files.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:collect_files:d0e84ee315cf9f92d19bc661950611bc765db191a7c7bd370e89718f6c1e2efa:d0e84ee315cf9f92d19bc661950611bc765db191a7c7bd370e89718f6c1e2efa": "The `collect_files` function returns a list of file paths from the specified base directory that are relevant for summarization. It starts with a predefined set of file patterns, such as README.md, text files, HTML files, and various document formats. The function uses the `rglob` method to recursively search for these patterns within the base directory and its subdirectories. If additional patterns are provided through the `extra_patterns` parameter, they are also included in the search.\n\nThe resulting list of file paths is then filtered to remove duplicates, ensuring that each file is only listed once. This is achieved by maintaining a set of seen files and appending unique files to the final list. The function returns this list of unique file paths.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:detect_placeholders:25a08a6da1445c735fe8a33598db7391d05a41f0845c4e08c64def81d68bba47:25a08a6da1445c735fe8a33598db7391d05a41f0845c4e08c64def81d68bba47": "The function `detect_placeholders` takes a string `text` as input and returns a list of section names that are still marked by placeholder tokens. It uses the helper function `find_placeholders` to identify all placeholder tokens in the text. Then, it filters these tokens against a dictionary `SECTION_PLACEHOLDERS`, which maps section names to their corresponding placeholder tokens. The result is a list of section names whose placeholders have not been replaced.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:extract_snippets:4b15c24def690385e6cf06ac7b09c5c034726f912a9874f61d76e18bcfaa4f02:4b15c24def690385e6cf06ac7b09c5c034726f912a9874f61d76e18bcfaa4f02": "The function `extract_snippets` processes a collection of Python files to extract relevant code snippets. It filters files based on a maximum number of files (`max_files`), time budget (`time_budget`), and file size limit (`max_bytes`). For each file, it reads the content up to the specified byte limit and extracts documentation strings from modules, classes, functions, and asynchronous functions. If the file is a Python script, it also identifies potential I/O signatures based on function arguments containing keywords like \"path,\" \"file,\" \"config,\" or \"io.\" The extracted snippets are stored in a dictionary with file paths as keys and concatenated text as values.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:extract_text:33ef5c6ad0914e25f55d7b65fbae51e9a33e3dab57eafff2dfebba425b3db9fa:33ef5c6ad0914e25f55d7b65fbae51e9a33e3dab57eafff2dfebba425b3db9fa": "The function `extract_text` reads and processes the content of a file located at the given `path`. It determines the file type based on its suffix (e.g., `.html`, `.md`, `.docx`). For HTML files, it uses BeautifulSoup to parse the content, replacing headings with Markdown-style headers and code blocks with fenced code blocks. For Markdown files, it simply reads the text. For DOCX files, if the `Document` class is available from the `python-docx` library, it extracts text from paragraphs, converting heading styles into Markdown headers. If any other file type or an error occurs during processing, it returns an empty string.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:infer_sections:e29fa74b52a2dfb9c0a4f5951b927ed33538530edf259a8336fe03f589f8ce6d:e29fa74b52a2dfb9c0a4f5951b927ed33538530edf259a8336fe03f589f8ce6d": "The function `infer_sections` takes a string `text` as input and returns a dictionary mapping section names to their corresponding content. If the input text is non-empty, it places the entire text under an \"Overview\" section and generates placeholder content for any other required sections labeled \"(inferred)\". If the input text is empty, it initializes all required sections with a default message indicating no information is available.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:inject_user_manual:117e7e324dff078d3d24e23c64d976c975063a6ede2371eac5127dfb3c592f73:117e7e324dff078d3d24e23c64d976c975063a6ede2371eac5127dfb3c592f73": "Inserts a top-level link to a user manual into an HTML file specified by `index_path`. The link is added to the first `<nav>` or `<ul>` element if present; otherwise, it is inserted at the start of the first element in `<body>` or the document root.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:insert_into_index:8fa929daa99b1c327537f24810475ed789e509cfccb066bee437588fe2ed5cb5:8fa929daa99b1c327537f24810475ed789e509cfccb066bee437588fe2ed5cb5": "The function `insert_into_index` appends a navigation entry linking to a specified file into an HTML index file. It reads the existing content of the index file using BeautifulSoup, which parses HTML and XML documents. The function looks for either a `<ul>` or `<nav>` element within the index file. If such an element is found, it checks if an anchor tag with the same `href` attribute as the filename already exists. If not, it creates a new anchor tag with the provided title and href attributes. Depending on whether the container is a `<ul>` or `<nav>`, it appends the anchor tag either inside a new list item (`<li>`) or directly to the container. Finally, it writes the modified HTML content back to the index file.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:llm_fill_placeholders:c1dfa401c2303a19b99cadf312238df0a57fc02c0cf0e2881424fef458dc5eff:c1dfa401c2303a19b99cadf312238df0a57fc02c0cf0e2881424fef458dc5eff": "The function `llm_fill_placeholders` processes a manual text by filling placeholders with relevant code snippets. It uses an LLM client and a response cache to manage API calls and avoid redundant requests. The function handles large code snippets by summarizing them before sending them to the model, ensuring that prompts fit within the model's context window. It iterates over sections of code snippets, constructs a prompt combining manual text and code snippets, and updates the manual by replacing placeholders with summarized information from the code. The process is logged for tracking which sections were updated using which files.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:llm_generate_manual:fb3f0a61d10570416402141b23ba4c05b422f25bc45e78b721e61b6c752cf2a5:fb3f0a61d10570416402141b23ba4c05b422f25bc45e78b721e61b6c752cf2a5": "The function `llm_generate_manual` processes documentation snippets to generate a user manual. It maps these snippets to manual sections, performs LLM calls for each section, and assembles the final manual text. The function returns the manual text, a mapping of source files to sections, and an evidence map capturing used snippets.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:main:b1e12313be9df1908a132a7f6cceb83ee5c7719ab94898cd27d3ba7d8b9ff6d7:b1e12313be9df1908a132a7f6cceb83ee5c7719ab94898cd27d3ba7d8b9ff6d7": "The `main` function serves as the entry point for generating project documentation. It parses command-line arguments to configure settings such as project path, output format, and chunking mode. The function initializes a configuration object based on these arguments and proceeds with several steps:\n\n1. Collects document files from the specified project directory.\n2. Reads text content from these files.\n3. Initializes an LLM client for generating summaries.\n4. Caches responses to avoid redundant requests.\n5. Generates an initial manual summary using the LLM.\n6. Detects any placeholders in the generated summary that need further processing.\n7. Optionally scans project code to fill in missing sections based on configuration settings.\n8. Validates and refines the manual sections.\n9. Renders the final HTML or PDF document.\n10. Inserts a link to the generated documentation into an index file if specified.\n11. Saves evidence data associated with the documentation process.\n\nThe function handles exceptions gracefully, falling back to manual section inference if LLM summarization fails. It returns 0 upon successful completion.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:map_evidence_to_sections:22b8d05fbb3dfe21312727decb4309022f9435fb6dc14a0b2b706c114a2bdd12:22b8d05fbb3dfe21312727decb4309022f9435fb6dc14a0b2b706c114a2bdd12": "The function `map_evidence_to_sections` processes a dictionary of documentation snippets and maps them to specific sections based on predefined keywords. It returns two dictionaries: `section_map`, which associates each section with the top 10 relevant snippets (by length), and `file_map`, which tracks which files contributed to each section.\n\nThe function iterates through each document, checking for section keywords that indicate where a snippet should be categorized. If a keyword is found, it extracts up to a maximum number of lines as a snippet, ensuring the snippet starts with relevant content (not empty, not commented out). The snippets are then sorted within their sections based on priority and length, with the \"Overview\" section having additional sorting criteria for README files and documentation directories.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:parse_manual:0d65c54a7521200016920ca79213b2c41413ed92272fa5bea53263424f7f3ec2:0d65c54a7521200016920ca79213b2c41413ed92272fa5bea53263424f7f3ec2": "The `parse_manual` function takes a string of text and an optional LLM client, along with a boolean flag to infer missing sections. It parses the input text into structured sections based on lines containing a colon (`Section: content`). If `infer_missing` is true and any required sections are absent, it uses the provided LLM client to generate summaries for these sections and marks them as inferred. The function returns a dictionary where keys are section titles and values are their corresponding contents.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:rank_code_files:867cf1fdc9b7dfca44fb29acfac7c159fdd5fcd08be986b71c258c2d51a96788:867cf1fdc9b7dfca44fb29acfac7c159fdd5fcd08be986b71c258c2d51a96788": "The `rank_code_files` function ranks Python code files under a specified root directory based on simple heuristics. It supports various file extensions including `.py`, `.m`, `.ipynb`, `.cpp`, `.h`, and `.java`. The function skips certain directories like `venv`, `.git`, and `tests`. It assigns scores to files containing specific keywords or patterns, such as \"run\", \"main\", \"cli\", etc., and returns a list of paths sorted by score in descending order.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:render_html:3b120c2d37e3589bb40fd7c7dc94faa13392521ec06c6facc1fc5124f3d6480d:3b120c2d37e3589bb40fd7c7dc94faa13392521ec06c6facc1fc5124f3d6480d": "The `render_html` function generates an HTML document from a dictionary of sections, each containing content and optionally supporting evidence. It constructs the HTML by iterating over the sections, creating navigation links for each section title and rendering the content. If a section is empty or lacks information, it substitutes available evidence snippets instead. The function includes styling for the HTML document, such as font families and colors, to improve readability.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:scan_code:1d29582b17b8e4a612129fc8c6624ba0f8b90b66508c821923274d8602fa2cdf:1d29582b17b8e4a612129fc8c6624ba0f8b90b66508c821923274d8602fa2cdf": "The `scan_code` function collects source code snippets from a specified directory (`base`) grouped by manual sections. It searches for keywords associated with the provided sections (or all known sections if none are specified) and returns a dictionary mapping section names to another dictionary of relative file paths and their corresponding snippet text.\n\nThe function performs the following steps:\n1. Collects patterns from source files using `collect_docs` and `extract_text`.\n2. Ranks code files based on these patterns.\n3. Extracts snippets from ranked files within specified limits (number of files, time budget, maximum bytes per file).\n4. Categorizes collected snippets by the specified sections or all known sections.\n5. Returns a dictionary with categorized snippets.\n\nThe function uses regular expressions to identify relevant patterns and filters out unwanted matches. It also handles exceptions during text extraction and ensures that only files with specific extensions (like `.py`) are considered.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:slugify:88d4c7b8a6c533486019f6b152d253cf6252bb77d53808069584f5735efe4688:88d4c7b8a6c533486019f6b152d253cf6252bb77d53808069584f5735efe4688": "Converts a given string into a filesystem-friendly slug. It removes all non-alphanumeric characters, converts the string to lowercase, and replaces spaces with underscores. If the resulting slug is empty, it defaults to \"user_manual\".",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:validate_manual_references:c4cecec51f7833ac2f784684c6cb44da75ebfa0c730ccd132158eb68eaabc5d1:c4cecec51f7833ac2f784684c6cb44da75ebfa0c730ccd132158eb68eaabc5d1": "This function `validate_manual_references` checks for missing file references in documentation sections. It scans the text of each section for substrings that resemble file paths or module names. If a referenced file is not found under the specified project root, it annotates the reference with `[missing]` in the section text. When an evidence map is provided, it records the missing references under the corresponding section in a `missing_references` list. The function modifies the input sections dictionary in place.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:write_pdf:b8f2e571e20bfa83a932d327bf0e5bb267d503e658378c4e28c37e5c8831f71d:b8f2e571e20bfa83a932d327bf0e5bb267d503e658378c4e28c37e5c8831f71d": "The function `write_pdf` takes an HTML string and a file path as input. It attempts to write the HTML content as a PDF file at the specified path. If successful, it returns `True`; otherwise, it returns `False`. The function uses BeautifulSoup to extract text from the HTML, then creates a PDF using ReportLab's canvas module, adding each line of text to the document before saving and closing the file.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:39ce94027bfc6ce0cad3c1969ec59b2e9fae55e8264b967e099883832496302f:39ce94027bfc6ce0cad3c1969ec59b2e9fae55e8264b967e099883832496302f": "A Python application using PyQt5 for a graphical user interface (GUI) to run documentation and code explanation tools. The application includes:\n\n1. A `PathLineEdit` class for file path input with drag-and-drop functionality.\n2. A `CollapsibleBox` class for creating collapsible sections in the GUI.\n3. A `CommandRunner` class that runs shell commands asynchronously, emitting output and completion signals.\n4. A `MainWindow` class that sets up the GUI layout, handles user interactions, and manages running documentation and code explanation tools.\n\nThe main functionality includes:\n- Selecting project and output directories.\n- Configuring options for DocGen (documentation generation) and ExplainCode (code explanation).\n- Running DocGen, ExplainCode, or both in sequence.\n- Displaying log output of the commands run.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:CollapsibleBox:__init__:3872795cd50f67882abd634cee89722f78baef841dae8e915249543f655adece:3872795cd50f67882abd634cee89722f78baef841dae8e915249543f655adece": "A class constructor initializes a widget with a toggle button and a content area. The toggle button is styled to have no border, a light gray color, and bold text. It displays the provided title and has an arrow pointing right. When clicked, it triggers the `on_toggled` method. Initially, the content area is hidden. A vertical layout is set up with no margins, containing both the toggle button and the content area.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:CollapsibleBox:fc409996f8c0466640044c76d7b562a10f09a899386226f8fdc63045c4594c8f:fc409996f8c0466640044c76d7b562a10f09a899386226f8fdc63045c4594c8f": "The `CollapsibleBox` class defines a widget with a toggle button and content area. It initializes with a styled toggle button that displays an arrow pointing right and hides the content initially. The `on_toggled` method controls the visibility of the content, switching between showing and hiding it based on the state of the toggle button.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:CollapsibleBox:on_toggled:f90ec87aaa91989724254207a4e933efac34041b0616a24b2d270248eb906904:f90ec87aaa91989724254207a4e933efac34041b0616a24b2d270248eb906904": "Toggles the visibility of content based on the state of a toggle button. When the button is checked, it displays an arrow pointing down and shows the content; when unchecked, it displays an arrow pointing right and hides the content.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:CollapsibleBox:setContentLayout:ac9bfe1723225a787e6fed8f56df1803aac7bf21a8460cdab57bb446c2364b27:ac9bfe1723225a787e6fed8f56df1803aac7bf21a8460cdab57bb446c2364b27": "Sets the content layout of an object.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:CommandRunner:559d7db5dd3b9781d91b32ca0936d8dde43f3713df35cb20ad14d92c3064a80d:559d7db5dd3b9781d91b32ca0936d8dde43f3713df35cb20ad14d92c3064a80d": "The `CommandRunner` class is designed to execute a list of commands concurrently, capturing their outputs and errors separately. It handles input streams by reading characters one at a time, emitting chunks as they are read, and manages carriage returns and newlines appropriately. After executing all commands, it emits a finished signal with the return code, breaking if any command fails.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:CommandRunner:__init__:e101f462c35c5d2aea35db85e4ee5dd50b4513aa99b522541dc82c8e27a017f4:e101f462c35c5d2aea35db85e4ee5dd50b4513aa99b522541dc82c8e27a017f4": "Initializes an object with a list of commands.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:CommandRunner:_reader:8cbfd3ce114ed1c88228963326a3e4e5c43e87fbd062a6965099f60e48b826d6:8cbfd3ce114ed1c88228963326a3e4e5c43e87fbd062a6965099f60e48b826d6": "Reads characters from a stream one by one, emitting chunks to an output. Handles carriage returns and newlines, flushing buffered text when the stream ends.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:CommandRunner:run:c94857cc54e41729c04041a0a02b8ef637ddeb94d917c5048d30a4c9036c500a:c94857cc54e41729c04041a0a02b8ef637ddeb94d917c5048d30a4c9036c500a": "The function `run` executes a list of commands, captures their output and errors in separate threads, waits for the processes to complete, and emits the results. If any command fails (non-zero exit code), it breaks out of the loop and sets the return code to -1. Finally, it emits a finished signal with the return code.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:MainWindow:5ab43074a27525db43f0703dc13204785195c43349ef8b3a01b013c96c53efde:5ab43074a27525db43f0703dc13204785195c43349ef8b3a01b013c96c53efde": "The `MainWindow` class defines a graphical user interface for generating documentation from source code using tools like DocGen-LM. It includes methods for selecting directories, running commands, displaying logs, and managing the UI state during processing.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:MainWindow:__init__:a80b0d28b1f21493df62eb0b88f81a94c02125321fa3d1ec29f46b28cd23ebe1:a80b0d28b1f21493df62eb0b88f81a94c02125321fa3d1ec29f46b28cd23ebe1": "This code defines a class with an `__init__` method that sets up the user interface for a documentation tool. The interface includes:\n\n- A header with a logo and title.\n- Fields to select project and output directories with browse buttons.\n- Options for DocGen, including checkboxes for including private functions and language selection.\n- Options for ExplainCode, including a combo box for output format and an option to include input data analysis with its own browse button.\n- A log area for displaying messages.\n- Buttons to run DocGen, ExplainCode, or both.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:MainWindow:append_log:479035b003afdc113e4797fee7c099619ef8d0c73b903f780a2ffa361feaaf55:479035b003afdc113e4797fee7c099619ef8d0c73b903f780a2ffa361feaaf55": "The function `append_log` appends text to a log widget. It uses a regular expression to split the input text into parts, including newline characters. For each part, if it is a newline character (`\\r`), it moves the cursor to the start of the line and clears any existing text on that line. If the part is not a newline character, it inserts the text at the current cursor position. After processing all parts, it sets the cursor back to the log widget and scrolls to the end of the content.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:MainWindow:build_docgen_cmd:6fa0775116713b62dd6629e8c1004ce85ebf3d3733c83a88ff84ed7cd8476068:6fa0775116713b62dd6629e8c1004ce85ebf3d3733c83a88ff84ed7cd8476068": "Constructs a command to run a document generator tool (`docgenerator.py`) with specified project and output paths. Optionally includes a flag to include private members if checked. Automatically detects supported languages without requiring an explicit flag.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:MainWindow:build_explain_cmd:7b8696f7337008622c6bc5488b4fc92413596481c1750330bdc72564631f2cb5:7b8696f7337008622c6bc5488b4fc92413596481c1750330bdc72564631f2cb5": "This function constructs a command list for executing an external script named `explaincode.py` using the Python interpreter (`pythonw`). It includes options for specifying the project path, output file, and output format. Additionally, it conditionally adds a data file if a checkbox is checked and a text field is not empty. The constructed command is returned as a list of strings.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:MainWindow:dark_style:024d23387b641216e7d149e6c045b026f1a451318d781be0d3d84d51867f51ef:024d23387b641216e7d149e6c045b026f1a451318d781be0d3d84d51867f51ef": "Returns a string containing CSS styles for a dark-themed user interface, including QWidget, QLineEdit, QPlainTextEdit, QComboBox, QPushButton, and QLabel.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:MainWindow:on_finished:c98dd27bd106b89d8d5059a01d5a7c208db9c09ee3836ee9d932c0f5bdb99f8b:c98dd27bd106b89d8d5059a01d5a7c208db9c09ee3836ee9d932c0f5bdb99f8b": "A function that logs the exit code of a process and sets its running state to False.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:MainWindow:run_both:123251ea533aa28d4fb511b62f853998d3769fcced0962a00cdc1cb16c3cfef0:123251ea533aa28d4fb511b62f853998d3769fcced0962a00cdc1cb16c3cfef0": "Clears the log and runs both the document generation command and the explanation command.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:MainWindow:run_commands:259d9e78ac20ac9cd282474591a8079c54a2e042ef9670b77335a47dad9adaff:259d9e78ac20ac9cd282474591a8079c54a2e042ef9670b77335a47dad9adaff": "The function `run_commands` takes a list of commands as input. It checks if project and output directories are set; if not, it logs an error message. If the directories are set, it sets the running state to true, initializes a `CommandRunner` with the provided commands, connects its output signal to append log messages, connects its finished signal to handle completion, and starts the command runner.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:MainWindow:run_docgen:0249c14aca7d5d21ff6d3b7929c59f2dbc05b970b05e9329f97566991188ecf6:0249c14aca7d5d21ff6d3b7929c59f2dbc05b970b05e9329f97566991188ecf6": "Clears the log and runs a command to generate documentation.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:MainWindow:run_explain:aaae3953f6dfd026db21ab5cd9b5c637f7a8e0fee01ae706e4db035bf9a67663:aaae3953f6dfd026db21ab5cd9b5c637f7a8e0fee01ae706e4db035bf9a67663": "Clears the log and runs a command to explain something.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:MainWindow:select_dir:2a0195f8b02fa1d0340ed30e33775539f64b5ddf0498a2fae1d7426f16c229f5:2a0195f8b02fa1d0340ed30e33775539f64b5ddf0498a2fae1d7426f16c229f5": "Function `select_dir` opens a file dialog to select an existing directory. If a directory is selected, it sets the text of the provided `QLineEdit` widget to the path of the selected directory.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:MainWindow:select_file:eefcbb0d572a55989ebf1a954aae8e90553ec7f2c5c165ee8e6029c3df4770d3:eefcbb0d572a55989ebf1a954aae8e90553ec7f2c5c165ee8e6029c3df4770d3": "The function `select_file` opens a file dialog to select a data file with extensions `.json`, `.csv`, or `.txt`. If a file is selected, it sets the text of the provided `QLineEdit` widget to the selected file's path.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:MainWindow:set_running:d3acbd2de6100d567839296867ec1053032418777abacda408081e46f5c8e826:d3acbd2de6100d567839296867ec1053032418777abacda408081e46f5c8e826": "The function `set_running` takes a boolean parameter `running`. It iterates over three buttons (`docgen_btn`, `explain_btn`, and `both_btn`) and sets their enabled state to the opposite of the `running` value. If `running` is `True`, the buttons are disabled; if `running` is `False`, the buttons are enabled.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:PathLineEdit:__init__:c9e8a7be9ec3c7638ba891fb56438f32b028d50d553e3cf05183fab3aa0b6309:c9e8a7be9ec3c7638ba891fb56438f32b028d50d553e3cf05183fab3aa0b6309": "Initializes an object with optional parent. Sets the object to accept drag-and-drop operations.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:PathLineEdit:c6094eff2de55ef6e638347d684ab546e9135920d1d720683c3aa67ac78d242e:c6094eff2de55ef6e638347d684ab546e9135920d1d720683c3aa67ac78d242e": "The `PathLineEdit` class is designed for handling drag-and-drop operations in a graphical user interface, specifically for accepting URLs that represent file paths. It includes methods to process these drops by extracting and setting the local file path of the first URL found in the event's MIME data. This functionality enhances the usability of the GUI by allowing users to easily input file paths through drag-and-drop interactions.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:PathLineEdit:dragEnterEvent:362f23d15259d38f2384b97d4fe0df74d022e537eb20da5aa442f957d48d0d35:362f23d15259d38f2384b97d4fe0df74d022e537eb20da5aa442f957d48d0d35": "Handles the `dragEnterEvent` by accepting the proposed action if the event contains URLs.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:PathLineEdit:dropEvent:2bae52494ea3b00064a9fc268f5338cc663c0b954be820963c807172bd13b7cf:2bae52494ea3b00064a9fc268f5338cc663c0b954be820963c807172bd13b7cf": "The function `dropEvent` handles a drop event by extracting URLs from the event's MIME data. If any URLs are present, it sets the text of the object to the local file path of the first URL in the list.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\html_writer.py:_highlight:d8c0f4103679ab9fec1906ebd37ada1168ceb15afc046767c3b9afea09da99a8:d8c0f4103679ab9fec1906ebd37ada1168ceb15afc046767c3b9afea09da99a8": "The function `_highlight` takes a string `code` and a string `language` as input. It returns the code highlighted for the specified language using Pygments. The function selects an appropriate lexer based on the language (Matlab, Python, C++, Java) or defaults to `TextLexer` if the language is not recognized. It then uses an HTML formatter to format the highlighted code and wraps it in `<pre><code>` tags for display.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\html_writer.py:_render_class:9e9a25ff5c5b60d649e898e41afe5422decdf40a800340db12fedff92bac3167:9e9a25ff5c5b60d649e898e41afe5422decdf40a800340db12fedff92bac3167": "This function `_render_class` generates HTML parts for a class and its subclasses. It takes a dictionary representing the class, a programming language string, and an optional level parameter (default is 2). The function returns a list of HTML strings.\n\n- It starts by creating an HTML heading tag (`<hX>`) with the class name.\n- If the class has a docstring or summary, it adds a paragraph with the escaped text.\n- It then processes variables within the class, adding headings and descriptions for each variable.\n- For each method in the class, it calls `_render_function` to generate HTML parts.\n- Finally, it recursively processes subclasses, wrapping them in `<details>` tags for expandable sections.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\html_writer.py:_render_function:cc6984d871e25f13bf9ff60f434e220aba41fea9622d718fc8d570fd37e53a73:cc6984d871e25f13bf9ff60f434e220aba41fea9622d718fc8d570fd37e53a73": "This function `_render_function` takes a dictionary representing a function (`func`), a programming `language`, an optional `level` for HTML headings (default is 3), and an optional `prefix`. It returns a list of HTML strings that represent the function and any nested subfunctions.\n\nThe function constructs an HTML heading based on the function's signature or name, using the specified level. If a summary or docstring is available, it adds a paragraph with the escaped content. If source code is provided, it calls another function `_highlight` to highlight the code according to the given language.\n\nFor each subfunction nested within the current function, it creates a `<details>` element with a `<summary>` for the subfunction's signature or name. It then recursively calls itself to render the HTML for the subfunction, increasing the heading level by 1. Finally, it appends all parts together and returns them as a list of HTML strings.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\html_writer.py:_render_html:c7242642078f9b017c0a9dc5c64bb29f142208d3800ea64ae7296763ecf50d1e:c7242642078f9b017c0a9dc5c64bb29f142208d3800ea64ae7296763ecf50d1e": "The function `_render_html` takes four parameters: `title`, `header`, `body`, and `nav_html`. It reads a template file specified by `_TEMPLATE_PATH`, which is assumed to be a path object. The template is expected to contain placeholders for the title, header, body, navigation HTML, and static path. These placeholders are replaced with the provided values using Python's string formatting method. The function then returns a string that represents the rendered HTML content, prefixed with a comment indicating it was generated by DocGen-LM.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\html_writer.py:cb7d2be80220e642e35c48dec36335863a7e75a6e55f27602ef20acab3ba0b36:cb7d2be80220e642e35c48dec36335863a7e75a6e55f27602ef20acab3ba0b36": "This module provides utilities for rendering documentation pages using simple template substitution. It includes functions for highlighting code snippets in various programming languages and for generating HTML content based on structured data representing project summaries, modules, classes, methods, and variables. The module also includes functions to write index and module-specific documentation pages to an output directory.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\html_writer.py:write_index:eb0432e45fa1b047e26f736ce6afdeedf9424cac4e71a59628767e26136f8cf6:eb0432e45fa1b047e26f736ce6afdeedf9424cac4e71a59628767e26136f8cf6": "This function `write_index` generates an HTML file named `index.html` in the specified output directory. It takes three required parameters: `output_dir`, `project_summary`, and `page_links`. The optional parameter `module_summaries` provides additional summaries for modules.\n\nThe function creates a directory if it doesn't exist, constructs navigation links from `page_links`, and includes a project summary and module summaries in the HTML body. It then uses `_render_html` to create the final HTML content and writes it to `index.html`.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\html_writer.py:write_module_page:540c15415916601ef75c9b4b15b59d50459baa88d7796ae0b1044c3733b82279:540c15415916601ef75c9b4b15b59d50459baa88d7796ae0b1044c3733b82279": "This function `write_module_page` generates an HTML documentation page for a module. It takes three parameters: `output_dir`, `module_data`, and `page_links`. The function creates the output directory if it doesn't exist. It constructs navigation items based on provided links and renders the body of the HTML page using data from `module_data`. The body includes summaries, classes, variables, and functions, each rendered with appropriate HTML tags and syntax highlighting where applicable. Finally, it writes the generated HTML content to a file named after the module in the output directory.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\llm_client.py:8f5b5f0b0df904ebe69c30d4e90b99dac958762ddee3adcb12e8b64107e13bf6:8f5b5f0b0df904ebe69c30d4e90b99dac958762ddee3adcb12e8b64107e13bf6": "This module provides an interface to communicate with a local language model (LMStudio) for generating summaries. It includes:\n\n- A `SYSTEM_PROMPT` defining the behavior of the documentation engine.\n- Common rules for prompt templates.\n- A `README_PROMPT` for enriching project summaries from README files.\n- A dictionary `PROMPT_TEMPLATES` containing different types of prompts for summarizing modules, classes, functions, and more.\n- A `sanitize_summary` function to clean up generated summaries by removing unwanted phrases.\n- An `LLMClient` class that acts as a thin wrapper around the LMStudio HTTP API:\n- Initializes with a base URL and model name.\n- Includes a `ping` method to check if the API is reachable.\n- Implements a `summarize` method to generate summaries for given text using specified prompt types, handling retries on failures.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\llm_client.py:LLMClient:2d3f5745c2c9cc3c4467856db82958a0a64617ca8d1080e7fb9ac90c1d3d1ed4:2d3f5745c2c9cc3c4467856db82958a0a64617ca8d1080e7fb9ac90c1d3d1ed4": "The `LLMClient` class is designed to interact with a local language model for generating summaries of code. It includes methods for initializing the client with a base URL and model, checking API reachability, and summarizing text using specified prompts. The class handles HTTP requests to send payloads and parse responses, providing robust error handling and retries for reliable communication with the LLM.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\llm_client.py:LLMClient:__init__:700c23b8c0716a1aaf00c10fbc2e056bef4f6e1dca9c72b739185f920ef55cf8:700c23b8c0716a1aaf00c10fbc2e056bef4f6e1dca9c72b739185f920ef55cf8": "Initializes an object with a base URL and a model. The base URL is stored without trailing slashes, and the endpoint for API requests is constructed by appending \"/v1/chat/completions\" to it. The model type is also stored.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\llm_client.py:LLMClient:ping:3fe5655e89accd067c6ddc9c1cc323c9dd9eac2dea9be6646ea4d470b3e0a436:3fe5655e89accd067c6ddc9c1cc323c9dd9eac2dea9be6646ea4d470b3e0a436": "The function `ping` checks if the API is reachable by sending a GET request to the specified base URL with an optional timeout. It returns `True` if the server responds successfully, otherwise it raises a `ConnectionError` indicating that the server cannot be contacted.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\llm_client.py:LLMClient:summarize:340953c686eb58c465b342c01876eeee10acc4d018b2970e5b107bcfedab0633:340953c686eb58c465b342c01876eeee10acc4d018b2970e5b107bcfedab0633": "The function `summarize` takes a string `text`, a `prompt_type`, and an optional `system_prompt`. It uses the specified prompt type to generate a summary of the text. The function constructs a payload with the model, temperature, and messages (including the system prompt and user prompt). It attempts to send this payload to an endpoint using a POST request. If successful, it parses the response to extract and sanitize the summary content. If any errors occur during the request or response handling, it retries up to three times before raising a `RuntimeError` with the error message.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\llm_client.py:sanitize_summary:c4f39e2b1de4c4e0fce785da0f03b1a0e14bd0163cabfaf7080795b522897fa2:c4f39e2b1de4c4e0fce785da0f03b1a0e14bd0163cabfaf7080795b522897fa2": "The function `sanitize_summary` takes a string `text` as input and returns a sanitized version of the text by removing lines that start with certain phrases or contain specific keywords related to summaries, outputs, responses, and other meta-commentary. It also removes lines that start with \"this script\", \"this code\", or \"this file\". The function uses regular expressions to match these patterns and filters out the unwanted lines before joining the remaining lines back into a single string.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\manual_utils.py:_count_tokens:d1fed506a13024435575c2dfe65a151c8e5970436b6bff948e10e8240d5d7a7b:d1fed506a13024435575c2dfe65a151c8e5970436b6bff948e10e8240d5d7a7b": "This function `_count_tokens` takes a string `text` as input and returns an integer representing the approximate number of tokens in the text. It uses a tokenizer to encode the text, which converts it into a sequence of tokens, and then calculates the length of this sequence to determine the token count.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\manual_utils.py:_split_text:1fbe38e813d1bcc7c6839842909b88e6099c0cb398e1df6a191bdf81e5bc90e4:1fbe38e813d1bcc7c6839842909b88e6099c0cb398e1df6a191bdf81e5bc90e4": "Splits input text into chunks based on maximum tokens and characters, preserving paragraphs. Uses regular expressions to identify paragraphs and counts tokens and characters for each chunk. Handles large paragraphs by splitting them further using a tokenizer function. Ensures no single chunk exceeds the specified limits while maintaining paragraph structure.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\manual_utils.py:_summarize_manual:16295a4241cfb0f788891cfdd334854c7daea1f1d19759063071160d787bb714:16295a4241cfb0f788891cfdd334854c7daea1f1d19759063071160d787bb714": "This function `_summarize_manual` generates a manual summary for a given text using a specified chunking strategy. It utilizes an LLMClient to interact with a language model and a ResponseCache to store and retrieve cached responses. The function supports automatic or manual chunking based on the input parameters. If chunking is enabled, it splits the text into manageable parts, summarizes each part using the LLM, and then merges the summaries back together. If chunking is disabled or not necessary, it directly summarizes the entire text. The function also includes error handling for chunking failures and network issues, as well as logging for debugging purposes.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\manual_utils.py:ca45f47ddbb3006a8bf59dd1857385df96e5bfaf41681af7c2da178cba05f5ca:ca45f47ddbb3006a8bf59dd1857385df96e5bfaf41681af7c2da178cba05f5ca": "This module provides functions for splitting text into chunks and generating summaries using a language model. It includes:\n\n1. `_count_tokens`: Counts the number of tokens in a given text.\n2. `_split_text`: Splits text into chunks based on token and character limits.\n3. `chunk_docs`: Splits a list of documents into roughly equal-sized chunks.\n4. `find_placeholders`: Finds placeholder tokens in a given text.\n5. `_summarize_manual`: Generates a summary for a given text using a chunking strategy, utilizing an LLMClient for summarization and a ResponseCache for caching responses.\n\nThe module uses concurrent processing with ThreadPoolExecutor to handle multiple chunks simultaneously, improving efficiency when dealing with large texts.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\manual_utils.py:chunk_docs:85bfbca67a2c11a77d726419a5cfce9f92d4698a7075d0d616a9282348ebb1b8:85bfbca67a2c11a77d726419a5cfce9f92d4698a7075d0d616a9282348ebb1b8": "This function `chunk_docs` takes a list of strings (`docs`) and an integer (`token_limit`) as input. It joins the non-empty strings in the list with double newlines for separation, then splits the resulting text into chunks where each chunk is roughly up to the specified `token_limit`. The splitting considers both token count and character count, with a maximum of three times the token limit for character count per chunk.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\manual_utils.py:find_placeholders:79e8e498619617b6256f9d9754b7435655be5ea2829976df863b3d45b9011f9c:79e8e498619617b6256f9d9754b7435655be5ea2829976df863b3d45b9011f9c": "This function `find_placeholders` takes a string `text` as input and returns a set of placeholder tokens found within the text. The placeholders are identified using a regular expression defined by `PLACEHOLDER_RE`, which matches tokens enclosed in double square brackets, such as ``[[TOKEN]]``. The function extracts all occurrences of these placeholders from the input text and returns them as a set to ensure uniqueness.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\parser_cpp.py:20fbb103bacaa4a0b0e1faa76ad26882965689f182fed8716afa4e58a1cc1689:20fbb103bacaa4a0b0e1faa76ad26882965689f182fed8716afa4e58a1cc1689": "This Python module provides a simple parser for C++ files, designed to extract namespaces, classes, functions, and public variables. It returns a structured dictionary compatible with `parse_python_file`, containing `module_docstring`, `classes`, and `functions`. Each item in these lists includes its source code snippet and any leading documentation comments. The module uses line-based parsing techniques to identify class bodies, method signatures, variable declarations, and namespace definitions within C++ files.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\parser_cpp.py:_extract_block:866f14816bf7682fc43975e160a1e6c029fdfb32c42f90dc63bd1bd7df6bc97e:866f14816bf7682fc43975e160a1e6c029fdfb32c42f90dc63bd1bd7df6bc97e": "The function `_extract_block` takes a list of strings `lines` and an integer `start`. It returns a tuple containing the text of a block starting at the index `start` and the ending index of that block. The block is defined by matching braces `{}`. The function iterates through the lines, counting the number of opening and closing braces to determine when the block ends.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\parser_cpp.py:_get_preceding_comment:9dc0dd0ea6ca00b947e0b39e3d3345fc0b0d8573328dfd0679df0ae699c38492:9dc0dd0ea6ca00b947e0b39e3d3345fc0b0d8573328dfd0679df0ae699c38492": "Collects contiguous comment lines appearing before a specified index in a list of source code lines. Handles both single-line and multi-line comments, including C-style block comments. Returns the collected comments as a single string.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\parser_cpp.py:_parse_class_body:6da0b0d437618431c0d15cd5e10e2f02d44e5ff29320f02446a352fb84dbb18b:6da0b0d437618431c0d15cd5e10e2f02d44e5ff29320f02446a352fb84dbb18b": "This function `_parse_class_body` parses the body of a class from a list of source code lines. It identifies and extracts public methods and variables within the specified range (`start` to `end`). The function returns two lists: one for methods and another for variables. Each method is represented as a dictionary containing its name, signature, docstring, and source code block. Similarly, each variable is represented as a dictionary with its name, type, docstring, and line of source code. The function also handles access modifiers (`public`, `protected`, `private`) to determine the visibility of members within the class.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\parser_cpp.py:parse_cpp_file:f0c9aa731e593532cc58e55d40540c2105146eb90299e555efd7a4b16dcd4e84:f0c9aa731e593532cc58e55d40540c2105146eb90299e555efd7a4b16dcd4e84": "The function `parse_cpp_file` reads a C++ source file and extracts structured information. It identifies the module-level comment, namespace, classes, and functions within the file. For each class and function, it captures their names, signatures, docstrings, and source code blocks. The function returns a dictionary containing these parsed elements, including optional namespace information if present.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\parser_java.py:729faf96c4d338772a690be0eaf2138a3bbdae3288180abc6c0056faa4919469:729faf96c4d338772a690be0eaf2138a3bbdae3288180abc6c0056faa4919469": "A simple parser for Java files used by DocGen-LM. Extracts package, classes, public methods, and variables using naive line-based parsing. The output mirrors `parse_python_file` with keys `module_docstring`, `classes`, and `functions`. Each entry includes its source code and leading documentation comments (Javadoc or `//`).",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\parser_java.py:_extract_block:69e4c894fa7a0d0141520be4769afb89555a41a9e58cb95f19c7ac2a307961ce:69e4c894fa7a0d0141520be4769afb89555a41a9e58cb95f19c7ac2a307961ce": "This function extracts a code block from a list of lines starting at a given index. It counts the number of opening and closing braces to determine when the block ends. The extracted block is returned along with the index of the last line included in the block.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\parser_java.py:_get_preceding_comment:6d15952f453c35cc9d19982606e36e165d4a4cc794516db40536277bb5b3d62d:6d15952f453c35cc9d19982606e36e165d4a4cc794516db40536277bb5b3d62d": "The function `_get_preceding_comment` retrieves the preceding comment(s) for a given line index in a list of source code lines. It iterates backward from the specified index, collecting single-line and multi-line comments until it encounters a non-comment or reaches the beginning of the file. The collected comments are then joined into a single string and returned, stripped of any leading or trailing whitespace.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\parser_java.py:_parse_class_body:d28191340c23958f4e03301ea58cab92e899222233d899e3bcb27d18f3278fb3:d28191340c23958f4e03301ea58cab92e899222233d899e3bcb27d18f3278fb3": "The function `_parse_class_body` processes a list of source code lines to extract method and variable declarations within a class body. It identifies public methods by looking for lines that start with \"public \", contain parentheses, and end with either an opening brace or an empty block. For each identified method, it extracts the signature, docstring, and source code block. Similarly, it identifies public variables by looking for lines that declare variables without parentheses and end with a semicolon. It also extracts the type, name, docstring, and source code line for each variable. The function returns two lists containing dictionaries of methods and variables respectively.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\parser_java.py:parse_java_file:7778550b5c206b638d11ed7be5b605178853259fb8a3a5cbbfd5c7671f493179:7778550b5c206b638d11ed7be5b605178853259fb8a3a5cbbfd5c7671f493179": "The function `parse_java_file` reads a Java source file from the specified path and parses it to extract information about packages, classes, methods, and variables. It returns a dictionary containing these parsed elements along with any preceding module docstring.\n\n- The function starts by reading the entire content of the Java file into a string.\n- It then splits this content into lines for easier processing.\n- It identifies the first line that contains actual code (ignoring empty lines and comments).\n- Using this starting point, it extracts any preceding comment as the module docstring.\n- It searches through each line to identify package declarations and class definitions.\n- For each class found, it extracts the class name, docstring, methods, and variables within the class.\n- The function constructs a dictionary with keys for the module docstring, classes, functions, and optionally the package name if one is found.\n- Finally, it returns this dictionary containing all parsed information.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\parser_matlab.py:15cf90e58e5b33528fe0fc6fa2e48fa77e43bd0fed902a29ea22b67a2f78ff68:15cf90e58e5b33528fe0fc6fa2e48fa77e43bd0fed902a29ea22b67a2f78ff68": "This module provides a function `parse_matlab_file` that parses MATLAB `.m` files and extracts basic structure. It reads the file content, identifies leading comment lines as the file header, and uses a regular expression to find and extract function declarations along with their arguments. The result is returned as a dictionary containing the file header and a list of functions, each represented by its name and argument list.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\parser_matlab.py:parse_matlab_file:33bb97aec9f3658c57d85b907d756bc3ec03fd1e7414d3e44c6ecd928d959fc0:33bb97aec9f3658c57d85b907d756bc3ec03fd1e7414d3e44c6ecd928d959fc0": "The function `parse_matlab_file` reads and parses a MATLAB `.m` file to extract its basic structure. It returns a dictionary containing the file's header comments and any function declarations found within the file. Each function entry includes the function name and a list of arguments. The function uses regular expressions to identify and parse function declarations, handling both comma-separated and semicolon-separated argument lists.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\parser_python.py:9b7a83be6356666450a5a1a457ffe2e114b6726c1c43053f6e27962b7ce8f0aa:9b7a83be6356666450a5a1a457ffe2e114b6726c1c43053f6e27962b7ce8f0aa": "This module provides a parser for Python files used by DocGen-LM. It uses the `ast` module to extract structures according to the SRS. The parser can parse Python source files and return structured information about the module's docstring, classes, and functions. Each class and function is represented as a dictionary containing details such as name, signature, returns, docstring, source code, subfunctions/subclasses, and more.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\parser_python.py:_format_arg:fd2f455173f27024c3892c9e2bfd8928040324937d0717699f0a26bc56650149:fd2f455173f27024c3892c9e2bfd8928040324937d0717699f0a26bc56650149": "Formats an argument of a function or method by appending its type annotation, if available.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\parser_python.py:_format_arguments:e83b45444286ee4c301b50e5672046bc0e75782b05225b7fb80bb538cff6ae36:e83b45444286ee4c301b50e5672046bc0e75782b05225b7fb80bb538cff6ae36": "This function `_format_arguments` takes an `ast.arguments` object as input and returns a string representation of the arguments. It processes positional-only arguments, regular arguments, variable positional arguments, keyword-only arguments, and variable keyword arguments, formatting each according to its type and default value if provided. The function constructs a list of formatted argument strings and joins them with commas to form the final output.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\parser_python.py:_format_signature:f266ff041b0a14f660105aab25233b18be4724a5a551b82b4d242df39d5865ff:f266ff041b0a14f660105aab25233b18be4724a5a551b82b4d242df39d5865ff": "This function `_format_signature` takes an `ast.FunctionDef` or `ast.AsyncFunctionDef` object as input and returns a string representing the signature of the function, including its name, parameters, and return type if specified. It uses another helper function `_format_arguments` to format the parameters.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\parser_python.py:_parse_classes:978b845a0c08d833afcdb53ff6e89b5147e606885737a1f1e9b4290f5df14c89:978b845a0c08d833afcdb53ff6e89b5147e606885737a1f1e9b4290f5df14c89": "This function recursively parses all `ClassDef` nodes within a given list of AST nodes. It iterates through each node in the input list and checks if it is an instance of `ClassDef`. If so, it calls another function `parse_class` to parse the class and appends the result to a list. If the node is an instance of `FunctionDef` or `AsyncFunctionDef`, it recursively calls itself with the body of the function as the new set of nodes to parse. Finally, it returns the list of parsed classes.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\parser_python.py:parse_class:5f64d74f7e284d138523892efd2030c38936e3faf45b8a57e8a4355842d34fd5:5f64d74f7e284d138523892efd2030c38936e3faf45b8a57e8a4355842d34fd5": "This function `parse_class` takes an AST node representing a class definition and the source code as input. It returns a dictionary containing information about the class, including its name, docstring, methods, subclasses, and source code segment. The function iterates through the body of the class to identify and parse any nested functions or asynchronous functions, adding them to the \"methods\" list in the returned dictionary. It also recursively parses any nested classes using `_parse_classes` and adds them to the \"subclasses\" list.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\parser_python.py:parse_classes:008df9fe565e4ecc94eecdb07e5ef3a732dde55fc5cb9a0e70a35f93245e6657:008df9fe565e4ecc94eecdb07e5ef3a732dde55fc5cb9a0e70a35f93245e6657": "This function is a public wrapper for `_parse_classes`, designed to parse classes from an abstract syntax tree (AST) node. It takes two parameters: `node`, which is an AST node, and `source`, which is the source code as a string. The function retrieves the body of the node using `getattr` and passes it along with the source code to `_parse_classes`.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\parser_python.py:parse_function:f76f326408c5c100b705bd44ff52983a7790c05f73a19f7ae83de48eec76eafe:f76f326408c5c100b705bd44ff52983a7790c05f73a19f7ae83de48eec76eafe": "This function `parse_function` takes an AST node representing a function or asynchronous function and the source code as input. It returns a dictionary containing details about the function, including its name, signature, return type, docstring, source code segment, subfunctions, and subclasses.\n\nThe function initializes a dictionary `func_info` with keys for each piece of information to be extracted. It then iterates over the body of the function node, checking for nested functions or asynchronous functions and recursively calling `parse_function` on them to add their details to `subfunctions`. Additionally, it calls `_parse_classes` to extract any subclasses within the function's body and adds them to `subclasses`.\n\nThe dictionary is populated with formatted signature using `_format_signature`, docstring extracted by `ast.get_docstring`, source code segment using `ast.get_source_segment`, and return type if available. Finally, the function returns the populated dictionary containing all relevant information about the function and its nested structures.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\parser_python.py:parse_python_file:0fd5d2fc5f951630966bfa1acf6ee353d0a342ff28fe1678ff3ab130d7e0a3c4:0fd5d2fc5f951630966bfa1acf6ee353d0a342ff28fe1678ff3ab130d7e0a3c4": "The function `parse_python_file` reads a Python source file and extracts structured information including the module docstring, classes, and functions. It uses the `ast` module to parse the source code into an abstract syntax tree (AST) and then iterates through the AST nodes to identify and extract relevant information. The extracted data is returned as a dictionary.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\reviewer.py:4f9d422499a1acff78c67b05122179a409cbacd25a4c242442e0aef707dbeb81:4f9d422499a1acff78c67b05122179a409cbacd25a4c242442e0aef707dbeb81": "This module provides a tool to review HTML documentation generated by DocGen-LM. It includes functions to check for assistant-like phrases, contradictions, and hallucinations in the HTML content. The `review_directory` function processes all `.html` files in a specified directory, applying these checks and optionally fixing issues by sanitizing paragraphs using a `sanitize_summary` function from an external library (`llm_client`). The tool can be run from the command line with options to specify the directory path and enable autofix mode.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\reviewer.py:_extract_tags:09cf43209218c0a1919ec079ff47b0d761583089fa4b732ec30e22da253a0841:09cf43209218c0a1919ec079ff47b0d761583089fa4b732ec30e22da253a0841": "The function `_extract_tags` extracts the content within HTML tags of a specified type from a given HTML string. It uses a regular expression pattern to match opening and closing tags of the specified type, capturing the text between them. The function returns a list of strings, each representing the content of one tag instance found in the input HTML.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\reviewer.py:_find_line_number:90ca3734eeb5b7d98414f54e8fcfbfe9fe8ca85e1a9291e6bb7f677262495f74:90ca3734eeb5b7d98414f54e8fcfbfe9fe8ca85e1a9291e6bb7f677262495f74": "The function `_find_line_number` searches for a specific phrase within an HTML string and returns the line number where the phrase is found. If the phrase is not found, it returns -1. The search is case-insensitive.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\reviewer.py:_is_generated_html:fb0cf39fac8463c71847c5a1c76847dfb6b84ad21361fcf8db00dfeaf49c9113:fb0cf39fac8463c71847c5a1c76847dfb6b84ad21361fcf8db00dfeaf49c9113": "Function `_is_generated_html` checks if a given string `text` appears to be output from the DocGen-LM tool. It returns `True` if the text contains specific markers indicating it is generated by DocGen-LM, such as \"Generated by DocGen-LM\", an HTML header for project documentation, or headers for classes and methods.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\reviewer.py:_review_file:a2ce0d1ae33eb9cf6a301a98d05c0559e39fe53f9f6fd6b1bd029f6a9179b353:a2ce0d1ae33eb9cf6a301a98d05c0559e39fe53f9f6fd6b1bd029f6a9179b353": "The function `_review_file` takes a file path and an optional boolean flag `autofix`. It reads the HTML content of the file. If the HTML is not generated by the tool, it returns an empty list. Otherwise, it checks for assistant phrasing, contradictions, and hallucinations in the HTML. For each issue found, it appends a formatted string to the results list indicating the type of issue and the file name. If `autofix` is True and there are issues, it sanitizes the paragraphs in the HTML and writes the modified content back to the file. Finally, it returns the list of issues.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\reviewer.py:_sanitize_paragraphs:0af7fed2a27b04e66b2181a2896f09a79dd82f0034bbf277ecfecfb4d25ff738:0af7fed2a27b04e66b2181a2896f09a79dd82f0034bbf277ecfecfb4d25ff738": "The function `_sanitize_paragraphs` takes an HTML string as input and sanitizes the content within paragraph tags. It uses a regular expression to find all paragraph elements (`<p>...</p>`) and applies a replacement function `repl` to each match. The replacement function strips any HTML from the text within the paragraph, sanitizes it using another function `sanitize_summary`, and then wraps the sanitized text back in paragraph tags. This ensures that the content within paragraphs is clean and properly formatted for display.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\reviewer.py:_strip_html:f803eb07c61b93ce19067cb61bafd5fe16636ac60fe81e359b97e93229afab42:f803eb07c61b93ce19067cb61bafd5fe16636ac60fe81e359b97e93229afab42": "The function `_strip_html` takes a string `text` as input and returns a new string with all HTML tags removed. It uses the `re.sub` function from the `re` module to substitute any sequence of characters enclosed in angle brackets (`<...>`) with an empty string, effectively stripping away HTML markup.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\reviewer.py:check_assistant_phrasing:7d29aee2ca43ee670cab2effdcc423bab6bdccddd09d3516d00f34b3e6968a3f:7d29aee2ca43ee670cab2effdcc423bab6bdccddd09d3516d00f34b3e6968a3f": "This function `check_assistant_phrasing` takes an HTML string as input and returns a list of phrases that resemble assistant-like language found within paragraph tags (`<p>`). It uses helper functions `_extract_tags`, `_strip_html`, and `_find_line_number` to process the HTML content. The function iterates over each paragraph, strips any HTML tags, converts the text to lowercase for case-insensitive comparison, and checks if any predefined assistant-like phrases are present. If a match is found, it appends the phrase along with its line number in the original HTML to the findings list.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\reviewer.py:check_contradictions:ae0b9001f82af7eb2373ddef1ebbd103012135430fa5718e7ca43989bfc015a4:ae0b9001f82af7eb2373ddef1ebbd103012135430fa5718e7ca43989bfc015a4": "Function `check_contradictions` analyzes HTML content to identify contradictions between the text and structure of a documentation page. It extracts paragraphs, methods, functions, and classes from the HTML. The function checks if the summary text claims there are no methods, functions, or classes but finds evidence of their presence in the HTML structure. If such contradictions are found, it returns a list of descriptions detailing these contradictions.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\reviewer.py:check_hallucinations:904ace42ce2ef7cbc3a1e55cf3826190ee836b310451eba7e57ffb5e9597f57e:904ace42ce2ef7cbc3a1e55cf3826190ee836b310451eba7e57ffb5e9597f57e": "The function `check_hallucinations` takes a string of HTML as input and returns a list of hallucination phrases detected within the HTML. It extracts all paragraph tags (`<p>`) from the HTML, strips away any HTML tags, converts the text to lowercase, and then checks if any predefined hallucination terms are present in the text. If a term is found, it is added to the list of findings, which is returned at the end of the function.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\reviewer.py:main:76779e14792998c8f5573597f84eca63fbf3b9c938d707509b0323cbaf675e16:76779e14792998c8f5573597f84eca63fbf3b9c938d707509b0323cbaf675e16": "The `main` function serves as the entry point for a command-line tool designed to review and optionally fix issues in HTML documentation generated by DocGen-LM. It accepts an optional list of arguments (`argv`) and performs the following tasks:\n\n1. Creates an argument parser with a description explaining the purpose of reviewing generated HTML documentation.\n2. Adds a required positional argument `directory` to specify the path to the HTML output directory that needs review.\n3. Adds an optional boolean flag `--autofix` which, when set, instructs the tool to automatically rewrite files to fix identified issues.\n4. Parses the provided arguments using the parser and stores them in the `args` object.\n5. Calls the `review_directory` function with the specified directory path and the autofix option.\n6. Returns an integer value of 0, indicating successful execution of the main function.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\reviewer.py:review_directory:430b4a283ff19f8580cd110215fbf65930332ba741683a127f2e99464417f916:430b4a283ff19f8580cd110215fbf65930332ba741683a127f2e99464417f916": "The function `review_directory` takes a directory path and an optional boolean flag `autofix`. It recursively iterates over all `.html` files within the specified directory. For each file, it attempts to review the file using the `_review_file` function with the provided `autofix` parameter. If successful, it prints each line of the results. If an exception occurs during the review process, it catches the exception, prints an error message indicating the file and the exception details, and continues to the next file.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\scanner.py:6210e016d08894b6184435dc7131442b805e20911384fe72a5f4ef374fffa93d:6210e016d08894b6184435dc7131442b805e20911384fe72a5f4ef374fffa93d": "The module implements a function to recursively discover source files of specific types (`.py`, `.m`, `.cpp`, `.h`, `.java`) within a given directory. It includes an ignore mechanism based on relative paths, allowing certain directories or files to be excluded from the search. The function returns a sorted list of absolute paths to the discovered source files.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\scanner.py:_is_subpath:46275a3a56393afdd358826030f50e96a344ef3e3d8fbd89cb0192f065c26d02:46275a3a56393afdd358826030f50e96a344ef3e3d8fbd89cb0192f065c26d02": "This function checks whether a given `path` is equal to or a subdirectory of another `parent` directory. It uses the `relative_to` method from Python's `Path` class, which raises a `ValueError` if `path` is not related to `parent`. The function returns `True` if no exception is raised, indicating that `path` is within `parent`, and `False` otherwise.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\scanner.py:scan_directory:fd8e0b91afb6b3ca918a2c7288b3a267a6d7ce93118deb8c9e96c9449ac7c914:fd8e0b91afb6b3ca918a2c7288b3a267a6d7ce93118deb8c9e96c9449ac7c914": "The function `scan_directory` recursively discovers source files with extensions `.py`, `.m`, `.cpp`, `.h`, and `.java` under a specified base directory. It skips directories listed in the `ignore` parameter and any internal `.git` folders. The function returns a sorted list of absolute paths to these discovered source files.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\setup.py:501f48f7d373462af3d41b0caf7d7e23e2a79c5fe2886cf307b86c01a8b8d82f:501f48f7d373462af3d41b0caf7d7e23e2a79c5fe2886cf307b86c01a8b8d82f": "This Python script uses `setuptools` to define a package with three modules: `explaincode`, `parser_cpp`, and `parser_java`. The `setup()` function is called directly when the script is executed, which configures and installs the specified modules.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\summarize_utils.py:_summarize:ea70c0956489d84c294871e10c1ea8f144a924b677599915dcf339f6f64871ab:ea70c0956489d84c294871e10c1ea8f144a924b677599915dcf339f6f64871ab": "This function `_summarize` takes in an `LLMClient`, a `ResponseCache`, a `key`, `text`, and a `prompt_type`. It attempts to retrieve a cached summary using the provided key. If a cached summary exists, it returns that. Otherwise, it generates a new summary using the LLM client with the given text and prompt type, caches this new summary under the specified key, and then returns it.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\summarize_utils.py:dfc94899d582f733d44e86f9d4150162786fe35452be561882e6039626bba1de:dfc94899d582f733d44e86f9d4150162786fe35452be561882e6039626bba1de": "This module provides functions for summarizing text using a language model client and caching responses. It includes:\n\n1. `_summarize`: Summarizes text directly if it fits within the context token limit, otherwise raises an exception.\n2. `summarize_chunked`: Sums up text by breaking it into chunks if necessary, then recursively merges summaries of these chunks into a single technical paragraph.\n\nBoth functions utilize a caching mechanism to store and retrieve previously computed summaries, reducing redundant computations.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\summarize_utils.py:summarize_chunked:44265b337b82e647d0ee1d51d95d65ec2bf529a468a5d2adc6ff5c9af8cbe488:44265b337b82e647d0ee1d51d95d65ec2bf529a468a5d2adc6ff5c9af8cbe488": "Summarizes text by chunking if necessary, using an LLM client and response cache. Handles tokenization, overhead calculation, and recursive merging of summaries to fit within context limits.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_cache.py:97b2ae8f04e70da29a7fb5d7cb91652ea871818ccc183154b3320347b5835642:97b2ae8f04e70da29a7fb5d7cb91652ea871818ccc183154b3320347b5835642": "This module defines two tests for a `ResponseCache` class. The first test, `test_cache_round_trip`, checks that data can be correctly set and retrieved from the cache file. It uses a temporary path to create a cache file, sets a key-value pair in the cache, reads it back, and asserts that the value matches the expected summary.\n\nThe second test, `test_cache_get_missing`, verifies that attempting to retrieve a non-existent key from the cache returns `None`. It creates an empty cache file, attempts to get a value for a missing key, and asserts that the result is `None`.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_cache.py:test_cache_get_missing:2bde0dd9ff6db864e61e9040616d1140b6d6ceb07d596a6186f9fa491aa954dc:2bde0dd9ff6db864e61e9040616d1140b6d6ceb07d596a6186f9fa491aa954dc": "This function tests the `get` method of the `ResponseCache` class. It creates a temporary directory and initializes a `ResponseCache` object with a path to a JSON file in that directory. The test asserts that calling the `get` method with a key (\"unknown\") that does not exist in the cache returns `None`.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_cache.py:test_cache_round_trip:4bee238aafcf2741af2aa5bce31f04ae712bf5b4d445bf6501d90c9049d9c958:4bee238aafcf2741af2aa5bce31f04ae712bf5b4d445bf6501d90c9049d9c958": "This function tests the round-trip functionality of a response cache. It creates a temporary file to store the cache and initializes a `ResponseCache` object with this file path. The function then sets a cache entry for a specific key (\"file.py\", \"content\") with the value \"summary\". After saving the cache, it reloads it from the same file and asserts that retrieving the cached value using the same key returns the expected \"summary\".",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_chunk_utils.py:d2a16b3c3609200d2d6d0ef21f64bf5274294b26300f2f0821797948f0587063:d2a16b3c3609200d2d6d0ef21f64bf5274294b26300f2f0821797948f0587063": "The module defines several test functions to validate the functionality of `get_tokenizer` and `chunk_text`. The tests ensure that:\n\n1. The tokenizer correctly encodes and decodes text.\n2. The text is chunked appropriately without losing content.\n3. Markdown headings are split into separate chunks.\n4. Code blocks are preserved across chunk boundaries.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_chunk_utils.py:test_chunk_text_preserves_code_blocks:1afbe9ccc830a59e5ef6bdeb33353cf3f4c147957dd2073a2e2647e68b03f7f7:1afbe9ccc830a59e5ef6bdeb33353cf3f4c147957dd2073a2e2647e68b03f7f7": "This function tests that code blocks are preserved when text is chunked. It uses a tokenizer to split the input text into manageable pieces while ensuring that any code blocks remain intact. The test checks if the specific code block \"```python\\nprint('hi')\\n```\" is present in any of the chunks and verifies that each chunk contains an even number of backticks, indicating the start and end of code blocks.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_chunk_utils.py:test_chunk_text_reconstructs_content:d8e969522c274d8030e17e48ee364ec6f0876bc60bd999e32d86184364b93ef5:d8e969522c274d8030e17e48ee364ec6f0876bc60bd999e32d86184364b93ef5": "This function tests the `chunk_text` method by splitting a long string into smaller chunks and then reconstructing them to ensure that the original content is preserved. It uses a tokenizer obtained from `get_tokenizer()` to determine how to split the text, with each chunk having a maximum length of 10 tokens. The test asserts that the concatenated chunks match the original text (ignoring leading/trailing whitespace) and that there are more than one chunk created.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_chunk_utils.py:test_chunk_text_splits_markdown_headings:365bfd1d621d70f412d302fc02b3b4a05f962c70a9adc470406ebf42590664c7:365bfd1d621d70f412d302fc02b3b4a05f962c70a9adc470406ebf42590664c7": "The function `test_chunk_text_splits_markdown_headings` tests the `chunk_text` function to ensure it correctly splits text into chunks based on a tokenizer, with specific focus on splitting at Markdown headings. It uses a predefined text containing two Markdown headings (`# H1` and `# H2`) and asserts that the resulting chunks are split appropriately, with each chunk starting with a heading.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_chunk_utils.py:test_get_tokenizer_roundtrip:21827997436da1d6d49217597d1c5495f9368b1a27a9922042a6e1ebd61737c9:21827997436da1d6d49217597d1c5495f9368b1a27a9922042a6e1ebd61737c9": "This function tests the round-trip encoding and decoding of a tokenizer. It retrieves a tokenizer instance using `get_tokenizer()`, encodes a sample text \"hello world\" into tokens, asserts that the result is a list, decodes the tokens back to text, and asserts that the decoded text matches the original, stripped of any leading or trailing whitespace.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_docgenerator.py:bd93d1343982129d654c006ec965a99e35d08b1cc647b7560f7fcc9a9e98b43b:bd93d1343982129d654c006ec965a99e35d08b1cc647b7560f7fcc9a9e98b43b": "The module contains unit tests for a code documentation generator. It uses the `unittest.mock` library to patch dependencies and test various scenarios, such as handling invalid Python files, generating summaries for classes and functions, skipping non-UTF8 files, and processing different programming languages like C++, Java, and Python. The tests ensure that the generator correctly identifies and processes different types of code elements while skipping or sanitizing problematic files.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_docgenerator.py:test_chunking_accounts_for_prompt_overhead:bcfac671eeb625e53f43536a6c1a68300fae3964a9626601b6f107cdb6b6ac2a:bcfac671eeb625e53f43536a6c1a68300fae3964a9626601b6f107cdb6b6ac2a": "The function `test_chunking_accounts_for_prompt_overhead` tests the chunking functionality of code summaries by ensuring that the system prompt and template overhead is accounted for when determining the maximum context tokens. It uses a mock to verify that the `_summarize` function is called more than once, indicating that the text has been successfully chunked.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_docgenerator.py:test_clean_output_dir:fa8503c87db5b430b56c0d831e4164aa811be269c5f8244c1d852e7f1c3f0a4c:fa8503c87db5b430b56c0d831e4164aa811be269c5f8244c1d852e7f1c3f0a4c": "The function `test_clean_output_dir` tests the `clean_output_dir` function from the `docgenerator` module. It creates a temporary directory, generates an HTML file with a specific comment, and another HTML file without any comment. A CSS file is also created. The `clean_output_dir` function is then called with the path to the temporary directory as an argument. After the function call, it asserts that the generated HTML file no longer exists, while the custom HTML file and the CSS file still exist.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_docgenerator.py:test_generates_class_and_function_summaries:7f9bd877ee8c67ab85580f40136e23690e7e239a0fbc0e1e69b42f04e581c796:7f9bd877ee8c67ab85580f40136e23690e7e239a0fbc0e1e69b42f04e581c796": "This function `test_generates_class_and_function_summaries` tests the generation of class and function summaries using a mock LLM client. It creates a temporary project directory with a Python module containing a class and a function, then invokes the main function with specified output directory. The mock client is configured to return predefined summaries for different components. After running the main function, it asserts that the correct summaries are generated and written to HTML files in the output directory.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_docgenerator.py:test_handles_class_without_docstring:f17673b288e96fa9ac7fca97cdf22702f0e33b859db864fbb3a1ba5417599e37:f17673b288e96fa9ac7fca97cdf22702f0e33b859db864fbb3a1ba5417599e37": "The function `test_handles_class_without_docstring` tests the handling of a Python class without a docstring by creating a temporary project directory, writing a Python file with an empty class definition, and then running the main function with the project directory as input. It uses a mock LLMClient to simulate responses for summarizing the module, project, and class. The test asserts that the return value of the main function is 0 and that the generated HTML file contains the class summary.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_docgenerator.py:test_merge_recurses_when_prompt_too_long:fb228f091dac709d076e8503f8d85bf258d71407c4e105f0fd4288054ca45c77:fb228f091dac709d076e8503f8d85bf258d71407c4e105f0fd4288054ca45c77": "The function `test_merge_recurses_when_prompt_too_long` tests the behavior of merging recursive summaries when the prompt exceeds a certain length. It uses a fake summarization function to simulate responses and asserts that the merge calls are made multiple times for docstrings. The test ensures that the system can handle long prompts by recursively breaking them down into manageable chunks.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_docgenerator.py:test_processes_cpp_file:30387860f74bda12d2cbf3c39588735be772e545c38a37cc0c4bec905c4267e2:30387860f74bda12d2cbf3c39588735be772e545c38a37cc0c4bec905c4267e2": "The function `test_processes_cpp_file` is designed to test the processing of a C++ file using the DocGen-LM project. It creates a temporary directory, simulates the presence of a C++ source file within it, and sets up mock objects for parsing the file and interacting with an LLM client. The function then calls the `main` function with the specified project directory and output location, asserting that the return value is 0 (indicating success) and that the mock parse function was called exactly once. Finally, it checks that an HTML file has been created in the output directory.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_docgenerator.py:test_processes_java_file:6b032411ee2be59ccb1c2c6a3418026cc7aa0de88ff820782c4d722281da3933:6b032411ee2be59ccb1c2c6a3418026cc7aa0de88ff820782c4d722281da3933": "This function `test_processes_java_file` tests the process of generating documentation for a Java file using the DocGen-LM tool. It sets up a temporary project directory with a single Java file named `Mod.java`. The function then mocks the parsing and LLM summarization processes, asserting that the `main` function returns 0 upon successful execution. Finally, it checks if the output HTML file for the Java class exists in the specified output directory.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_docgenerator.py:test_project_summary_is_sanitized:0f8456e625c1362da56a1d1176bb696f4f1330858a9413a86c3f59671aa00f6e:0f8456e625c1362da56a1d1176bb696f4f1330858a9413a86c3f59671aa00f6e": "The function `test_project_summary_is_sanitized` is a unit test that verifies the sanitization of project summaries generated by the DocGen-LM tool. It creates a temporary project directory with a Python module, invokes the main function with this project directory and an output directory, and asserts that the generated HTML does not contain certain unwanted strings while ensuring that the LLMClient's `summarize` method is called appropriately for different entities in the project (module, project, function).",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_docgenerator.py:test_readme_summary_used:28e48f499b83ff856db515c9d6a7fdf637be956180fbe4ede0ae9b031d00e47c:28e48f499b83ff856db515c9d6a7fdf637be956180fbe4ede0ae9b031d00e47c": "The function `test_readme_summary_used` tests the generation of documentation for a project that includes a README file. It creates a temporary project directory with a Python module and a README file, then uses a mock LLM client to simulate summarization of the README content. The function asserts that the main command returns 0 (indicating success) and checks if the generated HTML output contains a summary of the README.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_docgenerator.py:test_single_long_partial_is_recursively_chunked:f3317ecffc01fc5039a83efd2284161c788769c64fccb0dc0cd32e809b737c92:f3317ecffc01fc5039a83efd2284161c788769c64fccb0dc0cd32e809b737c92": "This function tests the recursive chunking of a single long partial text using a local language model (LLM). It sets up a fake summarization function to simulate responses from the LLM and then calls `summarize_chunked` with specific parameters. The test asserts that the number of calls made to the fake summarization function for docstring prompts is greater than one, indicating successful recursive chunking.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_docgenerator.py:test_skips_invalid_python_file:0184094ce35bf3d5ceba23489ec2c98fb4ed858b6d8d3e5dfd39d175fd10ce07:0184094ce35bf3d5ceba23489ec2c98fb4ed858b6d8d3e5dfd39d175fd10ce07": "The function `test_skips_invalid_python_file` tests the behavior of a documentation generation tool when encountering an invalid Python file. It creates a temporary project directory with an invalid Python file (`bad.py`) that contains a syntax error due to a leading zero in a numeric literal. The function then runs the main documentation generation command, mocking an LLM client to return a summary for valid files and asserting that the process completes successfully (return code 0). After execution, it verifies that only the index page is generated in the output directory, while the invalid file's documentation is not created.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_docgenerator.py:test_skips_non_utf8_file:5a630460f68d0f1abea46bf55b7543656d11f1b2e5916d4932652110146ffa8f:5a630460f68d0f1abea46bf55b7543656d11f1b2e5916d4932652110146ffa8f": "The function `test_skips_non_utf8_file` tests the behavior of a documentation generation tool when encountering non-UTF-8 encoded files. It creates a temporary project directory with a file that contains non-UTF-8 bytes, then runs the main function of the documentation generator with this project directory and an output directory specified. The test uses a mock LLM client to simulate successful ping and summary responses. After running the main function, it asserts that the tool skips generating documentation for the non-UTF-8 file and successfully generates documentation for other files in the project, creating an `index.html` file but not a `bad.html` file.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_docgenerator.py:test_structured_chunker_keeps_functions_atomic:ddbf9c6501d37af87f0773840b00d51d8583df73aec988ed7480a92ade0b5010:ddbf9c6501d37af87f0773840b00d51d8583df73aec988ed7480a92ade0b5010": "This function tests the `test_structured_chunker_keeps_functions_atomic` method, which ensures that functions are kept atomic during chunking. It uses a temporary path to create a Python file with two functions, parses it using the `parse_python_file` function from the `parser_python` module, and then chunks the text using the `_summarize_module_chunked` function from the `docgenerator` module. The test asserts that the number of chunks is equal to the number of functions and that each chunk contains a unique function source code.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_docgenerator.py:test_structured_chunker_splits_large_class_by_method:2697b875308bef6796897917d73f2c1232c23cfad35a1e98da96161f4742f2aa:2697b875308bef6796897917d73f2c1232c23cfad35a1e98da96161f4742f2aa": "This function tests the `test_structured_chunker_splits_large_class_by_method` from a project that generates and summarizes documentation from source code. It uses a temporary path to create a Python file with a class containing two methods. The function parses this file, sets up a tokenizer and cache, and then simulates calling `_summarize_module_chunked` with a mock client. It asserts that the number of chunks created matches the number of methods in the class and that each chunk corresponds to one method's source code.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_docgenerator.py:test_subclass_methods_are_summarized:eaccd257fc5212340ea7311ff66651da16cd5cc9e30a5c4f52ba5e2c170f429a:eaccd257fc5212340ea7311ff66651da16cd5cc9e30a5c4f52ba5e2c170f429a": "This function tests that subclass methods are summarized correctly. It creates a temporary project directory with a nested class structure and a method within the subclass. The function then patches the LLMClient to simulate successful pinging and returns predefined summaries for summarization functions. Finally, it asserts that the method name \"B:m\" is called during the chunked summarization process.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_docgenerator.py:test_summarize_chunked_splits_long_text:6be5b530e1ad9b2ba3a2c464161558fde625ca7c3d389f8d2b5d5b1274f873ae:6be5b530e1ad9b2ba3a2c464161558fde625ca7c3d389f8d2b5d5b1274f873ae": "This function tests the `summarize_chunked` utility by mocking the `_summarize` method to return a fixed summary. It uses a tokenizer, a cache, and a temporary path for caching responses. The test ensures that the `summarize_chunked` function is called multiple times when processing a long text, demonstrating its ability to handle chunking based on token limits.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_docgenerator_subclasses.py:77a42c49a04297507d96ac281add639b0c5692b2d65f55a79c7ca6a88ffafbb8:77a42c49a04297507d96ac281add639b0c5692b2d65f55a79c7ca6a88ffafbb8": "The module defines a test function `test_subclass_docs_and_method_summary` that uses the `unittest.mock.patch` to mock an `LLMClient` from the `docgenerator` module. It sets up a temporary project directory with a Python file containing a class `A` with a nested class `B` and a method `m`. The test calls the `main` function from `docgenerator` with the project directory path and an output directory path. It asserts that the return value of `main` is 0, indicating success. The test then reads the generated HTML file in the output directory and checks for specific strings related to class and method summaries.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_docgenerator_subclasses.py:test_subclass_docs_and_method_summary:6d571e4cd125b5c4bfb434f45260acbf279e291353503f36058eaf9a1c57ca48:6d571e4cd125b5c4bfb434f45260acbf279e291353503f36058eaf9a1c57ca48": "This function, `test_subclass_docs_and_method_summary`, tests the generation of documentation for subclasses and methods using a local language model (LLM). It creates a temporary project directory with a nested class structure in Python. The function then uses a mock LLM client to simulate responses during the documentation generation process. After running the main function with the specified project directory and output location, it checks if the generated HTML file contains summaries for the subclass `B` and its method `m`.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:_create_fixture:c44136c3c4f6a5abfda4b2d4ac17219618828f1deb9d9ae3c529d222e9c8ba87:c44136c3c4f6a5abfda4b2d4ac17219618828f1deb9d9ae3c529d222e9c8ba87": "Creates a temporary directory structure with nested subdirectories and files. Generates an HTML file in the nested directory, a README.md file with structured content, and a sample JSON file.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:_mock_llm_client:7a58f16d799e3a01b31964e47fa91ae1d656713fa428864651be743bb5ad8f10:7a58f16d799e3a01b31964e47fa91ae1d656713fa428864651be743bb5ad8f10": "This function `_mock_llm_client` returns an object that simulates a client for interacting with a language model (LLM). The returned object has a method `summarize` which takes three parameters: `text`, `prompt_type`, and an optional `system_prompt`. When called, this method returns a predefined summary string formatted using `textwrap.dedent`. The summary includes sections such as Overview, Purpose & Problem Solving, How to Run, Inputs, Outputs, System Requirements, and Examples. This mock LLM client is intended for testing or demonstration purposes where an actual LLM interaction is not required.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:b255f1cfcf5befe8f902b371186dba71f3dfbd8c11c42e932622e99a953d6bf9:merge0:552244a6cef4331800c627750f632f5d10b5699a4e54b92961a4fed668ea5d2c": "The code defines several functions and tests for creating documentation summaries, extracting text from files, rendering HTML, and handling different file formats. It includes a fixture creation function `_create_fixture`, a mock LLM client `_mock_llm_client`, and various test functions to ensure the functionality works as expected. The tests cover Markdown, HTML, and DOCX file processing, as well as PDF output generation. Additionally, there are functions for inferring sections from text, detecting placeholders, parsing manual content, validating references, and extracting snippets from code files. The module also contains several test functions for a code documentation tool, testing aspects such as categorizing code snippets, ranking code files, filling placeholders in user manuals, and handling various command-line options. These tests use `pytest` fixtures to set up temporary directories and mock objects for dependencies like file operations and external API calls. Furthermore, the module includes test functions for a summarization process, covering chunking, merging, caching, and large text handling. These tests utilize a mock client to simulate LLM calls and validate system behavior under different conditions.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:b255f1cfcf5befe8f902b371186dba71f3dfbd8c11c42e932622e99a953d6bf9:part0:5516db775b429103a40dd2a03a766cbe0e39e0bdb1b12007edef2db075c1950b": "The code defines several functions and tests for creating documentation summaries, extracting text from files, rendering HTML, and handling different file formats. It includes a fixture creation function `_create_fixture`, a mock LLM client `_mock_llm_client`, and various test functions to ensure the functionality works as expected. The tests cover Markdown, HTML, and DOCX file processing, as well as PDF output generation. Additionally, there are functions for inferring sections from text, detecting placeholders, parsing manual content, validating references, and extracting snippets from code files.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:b255f1cfcf5befe8f902b371186dba71f3dfbd8c11c42e932622e99a953d6bf9:part1:f6168ffd0c53de3b16c7a9eebf313f1905a2585db880dd3c97d8a20c97080ce6": "The module contains several test functions for a code documentation tool. Each function tests different aspects of the tool's functionality, such as categorizing code snippets, ranking code files, filling placeholders in user manuals, and handling various command-line options. The tests use `pytest` fixtures to set up temporary directories and mock objects for dependencies like file operations and external API calls.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:b255f1cfcf5befe8f902b371186dba71f3dfbd8c11c42e932622e99a953d6bf9:part2:6bbe7d26a85f376316a924b9f7e5d33cb08b1ccb650e5cc867902d439ce763e3": "The module contains several test functions for a summarization process. Each function tests different aspects of the summarization logic, including chunking, merging, caching, and handling of large texts. The tests use a mock client to simulate LLM (Large Language Model) calls and verify that the system behaves as expected under various conditions.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:test_cached_chunks_reused:ced08b603338e8c4ed9ba835610c537574e9ba98d67878d6957c6820335ca409:ced08b603338e8c4ed9ba835610c537574e9ba98d67878d6957c6820335ca409": "This function tests the reuse of cached chunks when summarizing text. It creates a dummy class `Dummy` with a `summarize` method that records its calls and returns a response based on the call count. The function then uses a `ResponseCache` to cache responses. It first summarizes a large text using `manual_utils._summarize_manual` with a `Dummy` client, which results in three calls to `summarize`. When summarizing the same text again, it reuses the cached response instead of making additional calls, as evidenced by the assertion that `len(client2.calls)` is 0.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:test_chunk_edit_hook_applied:2aef2bb45aa084a57b50b3a11554af2a9dd18ceeab01ec20f1625ce8748c738b:2aef2bb45aa084a57b50b3a11554af2a9dd18ceeab01ec20f1625ce8748c738b": "The function `test_chunk_edit_hook_applied` tests the `_summarize_manual` utility with a custom hook for chunk editing. It creates a dummy client to simulate LLM interactions and a cache to store responses. The text is split into chunks, each processed by the hook which converts them to uppercase. The final chunk is summarized using the dummy client's `summarize` method, which handles a specific system prompt by returning \"final\". The test asserts that the result matches the expected output and that the last call to the client's `summarize` method has the modified text in uppercase.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:test_chunking_none_no_llm_calls:4635a8642ce2b273138cc79781ae5fa567ad506266869398fb9b1cc4bb213c5e:4635a8642ce2b273138cc79781ae5fa567ad506266869398fb9b1cc4bb213c5e": "This function tests the behavior of a code summarization tool when chunking is disabled and no LLM calls are expected. It creates a large text file, sets up a mock LLM client that records its calls, and runs the main function with specific arguments. The test asserts that the LLM client was called five times and that the first call includes \"Overview\" in the system prompt.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:test_chunking_triggers_multiple_calls_and_logs:adcba05b1856c7e024a7db10dee82ce06c5157f488b19b5398f0d2c7d79c1484:adcba05b1856c7e024a7db10dee82ce06c5157f488b19b5398f0d2c7d79c1484": "This function tests the chunking and summarization process for a given text. It creates a dummy client that records its calls to summarize text based on system prompts. The test provides two paragraphs of text, each repeated 2000 times. The function then uses `manual_utils._summarize_manual` with a dummy client, response cache, and auto-chunking enabled. The result is compared to \"final\", indicating successful merging. The test asserts that the client was called three times: twice with chunk prompts and once with a merge prompt. It also checks that the merge call includes both paragraphs of text. Additionally, it verifies that debug logs are captured, confirming the chunking and merging steps.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:test_collect_docs_filters:24771abf73382ad0db01ab9e23b9ce12fc9e93985d3b843d27d9b50ac085b3f0:24771abf73382ad0db01ab9e23b9ce12fc9e93985d3b843d27d9b50ac085b3f0": "The function `test_collect_docs_filters` tests the `collect_docs` function from the `explaincode` module. It creates a temporary directory with various files, including Markdown and text files. The `collect_docs` function is expected to filter out non-Markdown files and return only those named \"keep.md\". The test asserts that \"keep.md\" is in the set of collected file names and that \"skip.txt\" is not included.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:test_custom_output_directory:2af87ac6281ad35fcb74143103b3e1cf85817ccd8bd8d3fa3029b8ef1ead56c3:2af87ac6281ad35fcb74143103b3e1cf85817ccd8bd8d3fa3029b8ef1ead56c3": "This function tests the functionality of generating documentation in a custom output directory. It creates a fixture using `_create_fixture` and sets up a mock LLM client with `_mock_llm_client`. The `main` function is then called with the specified input path and custom output directory. The test asserts that the expected HTML file (`user_manual.html`) and JSON evidence file (`user_manual_evidence.json`) exist in the custom output directory.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:test_custom_title_and_filename:12441f2cd8af6540e4328f30bbac5910c9128ca19308b157cae2c62c78f69116:12441f2cd8af6540e4328f30bbac5910c9128ca19308b157cae2c62c78f69116": "This function tests the generation of a custom title and filename for HTML documentation using the `explaincode` tool. It creates a temporary directory, sets up a mock LLM client, runs the main function with specified path and title, and asserts that the output file and evidence JSON exist. The output file should contain an `<h1>` tag with the text \"Fancy Guide\".",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:test_detect_placeholders:4fcee383a846c10a418fce8beb39bfd0444c6bff45a94350850ad885162b60eb:4fcee383a846c10a418fce8beb39bfd0444c6bff45a94350850ad885162b60eb": "The function `test_detect_placeholders` tests the `explaincode.detect_placeholders` method. It provides a string containing placeholders for an overview and outputs, and asserts that the detected placeholders match the expected set of missing elements.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:test_docs_index_default_and_injection:45cd0e164c98d73042e8d8ff1cbdfa2fedd8b75dc2f519ba9dd3519cac853108:45cd0e164c98d73042e8d8ff1cbdfa2fedd8b75dc2f519ba9dd3519cac853108": "This function `test_docs_index_default_and_injection` tests the creation of documentation index files and manual insertion. It uses a temporary directory, creates a mock LLM client, and runs the main function with specified parameters. The test checks if the user manual and evidence JSON files are created, and verifies that the navigation menu in the index.html file correctly links to the user manual.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:test_extract_snippets_skips_large_file:a069448e530476d47428e2ed2c711e1f707c6fb2c4391b2a3abfe41dfa571d5d:a069448e530476d47428e2ed2c711e1f707c6fb2c4391b2a3abfe41dfa571d5d": "The function `test_extract_snippets_skips_large_file` is a unit test for the `extract_snippets` function from the `explaincode` module. It checks that large files are skipped during snippet extraction when their size exceeds a specified limit. The test creates a temporary file with 210,000 bytes of data and attempts to extract snippets from it using the `extract_snippets` function with a maximum file size of 200,000 bytes. The test asserts that the large file is not included in the extracted snippets and logs an informational message indicating that the file size exceeds the limit.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:test_extract_text_docx_preserves_headings:ccdda36a4b83ffc2c2a1ec3553090b4d326e582aac3b03f62d95be25c5167634:ccdda36a4b83ffc2c2a1ec3553090b4d326e582aac3b03f62d95be25c5167634": "The function `test_extract_text_docx_preserves_headings` tests the ability of a hypothetical `explaincode.extract_text` function to correctly extract and preserve headings from a DOCX file. It creates a temporary DOCX document with a heading and a paragraph, saves it, and then uses `explaincode.extract_text` to read the content. The test asserts that the extracted text starts with a Markdown-formatted heading (`# Title`) and includes the plain text \"Text\".",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:test_extract_text_html_preserves_headings_and_code:2a85eb586d0de301a5a7498069537a94c31eda333380b249aafe0b052506b22b:2a85eb586d0de301a5a7498069537a94c31eda333380b249aafe0b052506b22b": "The function `test_extract_text_html_preserves_headings_and_code` tests the `extract_text` function from the `explaincode` module. It creates a temporary HTML file with headings (`<h1>`, `<h2>`) and code blocks (`<pre><code>`). The function reads this HTML file, extracts the text while preserving the structure of headings and code blocks, and asserts that the extracted text contains the expected headings and code content.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:test_extract_text_markdown_preserves_headings_and_code:845fe843df2d6c873f05a433756d3eb3b3a08ebc77afe4358e641ee1dbc6c6a9:845fe843df2d6c873f05a433756d3eb3b3a08ebc77afe4358e641ee1dbc6c6a9": "This function `test_extract_text_markdown_preserves_headings_and_code` tests the `extract_text` function from the `explaincode` module. It creates a temporary Markdown file with headings and code blocks, writes it to disk, and then reads it back using the `extract_text` function. The test asserts that the extracted text contains the original headings (`# Title`) and code blocks (including the Python print statement).",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:test_force_code_flag_triggers_code_fallback:ac9cd8e7e69b6d358db643643cfdba6e93a37be26ad154350e12f39217916116:ac9cd8e7e69b6d358db643643cfdba6e93a37be26ad154350e12f39217916116": "This function tests the behavior of a code summarization tool when the `--force-code` flag is used. It sets up a temporary directory, mocks the LLM client and ranking/extracting functions, and captures logs. The test asserts that the ranking and extracting functions are called once, and that specific log messages indicating a code scan trigger and completion of the first pass are present in the captured logs.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:test_full_docs_no_code_scan:3d2a262af6acc6b91868bb8912743a6b58d0d477ea54b80ee222c4764fc976cb:3d2a262af6acc6b91868bb8912743a6b58d0d477ea54b80ee222c4764fc976cb": "This function tests the generation of documentation without scanning code. It sets up a temporary path, creates a fixture, and uses monkeypatch to replace functions for ranking code files and extracting snippets with fake implementations that track calls. The test asserts that these functions are not called, logs indicate a successful document pass, and confirms that the code scan was skipped.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:test_graceful_missing_docx:a46a55407e2dca8c196a98bed8c91cbd270a8f77d3ee8b5667cfd7286679f3ab:a46a55407e2dca8c196a98bed8c91cbd270a8f77d3ee8b5667cfd7286679f3ab": "The function `test_graceful_missing_docx` is a test case designed to verify the behavior of a documentation generation tool when the required `python-docx` library is missing. It uses pytest fixtures for setup and teardown, ensuring that a temporary directory is created and used during the test.\n\n1. The function first creates a fixture using `_create_fixture(tmp_path)`, which likely sets up some initial conditions or files in the temporary path.\n2. It attempts to import `Document` from the `docx` module. If successful, it creates a new document, adds a paragraph, and saves it as \"guide.docx\" in the temporary path.\n3. The function then uses `monkeypatch.setattr` to mock out the `Document` class and `LLMClient` within the `explaincode` module with `_mock_llm_client`.\n4. It calls the `main` function with a command-line argument specifying the path of the temporary directory.\n5. Finally, it asserts that two files are created in the temporary path: \"user_manual.html\" and \"user_manual_evidence.json\". This indicates that the documentation generation process completed successfully even though the `python-docx` library was not available.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:test_hierarchical_merge_logged:666fb41a375d55e6253ee94a7b6a357861bc94846992e1f3d220d4506587ee1e:666fb41a375d55e6253ee94a7b6a357861bc94846992e1f3d220d4506587ee1e": "This function `test_hierarchical_merge_logged` tests the hierarchical merging process for summarizing text using an LLM client. It creates a dummy client that returns a large response initially and then a short response after two calls. The function uses a temporary path for caching responses, sets up logging to capture output, and summarizes a large text by chunking it automatically. The test asserts that the final result is \"short\", that more than three calls were made to the client, and that the log output contains the phrase \"Hierarchical merge pass\".",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:test_html_summary_creation:0dde6f54f220afba5e3f123994f38317448b27006e9150d886df6d61d2fa22ef:0dde6f54f220afba5e3f123994f38317448b27006e9150d886df6d61d2fa22ef": "This function `test_html_summary_creation` tests the creation of HTML summaries for a project. It uses a temporary path (`tmp_path`) and a monkeypatch to mock an LLM client. The function calls `main` with a specified path, which presumably generates documentation. It then checks that both a manual file (`user_manual.html`) and evidence file (`user_manual_evidence.json`) exist in the temporary path. The evidence file is parsed to ensure it contains an \"Overview\" section with evidence data. The HTML text is read and checked to ensure it does not contain the string \"No information provided.\" Finally, the function uses BeautifulSoup to parse the HTML and verifies that a navigation element (`nav`) exists with a link to the \"Overview\" section.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:test_infer_sections_infers_entries:4251979ddb462bbac797e41ef86bfec9d209a2f30cfb05afd71cc6825c4c0b6a:4251979ddb462bbac797e41ef86bfec9d209a2f30cfb05afd71cc6825c4c0b6a": "The function `test_infer_sections_infers_entries` tests the `infer_sections` function from the `explaincode` module. It asserts that the returned dictionary contains an \"Overview\" key with the value \"Some context\". For all other keys specified in `REQUIRED_SECTIONS`, it checks that their values end with \"(inferred)\". Finally, it ensures that the string \"No information provided.\" is not present in any of the section values combined.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:test_infer_sections_no_context_defaults:9953bd11034dc5a9aa424ba73bf94409d09e2c623b83dc2a992cc437260c9dd0:9953bd11034dc5a9aa424ba73bf94409d09e2c623b83dc2a992cc437260c9dd0": "This function tests the `infer_sections` method from the `explaincode` module. It asserts that when an empty string is passed as input, the output dictionary has values equal to \"No information provided.\"",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:test_insert_into_index:7f7d2677cb97daf6b389aeca12b99926126030e99bac3a61f77d1ce06db7c068:7f7d2677cb97daf6b389aeca12b99926126030e99bac3a61f77d1ce06db7c068": "The function `test_insert_into_index` is a unit test for inserting links into an HTML index file. It uses the `tmp_path` fixture to create a temporary directory and the `monkeypatch` fixture to mock the `LLMClient` class from the `explaincode` module. The function creates an output directory, initializes an empty HTML index file, and then calls the `main` function with specific command-line arguments to insert links into the index. Finally, it asserts that a link for \"User Manual\" is present in the modified HTML content.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:test_insert_into_root_index:60d7ca6a76c7330827bc6290bf4e109c245b42c6d577bc3e3ec5ee0c1f50463c:60d7ca6a76c7330827bc6290bf4e109c245b42c6d577bc3e3ec5ee0c1f50463c": "This function, `test_insert_into_root_index`, tests the functionality of inserting a generated documentation link into an existing HTML index file. It uses a temporary directory (`tmp_path`) to create a mock environment for testing. The function performs the following steps:\n\n1. Creates a fixture using `_create_fixture(tmp_path)`.\n2. Writes a basic HTML structure to `index.html` in the temporary directory.\n3. Mocks the LLMClient using `monkeypatch.setattr(explaincode, \"LLMClient\", _mock_llm_client)`.\n4. Calls the `main` function with command-line arguments to insert documentation into the index file (`--path`, `str(tmp_path)`, `--insert-into-index`).\n5. Verifies that the generated documentation files (`user_manual.html` and `user_manual_evidence.json`) exist in the `docs` directory.\n6. Parses the modified `index.html` using BeautifulSoup to find the `<nav>` element.\n7. Asserts that the `<nav>` element contains an anchor tag (`<a>`) with a `href` attribute pointing to the generated documentation file.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:test_llm_fill_placeholders_per_section_logging:f403f2d1803c9aa5d16ce7ca47125a4bd191c621c637aa6c315df39686223a3d:f403f2d1803c9aa5d16ce7ca47125a4bd191c621c637aa6c315df39686223a3d": "This function tests the `llm_fill_placeholders` method by simulating its interaction with an LLM client and a response cache. It uses a dummy class to mimic the LLM's behavior, capturing calls made to it. The test checks if placeholders in a manual string are correctly filled using data from evidence, ensuring that each placeholder is replaced with content from the corresponding file specified in the evidence. Additionally, it verifies that the function logs the process of filling each placeholder with the source code file used.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:test_map_evidence_overview_priority_and_filters:30377d3a494c9b034c2576fd70ecc20c9fb2a0e99ae6e79b8eede6d952b30f32:30377d3a494c9b034c2576fd70ecc20c9fb2a0e99ae6e79b8eede6d952b30f32": "The function `test_map_evidence_overview_priority_and_filters` tests the `map_evidence_to_sections` function from the `explaincode` module. It creates a dictionary of file paths and their content, simulating a collection of documentation files. The function maps these files to sections based on their content and filters out files in specific directories (`tests`, `examples`, `fixtures`). The test asserts that files in ignored directories are not included in the mapped sections and that the first two files are from the expected paths, while the third file is from a different path.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:test_map_evidence_snippet_limits:6a99989ae13765ae7e97bc5f3fe3a88d3e6a774380c9addceac1fe3c904b722a:6a99989ae13765ae7e97bc5f3fe3a88d3e6a774380c9addceac1fe3c904b722a": "The function `test_map_evidence_snippet_limits` tests the functionality of mapping evidence to sections, specifically focusing on snippet limits. It creates a dictionary of document paths and their contents, simulating long and short documents. The function then maps these documents to sections using `explaincode.map_evidence_to_sections`. It asserts that lines exceeding `MAX_SNIPPET_LINES` are not included in the snippets for long documents, while lines within the limit are included. Additionally, it checks that the snippet for a short document is correctly set to \"# Inputs\".",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:test_missing_run_triggers_code_fallback_with_limits:7517a7a0462e14505da7bcf0538635235930566a4ccb83d5c74d68dcb14319a9:7517a7a0462e14505da7bcf0538635235930566a4ccb83d5c74d68dcb14319a9": "The function `test_missing_run_triggers_code_fallback_with_limits` is a unit test for a documentation generation tool. It simulates the scenario where the tool needs to generate documentation but encounters missing run instructions or sections. The test sets up a temporary directory with a README file and three Python files. It then mocks the LLMClient, rank_code_files, and extract_snippets functions to simulate the behavior of the tool during the testing process.\n\nThe test asserts that the tool correctly identifies missing run instructions and uses code from the source files to fill in these gaps. It also checks that the tool logs the appropriate messages indicating the progress and any issues encountered during the documentation generation process.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:test_no_code_flag_skips_code_fallback:37bba025e1c6f8aa8403ffe8f3d18ad182c5993d8e3771f9268b95be8a30c003:37bba025e1c6f8aa8403ffe8f3d18ad182c5993d8e3771f9268b95be8a30c003": "This function tests the behavior of a documentation generation tool when the `--no-code` flag is used. It sets up a temporary directory with a README file and mocks out the LLMClient, rank_code_files, and extract_snippets functions to prevent actual code processing. The test asserts that these functions are not called when the `--no-code` flag is provided. It also checks that the log output indicates that the code scan was skipped due to the flag and that the \"How to Run\" section is included in the output.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:test_parallel_chunk_summarization:cf3000ebfc515e066f7ced260dac3c913ce2dfbcb4fe30634dbd6bc5895c3126:cf3000ebfc515e066f7ced260dac3c913ce2dfbcb4fe30634dbd6bc5895c3126": "This function `test_parallel_chunk_summarization` tests the summarization of text in parallel using a mock client that simulates delays. It creates a large text by repeating a paragraph, then uses a custom client to summarize the text with a delay when a specific system prompt is encountered. The test measures the time taken to summarize the text and asserts that it is less than 1.5 times the simulated delay, indicating efficient parallel processing.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:test_parse_manual_infers_missing_sections:03571818baae991d4e9e2aa73cf81c34e2d31f4bf54c97e2bc69615515b72ad1:03571818baae991d4e9e2aa73cf81c34e2d31f4bf54c97e2bc69615515b72ad1": "",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:test_pdf_summary_creation:f015135e385d3c878d5203c60ff0cf2213ccbcf8d2f0dc9c6f5a7a0ac476d255:f015135e385d3c878d5203c60ff0cf2213ccbcf8d2f0dc9c6f5a7a0ac476d255": "This function tests the creation of a PDF summary for a project. It checks if `reportlab` is installed, creates a fixture using `_create_fixture`, mocks an LLM client with `_mock_llm_client`, runs the main function with specified path and output format, and asserts that the generated PDF and evidence JSON files exist in the temporary path.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:test_rank_code_files_supports_cpp_h_java:e08d7ecf44cbf4443196dd9ed7ef8f130fc1534b5d0b9a5d68f9ed379e5ae040:e08d7ecf44cbf4443196dd9ed7ef8f130fc1534b5d0b9a5d68f9ed379e5ae040": "The function `test_rank_code_files_supports_cpp_h_java` tests the `rank_code_files` function from the `explaincode` module to ensure it supports C++, header, and Java files. It creates a temporary directory with various file types, including Python, C++, header, and Java files, as well as an ignored text file. The function then ranks these files and asserts that only the supported file types are included in the ranking, while the ignored file is excluded.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:test_render_html_includes_toc_and_sources_block:48336f7bd0c39ef918f5451253eb5d174c28eecbafaac7ebe320142e34110889:48336f7bd0c39ef918f5451253eb5d174c28eecbafaac7ebe320142e34110889": "The function `test_render_html_includes_toc_and_sources_block` tests the HTML rendering functionality of a documentation tool. It verifies that the generated HTML includes a table of contents (TOC) and source blocks containing specific file snippets. The test uses predefined sections and evidence, renders the HTML using the `explaincode.render_html` function, and then checks if the TOC contains links to \"Overview\" and \"How to Run\". Additionally, it ensures that the source blocks include text from \"readme.md\" and \"run.py\" files.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:test_render_html_renders_markdown_headings_and_code:7530e743fd033e202071b1576376db798cacac2e0a4aee55f4a5bfed3b06ca2b:7530e743fd033e202071b1576376db798cacac2e0a4aee55f4a5bfed3b06ca2b": "The function `test_render_html_renders_markdown_headings_and_code` tests the `render_html` function from the `explaincode` module. It creates a dictionary of sections with a Markdown heading and Python code snippet. The function then renders this into HTML using `explaincode.render_html`. The rendered HTML is parsed using BeautifulSoup to check if it contains an `<h1>` element with the text \"Title\" and a `<pre><code>` block containing the string \"print('hi')\".",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:test_scan_code_categorizes_snippets:bc1bb7ef1636617d71f1803c4aca1d7295394729600cb50ff11058bfc5dfde0b:bc1bb7ef1636617d71f1803c4aca1d7295394729600cb50ff11058bfc5dfde0b": "This function, `test_scan_code_categorizes_snippets`, tests the `scan_code` function in the `explaincode` module. It sets up a temporary directory with three Python files and uses monkeypatching to mock the `collect_docs`, `rank_code_files`, and `extract_snippets` functions from the same module. The mocked `extract_snippets` function returns predefined categories (\"Inputs\", \"Outputs\", \"How to Run\") for each file based on their content. The test then calls `scan_code` with these files, specifying maximum file count, time budget, and bytes per file limit. It asserts that the returned dictionary categorizes the snippets correctly according to their contents.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:test_scan_code_skips_non_source_dirs:f4b135c1799f5c2778c684204a3d7cda76ef22a75b0b3c140cca33170006fcfd:f4b135c1799f5c2778c684204a3d7cda76ef22a75b0b3c140cca33170006fcfd": "The function `test_scan_code_skips_non_source_dirs` tests the `scan_code` function from the `explaincode` module. It creates a temporary directory structure with source files in \"src\" and non-source directories for tests and examples. The `monkeypatch` is used to mock the `collect_docs` function, which is supposed to collect documentation from the codebase. The test asserts that only the source file under \"src\" is included in the result when scanning for documentation.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:test_validate_manual_references_flags_missing:ef0fe87a9e154d6075772d1c03d4766e2168c4306c669637c6b90c8ac0613f18:ef0fe87a9e154d6075772d1c03d4766e2168c4306c669637c6b90c8ac0613f18": "This function tests the validation of manual references in documentation sections. It creates a temporary directory with a Python file named `exists.py` containing the text \"pass\". The function then defines a dictionary `sections` with an \"Overview\" section that mentions both `exists.py` and a missing file `missing.py`. An empty dictionary `evidence` is also created to store validation results.\n\nThe function calls `explaincode.validate_manual_references` with the `sections`, `tmp_path`, and `evidence` as arguments. After execution, it asserts that `exists.py` is included in the \"Overview\" section of `sections`, indicating it was found. It also checks that `missing.py [missing]` is added to the \"Overview\" section, showing it was not found. Finally, it verifies that the \"missing_references\" key in the evidence dictionary for the \"Overview\" section contains a list with the missing file `missing.py`.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_html_writer.py:0d328a8316d6c274a1a52fe5b14bcec61ffc9bd273ede38f7dc2f101ba757cc7:0d328a8316d6c274a1a52fe5b14bcec61ffc9bd273ede38f7dc2f101ba757cc7": "The module provides functions to generate HTML documentation for Python modules and classes. It includes:\n\n1. `write_index`: Generates the main index page of a project, listing all modules with summaries.\n2. `write_module_page`: Generates detailed pages for individual Python modules, including their summary, variables, classes, methods, and functions.\n3. `_highlight`: Highlights code snippets in C++ and Java using syntax highlighting.\n\nThe module uses the `html_writer` module to perform the actual HTML generation. It includes tests to ensure that the generated HTML is correct and properly formatted.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_html_writer.py:test_cpp_java_highlighting:880d65acab4b17ebd2988de5a0b89fe8eea0c6da78dc7f97c07c9ed57644a9e5:880d65acab4b17ebd2988de5a0b89fe8eea0c6da78dc7f97c07c9ed57644a9e5": "The function `test_cpp_java_highlighting` is designed to test the highlighting functionality for C++ and Java code snippets. It uses a helper function `_highlight` to process the code strings with their respective language identifiers (\"cpp\" and \"java\"). The function then asserts that the output HTML contains `<span>` tags, indicating that syntax highlighting has been applied successfully.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_html_writer.py:test_subclass_rendering:77de3b68b5ba8fc63556926405ddaa1619fc6fab947045c6317772b50da8387d:77de3b68b5ba8fc63556926405ddaa1619fc6fab947045c6317772b50da8387d": "This function `test_subclass_rendering` tests the rendering of subclass information in HTML documentation. It creates a mock module data dictionary with a class `A` that has a subclass `B`. The subclass `B` contains a method `m`. The function writes this module data to an HTML file using the `write_module_page` function and then reads the generated HTML file. It asserts that the HTML contains `<details>` tags, indicating expandable sections, \"Class: B\" in the HTML, the method signature `def m(self)` is present, and there is exactly one `<pre><code>` tag for code rendering.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_html_writer.py:test_subfunction_rendering:1d07137feba03615281d0877cbb58d93966ced14f7e6bfbd2eca2b72c95816b0:1d07137feba03615281d0877cbb58d93966ced14f7e6bfbd2eca2b72c95816b0": "This function tests the rendering of subfunctions within a module's documentation. It creates a temporary directory, simulates module data with nested functions, writes the module page to HTML, and checks if the HTML output includes details for both outer and inner functions, as well as syntax highlighting for their source code.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_html_writer.py:test_write_index:06ea7d4c5c035b97537a6276d8b89920c67d990b018e82db5212c65ad93d2d34:06ea7d4c5c035b97537a6276d8b89920c67d990b018e82db5212c65ad93d2d34": "The function `test_write_index` tests the `write_index` function, which generates an HTML index file for a project. It creates a temporary directory, defines links and summaries for modules, writes the index file, reads its content, and asserts various conditions to ensure the output is correct. The assertions check for the presence of specific tags, text, and structure in the generated HTML file.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_html_writer.py:test_write_module_page:c6c7efca1757db2f4b99b9feb421332ffb855549691957f554fbc568d643d1b5:c6c7efca1757db2f4b99b9feb421332ffb855549691957f554fbc568d643d1b5": "The function `test_write_module_page` tests the generation of an HTML module page using a temporary path. It creates mock data for a module, including its name, summary, variables, classes, and functions. The function then calls `write_module_page` to generate the HTML file and reads it back to verify that the output contains expected elements such as links, headers, summaries, and code snippets.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_integration.py:7610cd2fce0cd37892fc17f69cefa5dc0c0897e6aab60df5a0bd194234f19d04:7610cd2fce0cd37892fc17f69cefa5dc0c0897e6aab60df5a0bd194234f19d04": "The module defines two test functions for a documentation generator. The first function, `test_docgenerator_generates_html`, tests the generation of HTML documentation from various file types (Python, MATLAB, C++, Java) within a project directory. It uses a mock LLMClient to simulate API responses and verifies that HTML files are created in the output directory with expected content.\n\nThe second function, `test_static_copied_from_any_cwd`, tests the copying of static assets (like CSS) from any current working directory to the output documentation directory. It also uses a mock LLMClient and asserts that the static file is present in the output directory.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_integration.py:test_docgenerator_generates_html:564b0b73998067ac5ecbb8fab61580f5357278cfb0fe91f2d1709e1ececa8431:564b0b73998067ac5ecbb8fab61580f5357278cfb0fe91f2d1709e1ececa8431": "This function `test_docgenerator_generates_html` tests the functionality of a documentation generator tool named DocGen-LM. It sets up a temporary project directory containing files written in Python, MATLAB, C++, and Java. The function then calls the main function of the documentation generator with this project directory as input and an output directory specified by `tmp_path / \"out\"`. A mock LLM client is used to simulate responses during the test, ensuring that the generator processes each file type correctly. After running the main function, the test verifies that HTML files have been generated for each source file in the project directory and that the summary text is included in these HTML files.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_integration.py:test_static_copied_from_any_cwd:4a6d8f50b683ebc5cbf6181e71724090497792f4c0b6b4c1ee59a47d971e63fd:4a6d8f50b683ebc5cbf6181e71724090497792f4c0b6b4c1ee59a47d971e63fd": "The function `test_static_copied_from_any_cwd` is a test case for the `docgenerator` project. It checks if the static files, such as `style.css`, are copied to the output directory when generating documentation from a Python project. The test creates a temporary project directory with a single Python module (`mod.py`) and an output directory. It then patches the `LLMClient` class to simulate successful communication with a local language model and returns a predefined summary. The function changes the current working directory to the temporary project directory, runs the main function of the `docgenerator` tool with the specified project and output directories, and asserts that the return value is 0 (indicating success). Finally, it checks if the `style.css` file exists in the static directory of the output.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_llm_client.py:ff8a0c5e5d3895b53e3efd3ac0badb2dca6ba723a90e55d61bc0a3a56cb89180:ff8a0c5e5d3895b53e3efd3ac0badb2dca6ba723a90e55d61bc0a3a56cb89180": "This module defines unit tests for an `LLMClient` class, which interacts with a language model. The tests cover the following functionalities:\n\n1. **Ping Method**: Verifies that the `ping` method successfully checks connectivity to the language model server.\n2. **Summarize Method**: Tests the `summarize` method's ability to handle retries and return summaries. It also checks how it handles exceptions and errors from the language model.\n3. **Sanitize Summary Function**: Ensures that the `sanitize_summary` function filters out unwanted phrases from the summary text.\n4. **Prompt Templates**: Validates that the prompt templates for different types (class, function, readme) are correctly formatted and used.\n\nThe tests use mocking to simulate HTTP requests and responses, ensuring that the client behaves as expected under various conditions.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_llm_client.py:test_ping_failure:11fa7fd5b2ee77a4c3f23d752696f1d7239ebe63e608b09e47e8aa82af23e7cf:11fa7fd5b2ee77a4c3f23d752696f1d7239ebe63e608b09e47e8aa82af23e7cf": "This function tests the `ping` method of an `LLMClient` class when a connection failure occurs. It uses the `patch` decorator from the `unittest.mock` module to simulate a request exception, causing the `ping` method to raise a `ConnectionError`. The test asserts that the expected exception is raised during the ping operation.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_llm_client.py:test_ping_success:d5cc9d07b288163317485bece66a2af6a6822ab619ce4cbd872e05107d81ba58:d5cc9d07b288163317485bece66a2af6a6822ab619ce4cbd872e05107d81ba58": "The function `test_ping_success` tests the `ping` method of an `LLMClient` class. It sets up a mock response that simulates a successful HTTP GET request to \"http://fake\". The `raise_for_status` method of the mock response is also mocked to ensure it does not raise any exceptions. The function asserts that calling `client.ping()` returns `True`, indicating a successful ping. It further verifies that the `requests.get` method was called once with the specified URL and timeout, and that `raise_for_status` was called on the mock response.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_llm_client.py:test_prompt_varies_by_type:ed82bda8d4634a708d7fe2a0f287c2a7b51614e144a7cf6840bb4f480ee0f8f8:ed82bda8d4634a708d7fe2a0f287c2a7b51614e144a7cf6840bb4f480ee0f8f8": "The function `test_prompt_varies_by_type` tests the behavior of an `LLMClient` when summarizing different types of code elements (class and function). It uses a mock response to simulate an LLM's response and patches the `requests.post` method to return this mock response. The function then calls `client.summarize` with different types (\"class\" and \"function\") and asserts that the prompts sent to the LLM are formatted according to predefined templates (`PROMPT_TEMPLATES[\"class\"]` and `PROMPT_TEMPLATES[\"function\"]`). It further confirms that the prompts for class and function summaries are different.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_llm_client.py:test_readme_prompt_template_used:ff6b5772c6f9a1decbe52bfdb3a22fcac17b567597ff42381ea109006a972aa0:ff6b5772c6f9a1decbe52bfdb3a22fcac17b567597ff42381ea109006a972aa0": "The function `test_readme_prompt_template_used` tests whether the `summarize` method of an `LLMClient` instance uses the correct prompt template for generating a README summary. It sets up a mock response from an LLM client, patches the `requests.post` call to return this mock response, and then calls the `summarize` method with \"foo\" as the text and \"readme\" as the context. The function asserts that the content of the second message in the prompt matches the expected README template formatted with the input text \"foo\".",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_llm_client.py:test_sanitize_summary_filters_phrases:237a4b301fbce0afc4d78adb65ac5b7c6ce0daa16b79e54141348454c0b16bc7:237a4b301fbce0afc4d78adb65ac5b7c6ce0daa16b79e54141348454c0b16bc7": "",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_llm_client.py:test_summarize_raises_runtime_error_with_message:49455604bbbcbde13bbfa04a0a13574251c6b0ee0b0eaec048530fc0fee212c0:49455604bbbcbde13bbfa04a0a13574251c6b0ee0b0eaec048530fc0fee212c0": "The function `test_summarize_raises_runtime_error_with_message` tests the behavior of the `summarize` method in the `LLMClient` class when it encounters an error. It sets up a mock response that simulates an HTTP error and a JSON parsing error, with the text \"server exploded\" returned by the server. The function then asserts that calling the `summarize` method raises a `RuntimeError` with the message \"server exploded\".",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_llm_client.py:test_summarize_retries_and_returns_summary:2412bcabef08e11b202d497982576c4c927c56f90683dc429d1afab49a8d33b6:2412bcabef08e11b202d497982576c4c927c56f90683dc429d1afab49a8d33b6": "This function tests the `summarize` method of an `LLMClient` class. It mocks a request to an LLM client that initially fails with a `RequestException`, then succeeds and returns a JSON response containing a code summary. The function asserts that the returned summary matches the expected content, that two requests were made (one failing and one succeeding), that a sleep call was made after the first failure, and that the correct prompt template was used for the second request.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_manual_utils.py:79194c18898c3be5fd9b77410afeef01c9f0a1405b52a64720962e71b081ca75:79194c18898c3be5fd9b77410afeef01c9f0a1405b52a64720962e71b081ca75": "The module defines two functions: `_count` and `test_chunk_docs_respects_token_limit`, `test_find_placeholders`. The `_count` function calculates the number of tokens in a given text using a tokenizer from the `manual_utils` module. The `test_chunk_docs_respects_token_limit` function tests the `chunk_docs` function from the `manual_utils` module to ensure it respects a token limit by splitting documents into chunks that do not exceed the limit. The `test_find_placeholders` function tests the `find_placeholders` function from the `manual_utils` module to verify its ability to identify and return placeholders in a given text.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_manual_utils.py:_count:ba81ca63e96212540673de141920db0219fb306fcfd8960788a1742fe86955b3:ba81ca63e96212540673de141920db0219fb306fcfd8960788a1742fe86955b3": "The function `_count` takes a string `text` as input and returns the number of tokens in the text, as encoded by `manual_utils.TOKENIZER`.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_manual_utils.py:test_chunk_docs_respects_token_limit:5f3de284e61277d0cd2761c87e2971dbed404da47d5c382ed35aad482c2001b9:5f3de284e61277d0cd2761c87e2971dbed404da47d5c382ed35aad482c2001b9": "The function `test_chunk_docs_respects_token_limit` tests the `chunk_docs` function from `manual_utils`. It asserts that when given a list of documents, each document is chunked into parts no larger than a specified token limit (2000 tokens). The test checks that the total number of chunks does not exceed 2 and that each chunk contains no more than 2000 tokens.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_manual_utils.py:test_find_placeholders:a24fab955006d1e5d2bfca819f5e234f70171d5b2acad5773c85d31e3411f1c0:a24fab955006d1e5d2bfca819f5e234f70171d5b2acad5773c85d31e3411f1c0": "The function `test_find_placeholders` is designed to test the functionality of a utility function named `find_placeholders`. This utility function is part of a module called `manual_utils`, which is not explicitly shown in the provided code snippet. The purpose of `find_placeholders` is to identify and extract placeholder tokens from a given text string.\n\nIn the provided test case, the input string `text` contains two placeholders: `[[NEEDS_OVERVIEW]]` and `[[FOO]]`. The function `manual_utils.find_placeholders(text)` is expected to return a set containing these two placeholders. The assertion checks if the output of the function matches the expected set of tokens.\n\nThis test ensures that the `find_placeholders` function correctly identifies and extracts placeholder tokens from a text string, which is essential for further processing or analysis in the project.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_parser_cpp.py:7bf655540a7446dfdc4c0a3d20712a34c8c0cefe70fdce7aa5e2197a6cc58f87:7bf655540a7446dfdc4c0a3d20712a34c8c0cefe70fdce7aa5e2197a6cc58f87": "This module defines a test function `test_parse_cpp` that uses the `parse_cpp_file` function from `parser_cpp.py` to parse a C++ source file. The test checks if the parsed data includes the correct module comment, namespace, functions, and classes, as well as their respective docstrings and source code snippets.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_parser_cpp.py:test_parse_cpp:ba56aab81c4865441a7d4fe897ad0d646175b951eea2800e474da09d73cc5cc1:ba56aab81c4865441a7d4fe897ad0d646175b951eea2800e474da09d73cc5cc1": "The function `test_parse_cpp` tests the parsing of a C++ source file using the `parse_cpp_file` function. It creates a temporary C++ file with a module comment, namespace, functions, and classes. The test asserts that the parsed results match the expected values for the module docstring, namespace, functions, classes, variables, and methods.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_parser_java.py:81c91b4467b1272b3aee2c23a686157de0d00112a71e34af42e7260d11e289fb:81c91b4467b1272b3aee2c23a686157de0d00112a71e34af42e7260d11e289fb": "This module defines a test function `test_parse_java` that uses the `parse_java_file` function from the `parser_java` module to parse a Java source file. The test checks if the parsed result contains the expected package, class, field, and method information.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_parser_java.py:test_parse_java:8221271045ffd588ec5e3f6074a831acd259c3bed638b98024a71b416dff6331:8221271045ffd588ec5e3f6074a831acd259c3bed638b98024a71b416dff6331": "This function `test_parse_java` is designed to test the parsing of a Java source file using a hypothetical `parse_java_file` function. It creates a temporary Java file with a package declaration, a utility class named `Util`, and two members: a public integer field `count` and a method `work`. The test checks if the parsed result contains the correct module docstring, package name, and details of the class, including its methods and fields.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_parser_matlab.py:d371df41f01bfadecc63c5f1bddb7b77eb2309a17405bffe247ca4a3e17973bd:d371df41f01bfadecc63c5f1bddb7b77eb2309a17405bffe247ca4a3e17973bd": "This module contains two test functions to verify the functionality of a MATLAB file parser. The `test_parse_simple_matlab` function checks if the parser correctly extracts the header and a single function from a simple MATLAB file. The `test_parse_multiple_functions` function tests the parser's ability to handle multiple functions within a single MATLAB file, ensuring that each function is correctly identified and its arguments are accurately parsed.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_parser_matlab.py:test_parse_multiple_functions:95f478e2dc6c9079bb5426b0cf3c9a5aa58f54cd3f842a0ee81ac732789a9b59:95f478e2dc6c9079bb5426b0cf3c9a5aa58f54cd3f842a0ee81ac732789a9b59": "This function `test_parse_multiple_functions` tests the parsing of a MATLAB file containing multiple functions. It creates a temporary file with two MATLAB functions, calls a parser function `parse_matlab_file`, and asserts that the parsed result contains the correct information about the header (empty), the number of functions (two), their names (`compute` and `square`), and their argument lists (`[\"a\", \"b\"]` for `compute` and `[\"x\"]` for `square`).",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_parser_matlab.py:test_parse_simple_matlab:0782cd60944765e32ec3d0071495b7aa79da093b52d95df08f45b9df7b7efcd7:0782cd60944765e32ec3d0071495b7aa79da093b52d95df08f45b9df7b7efcd7": "This function, `test_parse_simple_matlab`, is designed to test the parsing of a simple MATLAB file using the `parse_matlab_file` function. It creates a temporary file with a basic MATLAB script containing a function named `add`. The function then calls `parse_matlab_file` on this temporary file and asserts that the parsed result contains the correct header text and one function definition. The function checks that the name of the function is \"add\" and that it has two arguments, \"x\" and \"y\".",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_parser_python.py:0656a74b22ae45e63880587901e7b10ae787467de6bd22083f6803af85bd3957:0656a74b22ae45e63880587901e7b10ae787467de6bd22083f6803af85bd3957": "The module defines several test functions to verify the functionality of a `parse_python_file` function. Each test function creates a Python source file with different structures (simple modules, complex signatures, nested classes, deeply nested classes, and class inside methods), writes it to a temporary directory, and then parses it using `parse_python_file`. The tests assert that the parsed results match the expected structure and content of the source files.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_parser_python.py:test_class_inside_method:96dd60a400bf8f76107dc106550e167e84273c79412dc54a5ab1b038cb1fd038:96dd60a400bf8f76107dc106550e167e84273c79412dc54a5ab1b038cb1fd038": "The function `test_class_inside_method` is designed to test the parsing of Python source files containing nested classes and methods. It uses a temporary directory provided by `tmp_path` to create a file named `inner.py`. The content of this file defines a class `A` with an outer method `outer`, which itself contains another class `B` with a method `m`.\n\nThe function then calls `parse_python_file` with the path to the created Python file. This function is assumed to parse the Python source code and return a dictionary representing the parsed structure.\n\nAfter parsing, the function asserts that:\n1. The first class in the result has one subclass.\n2. The name of this subclass is \"B\".\n3. The subclass `B` contains one method named \"m\".\n\nThis test ensures that the parser correctly identifies nested classes and methods within a Python file.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_parser_python.py:test_deeply_nested_classes:d8bb698b334378fd85c6ea120ccee8d7b21d71d7f9d545ec9bcdf95586715d49:d8bb698b334378fd85c6ea120ccee8d7b21d71d7f9d545ec9bcdf95586715d49": "This function `test_deeply_nested_classes` tests the parsing of Python files containing deeply nested classes. It creates a temporary file with nested class definitions, parses it using `parse_python_file`, and then asserts that the nested classes and their methods are correctly identified in the parsed result. The test checks if the innermost class \"C\" and its method \"inner\" are present under the correct parent classes.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_parser_python.py:test_parse_complex_signature:5371c0d194b980605271b3a72c00cf0a253f352484c12c6779d07c5b3fae2a46:5371c0d194b980605271b3a72c00cf0a253f352484c12c6779d07c5b3fae2a46": "This function `test_parse_complex_signature` tests the parsing of a Python file containing a complex function signature. It creates a temporary Python file with a docstring and a function definition, then parses this file using `parse_python_file`. The test checks that the parsed signature matches the expected format, and verifies that the function's docstring is correctly extracted and included in the parsed result.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_parser_python.py:test_parse_nested_structures:364fe6218889a3d97b9f465b5912abd2ecb6138958d45268079037c6c6e2c39f:364fe6218889a3d97b9f465b5912abd2ecb6138958d45268079037c6c6e2c39f": "This function `test_parse_nested_structures` tests the ability to parse nested structures in Python source code. It creates a temporary file with nested functions and classes, then uses `parse_python_file` to analyze the file. The test verifies that the parsed result correctly identifies outer and inner functions, as well as nested subclasses and methods within those subclasses.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_parser_python.py:test_parse_simple_module:59ff37d1d05c731c2b348492e0b1018a1737864073a5b56fff9c499da03d797b:59ff37d1d05c731c2b348492e0b1018a1737864073a5b56fff9c499da03d797b": "This function tests the parsing of a simple Python module. It creates a temporary file with a sample Python script containing a module docstring, a class with a method, and a standalone function. The `parse_python_file` function is called to parse this file. The test asserts that the parsed result contains the correct module docstring, class name, class docstring, method signature, method docstring, method source code, function name, function signature, return type, function docstring, and function source code.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_reviewer.py:83233473a3bb44ee0c5e26502caa85ad29205c84af0e40280e3fd12a3f730505:83233473a3bb44ee0c5e26502caa85ad29205c84af0e40280e3fd12a3f730505": "This module defines functions to test the detection of assistant phrasing, contradictions, and hallucinations in Python modules. It uses a temporary directory to create module pages with specified summaries and methods. The `main` function from the `reviewer` module is called to process these pages, which outputs messages indicating detected issues like assistant phrasing, contradictions, or hallucinations. Additionally, it includes a test for an autofix feature that removes certain phrases from the HTML output.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_reviewer.py:_make_module:c5094f7c07fb350b01683b5930056a1c8972f32728950d3d399b5592cbc47fcf:c5094f7c07fb350b01683b5930056a1c8972f32728950d3d399b5592cbc47fcf": "This function `_make_module` creates a temporary directory for a Python module and generates an HTML page summarizing the module. It takes three parameters: `tmp_path`, which is the path to the temporary directory; `summary`, which is a string describing the module; and `methods`, which is an optional list of methods to include in the summary. If `methods` is provided, it adds a class named \"Foo\" with the specified methods to the module data. The function then writes the module page using the `write_module_page` function and returns the path to the generated HTML file (`mod.html`).",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_reviewer.py:test_assistant_phrasing_detected:bcf06673e59d90396fad62e035aab666f03065092d591d8167063267c356572a:bcf06673e59d90396fad62e035aab666f03065092d591d8167063267c356572a": "The function `test_assistant_phrasing_detected` is designed to test the detection of assistant phrasing during the documentation generation process. It creates a temporary module with specific content, runs the main function with the path to this module as an argument, and captures the output using `capsys`. The function then asserts that the string \"[ASSISTANT]\" is present in the output, indicating that assistant phrasing was detected. Additionally, it checks that \"mod.html\" is in the output, suggesting that a file named \"mod.html\" was generated during the process.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_reviewer.py:test_autofix_removes_phrasing:e063eafd990f5e44d13b9779d7d5d5b7bf8829a1d7ef50dbee6caa0a7f89cabd:e063eafd990f5e44d13b9779d7d5d5b7bf8829a1d7ef50dbee6caa0a7f89cabd": "This function tests the `--autofix` option of the project's command-line interface (CLI). It creates a temporary module with specific phrasing, runs the CLI with the `--autofix` flag on that module, and then checks if the phrasing has been removed from the generated HTML file.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_reviewer.py:test_contradiction_detected:127eb872460ad4ab09b70b5d15190afce09114ae495f614275747afc8f514a69:127eb872460ad4ab09b70b5d15190afce09114ae495f614275747afc8f514a69": "The function `test_contradiction_detected` is a test case designed to verify the detection of contradictions within source code. It takes two parameters: `tmp_path`, which represents a temporary directory path, and `capsys`, which captures standard output.\n\nThe function performs the following steps:\n1. Defines a list of methods with a single method named \"bar\" that has an empty docstring and no source code.\n2. Creates a module in the specified temporary path using `_make_module` function, which is not shown but presumably generates a Python file with the provided methods.\n3. Calls the `main` function with the path to the temporary directory as an argument, simulating the execution of the main program on the test module.\n4. Reads the captured standard output using `capsys.readouterr().out`.\n5. Asserts that the string \"[CONTRADICTION]\" is present in the captured output, indicating that a contradiction was detected during the processing.\n\nThis test ensures that the system correctly identifies and reports contradictions in source code, which could be related to issues such as conflicting documentation or logic errors.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_reviewer.py:test_hallucination_detected:99763cf8c987f64f246dcb667ea67cbe2a1d734f601d06e5e76a2c670296db4a:99763cf8c987f64f246dcb667ea67cbe2a1d734f601d06e5e76a2c670296db4a": "The function `test_hallucination_detected` is designed to test for the detection of hallucinations during the summarization process. It creates a temporary module using `_make_module`, which presumably generates a Python file with the specified documentation string. The function then calls the `main` function with the path to this temporary directory, simulating the execution of the project's main functionality. After executing, it captures the standard output and checks if the string \"[HALLUCINATION]\" is present in the output, indicating that a hallucination was detected during the summarization process.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_scanner.py:9fb66b0d67a215b5195a4a239c0f088601d37be9f219b4e6b10e9a18e33b8b13:9fb66b0d67a215b5195a4a239c0f088601d37be9f219b4e6b10e9a18e33b8b13": "The module defines a test suite for the `scan_directory` function from the `scanner` module. It includes tests to verify that:\n\n1. The function correctly ignores specified folders.\n2. The function returns all files of various types (Python, Objective-C, text).\n3. The function skips the `.git` folder by default.\n4. The function supports additional file extensions like C++, C headers, and Java.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_scanner.py:create_files:b37ed51843aea06858d3d1b6a6d691c9782d4de1e9325ec4a08a38b9324ac9d2:b37ed51843aea06858d3d1b6a6d691c9782d4de1e9325ec4a08a38b9324ac9d2": "This function `create_files` takes a directory path (`base`) and a list of file paths relative to that directory (`files`). It iterates over each relative file path, constructs the full path by joining it with the base directory, creates any necessary parent directories (if they don't already exist), and then writes an empty string to the file.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_scanner.py:test_scan_directory_ignore_folder:fadc6c5a174cc2e9fc33a4f101d6db329b35c55eefd3c8c5eff36213ff3c5a9a:fadc6c5a174cc2e9fc33a4f101d6db329b35c55eefd3c8c5eff36213ff3c5a9a": "The function `test_scan_directory_ignore_folder` tests the `scan_directory` function to ensure it correctly ignores specified folders when scanning a directory. It creates a temporary directory with various files and subdirectories, including an ignored folder named \"ignore_me\". The function then calls `scan_directory` with the path of the temporary directory and a list containing the name of the folder to ignore. The result is compared to an expected set of file paths, which excludes any files within the ignored folder.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_scanner.py:test_scan_directory_mixed_file_types:5dee83d12c1eaf78511d1e60b9b4021c05df90dcd65e7ef951d2e4ef8a9272f2:5dee83d12c1eaf78511d1e60b9b4021c05df90dcd65e7ef951d2e4ef8a9272f2": "This function, `test_scan_directory_mixed_file_types`, is designed to test the functionality of a directory scanning utility. It creates a temporary directory with files of various types (Python, MATLAB, text) and nested subdirectories containing additional files. The function then calls `scan_directory` with the path of this temporary directory and an empty list as arguments.\n\nThe expected result is a set of file paths representing all Python and MATLAB files in the directory and its subdirectory, excluding non-programming files like `.txt` and Markdown files. The test asserts that the actual result matches this expected set of file paths.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_scanner.py:test_scan_directory_skips_git_folder:2735e42e7376bf1a029a4da0763af5fe8f2726bb04f5e530d713a0584687b3c7:2735e42e7376bf1a029a4da0763af5fe8f2726bb04f5e530d713a0584687b3c7": "This function tests the `scan_directory` function to ensure it skips files and directories within a `.git` folder. It creates a temporary directory with a mix of files, including those inside a `.git` subdirectory. The function then scans the directory and asserts that only non-`.git` files are included in the result.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_scanner.py:test_scan_directory_supports_cpp_h_java:afda27088b33bcc6067f65ad521ee66459cea5f3fb0531567d85ba74d7b06781:afda27088b33bcc6067f65ad521ee66459cea5f3fb0531567d85ba74d7b06781": "The function `test_scan_directory_supports_cpp_h_java` tests the `scan_directory` function to ensure it correctly identifies and includes all supported file types (C++, C++ header, Java, and Java nested files) within a specified directory. It uses a temporary path created by `tmp_path`, populates it with various files including nested directories, and then asserts that the `scan_directory` function returns a set of file paths matching those expected for the given file types.",
  "PROJECT:fb02e6e9708fb901818bbb6cf969808832bdff359161ee46cf8eaa6665d3802e:fb02e6e9708fb901818bbb6cf969808832bdff359161ee46cf8eaa6665d3802e": "This project includes a suite of tools for generating and summarizing documentation from source code. It features classes and functions for caching responses, chunking text into manageable pieces, parsing various programming languages (Python, Java, C++, MATLAB), summarizing code structures, and interacting with an LLM to generate summaries. The GUI wrapper provides a user interface for selecting directories and files, running commands, and displaying logs. Utilities are included for handling HTML rendering, manual parsing, and code review. The project also contains extensive testing to ensure functionality across different languages and scenarios.",
  "README:b3ecc1a4f38b030a9777cc9e1c4c8b667da9c029caacca4368a617a75a9f0141:b3ecc1a4f38b030a9777cc9e1c4c8b667da9c029caacca4368a617a75a9f0141": "DocGen-LM is a tool for generating static HTML documentation for Python, MATLAB, C++, and Java projects by analyzing source files with a local LLM. It supports nested functions and subclasses, rendering complex structures as expandable sections in the output. The tool includes both command-line interface (CLI) and graphical user interface (GUI) usage options, allowing users to specify project directories, output locations, and other parameters. Additionally, it provides a utility called `explaincode.py` for generating lightweight project summaries and documentation, with options for chunking text based on token or character limits.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\cache.py:ResponseCache:4bf39f0ddf33468e133fc0de74e4b5ffcc04454990de01f6d9556f317e81e88f:bb8c5e04ff12539d13e7ca41ecbd56f704e29527621cb046143ffeb35745f4a7": "The `ResponseCache` class provides a mechanism for caching and persisting mappings from stable keys to language model (LLM) responses. It initializes by loading existing data from a specified file path, or creating an empty cache if the file does not exist. The class includes methods for generating deterministic keys based on file paths and content, retrieving cached values by key, and storing new key-value pairs while persisting them to disk.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\cache.py:__init__:c1f1b5d8279be7d7b539f13e0f1ed5f3bf047e3849de3d09dced152030787cc8:0ee92105e1cc8f363e943216460d0783affa08d72036e0525d6bb33b4acfd89c": "Initializes a new instance of the `ResponseCache` class with a specified cache file path. If the file exists, it reads and parses the JSON content into a dictionary; otherwise, it initializes an empty dictionary to store cached responses.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\cache.py:_save:107fcb6f42ffb8b4042d367920e7acd6158d36d7140c14e045a78fceb7861e5a:f6ebc9147ac634efba6c3fc550d9d923eb7e7e8c747c8a2ecb9501dd240b32e2": "The `_save` method in the `ResponseCache` class writes the current cache data to a file. It uses the `write_text` method of the `file` attribute to serialize the `_data` dictionary into a JSON string with an indentation of 2 spaces and sorted keys, then saves it to disk using UTF-8 encoding.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\cache.py:get:9a9298cce1cb41a7569727146f86f3409843bffefee05571378bfea5df4a8846:51364331c8191334c402a14bd616d2e768549254897b7ef00ac67c8900d0cf95": "The `get` method in the `ResponseCache` class retrieves the cached value associated with a given key. If the key exists in the cache, it returns the corresponding value; otherwise, it returns `None`.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\cache.py:make_key:2431c08f694bcb0ae44b4951c2e4e32e4b52b9f952999698f752141a3c930b6b:fbe1559fedb7e31f9bf71a0fdff76010b9e6b1bce1472058376d8fa962f900b9": "The `make_key` function generates a deterministic key for a given file path and content. It uses SHA-256 hashing to create a unique identifier based on the input content, ensuring that the same file path and content combination always produces the same key. The key is formatted as `{file_path}:{digest}`, where `digest` is the hexadecimal representation of the SHA-256 hash of the content.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\cache.py:set:9fa26419fefca2226adf104d0b1efbda4d7ae7dc80365bb34a47bb2668542539:1dad34cd3eb9ce473f362f33346ed32d51d408159421328967039148737c9a35": "This function `set` in the `ResponseCache` class stores a value associated with a given key in an internal dictionary `_data`. After storing the value, it calls another method `_save()` to persist these changes to disk in JSON format.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\chunk_utils.py:_split_blocks:f06d52d7c77f836b2b82ba819cc711a5783e6ff912e483e63fdebb6b3ced66e7:9815324cad488edaf3bc42e36b508da87afc1dc018c4cdf39a81af233bd5a79b": "The function `_split_blocks` takes a string of Markdown text and returns a list of paragraphs, headings, and code blocks. It processes the input line by line, identifying and separating different types of blocks based on specific markers like paragraph breaks (`\\n`), headings (lines starting with `#`), and code fences (```` ``` ````). The function maintains state to track whether it is currently inside a code block and accumulates lines into lists that represent each type of block. It then filters out any empty blocks before returning the list of processed blocks.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\chunk_utils.py:_split_long_block:acb824eb4da70e6c27da7236e9eb1f9b056b04f9fdaa19b08ce712fd35bb1340:b292ad755883833303f341843a3089b972947d1d32694b290ac7710eb80102f5": "This function `_split_long_block` takes a string `block`, a tokenizer, and an integer `chunk_size_tokens`. It splits the block into smaller chunks if it exceeds the specified token size. If the block is shorter than or equal to the token size, it returns the block as a single element list. Otherwise, it calculates average characters per token and determines the maximum number of characters for each chunk based on this calculation and the token size. It then splits the block into chunks of approximately `max_chars` length.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\chunk_utils.py:chunk_text:6f22a4f432ce2505287ed241536b6e16499c8eac475f9edbb94526acdb011ef8:1a939eb51fa3d82f1487fc249c307d4b7fbab316a801d3471b7eae01cf0f6726": "The function `chunk_text` splits a given text into manageable chunks based on the specified number of tokens. It uses a tokenizer to determine the number of tokens in each block and ensures that natural break points like blank lines, Markdown headings, and fenced code blocks are respected. If a single block exceeds the token limit, it falls back to splitting that block by character length. The function returns a list of chunks.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\chunk_utils.py:get_tokenizer:d22a53823ab559d5b1f2d2555821e747d384b78bf9891eb4c45eb369b4c07eaa:dd5bb0463be79f85832d5d12ddfb54f4889201e595a303e66f3edcb342697879": "This function returns a tokenizer object used for estimating token counts. It first attempts to load the `tiktoken` library and get the \"cl100k_base\" encoding. If that fails or is not available, it tries to use the \"gpt-3.5-turbo\" model. If both fail, it prints a warning and returns a simple tokenizer that splits text into words for tokenization and joins them back together for decoding.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\docgenerator.py:_build_function_prompt:7893581217d6965d8a177d18c344b62a8250236d9c0804471ca94b50ff266e28:60df5102ec1d9f381e8a8991884bd7692acfb83c856d2727cf6965036a5e3ff0": "This function `_build_function_prompt` constructs a prompt for summarizing a given Python function. It takes four parameters: `source`, which is the function's source code; and three optional parameters, `class_name`, `class_summary`, and `project_summary`, which provide additional context about the class and project containing the function.\n\nThe function returns a string that includes:\n1. A brief introduction as a documentation generator.\n2. Information about the class to which the function belongs, if provided.\n3. A summary of the class, if provided.\n4. A summary of the project, if provided.\n5. Instructions on how to summarize the function based solely on its source code.\n6. The actual source code of the function enclosed in a code block.\n\nThis prompt is designed to guide an LLM (Language Model) in generating a concise and accurate summary of the function's purpose and behavior, leveraging any available context about its class and project.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\docgenerator.py:_chunk_module_by_structure:15dcc6c679f9e6c94f76bc64a6eda4397d149ab25c8e0f5bca48f1b30b367244:b105b4a4deddf1afd2cd7fa33dfbf788f82840d6802fb2a2a0e8b48f0260e511": "This function `_chunk_module_by_structure` processes a parsed module dictionary, breaking down its content into text chunks based on token size limits. It first extracts the module's docstring and adds it to blocks if present. Then, it iterates through classes, methods, variables, and functions within the module, adding their source code to blocks. The function then processes these blocks to create chunks that do not exceed a specified token size, ensuring that each chunk is manageable for processing by a tokenizer. If a block exceeds the token limit, it is further broken down into smaller chunks. Finally, any remaining blocks are added to the list of chunks, which is returned as the result.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\docgenerator.py:_rewrite_docstring:1ac89e56f1f10270ae216072f202de51911c6f38a47031b24c0e2159001c8462:247b5cfa20c44dfeccfd2d8886528949ac6a46879ecb7f73f00ed861276ef743": "The function `_rewrite_docstring` rewrites the docstring of a code item using optional context provided by the user. It takes an `LLMClient` for interacting with a language model, a `ResponseCache` for caching responses, the file path and item details as input. The function constructs a prompt based on the source code, class name, class summary, and project summary (if provided). It then uses this prompt to generate a new docstring through chunked summarization using the LLM, which is stored back in the item dictionary after sanitization. If no source or docstring is available, it prints a warning message.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\docgenerator.py:_summarize_class_recursive:eac5fe67d04cd103c59126447bf24a4b43662f54c68f00f326657fab4c4b628c:cb8f024ef06e55f03d8deba9d874220627849e2723289340e2a45bd0b9591568": "This function recursively summarizes a class and its members. It generates summaries for methods and variables, constructs a class prompt using these summaries, and then uses an LLM to generate a new docstring for the class. The function also handles rewriting docstrings for methods and variables within the class. It caches responses to avoid redundant calls to the LLM.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\docgenerator.py:_summarize_members_recursive:fc18f0f52b1b915b92afa985c43d59b12711bfb4ba8b3bccf4155fff72ae05c4:6fdaef32ec19a2a34aae05dd7aea562d22390ba92c611c62cd14bc349bab57fe": "This function recursively summarizes methods and variables within a class, including those of its subclasses. It uses an LLMClient to generate summaries for each method and variable, caching the results using a ResponseCache to avoid redundant calls. The summaries are stored back in the original data structure under \"summary\" and \"docstring\" keys.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\docgenerator.py:_summarize_module_chunked:b6b309b4a41e230300dd95448092e68dd7115dcff8d3b4e763aef9564369428a:d9e13ce7fee3a107f9c98e4991a958f9ef7d935813f4c620accbeb6818ebb823": "This function `_summarize_module_chunked` is designed to summarize a module of code using structure-aware chunking. It takes parameters including an LLM client, response cache, key prefix, module text, module dictionary, tokenizer, maximum context tokens, and chunk token budget. The function first checks if the module text can be summarized in one go without exceeding the available tokens. If not, it attempts to chunk the module based on its structure. Each chunk is then summarized individually. After summarizing all chunks, the function combines these summaries into a single technical paragraph using an iterative merging process that ensures the final summary does not exceed the available token budget. The function handles exceptions during chunking and summarization processes, printing warnings and returning sanitized summaries in case of failures.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:Config:0b3ed3eff1c79c43fbe5d931fef9fce219dad2ae4a03975c80a50074ce4a92d9:594733ac4138c0c5ad11ce6e6840136f00c85e7c41a44ed0802b36201d93f5ba": "The `Config` class defines a data structure for configuration settings parsed from command-line interface (CLI) arguments. It includes various attributes such as file paths, output formats, and boolean flags to control the behavior of a program based on user input.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:_edit_chunks_in_editor:e2bce0b6c3eb4a2b38cb910d31fa2f2e81c40b6236077a8e2b63f3cfa4305ccb:c9b62e5a61f703013a6c793a8d075682f700bd2b156e07c33b746db2b54972b3": "This function `_edit_chunks_in_editor` takes a list of code chunks as input, joins them into a single string with separators, writes the string to a temporary file, opens the file in the user's default editor for modification, reads the edited content back, and returns a list of non-empty chunks after editing.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:collect_docs:7aae4ae535350137f6ce486ead580c3d2c41bcdaf7b9a9eedb1eb40b474a098d:d0eb6765d029de21a4003dd22387d8b2d57ae7dc00de19ee3a1b18ca10ea6eea": "Collects documentation files under the specified base directory. Includes README and Markdown files, as well as HTML and Markdown files within a \"docs\" subdirectory. Ensures uniqueness by avoiding duplicate file inclusion.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:collect_files:27b0ca83b7f75875027c1f0eaf5d11795e2d0bff0e0360e2468bbdb4f8e6b589:d0e84ee315cf9f92d19bc661950611bc765db191a7c7bd370e89718f6c1e2efa": "The function `collect_files` is designed to gather files relevant for summarization from a specified base directory. It starts with a list of default file patterns (`README.md`, text files, HTML files, document files, CSV files, JSON files) and extends this list with any additional patterns provided by the user through the `extra_patterns` parameter. The function uses the `rglob` method to recursively search for files that match these patterns within the base directory. To ensure uniqueness, it filters out duplicate files and returns a list of unique file paths.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:detect_placeholders:fbdc144a986fd9561c00e5cb51ad84ef809cde05a631e0fb94dd92b29f26d334:25a08a6da1445c735fe8a33598db7391d05a41f0845c4e08c64def81d68bba47": "The function `detect_placeholders` takes a string `text` as input and returns a list of section names that are still marked by placeholder tokens. It uses the helper function `find_placeholders` to identify all placeholder tokens in the text, then filters these tokens against a dictionary `SECTION_PLACEHOLDERS` to map each token back to its corresponding section name. The resulting list contains only those section names for which placeholders were found in the input text.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:extract_snippets:4c288d19fb6b502a481fdb19ef1c5e014dd29779b2bad4ca6991a8cf6af0436f:4b15c24def690385e6cf06ac7b09c5c034726f912a9874f61d76e18bcfaa4f02": "The function `extract_snippets` processes a list of Python source files to extract relevant code snippets. It filters files based on the number of files processed (`max_files`), time elapsed (`time_budget`), and file size (`max_bytes`). For each file, it reads up to `max_bytes` characters and extracts:\n\n1. The module docstring if the file is a Python script.\n2. Docstrings from classes, functions, and async functions that may involve I/O operations (identified by parameters like 'path', 'file', 'config', or 'io').\n3. Lines related to command-line interface parsing using `ArgumentParser`.\n4. The content of the `__main__` block if present.\n\nThe extracted snippets are stored in a dictionary with file paths as keys and the corresponding text as values.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:extract_text:5317e21763290e1986a9167d7a99889317c62fc64eebaa15b8963987681034dc:33ef5c6ad0914e25f55d7b65fbae51e9a33e3dab57eafff2dfebba425b3db9fa": "The function `extract_text` reads and processes the content of a file located at the given `path`. It determines the file type based on its extension (`suffix`). For HTML files, it uses BeautifulSoup to parse the content, replacing headings with Markdown-style headers and code blocks with fenced code. For Markdown files, it simply reads the text. For DOCX files (if the `Document` class is available), it extracts text from paragraphs, converting heading styles into Markdown headers. If any other file type or an error occurs during processing, it returns an empty string.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:infer_sections:07daf1ba05a7728ba1b14da961574cdc590c610b0e47e49fb4dd329e675bfcde:e29fa74b52a2dfb9c0a4f5951b927ed33538530edf259a8336fe03f589f8ce6d": "The function `infer_sections` takes a string `text` as input and returns a dictionary of sections. If the input text is non-empty, it places the combined text in an \"Overview\" section and generates placeholder content for other required sections labeled \"(inferred)\". If the input text is empty, it sets all required sections to indicate that no information is provided.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:inject_user_manual:1949522710d48d2feab9b536852d94dec8eaef6fd19ff99a1a27b8fa537e300b:117e7e324dff078d3d24e23c64d976c975063a6ede2371eac5127dfb3c592f73": "Inserts a top-level link to a user manual into an HTML file. The link is added to the first navigation element (`<nav>` or `<ul>`) if present; otherwise, it is inserted at the start of the first element in `<body>` or the document root.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:insert_into_index:cedfaa3781b3e670ff7e75ec9b65187ee0c787804c05cfbc8c230c1f12322796:8fa929daa99b1c327537f24810475ed789e509cfccb066bee437588fe2ed5cb5": "The function `insert_into_index` appends a navigation entry linking to a specified file into an HTML index file. It reads the existing content of the index file using BeautifulSoup, finds or creates a container element (`ul` or `nav`), checks if the link already exists, and then adds a new anchor tag with the specified title and filename as the href attribute. Finally, it writes the updated HTML back to the index file.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:llm_fill_placeholders:85ccaad8b839342a051883c9bc0065ab7b6d45c3de75e05366afb203d141e5dc:c1dfa401c2303a19b99cadf312238df0a57fc02c0cf0e2881424fef458dc5eff": "The function `llm_fill_placeholders` processes a manual text and integrates relevant code snippets into it. It uses an LLM client to fetch summaries of code snippets and updates the manual accordingly. The process involves summarizing long code snippets if necessary, constructing prompts with both manual text and code snippets, and updating the manual by replacing placeholders with summarized information. The function also logs the sections that have been updated with code from specific files.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:llm_generate_manual:8af03bee910781b46d21faef63247d409d995c31ff2efd717f4bc087b67ec756:fb3f0a61d10570416402141b23ba4c05b422f25bc45e78b721e61b6c752cf2a5": "The function `llm_generate_manual` processes documentation snippets to generate a user manual. It maps snippets to sections, performs LLM calls for each section, and assembles the final manual text. The function returns the manual text, a mapping of source files to sections, and an evidence map capturing used snippets.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:map_evidence_to_sections:7e1253afc82a38e1837cb62bc0e08124e5c34eca4bb2cf00712ea38f320af7a4:22b8d05fbb3dfe21312727decb4309022f9435fb6dc14a0b2b706c114a2bdd12": "This function `map_evidence_to_sections` processes a dictionary of documentation snippets, mapping them to specific sections based on keywords. It returns two dictionaries: `section_map`, which maps section names to lists of tuples containing the source path and snippet text, and `file_map`, which maps each source path to the set of sections it contributes to. The function filters out snippets from excluded directories and limits each section to the top 10 snippets by length. It also prioritizes certain sections like \"Overview\" based on file names and directory structure.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:parse_manual:b08d53dd873132a2507aa75f8d064f9f605f68fe0cd500fd5a97f7e1a502eb32:0d65c54a7521200016920ca79213b2c41413ed92272fa5bea53263424f7f3ec2": "The `parse_manual` function takes a string of text, an optional LLMClient instance, and a boolean flag for inferring missing sections. It parses the text into structured sections based on lines containing a colon. If specified, it infers any missing required sections using the provided LLMClient and marks them as inferred in the output.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:rank_code_files:a1a85de661d42f880e0badaed8fa13b0fe25a627314fb61d2b2068bb2a2e6d6d:867cf1fdc9b7dfca44fb29acfac7c159fdd5fcd08be986b71c258c2d51a96788": "The `rank_code_files` function ranks Python code files under a specified root directory based on simple heuristics. It supports various file extensions such as `.py`, `.m`, `.ipynb`, `.cpp`, `.h`, and `.java`. The function skips certain directories like `venv`, `.git`, and `tests` during the ranking process. It uses regular expressions to identify keywords related to code structure, such as \"run\", \"main\", and \"cli\". Additionally, it considers user-specified patterns to further enhance the scoring of relevant files. The final list of ranked files is returned in descending order based on their scores.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:render_html:5e450b5fda24c51c58a18a6ce33a799051bd5e643510eb23d2e01e714eea229b:3b120c2d37e3589bb40fd7c7dc94faa13392521ec06c6facc1fc5124f3d6480d": "The `render_html` function generates HTML content for a documentation page based on provided sections, title, and an optional evidence map. It processes each section to either use its content or substitute it with evidence snippets if the content is empty or lacks information. The function includes slugification for navigation links, HTML escaping for security, and Markdown rendering for formatted text. It constructs the final HTML document by combining a header, navigation menu, and body parts containing section titles and their corresponding content.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:scan_code:cdef0df0b35d8e473a11c5ae7394f2bd6c8b162b9d0c1f8d10794ff7baba6925:1d29582b17b8e4a612129fc8c6624ba0f8b90b66508c821923274d8602fa2cdf": "The `scan_code` function collects source code snippets from a specified base directory, grouping them by manual sections. It searches for keywords associated with the given sections (or all known sections if none are provided) and returns a dictionary mapping section names to another dictionary of relative file paths and their corresponding snippet texts. The function uses patterns extracted from documentation files to identify relevant source files, ranks these files based on certain criteria, extracts snippets from them, and categorizes them according to the specified or default sections.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:slugify:e75a978e35be92a323c900d0f9c8189c176f35e5cd0521d7501d0c43e7a40854:88d4c7b8a6c533486019f6b152d253cf6252bb77d53808069584f5735efe4688": "Converts a given string into a filesystem-friendly slug. It removes all non-alphanumeric characters and replaces them with underscores, then converts the string to lowercase. If the resulting slug is empty, it defaults to \"user_manual\".",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:validate_manual_references:9a02f2f03b1c558f34ef23e04c7496432c27cffe7dd270e12e48f8a0f572b27c:c4cecec51f7833ac2f784684c6cb44da75ebfa0c730ccd132158eb68eaabc5d1": "This function `validate_manual_references` checks for missing file references in a dictionary of documentation sections. It uses regular expressions to identify potential file paths or module names within the text of each section. If a referenced file is not found under the specified project root, it appends \"[missing]\" to the reference in the section text. Additionally, if an `evidence_map` is provided, it records the missing references for each section. The function modifies the input `sections` dictionary in place.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:write_pdf:090e09889dfded8934523fb87b76af6b8c63047b9a0b10438b00b3c6726174a0:b8f2e571e20bfa83a932d327bf0e5bb267d503e658378c4e28c37e5c8831f71d": "The function `write_pdf` takes an HTML string and a file path as input. It checks if the `canvas` module is available; if not, it returns `False`. The function then extracts text from the HTML using BeautifulSoup, splits it into lines, and creates a PDF document using the `canvas` library. Each line of text is added to the PDF at specified coordinates. Finally, the PDF is saved to the provided path, and the function returns `True` on success.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:__init__:5f45a56034f048b98b8d2552ddac0fb347a3117a5b7fa66f3a669d96f3a78e7b:27d674ac16147359cb0b63743b088f4e4a007ae8d80ebceb221fde7e46e21672": "The `__init__` method initializes the `MainWindow` class, setting up a graphical user interface for generating documentation using DocGen-LM. It includes components for selecting project and output directories, configuring DocGen and ExplainCode options, displaying logs, and running commands to generate documentation or summaries. The UI is organized into sections for project settings, DocGen options, ExplainCode options, log display, and control buttons.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:__init__:668b0760e96ed318f7344710330ceef401414d2f2767a1558949913e1f688f24:bd2791da9404630684a9a114ec6b5e1609261fa28bdea0443949b2bb2c4689b5": "The `__init__` method initializes a new instance of the `CommandRunner` class. It takes a list of commands (`cmds`) as an argument and assigns it to the instance variable `self.cmds`. This method is typically called when creating a new object of the class, setting up the initial state with the provided commands.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:__init__:7eefb3605fb2e7e3c48bd60faea9f2689f123e7ab339d6f36b38a7bc645a43f5:13e966e287a5880fb7855cb8fde857504eb1f3e151497ace06cc739399bda551": "The `__init__` method initializes a new instance of the `PathLineEdit` class. It calls the constructor of its superclass and sets the widget to accept drag-and-drop events. This allows the `PathLineEdit` to handle file path inputs through drag-and-drop operations in a graphical user interface.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:__init__:bf781efe56a3af0d9e15ebd77fdb3210e097aa37856a133746e60052c42c327b:099023549602f5899b2abe59224925c5eacfce73d0640852ff91ecbb26d66efb": "The `__init__` method initializes a `CollapsibleBox` instance. It sets up a toggle button with the provided title and styles it to have no border, a light gray color, and bold font weight. The toggle button is configured to display an arrow pointing right and has a checkable state. When clicked, the `on_toggled` method is connected to handle the visibility of the content area.\n\nA `QWidget` for the content is created and initially set to be invisible. A vertical layout is added to the main widget, with the toggle button and content area as its children. The layout's margins are set to zero.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:_reader:b61bc98c986a073f3953f8398f483f213dbbad35c09de497f9ebf4d630d96caf:5fd481bd99dc8bae0c23d29b3e550a55535f701e70d737909f734c30d028476f": "The `_reader` method reads a stream character by character, emitting chunks as they are read. It handles carriage returns and newlines appropriately, flushing any buffered text when the stream ends.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:append_log:95aaf4d7fb70a22359b393f3643a32cf2fe2a9fbacb6362c6ea48987b02025ba:749eaf1a538f569df8667bab40b77fbe3ff86fe92b64f98af702f9802961fe54": "The `append_log` method in the `MainWindow` class is designed to add text to a log widget. It uses a regular expression to split the input text into parts, handling carriage return characters (`\\r`) by moving the cursor to the start of the line and clearing any existing text before inserting new content. The method ensures that the log widget's vertical scrollbar is at the bottom after appending the text, maintaining a scrollable view of the log output.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:build_docgen_cmd:fa1aaf43a827447304dbbf36e53dcf2066c6dced9d767a84e6f3316b6acd1440:1b5c95b2df1db471c199a07aafbf4870c973187774cfc3b7bf4f906d398f2b15": "The `build_docgen_cmd` method constructs a command list to run the `docgenerator.py` script with specified parameters. It includes the Python interpreter (`pythonw`), the script name (`docgenerator.py`), and project and output directory paths from user input fields (`self.project_edit.text()` and `self.output_edit.text()`). If a checkbox indicating private documentation generation is checked, it appends the `--include-private` flag to the command.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:build_explain_cmd:c8245fac46c7ac83196954d0c4f38ee883297b6a7bd3f6fbb1f42c89d18b6dc5:17c6d26b0edd76d7bc345d5e46131a3098a0e80454d087c80d30ced5ff59c161": "The `build_explain_cmd` method constructs a command to run the `explaincode.py` utility for generating documentation. It compiles a list of arguments based on user input in the GUI, including the project directory path, output location, and format. If specified, it also includes additional data for processing. The method returns this list as a command that can be executed to generate documentation using DocGen-LM.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:dark_style:604b6a4127a401cd5119f1cceac074bdbc96d1acd84461797d145b6e2aae5c10:74681d7e57323a16993d67b7de9f88afca2d43c307fcb0acf0bd2c3924561b9a": "The `dark_style` method in the `MainWindow` class returns a string containing CSS styles for various widgets. These styles define the appearance of the GUI elements in a dark theme, including background colors, text colors, fonts, and button states. The styles apply to `QWidget`, `QLineEdit`, `QPlainTextEdit`, `QComboBox`, and `QPushButton`.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:dragEnterEvent:abf156aaf4ea45565a7e6ccbd556a202d6d774cf68f262ecfac0f94d1342602e:cf17b58ca88cc9262fbc7528d59b604dc939c5456aef6834830709437255d2c7": "The `dragEnterEvent` method in the `PathLineEdit` class handles the drag-and-drop enter event for accepting URLs that represent file paths. It checks if the MIME data contains URLs and accepts the proposed action if it does, allowing the drop operation to proceed.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:dropEvent:ece1a1d4134a5fc2c97f46dec8132ce0d778810f12b337c27a52a4a1a25a73d9:c44ce9c940b3cc5d4fd52d2c72fa3710f5f6d7a8a31fa4bff12705da1c27f98e": "The `dropEvent` method in the `PathLineEdit` class handles drag-and-drop events by extracting URLs from the MIME data of the event. If any URLs are found, it sets the text of the `PathLineEdit` to the local file path represented by the first URL. This allows users to input file paths through drag-and-drop interactions within a graphical user interface.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:on_finished:8008a83cc9308d8c185efbd914cb59dcdce24ed47c8270aa41b35bcaa528ecbe:2973307993a9b21cacca47456bd5acf9f986830abd996e03042ffbb6594c167d": "The `on_finished` method in the `MainWindow` class is triggered when a process finishes execution. It appends a log message indicating the exit code of the process and sets the UI state to indicate that the process is no longer running.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:on_toggled:8fb8368d74f9e6d03c95e2d74173abf0d8ef6d5a896266a70906abd2824338be:8ef42bcd6a7bdf4f1279f5146d9f5aa235b318a29bd57bd07ad8bfdecf7954b9": "The `on_toggled` method in the `CollapsibleBox` class handles the state change of a toggle button. It checks whether the toggle button is currently checked or unchecked. If the button is checked, it sets the arrow on the button to point down and makes the content area visible. If the button is unchecked, it sets the arrow to point right and hides the content area. This method ensures that the content area is only displayed when the toggle button is active, providing a collapsible section within the widget.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:run:72f4756c88eb64c63b5b0879c44e4e0ddc307e1babfbeeab611c8500cfb42d19:73067b25ff2aa8678e937653b2f85fdcd96f66ff9f8d9c932bb0c7c6fbd1ef68": "The `run` method of the `CommandRunner` class executes a list of commands concurrently. It captures the standard output and error streams for each command, emitting them separately. The method uses threads to read from the output and error streams in real-time, ensuring that data is emitted as it becomes available. If any command fails (i.e., returns a non-zero exit code), the method breaks out of the loop and emits a finished signal with an error code. If no commands fail, it emits a finished signal with a success code.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:run_both:752e148b2503f795dee5f390126489b41f62e3f5c651737733d9f5750a238ef6:0566accc3cc79fc4d27763161f65987b7b03689389966a729e0a80c9a0eca583": "The `run_both` method in the `MainWindow` class clears the log and then runs two commands: one for building documentation using DocGen-LM and another for generating explanations using `explaincode.py`.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:run_commands:7a0601c470a7d4c3ad1b6d41b1b04df2307be07c5745ff24b0964dd5ba8e2c43:aa46bc06a2ee16b33feed9d4a2de3da8f19df7f9b9b11bfca14371d47f42fc52": "The `run_commands` method in the `MainWindow` class is designed to execute a list of commands related to documentation generation. It first checks if both project and output directories are specified by the user. If either is missing, it logs an error message and returns without executing any commands. If both directories are set, it sets the UI state to indicate that processing is running. Then, it creates an instance of `CommandRunner`, passing the list of commands to execute. It connects the output signal from `CommandRunner` to a method that appends log messages to the user interface. Additionally, it connects the finished signal to another method that handles post-processing after the command execution completes. Finally, it starts the command runner to begin executing the commands asynchronously.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:run_docgen:d974068de6fbe99444857f9794bc1c7c54a20a5caa5b053561022c8fd9856613:d417d8af7b49ef9b6ad92f4c9552c8499fcfa513c009e709fac0f9adcc64371f": "The `run_docgen` method in the `MainWindow` class clears the log and then runs a command to generate documentation using DocGen-LM.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:run_explain:4faa917cb53277314b27fa2dc3fac0314725eb7c6c4cfec0388268e056c69668:c8d24f5b399139c3e0728c30df768335d629e95d2ca17b0ffd009bb56cbe8e05": "The `run_explain` method in the `MainWindow` class clears the log and then runs a command to generate documentation using the `explaincode.py` utility. It constructs the command by calling `build_explain_cmd` and passes it to `run_commands`.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:select_dir:2439b93efb3e0e2ba023c4923fea3e6f121e42effd0c74c458cf05d735150777:c0cc220fbe96c1c558abf32df25548926e2c1c5049dcc285538128b01f8794d0": "The `select_dir` method in the `MainWindow` class allows users to select a directory by opening a file dialog. If a directory is selected, it sets the text of the provided `QLineEdit` widget to the path of the selected directory.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:select_file:e16157fecc1078f1cfc1a23567b494839abf74335cbc084833d2e27112d1639e:be2030b58ea024a51d3ac2c254aea11bb01e4dcedc96d031d4cc8cc6695d42cf": "The `select_file` method in the `MainWindow` class is designed to open a file dialog for selecting data files. It accepts a `QLineEdit` widget as an argument, which is used to display the selected file path. When invoked, it prompts the user to choose a file from a list of supported formats (JSON, CSV, TXT) or all files. If a file is selected, its path is set in the provided `QLineEdit` widget.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:setContentLayout:99753ad16debd90a92e2fa9d39b802d8e6809b6fc49da59fd6d8612aa350026f:8797e37c3767292703a6a86f2bd4d959ef175a668e6b0acc9daf49c10da5c37e": "The `setContentLayout` method sets the layout for the content area of the `CollapsibleBox`. It takes a `layout` parameter and assigns it to the `content` attribute's layout. This allows for customizing the arrangement of widgets within the content area of the collapsible box.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:set_running:ab0f14abb9298d5d1d0f2f5c7937fa75c9413cd52ae5011d8ac2ca565dccde1a:143502eeda2ff52c17fa1937f84faa0b2119698bd303731ec1eda3d4ddddc60f": "The `set_running` method in the `MainWindow` class enables or disables three buttons (`docgen_btn`, `explain_btn`, and `both_btn`) based on the value of the `running` parameter. If `running` is `True`, all buttons are disabled; if `running` is `False`, all buttons are enabled. This method is used to manage the UI state during processing, ensuring that users cannot interact with the buttons while a task is running.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\html_writer.py:_highlight:1ef43842ab84b3494e54ed45fba96bb2727b106ee751581ff3eb4ff1b30a3ee4:d8c0f4103679ab9fec1906ebd37ada1168ceb15afc046767c3b9afea09da99a8": "The function `_highlight` takes a string `code` and a string `language` as input. It returns the code highlighted for the specified language using Pygments, a syntax highlighting library. The function selects an appropriate lexer based on the language (Matlab, Python, C++, Java) or defaults to `TextLexer` if the language is not recognized. It then formats the highlighted code using an HTML formatter with no classes and nowrap options. The output is wrapped in `<pre><code>` tags for proper rendering in HTML.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\html_writer.py:_render_class:9bb2b89e4a093e99bd6bdc9633c05a98e41646726452136dfa7bcba658dd2fe0:9e9a25ff5c5b60d649e898e41afe5422decdf40a800340db12fedff92bac3167": "This function `_render_class` generates HTML parts for a class and its subclasses. It takes a dictionary representing the class, a programming language string, and an optional level parameter (default is 2) to control the heading levels in the generated HTML.\n\nThe function constructs HTML elements based on the class's name, docstring/summary, variables, methods, and subclasses. For each variable, it includes its name and summary if available, and highlights the source code using a `_highlight` function (not shown). Methods are rendered by calling another function `_render_function`. Subclasses are wrapped in `<details>` elements with summaries.\n\nThe generated HTML parts are returned as a list of strings, which can be concatenated to form a complete HTML representation of the class structure.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\html_writer.py:_render_function:4b19d123f111baab618941c2ea4fbdbe64278f4b54558be03621520ff24cc21a:cc6984d871e25f13bf9ff60f434e220aba41fea9622d718fc8d570fd37e53a73": "This function `_render_function` takes a dictionary representing a function (`func`), a programming `language`, an optional `level` for HTML headings (default is 3), and an optional `prefix`. It returns a list of HTML strings that represent the function and any nested subfunctions. The function constructs HTML tags based on the function's signature, summary, and source code, using the specified language for syntax highlighting. Subfunctions are rendered as expandable sections within `<details>` tags.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\html_writer.py:write_index:c292880b271f62dc5c94d9a31263844d471256d5fffb733032a0cf924188dce4:eb0432e45fa1b047e26f736ce6afdeedf9424cac4e71a59628767e26136f8cf6": "This function `write_index` generates the content for an `index.html` file in a specified output directory. It takes parameters for project summary, navigation links, and optional module summaries. The function creates the necessary directory if it doesn't exist, constructs HTML elements for the project summary, navigation links, and module summaries, and then writes these elements to an `index.html` file using a helper function `_render_html`.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\html_writer.py:write_module_page:578b7177d72fe56b8ee5027aea0c68fac9457b8f653ea13f175abd77451d629b:540c15415916601ef75c9b4b15b59d50459baa88d7796ae0b1044c3733b82279": "This function `write_module_page` generates an HTML documentation page for a module. It takes three parameters: `output_dir`, which is the directory where the output HTML file will be saved; `module_data`, a dictionary containing information about the module such as its name, language, summary, classes, variables, and functions; and `page_links`, an iterable of tuples representing navigation links for the page.\n\nThe function first constructs the destination directory and ensures it exists. It then extracts necessary data from `module_data` such as the module's name and language. Navigation items are created based on the provided `page_links`.\n\nThe body of the HTML page is built by concatenating various parts, including a summary paragraph, sections for classes and variables (if any), and functions. Each class and function is rendered using helper functions `_render_class` and `_render_function`, respectively.\n\nFinally, the complete HTML content is generated using `_render_html`, which takes the module name, title, body, and navigation HTML as arguments. The resulting HTML is written to a file in the output directory with the filename corresponding to the module's name.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\llm_client.py:LLMClient:dfa601b20cf4db8e9418337c45ddf1e6e1a5c6668c152a915397bf43d6b050b2:009ca49135e5578004b3773e87124769f683d1c0f26d61e417667c66d0f69bf5": "The `LLMClient` class provides a thin wrapper around the LMStudio HTTP API. It includes methods for checking if the API is reachable with the `ping` method and for generating summaries of text using specified prompt types with the `summarize` method. The `summarize` method handles retries in case of failures and sanitizes the summary content before returning it.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\llm_client.py:__init__:0136abb5a69e88029b252d0223c1a4409526586662fb85ae191627b65d5f3afc:4b2180b7796b9aa25b2d83df7154438fd59f0894704a67541d5575939f7677ed": "Initializes the `LLMClient` with a base URL and model. Sets the base URL, constructs the endpoint for sending requests, and specifies the model to be used for generating summaries.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\llm_client.py:ping:05d31d7d94e49b006990c20ba9efd56025312d5f048afc164ef7eb6269862326:b1d10af7487c9da5faf194ce08fc74022cac6862788566fddb3b7a5735d0caec": "The `ping` method in the `LLMClient` class checks if the API is reachable by sending a GET request to the base URL with a specified timeout. It returns `True` if the server responds successfully, otherwise it raises a `ConnectionError` indicating that the server cannot be contacted.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\llm_client.py:sanitize_summary:30f628052d5d348787e935f560502b25e1423c1f00b66661e758c784eea68953:c4f39e2b1de4c4e0fce785da0f03b1a0e14bd0163cabfaf7080795b522897fa2": "The function `sanitize_summary` takes a string `text` as input and returns a sanitized version of the text by removing lines that start with certain phrases considered meta commentary or redundant. It also filters out lines containing specific keywords related to summaries, outputs, responses, and other irrelevant content. The function uses regular expressions to identify and remove unwanted patterns from each line before joining the remaining lines back into a single string.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\llm_client.py:summarize:967f459b3e09e2c1b61399dbf3a329d120c9d3d3b39bca76b943017b8fb196d1:4220b0d309a492aad96adf73e2332ac2292ee5b87bc50e169754e50f2f4d7b96": "The `summarize` method in the `LLMClient` class is designed to generate a summary for a given text using a specified prompt type. It uses a template based on the prompt type, formats the text into a prompt, constructs an HTTP payload with model details and messages, and sends this payload to an endpoint. The method includes robust error handling with retries up to three times in case of HTTP errors or request exceptions. If all attempts fail, it raises a `RuntimeError` with the last encountered error message.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\manual_utils.py:_count_tokens:d6f37fb121fd9068856958741bf6a7d883470a8f77dfd7e9fd2d5cadf616c87c:d1fed506a13024435575c2dfe65a151c8e5970436b6bff948e10e8240d5d7a7b": "The function `_count_tokens` takes a string `text` as input and returns an integer representing the approximate number of tokens in the text. It uses a tokenizer to encode the text into tokens and then calculates the length of this encoded list, which corresponds to the token count.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\manual_utils.py:_split_text:d3e332c13546f3cc5626375b172b154a8e7968b4ae7183242b39c08c5154c21f:1fbe38e813d1bcc7c6839842909b88e6099c0cb398e1df6a191bdf81e5bc90e4": "Splits input text into chunks based on maximum tokens and characters, preserving paragraphs. Uses regular expressions to identify paragraphs and counts tokens for each piece. Handles large paragraphs by splitting them further using a tokenizer function. Ensures no chunk exceeds the specified limits while maintaining paragraph structure.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\manual_utils.py:_summarize_manual:55b49cfa386310a116dd0c817e6f84ffbf64b5bf7548a33701c684966c61dccb:16295a4241cfb0f788891cfdd334854c7daea1f1d19759063071160d787bb714": "This function `_summarize_manual` generates a manual summary for given text using an LLM (Language Model) client. It supports different chunking strategies: \"manual\" for user-defined chunks, \"auto\" for automatic chunking based on token and character limits, and \"none\" to disable chunking if content exceeds limits. The function uses caching to store and retrieve previously summarized parts of the text to avoid redundant processing. If a post-chunk hook is provided, it applies this hook after summarizing each chunk. The function handles hierarchical merging of chunks if the initial merge exceeds token or character limits. It also logs debug information about the process and handles exceptions gracefully by printing warnings and continuing with alternative methods.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\manual_utils.py:chunk_docs:b36f3edf2b755ebae55697464b8bac7d44c890f59e539a39ae6f694909e92d19:85bfbca67a2c11a77d726419a5cfce9f92d4698a7075d0d616a9282348ebb1b8": "Splits a list of documents into roughly token-limited chunks.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\manual_utils.py:find_placeholders:7a6a944981059c21eb4d8528cd470b32905a23e785ebb8a72fcba936d2633955:79e8e498619617b6256f9d9754b7435655be5ea2829976df863b3d45b9011f9c": "The function `find_placeholders` takes a string `text` as input and returns a set of placeholder tokens found within the text. Placeholder tokens are identified using a regular expression defined by `PLACEHOLDER_RE`, which matches strings in the format ``[[TOKEN]]``. The function extracts all such tokens from the input text and returns them as a set, ensuring uniqueness among the placeholders found.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\parser_cpp.py:_extract_block:291394bf7390bb246b46943760c4f6125aea0dececc275af01c9cbb0cf1c42ce:866f14816bf7682fc43975e160a1e6c029fdfb32c42f90dc63bd1bd7df6bc97e": "The function `_extract_block` takes a list of strings `lines` and an integer `start`. It returns a tuple containing the text of a block starting at the given index and the ending index of that block. The block is defined by matching curly braces `{}`. The function iterates through the lines, counting the number of opening and closing braces to determine when the block ends.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\parser_cpp.py:_get_preceding_comment:08f00138ee23fcf3a0b6a3a2882fb85b01e978061f4d646fc148123a53233237:9dc0dd0ea6ca00b947e0b39e3d3345fc0b0d8573328dfd0679df0ae699c38492": "Collects contiguous comment lines appearing before a specified index in a list of code lines. Handles both single-line (`//`) and multi-line (`/* ... */`) comments, ensuring they are collected in the correct order.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\parser_cpp.py:_parse_class_body:dd412310404826ccf8b35906f8117d0e2c2eb76dc5805d8e8dac6b8e707c9dd9:6da0b0d437618431c0d15cd5e10e2f02d44e5ff29320f02446a352fb84dbb18b": "The function `_parse_class_body` parses the body of a class from a list of source code lines. It identifies and extracts public methods and variables within the specified range (`start` to `end`). The function returns two lists: one for public methods and another for public variables. Each method is represented as a dictionary containing its name, signature, docstring, and source code block. Similarly, each variable is represented as a dictionary with its name, type, docstring, and the line it appears on. The function also handles access modifiers (`public`, `protected`, `private`) to determine which members are considered public.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\parser_cpp.py:parse_cpp_file:7d214efee05d7f7c356f39ec80e271a4ffd4dedf959740a51ad235ce023096c7:f0c9aa731e593532cc58e55d40540c2105146eb90299e555efd7a4b16dcd4e84": "The function `parse_cpp_file` reads a C++ source file and extracts structured information. It processes the file line by line to identify and parse module-level comments, namespaces, classes, and functions. For each class and function, it captures their names, signatures, docstrings, and source code blocks. The function returns a dictionary containing the parsed information, including any namespace defined in the file.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\parser_matlab.py:parse_matlab_file:c0c5ab6c4b74cd84c654df246a60db29646021a6b9c8778c7db5f04a04bf7257:33bb97aec9f3658c57d85b907d756bc3ec03fd1e7414d3e44c6ecd928d959fc0": "The function `parse_matlab_file` reads and parses a MATLAB `.m` file to extract its header comments and any function declarations. It returns a dictionary containing the extracted header as a string and a list of dictionaries, each representing a function declaration with its name and arguments. The function uses regular expressions to identify and parse function definitions within the file's body.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\parser_python.py:_format_arg:bb9443e03691b63c73ceae795113eea59c0e43268a4178ebbac1a42f828301e4:fd2f455173f27024c3892c9e2bfd8928040324937d0717699f0a26bc56650149": "This function formats an argument (`arg`) from the `ast` module by appending its type annotation (if present) to the argument name. It returns a string representing the formatted argument.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\parser_python.py:_format_arguments:4344f530adf613b6c61767c851b0cd84f8ede40a511156a804e8d320403fe87b:e83b45444286ee4c301b50e5672046bc0e75782b05225b7fb80bb538cff6ae36": "This function `_format_arguments` takes an `ast.arguments` object as input and returns a string representation of the arguments. It handles positional-only, regular, variable positional, keyword-only, and variable keyword arguments, including their defaults if provided. The function uses helper functions to format individual arguments and constructs the final string by joining these parts with commas.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\parser_python.py:_format_signature:4944425d64fd6efb360b5e0ed41ba2427dcede468963c8ff59676fa90bbb581f:f266ff041b0a14f660105aab25233b18be4724a5a551b82b4d242df39d5865ff": "This function `_format_signature` takes an `ast.FunctionDef` or `ast.AsyncFunctionDef` object as input and returns a string representing the signature of the function. It formats the function name, parameters, and return type (if present) into a readable string using another helper function `_format_arguments`.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\parser_python.py:_parse_classes:18ae327f9a9c4ba98480a57700949041284862df9ce293a452f5740b5d670218:978b845a0c08d833afcdb53ff6e89b5147e606885737a1f1e9b4290f5df14c89": "This function recursively parses all `ClassDef` nodes within a list of AST nodes. It iterates through each item in the provided list; if an item is a `ClassDef`, it calls another function `parse_class` to process and store the class information. If an item is a `FunctionDef` or `AsyncFunctionDef`, it recursively calls itself to parse any nested classes within those functions. The result is a list of dictionaries, each representing a parsed class with relevant details from the source code.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\parser_python.py:parse_class:6e4c2e595d10a7f1589d3e9af9d42ec805a9aa0eb68434d49afaec7dafad3a9d:5f64d74f7e284d138523892efd2030c38936e3faf45b8a57e8a4355842d34fd5": "This function `parse_class` takes an AST node representing a class definition and the source code as input. It returns a dictionary containing information about the class, including its name, docstring, methods, subclasses, and source code segment. The function iterates through the body of the class to identify and parse any nested functions (methods) using the `parse_function` function. It also recursively parses any subclasses found within the class definition.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\parser_python.py:parse_classes:a9dc5f26a517c638b16790f394dc897c8c846889ee5fa6f21aa85873a6b5b995:008df9fe565e4ecc94eecdb07e5ef3a732dde55fc5cb9a0e70a35f93245e6657": "This function serves as a public interface for parsing classes within an abstract syntax tree (AST). It takes two parameters: `node`, which is the AST node to parse, and `source`, a string containing the source code. The function calls a private helper function `_parse_classes` with the body of the given node (or an empty list if no body exists) and the source code as arguments. The result from `_parse_classes` is returned.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\parser_python.py:parse_function:97f3aca9bc6542b31cbab62ca2f06fa80dd30611a74741113e4957493989d9d0:f76f326408c5c100b705bd44ff52983a7790c05f73a19f7ae83de48eec76eafe": "This function `parse_function` takes an AST node representing a function definition (`ast.FunctionDef` or `ast.AsyncFunctionDef`) and the source code as input. It returns a dictionary containing information about the function, including its name, signature, return type, docstring, source code snippet, subfunctions, and subclasses.\n\nThe function initializes a dictionary `func_info` with keys for each piece of information to be extracted. It then iterates over the body of the function node to find any nested functions or asynchronous functions, recursively calling `parse_function` on them and appending the results to the `subfunctions` list in `func_info`. Additionally, it calls `_parse_classes` to extract any subclasses defined within the function's body and appends these to the `subclasses` list.\n\nThe function uses helper functions like `_format_signature` and `_parse_classes`, which are not shown in the provided code snippet.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\parser_python.py:parse_python_file:e1606e572d6d1d48b03cd6df3fb4fad454214c52b70b9d100e8c70c568737e32:0fd5d2fc5f951630966bfa1acf6ee353d0a342ff28fe1678ff3ab130d7e0a3c4": "The function `parse_python_file` reads a Python source file and extracts structured information. It returns a dictionary containing the module docstring, classes, and functions defined in the file. The function uses the `ast` module to parse the source code and iterates through its body to identify class definitions and function definitions, which are then parsed using helper functions `parse_class` and `parse_function`.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\reviewer.py:_is_generated_html:7bbbf408371a583a591e3bab96cbf8dbcf6c1278e2cb0360ea5090894a7cf49a:fb0cf39fac8463c71847c5a1c76847dfb6b84ad21361fcf8db00dfeaf49c9113": "The function `_is_generated_html` checks whether a given string `text` appears to be output from the DocGen-LM tool. It returns `True` if the text contains specific markers that indicate it was generated by DocGen-LM, such as the phrase \"Generated by DocGen-LM\", an `<h1>` heading for project documentation, or headings for classes and methods in HTML format.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\reviewer.py:check_assistant_phrasing:83169ab80368cb729414561d379af475de0277671301aded659917384642e930:7d29aee2ca43ee670cab2effdcc423bab6bdccddd09d3516d00f34b3e6968a3f": "The function `check_assistant_phrasing` takes an HTML string as input and returns a list of phrases that resemble assistant-like language found within paragraph tags. It extracts all paragraph elements from the HTML, strips any HTML tags from the text, converts it to lowercase for case-insensitive comparison, and checks if any predefined phrases are present in the text. If a match is found, it appends the phrase along with its line number in the original HTML to the findings list.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\reviewer.py:check_contradictions:2ec172b84cbca908b537bf279d662842ab4934f0dcd610fc7e061c0d2e13ed75:ae0b9001f82af7eb2373ddef1ebbd103012135430fa5718e7ca43989bfc015a4": "Function `check_contradictions` takes an HTML string as input and returns a list of contradiction descriptions. It processes the HTML to extract paragraphs, methods, functions, and classes. The function checks for contradictions between statements in the summary text and the actual presence of methods, functions, and classes in the HTML. If a contradiction is found, it appends a description of the contradiction to the findings list.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\reviewer.py:check_hallucinations:f827f0c08c66861b225b85cc61078bef3905feb488671ecdb05e17abb81fc9aa:904ace42ce2ef7cbc3a1e55cf3826190ee836b310451eba7e57ffb5e9597f57e": "The function `check_hallucinations` analyzes HTML content to detect the presence of specific phrases, known as hallucination terms. It returns a list of these detected phrases. The function uses two helper functions: `_extract_tags` to retrieve paragraph tags from the HTML and `_strip_html` to remove HTML tags from the text. It then converts the stripped text to lowercase for case-insensitive comparison with predefined hallucination terms stored in `HALLUCINATION_TERMS`. If any of these terms are found, they are added to the list of findings, which is returned at the end of the function.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\scanner.py:_is_subpath:6ba93d1ca49852b44b895dd20f4abf99d54b709d09e9bfe4fe486c6bd6672429:46275a3a56393afdd358826030f50e96a344ef3e3d8fbd89cb0192f065c26d02": "Returns `True` if the given `path` is equal to or a subdirectory of `parent`.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\scanner.py:scan_directory:a6e76fb847cdf24cbf5ac14ae8a6793625e2d7f727328e6b271546298ab6114e:fd8e0b91afb6b3ca918a2c7288b3a267a6d7ce93118deb8c9e96c9449ac7c914": "The `scan_directory` function recursively discovers source files with extensions `.py`, `.m`, `.cpp`, `.h`, and `.java` under a specified base directory. It skips directories listed in the `ignore` parameter and any internal `.git` folders. The function returns a sorted list of absolute paths to the discovered source files.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\summarize_utils.py:summarize_chunked:b18ed279f055ca7084e6464ad1759ec3943a75984289db070222af4759f86d1f:44265b337b82e647d0ee1d51d95d65ec2bf529a468a5d2adc6ff5c9af8cbe488": "This function `summarize_chunked` is designed to summarize a given text by chunking it if necessary. It takes an LLM client, a response cache, a key prefix, the text to be summarized, and various parameters such as prompt type, system prompt, maximum context tokens, and chunk token budget.\n\nThe function first calculates the available tokens based on the provided parameters and the overhead of the system prompt and template. If the length of the text is less than or equal to the available tokens, it proceeds to summarize the text directly using another internal function `_summarize`.\n\nIf the text exceeds the available tokens, the function attempts to chunk the text into smaller parts based on the specified chunk token budget. It then summarizes each chunk individually and combines the summaries into a single technical paragraph.\n\nThe combination process involves recursively merging chunks until the combined summary fits within the available tokens. If any step fails (e.g., due to network issues), it handles exceptions by logging warnings and attempting alternative methods, such as summarizing the text directly or sanitizing an empty summary.\n\nFinally, the function returns a sanitized summary of the text, ensuring that it adheres to specific instructions for combining summaries without speculation or uncertain language."
}