{
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\cache.py:ResponseCache:__init__:283588304f15e4b8f02e0474286ba4c1200ccede12e8640bd9d91f3295183773:283588304f15e4b8f02e0474286ba4c1200ccede12e8640bd9d91f3295183773": "Initializes an object with a file path, loads JSON data from the file if it exists, handles JSON decode errors by setting empty data, and ensures a progress tracking dictionary exists in the data structure.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\cache.py:ResponseCache:_save:d6c96e0258c810e9fec48856af580533cfc0aa8f13ea666bb1d396aa4abe5e41:d6c96e0258c810e9fec48856af580533cfc0aa8f13ea666bb1d396aa4abe5e41": "The function writes serialized JSON data to a file. It converts the object's data attribute to a JSON string with formatted indentation and sorted keys, then saves it to the specified file using UTF-8 encoding.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\cache.py:ResponseCache:bd6bb1ade7b06689bac33b77421dadc314f2934d52c810b3f113295642a83587:bd6bb1ade7b06689bac33b77421dadc314f2934d52c810b3f113295642a83587": "The `ResponseCache` class provides a caching mechanism for storing and retrieving response data, using file paths and content hashes to generate unique keys. It maintains progress tracking for documentation generation tasks and ensures cached data is persisted to disk. The class supports loading existing cache files, updating cached values, and managing progress information with methods for getting, setting, and clearing entries.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\cache.py:ResponseCache:clear_progress:4afabd3c72dd7481e402d4d9e731329ea3d6f3c362d796a37005901574f205f9:4afabd3c72dd7481e402d4d9e731329ea3d6f3c362d796a37005901574f205f9": "Function clears all saved progress information by resetting the \"__progress__\" key in internal data storage and persists the change.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\cache.py:ResponseCache:get:eeb84b4591575a8ed2767f4abac56f1f2dd0697e81322599734b8b31e94ddcce:eeb84b4591575a8ed2767f4abac56f1f2dd0697e81322599734b8b31e94ddcce": "The function retrieves a cached value associated with the specified key from an internal data store. It takes a string key as input and returns the corresponding value if it exists, or None if the key is not found. The implementation uses a dictionary-like get method on an internal _data attribute to perform the lookup operation.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\cache.py:ResponseCache:get_progress:39ba9bd1b428ced00430a3d9e89153d2e8ee91f6f6623d13eafd158f4de0b69a:39ba9bd1b428ced00430a3d9e89153d2e8ee91f6f6623d13eafd158f4de0b69a": "The function retrieves and returns a shallow copy of the progress data stored in the object's internal data structure. It accesses the \"__progress__\" key from the internal \"_data\" dictionary and returns a new dictionary containing the same key-value pairs, preventing direct modification of the original progress data.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\cache.py:ResponseCache:make_key:4f63c9f618b20a79035ed49cae07b9b800a46f352498e23dc8700f47c38fe96d:4f63c9f618b20a79035ed49cae07b9b800a46f352498e23dc8700f47c38fe96d": "Function that generates a deterministic key by combining a file path with a SHA-256 hash of the file's content. The key is formatted as \"file_path:hash_value\" where the hash is computed from UTF-8 encoded content.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\cache.py:ResponseCache:set:0bc8af7637662ae14e3eca8604a4d7155ff442d423955a243d6b586ffee8d8ba:0bc8af7637662ae14e3eca8604a4d7155ff442d423955a243d6b586ffee8d8ba": "Stores a string value under a specified key in memory and immediately persists the data to disk.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\cache.py:ResponseCache:set_progress_entry:5213bc08e476bb362c55f096cf9227f60da37d1862f66ae21b376f8dbf55a79f:5213bc08e476bb362c55f096cf9227f60da37d1862f66ae21b376f8dbf55a79f": "Records module data for a specified path in the progress map and saves the updated data.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\cache.py:__init__:25ba0d6c0f948722fe9db12d529a21f5c1cd40a7bdcd363dbd2c05d27b6300e6:25ba0d6c0f948722fe9db12d529a21f5c1cd40a7bdcd363dbd2c05d27b6300e6": "Initializes the `ResponseCache` instance by loading cached data from a specified file path. If the file exists and contains valid JSON, it loads the data into `_data`. If the file does not exist or contains invalid JSON, it initializes `_data` as an empty dictionary. Ensures that a `\"__progress__\"` key exists in `_data`, initializing it as an empty dictionary if it is missing.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\cache.py:__init__:65e99db4e0154f5162844567b3b5898687f3c5ba589620bb23bbf1c373488d26:65e99db4e0154f5162844567b3b5898687f3c5ba589620bb23bbf1c373488d26": "Initializes a ResponseCache instance by loading data from a JSON file at the specified path. If the file exists and contains valid JSON, it loads the data into `self._data`; otherwise, it initializes an empty dictionary. If the loaded data or newly created dictionary does not contain a \"__progress__\" key, it sets one to an empty dictionary.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\cache.py:_save:491a870dbba10725806fde22653f16082e13c70f678f46537d08fe062b98fa6f:491a870dbba10725806fde22653f16082e13c70f678f46537d08fe062b98fa6f": "The function `_save` serializes the instance's data to a JSON format and writes it to a file. It uses `json.dumps` with `indent=2` and `sort_keys=True` for formatted output, then writes the resulting string to `self.file` using UTF-8 encoding. This method updates the cached data stored in the file associated with the instance.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\cache.py:_save:a2df77d674fbd042d8e9c130d7c1a0b4fa99e84e12ae946948d9f840202dc04a:a2df77d674fbd042d8e9c130d7c1a0b4fa99e84e12ae946948d9f840202dc04a": "The `_save` method in the `ResponseCache` class serializes the cached data to a JSON format and writes it to a file. It uses `json.dumps` with `indent=2` and `sort_keys=True` for formatted output, then writes the resulting string to the file specified by `self.file` using UTF-8 encoding.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\cache.py:b7996266039c2634cf466bed532ccc6ffe7e701fec85156374b5bb40d1ebd2f5:b7996266039c2634cf466bed532ccc6ffe7e701fec85156374b5bb40d1ebd2f5": "The module implements a disk-based cache for storing and retrieving LLM responses. It provides functionality to generate deterministic keys based on file paths and content, retrieve cached values, store new values, and manage progress tracking for processed modules. The cache persists data to a JSON file and supports operations to clear progress information.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\cache.py:clear_progress:a29c32a93a66463da7daaa6e77d580c9d5067f7b0ed9e68f44ba217bc443a2b9:a29c32a93a66463da7daaa6e77d580c9d5067f7b0ed9e68f44ba217bc443a2b9": "The `clear_progress` method removes all saved progress information by resetting the \"__progress__\" key in the internal data dictionary to an empty dictionary, then saves the updated data.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\cache.py:clear_progress:fef5f619b12352b12ba61acf21d8a1a87cadb5a2fe00b38bf734dbb77a3c38fe:fef5f619b12352b12ba61acf21d8a1a87cadb5a2fe00b38bf734dbb77a3c38fe": "The `clear_progress` method removes all saved progress information by resetting the `\"__progress__\"` key in the internal data dictionary to an empty dictionary and then saving the updated state.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\cache.py:get:ba2551f915aeffa334341b44e9c94784caea65ed774339df7eaf1fc7245bb1f5:ba2551f915aeffa334341b44e9c94784caea65ed774339df7eaf1fc7245bb1f5": "The `get` method retrieves a cached value associated with the specified key from the `_data` storage. It returns the value if the key exists, or None if the key is not present. The method accepts a string key and returns an optional string value.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\cache.py:get:f7b2acc7949210cd8231bf13886cce5a7dc41d12fbf835f5a33d38059c872923:f7b2acc7949210cd8231bf13886cce5a7dc41d12fbf835f5a33d38059c872923": "The `get` method retrieves a cached value associated with the specified key from the internal data storage of the `ResponseCache` class. If the key exists in the cache, the corresponding value is returned; otherwise, None is returned. The method takes a string key as input and returns an optional string value.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\cache.py:get_progress:7fcc4a0b6edaca23a4505c81e1855c0238456d6c55ea38ce3fea22db19b5a1aa:7fcc4a0b6edaca23a4505c81e1855c0238456d6c55ea38ce3fea22db19b5a1aa": "Returns a shallow copy of the progress data mapping from processed module paths to their associated data. The progress data is retrieved from the internal `_data` dictionary using the key \"__progress__\". This ensures that external modifications to the returned dictionary do not affect the internal state of the cache.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\cache.py:get_progress:8a1af5e6dd9a6f8bfcc4eedbe9ac7c7bed03cdef99b2efadd028fa9c86756b8a:8a1af5e6dd9a6f8bfcc4eedbe9ac7c7bed03cdef99b2efadd028fa9c86756b8a": "The function `get_progress` retrieves and returns a shallow copy of the progress tracking data stored in the `_data` attribute of the `ResponseCache` class. The progress data maps processed module paths to their corresponding information. By returning a copy, the function prevents external modifications to the internal progress mapping.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\cache.py:make_key:1f593e8984573caf6e9db1a32bad2683b02c2ff19e073a331d96f7495d50aabd:1f593e8984573caf6e9db1a32bad2683b02c2ff19e073a331d96f7495d50aabd": "The function `make_key` generates a deterministic cache key by combining a file path with a SHA-256 hash of the file's content. It takes two parameters: `file_path` (a string representing the path to a file) and `content` (a string containing the file's content). The function encodes the content as UTF-8, computes its SHA-256 hash, and returns a string formatted as \"{file_path}:{digest}\", where digest is the hexadecimal representation of the hash. This ensures that the same file path and content combination will always produce the same key, enabling consistent cache lookups.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\cache.py:make_key:80486e27ae5d6bf45f4a9f11b59e90815a14d82e798fc6e486da18aac5bf5dd7:80486e27ae5d6bf45f4a9f11b59e90815a14d82e798fc6e486da18aac5bf5dd7": "The function `make_key` generates a deterministic key based on a file path and its content. It takes two parameters: `file_path` (a string representing the path to a file) and `content` (a string representing the file's content). The function computes a SHA-256 hash of the encoded content and combines it with the file path to produce a unique key in the format `file_path:digest`, where `digest` is the hexadecimal representation of the hash. This key can be used to uniquely identify a specific file and its content for caching or indexing purposes.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\cache.py:set:8705aa0b6c7305ee74c7c83af68c082faea294f79bebad25b1a5d3e5077736df:8705aa0b6c7305ee74c7c83af68c082faea294f79bebad25b1a5d3e5077736df": "The `set` method stores a string value under a specified key in the response cache and persists the updated cache to disk. It updates the internal data dictionary with the key-value pair and then invokes the `_save` method to write the changes to storage.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\cache.py:set:ff82763ae925b6c4225c75e7586458b4704ca83db1b771fa7b90c2804419741d:ff82763ae925b6c4225c75e7586458b4704ca83db1b771fa7b90c2804419741d": "Stores a value under the specified key in the cache and persists the updated cache data to disk.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\cache.py:set_progress_entry:10844ae066235f839933fb165bed61c726840286c388e21808ae96a5985101e2:10844ae066235f839933fb165bed61c726840286c388e21808ae96a5985101e2": "Records the provided `module_data` associated with the given `path` in the progress tracking structure. Updates the internal progress map and persists the changes by saving the data.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\cache.py:set_progress_entry:18ee10626740a9d7bf29e77e0640a07c3d138e1deb592be6f9d39ed460b3b0e5:18ee10626740a9d7bf29e77e0640a07c3d138e1deb592be6f9d39ed460b3b0e5": "Records module data for a specified path in the progress map and saves the cache.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\chunk_utils.py:9148eb950a26929210792751150dea2da5c0a8399b370e1ed539eb2faeed37b0:9148eb950a26929210792751150dea2da5c0a8399b370e1ed539eb2faeed37b0": "The module provides utilities for splitting text into chunks based on natural boundaries like blank lines, Markdown headings, and code fences. It includes functions to strip special FIM tokens, obtain a tokenizer for estimating token counts, and split text into chunks that are approximately a specified number of tokens in size. When a single block exceeds the token limit, it falls back to splitting by character length. The module uses an optional `tiktoken` library for accurate tokenization, with a fallback to a simple space-based splitter if `tiktoken` is unavailable.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\chunk_utils.py:_Simple:2746f1ce55404abdced9ddb88ce76a5c85f0cbb5f750beb1e8e84fbbbfa0d554:2746f1ce55404abdced9ddb88ce76a5c85f0cbb5f750beb1e8e84fbbbfa0d554": "The `_Simple` class provides basic text encoding and decoding functionality, where `encode` converts a string into a list of words by splitting on whitespace after removing FIM tokens, and `decode` reconstructs a string from a list of tokens by joining them with spaces. It serves as a simple utility for handling tokenized text within the documentation generation process. The class supports processing input text for summarization tasks but does not expose any public variables.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\chunk_utils.py:_Simple:decode:0063ff559a778604c0b04e065f2daad212b42862c65cdd97a4fe338261b13bd3:0063ff559a778604c0b04e065f2daad212b42862c65cdd97a4fe338261b13bd3": "This function takes a list of tokens as input and returns a single string formed by joining all tokens with spaces between them.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\chunk_utils.py:_Simple:encode:aa827c73b9b4f1291471e35dcaad0a352e62db69ae2c71f3c7bf8ac77bf42653:aa827c73b9b4f1291471e35dcaad0a352e62db69ae2c71f3c7bf8ac77bf42653": "The function takes a string input, removes FIM tokens from it using a helper function, and splits the resulting string into a list of words based on whitespace separation.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\chunk_utils.py:_split_blocks:1a296d05778138018414482442af6bda8df4552e2321aaff7ecf11398988c4e8:1a296d05778138018414482442af6bda8df4552e2321aaff7ecf11398988c4e8": "The function `_split_blocks` takes a Markdown text string and splits it into distinct blocks, separating paragraphs, headings, and code fences. It processes the input line by line, tracking whether it is inside a code block (delimited by triple backticks) and collecting lines accordingly. When encountering a new heading (line starting with `#`) or an empty line outside of a code block, it finalizes the current block and starts a new one. Code fences are handled as complete blocks, including their opening and closing markers. The result is a list of strings, each representing a distinct Markdown block, with empty entries removed.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\chunk_utils.py:_split_long_block:805be32dcbf01cbfea4c38662b3f0dd1eabf92e16fa63be31416db31a57f4a15:805be32dcbf01cbfea4c38662b3f0dd1eabf92e16fa63be31416db31a57f4a15": "The function `_split_long_block` splits a given string block into smaller chunks based on an estimated token count using a tokenizer. It first encodes the input block into tokens. If the number of tokens is less than or equal to the specified `chunk_size_tokens`, it returns the block as a single-element list. Otherwise, it calculates an average character length per token and determines the maximum number of characters allowed per chunk. The block is then divided into substrings of this maximum character length and returned as a list of strings.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\chunk_utils.py:chunk_text:14b009256b504ce6d9fc7fde828500bd4c7b9df5e55daca33d18b943a4ce3004:14b009256b504ce6d9fc7fde828500bd4c7b9df5e55daca33d18b943a4ce3004": "The function `chunk_text` divides a given text into segments, where each segment contains approximately a specified number of tokens. It processes the text by first splitting it into logical blocks, then aggregates these blocks into chunks without exceeding the token limit. If a block is too large to fit within the limit, it is further subdivided based on character length. The function preserves natural text boundaries such as blank lines, Markdown headings, and code fences when forming chunks.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\chunk_utils.py:decode:f951c684582ab37e50e6407ea0ec3c2031e69a74438f4714d2ec7ac1285c8fa0:f951c684582ab37e50e6407ea0ec3c2031e69a74438f4714d2ec7ac1285c8fa0": "The function `decode` takes a list of tokens as input and returns a single string formed by joining the tokens with spaces. It is a method of the class `_Simple`.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\chunk_utils.py:encode:90f9df0dcee693b923ff31dc856b16683911875edd5a29906efc78806652ef5e:90f9df0dcee693b923ff31dc856b16683911875edd5a29906efc78806652ef5e": "The function `encode` takes a string input `text`, removes FIM (Fix, Improve, Modify) tokens using the `strip_fim_tokens` utility, and then splits the resulting string into a list of words based on whitespace. The output is a list of tokens representing the words in the input text.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\chunk_utils.py:get_tokenizer:a4d901e0a13a5708cad04a8f2d38645783bcf54235409263a0d15df1dd97eacb:a4d901e0a13a5708cad04a8f2d38645783bcf54235409263a0d15df1dd97eacb": "The function `get_tokenizer` returns a tokenizer object for estimating token counts. It attempts to use the `tiktoken` library to load the `cl100k_base` encoding, with fallback to `gpt-3.5-turbo` encoding if the first fails. To handle potential network-related warnings during encoding loading, it temporarily suppresses unraisable exception hooks. If `tiktoken` is unavailable or fails to load, it provides a simple fallback tokenizer that splits text into tokens by whitespace and joins them back with spaces. A warning message is printed to stderr if `tiktoken` cannot be loaded.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\chunk_utils.py:strip_fim_tokens:0f06c5f2f53a03394c10c32b60695002d26c1373fdb0f5d3a2f60ed155e558e9:0f06c5f2f53a03394c10c32b60695002d26c1373fdb0f5d3a2f60ed155e558e9": "The function `strip_fim_tokens` removes FIM (Fill-In-the-Middle) special tokens from a given string. It takes a string input and returns the string with all FIM tokens eliminated using a regular expression substitution. The regular expression pattern used for this purpose is referenced as `FIM_RE`.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\docgenerator.py:790e84c9f06963fa4a190b32761e9ec794933f749bba99c58330687b57f958c9:merge0:0a0137d5586ac5fa63d14058a7b2292d6507bafb0cfeff3ce65a8bb09e8b1948": "This module implements a command-line interface for generating HTML documentation from source code using language model APIs. It processes Python, MATLAB, C++, and Java files by parsing their structural elements, requesting summaries from an LLM client, and writing results to HTML output. The implementation includes functions for cleaning output directories, summarizing code modules with token-based chunking, merging partial summaries, building context-aware prompts for function documentation, rewriting docstrings, and recursively processing functions and class members. It supports caching of LLM responses and handles large code structures by breaking them into manageable chunks while preserving original source structure during processing. The module provides recursive processing of classes, methods, and variables to generate comprehensive summaries and rewrite docstrings, with main functionality that parses source files, builds project summaries, and generates HTML documentation containing navigation and markdown context. It manages caching for both progress tracking and LLM responses, supports resuming or clearing progress, and uses tokenization and chunking techniques to handle large inputs within context limits across multiple programming languages.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\docgenerator.py:790e84c9f06963fa4a190b32761e9ec794933f749bba99c58330687b57f958c9:part0:6f455d4018be53ca6673dae7ee8ef8ea25ac236aa3f05027ef856efdd324c009": "Module defines a command-line interface for generating HTML documentation from source code using LLMs. It processes Python, MATLAB, C++, and Java files by parsing their structure, requesting summaries from an LLM client, and writing the results to HTML output. The implementation includes functions for cleaning existing output directories, summarizing code modules with token-based chunking, merging partial summaries, building context-aware prompts for function documentation, rewriting docstrings, and recursively processing functions and class members. It supports caching of LLM responses and handles large code structures by breaking them into manageable chunks while preserving the original source structure during processing.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\docgenerator.py:790e84c9f06963fa4a190b32761e9ec794933f749bba99c58330687b57f958c9:part1:2525e47e8dcb5b6e66d4b57e251aaa6fe5dc924d2317c8b1b62328461a5d13f9": "The module defines functions for summarizing and documenting code using a local language model. It includes recursive processing of classes, methods, and variables to generate summaries and rewrite docstrings. The main function parses source files, builds a project summary, and generates HTML documentation with navigation and markdown context. It handles multiple programming languages, manages caching for progress and responses, and supports resuming or clearing progress. The implementation uses tokenization and chunking for managing large inputs within context limits.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\docgenerator.py:_build_function_prompt:e124063a5d8ca7931de79b5771e30c2ce6dae7db7ff1ac9009564bc5364b44fe:e124063a5d8ca7931de79b5771e30c2ce6dae7db7ff1ac9009564bc5364b44fe": "The function `_build_function_prompt` generates a context-enriched prompt for summarizing a given function's source code. It accepts the function's source code and optional class and project context details, then constructs a structured prompt string that includes instructions for the documentation generator and the source code enclosed in a code block. The prompt is formatted to guide the summarization process by providing relevant contextual information such as the containing class and project summary, while ensuring the output adheres to specific formatting constraints.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\docgenerator.py:_chunk_module_by_structure:28c3f3f45331ad8a959f0c7a5c62f62f7768e4a33e856a73410a0e36df3262e2:28c3f3f45331ad8a959f0c7a5c62f62f7768e4a33e856a73410a0e36df3262e2": "The function `_chunk_module_by_structure` takes a parsed module dictionary, a tokenizer, and a maximum chunk size in tokens. It organizes the module's content into text chunks that do not exceed the specified token limit. The function processes module-level docstrings, class definitions, methods, variables, and functions, prioritizing structure-based grouping. If individual blocks exceed the token limit, they are further split using a helper function `chunk_text`. The result is a list of text chunks suitable for processing by a language model.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\docgenerator.py:_insert:a43ccdc3e97d58bdc184311857e4289bf4db72f33e3a0e794ed7672bfaa7af60:a43ccdc3e97d58bdc184311857e4289bf4db72f33e3a0e794ed7672bfaa7af60": "The function `_insert` recursively builds a nested dictionary structure to organize items into a tree-like hierarchy based on a list of path components. It takes a dictionary `tree`, a list of strings `parts` representing path segments, a string `name` for the item being inserted, and a string `link` associated with the item. If the `parts` list is empty, it appends a tuple of `(name, link)` to the `\"__files__\"` key in the current tree node. Otherwise, it processes the first segment in `parts`, creates or retrieves a subtree for that segment, and recursively inserts the remaining segments into the subtree. This enables hierarchical organization of items such as files or documentation entries within a structured navigation system.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\docgenerator.py:_merge_recursive:bdeb581638b738adea3aa6d5527fa27136055b4aedbe8b3e701d0f7f3ef5097a:bdeb581638b738adea3aa6d5527fa27136055b4aedbe8b3e701d0f7f3ef5097a": "The function `_merge_recursive` is a recursive helper function designed to merge a list of string items into a single summarized output. It constructs prompts by joining the input strings with bullet points and evaluates whether the combined prompt fits within the token limit defined by `available_tokens`. If the prompt exceeds the limit, it splits the items into groups that fit within the token budget and recursively processes each group. When a single item remains, it processes that item using a chunked summarization approach. The function supports hierarchical merging of items to manage large inputs while respecting token constraints imposed by the language model. It uses caching keys based on depth and operation type to ensure consistent processing and avoid redundant computations.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\docgenerator.py:_rewrite_docstring:4249a1353397da5e9172dc699e2c440c00dea9f3117c4da6d2ca7760b2d53ed6:4249a1353397da5e9172dc699e2c440c00dea9f3117c4da6d2ca7760b2d53ed6": "The function `_rewrite_docstring` updates the docstring of a given code item by generating a new docstring using a language model. It accepts an LLM client, cache, file path, and item dictionary containing source code and current docstring. Optional context such as class name, class summary, and project summary can be provided to enhance the docstring generation.\n\nIf no source or docstring is present, it issues a warning and exits. If no docstring exists, it returns early without modification. When context is provided, it constructs a prompt using `_build_function_prompt` and computes a cache key based on the item's content and context. Otherwise, it uses a default prompt format.\n\nThe function then calls `_summarize_chunked` to process the prompt with the LLM, leveraging caching to avoid redundant computations. The resulting summary replaces the original docstring in the item dictionary. If no valid summary is returned, it defaults to \"No summary available.\"",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\docgenerator.py:_summarize:ad5875efed31362952ae9cc42c7bdcbc61a40fb016cb50abab0eaf22b3ed19c9:ad5875efed31362952ae9cc42c7bdcbc61a40fb016cb50abab0eaf22b3ed19c9": "The function `_summarize` retrieves or generates a summary for a given text using an LLM client and caches the result. It first checks if a cached response exists for the provided key. If so, it returns the cached summary after sanitizing it to prevent tokenizer errors. If no cached response is found, it generates a new summary using the client's `summarize` method with the specified prompt type, stores the result in the cache, and returns the generated summary.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\docgenerator.py:_summarize_class_recursive:db470155994a433d3491dfdcb45c3f19fcf3a285032dacd1af754fb383ce875c:db470155994a433d3491dfdcb45c3f19fcf3a285032dacd1af754fb383ce875c": "The function `_summarize_class_recursive` recursively summarizes a class by processing its members, methods, and variables, and then generates and updates docstrings for the class and its components. It first processes all members of the class using `_summarize_members_recursive`. It constructs formatted text for methods and variables, then creates a prompt using `CLASS_PROMPT` to generate a class summary via `_summarize_chunked`. The generated summary is sanitized and used to update the class's docstring. If an original docstring exists, it is preserved and used in `_rewrite_docstring` to refine the class's documentation. The function then applies `_rewrite_docstring` to each method and variable within the class. Finally, it recursively calls itself for any subclasses present in the class data.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\docgenerator.py:_summarize_function_recursive:e110bf2c3df6875a654c6616d3dc4a316dc4761b278d4f62b111f3f6ff62627c:e110bf2c3df6875a654c6616d3dc4a316dc4761b278d4f62b111f3f6ff62627c": "The function `_summarize_function_recursive` recursively summarizes a given function and its nested subfunctions and subclasses. It constructs a prompt using the function's source code or signature, retrieves or generates a summary via a language model client, and stores the result in the function dictionary. If enabled, it also rewrites the function's docstring. The function processes subfunctions by recursively calling itself and handles subclasses by invoking `_summarize_class_recursive`. It utilizes caching and token budgeting to manage large inputs and ensure efficient processing.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\docgenerator.py:_summarize_members_recursive:8654da784669578bf9785877f93635aba705d0bb141b67703be7b9d81e70ef6f:8654da784669578bf9785877f93635aba705d0bb141b67703be7b9d81e70ef6f": "The function `_summarize_members_recursive` recursively summarizes the methods and variables of a given class and its subclasses. For each method, it retrieves or constructs source code, generates a summary using a chunked summarization approach, and assigns the summary as both the \"summary\" and \"docstring\" fields. It then performs further recursive summarization on the method's contents. Similarly, for each variable, it generates a summary and assigns it to the \"summary\" and \"docstring\" fields. The function also recursively processes any subclasses of the current class, applying the same summarization logic. The summarization uses an LLM client, a response cache, and token budgeting to manage context length.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\docgenerator.py:_summarize_module_chunked:17dfe3e1942eafc94458643b05cd009b0aa981be5f86059db662d8259b0f0b05:17dfe3e1942eafc94458643b05cd009b0aa981be5f86059db662d8259b0f0b05": "The function `_summarize_module_chunked` summarizes a module by using structure-aware chunking to manage token limits for LLM processing. It first checks if the entire module text fits within the available token budget; if so, it summarizes directly. Otherwise, it splits the module into structured chunks based on its hierarchy, processes each chunk, and then merges the partial summaries into a final summary. If structure-based chunking fails, it falls back to summarizing the full module text. The merging process recursively combines summaries while respecting token limits, and in case of failures during merging, it returns a sanitized concatenation of partial summaries. The function uses a tokenizer to estimate token counts and integrates with an LLM client and response cache for efficient processing.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\docgenerator.py:clean_output_dir:e6523e926dac13d9cb9ca45f8a6c1bf4886bebfd8dc96cebaf04a52ababe0969:e6523e926dac13d9cb9ca45f8a6c1bf4886bebfd8dc96cebaf04a52ababe0969": "The function `clean_output_dir` removes HTML files from a specified output directory if they were generated by DocGen-LM. It iterates through all files in the directory, checks if a file has a `.html` extension, and reads the first line of the file. If the first line contains the string \"Generated by DocGen-LM\", the file is deleted. Any errors encountered while processing a file are caught and reported as warnings, but do not stop the function's execution.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\docgenerator.py:main:9efbdcefbdada3811bda496623fd06341a42641bdca8c62aa493a7bdc2dfc890:9efbdcefbdada3811bda496623fd06341a42641bdca8c62aa493a7bdc2dfc890": "The `main` function serves as the primary entry point for generating HTML documentation from source code using a local language model. It accepts command-line arguments to configure the source directory, output location, LLM API endpoint, token limits, and other processing options. The function initializes an LLM client, validates connectivity, and sets up tokenization and chunking parameters based on context limits.\n\nIt scans the source directory for supported files (Python, C++, Java, MATLAB), parses them into structured data, and summarizes modules using chunked LLM requests. The function maintains progress tracking via a cache to support resumable runs and clears progress upon successful completion if specified.\n\nFor each module, it processes classes and functions recursively to generate detailed summaries, integrating project-level context for enhanced accuracy. Markdown files from documentation directories are also included in the project summary. After all processing is complete, the function writes an index page and individual module pages to the output directory, updating the progress cache accordingly. The function returns an integer exit code indicating success or failure.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:5c43aa85822144159cdb19689df89d86e6e5d4d653e2c12166248aeee5cd442a:merge0:6161833f942bb0dd36c89448e6fa8bb937cc52c7868df11c07ac40f14fdc19f0": "This module provides functionality for generating project documentation summaries by processing documentation and code files. It includes configuration handling, file collection from specified paths, and text extraction from various document formats. The module supports section mapping based on keywords, ranking of code files using heuristics, and insertion of navigation links into HTML index files. It defines functions for extracting code snippets from files, organizing them by manual sections, and generating documentation using LLMs, including logic to scan code files, parse Python syntax, and collect relevant documentation parts such as docstrings, CLI parsers, and main blocks. The `scan_code` function ranks files based on patterns and categorizes snippets into sections, while `llm_generate_manual` creates manual sections from documentation snippets and `llm_fill_placeholders` updates the manual by replacing placeholder tokens with information extracted from code snippets. An auxiliary function `_edit_chunks_in_editor` allows users to manually edit documentation chunks in their preferred editor. The module also includes functions for rendering HTML from structured sections, parsing manual content into sections, validating file references within those sections, inferring section structure from plain text, and writing HTML content to PDF format. The `render_html` function generates an HTML document with navigation and styled content, incorporating evidence snippets when section content is missing.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:5c43aa85822144159cdb19689df89d86e6e5d4d653e2c12166248aeee5cd442a:part0:cad03170c79ae4f0d1d2f36c57f3909c62a26464f20a175abadc08436cee8417": "The module defines functionality for generating project summaries from documentation and code files. It includes configuration handling, file collection from specified paths, text extraction from various document formats, section mapping based on keywords, and ranking of code files using heuristics. The module also supports inserting navigation links into HTML index files and detecting placeholder sections within text.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:5c43aa85822144159cdb19689df89d86e6e5d4d653e2c12166248aeee5cd442a:part1:1d7f8b24a1310f8f2ff2b36d1a1e2d3af8011bf41c2706426d0f025a6d5852db": "The module defines functions for extracting code snippets from files, organizing them by manual sections, and generating documentation using LLMs. It includes logic to scan code files, parse Python syntax, and collect relevant documentation parts such as docstrings, CLI parsers, and main blocks. The `scan_code` function ranks files based on patterns and categorizes snippets into sections. The `llm_generate_manual` function uses LLMs to create manual sections from documentation snippets, handling both inferred and provided content. The `llm_fill_placeholders` function updates the manual by replacing placeholder tokens with information extracted from code snippets. An auxiliary function `_edit_chunks_in_editor` allows users to manually edit documentation chunks in their preferred editor.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:5c43aa85822144159cdb19689df89d86e6e5d4d653e2c12166248aeee5cd442a:part2:728ef003d9b9cf619f2797bd3f130e29e504e38c3a5e8a9633d300640b8df8a4": "The module defines functions for rendering HTML from structured sections, parsing manual content into sections, validating file references within those sections, inferring section structure from plain text, and writing HTML content to PDF format. The `render_html` function generates an HTML document with navigation and styled content, incorporating evidence snippets when section content is missing. The `parse_manual` function processes raw text into a dictionary of sections, inferring missing required sections using an LLM if enabled. The `validate_manual_references` function checks for missing file references in section content and annotates them. The `infer_sections` function creates a basic section structure from plain text. The `write_pdf` function converts HTML to PDF using a canvas library.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:5c43aa85822144159cdb19689df89d86e6e5d4d653e2c12166248aeee5cd442a:part3:a9277aadc6312b031707b1eddb8a882d73e638ba5c39005838093b1f6829288b": "The module defines a function `main` that orchestrates the generation of project documentation summaries. It accepts command-line arguments to configure the output format, target directory, title, and code scanning behavior. The function processes documentation files, uses an LLM client to generate a manual, and handles missing sections by optionally scanning code. It supports HTML and PDF output formats, and can insert the generated manual into an index file. The process includes logging, caching, and validation steps. In case of LLM failure, it falls back to inferring sections from documentation text. The final output is written to a file with associated evidence metadata.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:Config:4a4c422a74697f35b868f237d8aad578cc1aa9a2f7bae0ca12357a8810bab574:4a4c422a74697f35b868f237d8aad578cc1aa9a2f7bae0ca12357a8810bab574": "The `Config` class serves as a configuration handler for the DocGen-LM documentation generator, managing settings and parameters needed for processing source files across multiple programming languages. It supports features like language detection, path configuration, and LLM integration for summarization tasks. The class facilitates both command-line and GUI operation while maintaining cached progress for resumable documentation generation runs.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:_edit_chunks_in_editor:6e6e8831792ee7c780677eabf55517c04ad86f16645568a786e07b737b4c0bf8:6e6e8831792ee7c780677eabf55517c04ad86f16645568a786e07b737b4c0bf8": "The function `_edit_chunks_in_editor` takes a list of strings (`chunks`) and opens them in a user's preferred text editor for modification. The chunks are joined with a separator line (`---`) and written to a temporary file. The user's editor is determined by environment variables `EDITOR` or `VISUAL`, defaulting to `vi` if neither is set. After the editor is closed, the modified content is read back from the temporary file, split by the separator, and returned as a list of non-empty, stripped strings. The temporary file is deleted after use.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:_slugify:389a7378184f8f9eda22f5f975f0647e94c20db0a3389b653ffb07c2f82a3d8e:389a7378184f8f9eda22f5f975f0647e94c20db0a3389b653ffb07c2f82a3d8e": "The function `_slugify` converts a given string into a URL-friendly slug format. It transforms the input text to lowercase, replaces all non-alphanumeric characters with hyphens, and removes any leading or trailing hyphens from the result.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:collect_docs:590dd718371773127f7360206268fbc73af48ddcf2b2d1f646257506382f2ab5:590dd718371773127f7360206268fbc73af48ddcf2b2d1f646257506382f2ab5": "The function `collect_docs` gathers documentation files located under a specified base directory. It identifies files matching certain patterns in two locations: the project root and a `docs` subdirectory. Specifically, it collects files with extensions `.md`, `.txt`, `.html`, and `.docx` in the root, and recursively finds all `.html` and `.md` files within the `docs` directory. The function ensures that each file is included only once by tracking seen paths and returns a list of unique documentation file paths.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:collect_files:a65905d3323d9312332bd48934ed51dcf691690e9b0acd73d96d522a31600955:a65905d3323d9312332bd48934ed51dcf691690e9b0acd73d96d522a31600955": "The function `collect_files` takes a base directory path and an optional list of additional file patterns, then returns a list of unique file paths within the base directory that match the specified patterns. It first defines a default set of file patterns including README.md, text files, HTML files, DOCX files, CSV files, and JSON files. It then recursively searches for files matching these patterns in the base directory and any additional patterns provided. The function ensures that each file path appears only once in the returned list by tracking seen files.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:detect_placeholders:2c7b3d7808259f114d0d3baefe05fd63e74d2f7272735807608882d0849eb4a8:2c7b3d7808259f114d0d3baefe05fd63e74d2f7272735807608882d0849eb4a8": "The function `detect_placeholders` identifies and returns a list of section names from a given text that are still marked by placeholder tokens. It takes a string input `text`, uses the helper function `find_placeholders` to locate tokens within the text, and then filters these tokens against a predefined dictionary `SECTION_PLACEHOLDERS`. The result is a list of section names whose corresponding placeholder tokens were found in the input text.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:extract_snippets:7a6166e4507a06624e95d62abd95059cea965cf4fcd642ec29ff0a08bbd0706f:7a6166e4507a06624e95d62abd95059cea965cf4fcd642ec29ff0a08bbd0706f": "The function `extract_snippets` extracts relevant code snippets from a collection of files, returning a dictionary mapping file paths to their extracted content. It iterates through the provided files, respecting limits on the number of files, total time, and individual file size. For Python files, it parses the abstract syntax tree to extract module docstrings, function and class docstrings, I/O signatures, CLI parser information, and `__main__` blocks. For non-Python files, it includes the entire file content. The function skips files that exceed size limits, cannot be read, or fail to parse. Progress is logged, and the output is structured into parts based on the file type and content.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:extract_text:9f2cab5dbe76ac6dd25dd89c4e0ecec436c9a110e446f192cc3c2afa06eb124f:9f2cab5dbe76ac6dd25dd89c4e0ecec436c9a110e446f192cc3c2afa06eb124f": "The function `extract_text` reads and extracts plain text from a file located at the given path, handling different file types based on their suffix. It supports HTML, Markdown (.md), and Word (.docx) files. For HTML files, it processes headings by converting them to markdown-style headers and code blocks into fenced code blocks before extracting the text. For Markdown files, it returns the raw text content. For Word documents, it converts paragraphs into text, formatting headings as markdown headers and preserving regular paragraphs. If the file type is not specifically handled or an error occurs during processing, the function returns an empty string.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:infer_sections:bddca2c6344757c3851325c1fd202bc6a97e11a3ef0365131c9e03e171230170:bddca2c6344757c3851325c1fd202bc6a97e11a3ef0365131c9e03e171230170": "The function `infer_sections` takes a string input and returns a dictionary of sections. If the input text is non-empty, it places the text under the \"Overview\" section and populates the remaining required sections with placeholder content labeled as \"(inferred)\". If the input text is empty, all required sections are assigned a default message indicating no information is provided. The function uses a predefined list `REQUIRED_SECTIONS` to determine which sections to include in the output dictionary.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:inject_user_manual:c989b3887a39d15d9b0f24e6d975db262d1fa4d162b28cd9df45617dc2501726:c989b3887a39d15d9b0f24e6d975db262d1fa4d162b28cd9df45617dc2501726": "The function `inject_user_manual` inserts a hyperlink to a user manual into an HTML file specified by `index_path`. The link, with the text defined by `title` and pointing to `filename`, is added as the first element within the first navigation structure (`<nav>` or `<ul>`) found in the document. If no such structure exists, the link is inserted at the beginning of the first element within the `<body>` tag or the root of the document. The function reads the HTML content using BeautifulSoup, modifies it to include the new link, and writes the updated content back to the file. If reading the file fails, the function silently returns without making changes.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:insert_into_index:9fd0e0e677c8dff8c21089d3ae23dc39493be24b14291f63cd3f4d2f853ccd1c:9fd0e0e677c8dff8c21089d3ae23dc39493be24b14291f63cd3f4d2f853ccd1c": "The function `insert_into_index` appends a navigation link to an HTML file. It takes the path to an index file, a title for the link, and the filename to link to. The function reads the HTML content of the index file, parses it using BeautifulSoup, and finds either a `<ul>` or `<nav>` element to insert the new link into. If a link with the same `href` already exists, it does nothing. Otherwise, it creates a new `<a>` tag with the provided title and filename, wraps it in a `<li>` tag if the container is a `<ul>`, and appends it to the container. Finally, it writes the modified HTML back to the index file. If any error occurs during parsing or writing, the function silently returns without making changes.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:llm_fill_placeholders:ba726c6dbcc2eea6bada8d961e7d4d6df8340f3c3b43226e30751373d03ce291:ba726c6dbcc2eea6bada8d961e7d4d6df8340f3c3b43226e30751373d03ce291": "The function `llm_fill_placeholders` updates a manual text by replacing placeholders with relevant code snippets from a dictionary of code files. It processes each section of code snippets, summarizes them if they exceed the token budget, and uses an LLM client to generate updated manual content. The function maintains token usage within the model's context window by summarizing long snippets and returns the updated manual text after processing all sections.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:llm_generate_manual:1c59c1c5ae17732fabe4df7db69aa406fb43fecdb809658f28b4fd4de91a4c06:1c59c1c5ae17732fabe4df7db69aa406fb43fecdb809658f28b4fd4de91a4c06": "The function `llm_generate_manual` generates a user manual from provided documentation snippets by mapping them to predefined sections, performing LLM-based summarization for each section, and assembling the final output. It takes a dictionary of documentation paths to content, an LLM client for generating summaries, a response cache for storing and retrieving prior results, and an optional chunking strategy.\n\nFor each required section, it retrieves relevant documentation snippets, constructs a prompt using those snippets, and determines whether the section content should be inferred or generated from the snippets. If inference is needed, it uses a placeholder; otherwise, it sends the context to the LLM with a system prompt that restricts responses to only the provided information.\n\nThe function handles large inputs by chunking when necessary, using token limits and a tokenizer to manage context size. It caches results to avoid redundant processing and sanitizes outputs before use. The output includes the final manual text, a mapping of source files to sections they contributed to, and an evidence map detailing which snippets were used for each section.\n\nThe function relies on helper utilities such as `map_evidence_to_sections`, `summarize_chunked`, `sanitize_summary`, `parse_manual`, and `find_placeholders` to manage the documentation processing pipeline. It logs information",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:main:3b2475bfc1f5f9e3cb93cd8c6340e4b9e2bb8bec4b27677d99088e132daf9011:3b2475bfc1f5f9e3cb93cd8c6340e4b9e2bb8bec4b27677d99088e132daf9011": "The `main` function serves as the primary entry point for the documentation generation tool. It accepts command-line arguments to configure the documentation process, including project path, output format (HTML or PDF), title, and code scanning behavior. The function initializes a configuration object based on parsed arguments and sets up the output directory.\n\nIt reads existing documentation files from the project, processes them using an LLM-based summarization pipeline, and handles missing sections by optionally scanning code if needed. The tool supports chunking strategies for large inputs and caches responses to avoid redundant processing. If LLM summarization fails, a fallback mechanism infers sections from combined text.\n\nThe generated content is rendered into HTML or PDF format, with options to insert a link into an existing `index.html`. Evidence maps are saved alongside the output, and the tool supports resumable runs through caching and progress tracking. The function returns an integer indicating success or failure of the operation.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:map_evidence_to_sections:996a48fe0d4205c6ad5bda667ae16186594dd7f60c6a82c15963cb39feb94f1d:996a48fe0d4205c6ad5bda667ae16186594dd7f60c6a82c15963cb39feb94f1d": "The function `map_evidence_to_sections` maps documentation snippets from source files to predefined manual sections based on keyword matching. It takes a dictionary of file paths to their content and returns a tuple containing:\n\n1. A mapping (`section_map`) from section names to lists of tuples, each containing a file path and a snippet of text belonging to that section.\n2. A mapping (`file_map`) from each file path to the set of sections it contributed to.\n\nThe function processes each file's content line-by-line, searching for lines that match keywords associated with specific sections. When a match is found, it collects subsequent non-empty lines up to a maximum number of lines (`MAX_SNIPPET_LINES`), excluding lines that are empty, start with `#`, or are HTML header tags. Snippets are limited to the top 10 longest per section, except for \"Overview\" entries which are prioritized based on file path characteristics.\n\nSections are sorted differently depending on whether they are \"Overview\" or not:\n\nOnly snippets from files not in excluded directories (`tests`, `examples",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:parse_manual:cbe2fcd05b6ee4f8355466bb6c77f20762318b235134ea2cc0d48ddeadde6738:cbe2fcd05b6ee4f8355466bb6c77f20762318b235134ea2cc0d48ddeadde6738": "The function `parse_manual` takes a text input and parses it into structured sections based on colon-separated headings. It splits the input text on lines containing a colon, extracting section names and their corresponding content. If `infer_missing` is enabled and required sections are missing, it uses an LLM client to generate inferred content for those sections. The function returns a dictionary mapping section names to their content, with inferred sections marked as \"(inferred)\". It handles multi-line content under a section heading and ensures all required sections are present in the output.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:rank_code_files:bd612723b4b18e4115b9b44f91ebd74fa8661876e5e53750917ef0b18bd87819:bd612723b4b18e4115b9b44f91ebd74fa8661876e5e53750917ef0b18bd87819": "The function `rank_code_files` takes a root directory path and a list of patterns, and returns a sorted list of code file paths under the root directory. The files are ranked based on simple heuristics that consider the presence of specific keywords in the relative file paths and matches against provided patterns. Supported file extensions include Python (.py), MATLAB (.m), Jupyter Notebook (.ipynb), C++ (.cpp, .h), and Java (.java). The function excludes certain directories such as virtual environments, version control folders, build artifacts, and test-related directories from consideration. Files are scored based on keyword matches and pattern inclusion, with higher scores indicating priority. The final list is sorted by score (descending) and then lexicographically by path.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:render_html:3e4915376b2a09024c47993f646616216786a8e24f0d99c716b531d7f1358037:3e4915376b2a09024c47993f646616216786a8e24f0d99c716b531d7f1358037": "The `render_html` function generates an HTML document from a dictionary of sections, each containing content and optional evidence snippets. It constructs a navigable HTML page with a title, a table of contents, and section headers with anchor links. For each section, if the content is empty or marked as \"no information provided\" and evidence is available, it displays the evidence snippets and associated source files. Otherwise, it renders the content using Markdown (if available) or escapes it as plain text. The function uses a helper `_slugify` to create URL-safe anchors for navigation and applies basic styling to the output. The resulting HTML includes structured sections, navigation, and formatting for both content and evidence.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:scan_code:68e5d1c66484b938003fa6bd6cbb4691cee192e1bc511582602de1976df716f3:68e5d1c66484b938003fa6bd6cbb4691cee192e1bc511582602de1976df716f3": "The function `scan_code` collects source code snippets from a specified base directory, organizing them by manual sections based on keyword matching. It accepts parameters to limit the number of files processed, the time budget, and the maximum bytes per file. The function first gathers documentation files, extracts text, and identifies patterns such as file paths or Python file extensions. These patterns are used to rank code files, which are then extracted into snippets with size and time constraints. The resulting snippets are categorized by section based on predefined keywords, and only sections with matching snippets are returned in the output dictionary.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:slugify:99ab1395d03f9d0d8b550f5200fd2955c36819b730606b12489a77702ca33701:99ab1395d03f9d0d8b550f5200fd2955c36819b730606b12489a77702ca33701": "The function `slugify` converts a given string into a filesystem-friendly slug. It takes a string input, converts it to lowercase, and replaces any sequence of non-alphanumeric characters with underscores. Leading and trailing underscores are removed from the result. If the resulting string is empty, it defaults to returning \"user_manual\".",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:validate_manual_references:8b74090425b7e4f874ca52885483b7c52a67e0c8c737bf97014c4952b941a103:8b74090425b7e4f874ca52885483b7c52a67e0c8c737bf97014c4952b941a103": "The function `validate_manual_references` identifies and flags file references within sections of documentation that do not correspond to existing files in a project. It takes a dictionary of section titles and their text content, a project root path, and an optional evidence map for recording missing references.\n\nUsing a regular expression, it scans each section's text for substrings that resemble file paths or module names with specific extensions (e.g., `.py`, `.m`, `.md`). For each matched reference, it checks whether the reference exists as a file or filename within the project root. If a match is not found, the reference is annotated with `[missing]` in the section text.\n\nIf an `evidence_map` is provided, missing references are also recorded under a `missing_references` key for each section. The function modifies the input `sections` dictionary in place, updating the text content to include the `[missing]` annotations and optionally logging missing references in the evidence map.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:write_pdf:e9855c83e5c47d1b9e9f951a86729443a3750cab0e7d0651cfb733698a450d18:e9855c83e5c47d1b9e9f951a86729443a3750cab0e7d0651cfb733698a450d18": "The function `write_pdf` converts HTML content into a PDF file using the `reportlab` library. It takes an HTML string and a file path as inputs, and writes the text content of the HTML to the specified path as a PDF document. The function returns `True` if successful, or `False` if the required `canvas` module is not available. The text from the HTML is extracted using `BeautifulSoup`, split into lines, and written to the PDF using a `Canvas` object with a letter-sized page format.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:CollapsibleBox:__init__:089f54c1ff6b251bb919dd67c7e75534c8b994f331a7a8e29287a99dc891260f:089f54c1ff6b251bb919dd67c7e75534c8b994f331a7a8e29287a99dc891260f": "Initializes a collapsible section widget with a toggle button and content area. Creates a tool button styled as a title bar with a right-pointing arrow indicator, sets up a vertical layout containing the button and a hidden content widget, connects the button's clicked signal to a toggle handler, and applies specific styling to the button. The content widget is initially hidden and will be shown or hidden based on the toggle state.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:CollapsibleBox:ce60c33f9e060b8c49ad00e56dd761804896602ab41006bc9bdbe2513a9209f7:ce60c33f9e060b8c49ad00e56dd761804896602ab41006bc9bdbe2513a9209f7": "The `CollapsibleBox` class implements a widget with a toggleable content area, featuring a styled button that displays a title and arrow icon to indicate expand/collapse state. When the toggle button is pressed, the `on_toggled` method updates the arrow direction and shows or hides the content area accordingly. The `setContentLayout` method allows customization of the content area's layout through a provided layout object.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:CollapsibleBox:on_toggled:6749018187cbdf12b01fca350d366f3e2051050d7b90ffdc1826912d6ff7f2eb:6749018187cbdf12b01fca350d366f3e2051050d7b90ffdc1826912d6ff7f2eb": "Function that handles toggle button state changes by updating the button's arrow direction and showing or hiding associated content based on whether the button is checked.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:CollapsibleBox:setContentLayout:ac9bfe1723225a787e6fed8f56df1803aac7bf21a8460cdab57bb446c2364b27:ac9bfe1723225a787e6fed8f56df1803aac7bf21a8460cdab57bb446c2364b27": "The function sets the layout for an object's content area. It takes a layout parameter and assigns it to the layout property of the content attribute of the instance.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:CommandRunner:__init__:e101f462c35c5d2aea35db85e4ee5dd50b4513aa99b522541dc82c8e27a017f4:e101f462c35c5d2aea35db85e4ee5dd50b4513aa99b522541dc82c8e27a017f4": "Initializes an object with a collection of commands and calls the parent class initializer.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:CommandRunner:_reader:8cbfd3ce114ed1c88228963326a3e4e5c43e87fbd062a6965099f60e48b826d6:8cbfd3ce114ed1c88228963326a3e4e5c43e87fbd062a6965099f60e48b826d6": "Function reads from a stream character by character, collecting text into buffers and emitting chunks. It handles carriage return characters by flushing the buffer and emitting the return character, allowing GUI progress bar updates. Line feed characters trigger emission of the buffered text plus the newline, then reset the buffer. Other characters are appended to the buffer. When end of stream is reached, any remaining buffered text is emitted before breaking the loop.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:CommandRunner:c40ddab8d14a47b238b1ddfd0afee56a74ef25acddad1fd4854b4f3a20abaf90:c40ddab8d14a47b238b1ddfd0afee56a74ef25acddad1fd4854b4f3a20abaf90": "The `CommandRunner` class executes a sequence of shell commands, capturing their output in real-time using dedicated reader threads for stdout and stderr. It processes each command's output character by character, emitting chunks and carriage returns for progress updates, and stops execution if any command fails. The class handles exceptions during command execution and signals completion with a final return code.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:CommandRunner:run:c94857cc54e41729c04041a0a02b8ef637ddeb94d917c5048d30a4c9036c500a:c94857cc54e41729c04041a0a02b8ef637ddeb94d917c5048d30a4c9036c500a": "Function executes a sequence of shell commands, emitting output for each command. It uses subprocess to run commands and threads to handle stdout and stderr reading concurrently. The function tracks return codes and stops execution if any command fails. Upon completion, it emits the final return code.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:MainWindow:__init__:28dcf5dc3d1101be993832fad1e6ab88ca620dc517eca90828727454f110a1e9:28dcf5dc3d1101be993832fad1e6ab88ca620dc517eca90828727454f110a1e9": "Initializes the user interface for a documentation tool with components for selecting project and output directories, configuring DocGen and ExplainCode options, displaying logs, and controlling execution of documentation generation processes. Includes widgets for path selection, checkboxes for language and feature options, a combobox for output format, and buttons to trigger different processing actions. Sets up a dark-themed style and organizes interface elements into collapsible sections.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:MainWindow:append_log:21ba5c332300d9c644f85e2fb0258c440926a8fe2cc43499e41598c9a97b088d:21ba5c332300d9c644f85e2fb0258c440926a8fe2cc43499e41598c9a97b088d": "Function appends text to a log widget while handling carriage return characters by replacing text on the current line and ensures the scroll bar remains at the maximum position.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:MainWindow:build_docgen_cmd:0bb90693d605ca6dd10cc8c288bcba60e30d0e2879a67edc4e2df09ee6cb5998:0bb90693d605ca6dd10cc8c288bcba60e30d0e2879a67edc4e2df09ee6cb5998": "Function builds a command list for running a documentation generator script with specified project and output paths, optional resume flag, and private inclusion flag.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:MainWindow:build_explain_cmd:7b8696f7337008622c6bc5488b4fc92413596481c1750330bdc72564631f2cb5:7b8696f7337008622c6bc5488b4fc92413596481c1750330bdc72564631f2cb5": "Function builds a command list for executing an explanation process with specified project path, output location, and format. Includes optional data parameter when enabled and populated. Returns the constructed command array for subprocess execution.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:MainWindow:c88fd8fd243bd0c210a4797b3361b2c4df3682090c79a4f87e21d01cda155572:c88fd8fd243bd0c210a4797b3361b2c4df3682090c79a4f87e21d01cda155572": "The `MainWindow` class implements a graphical user interface for the DocGen-LM documentation tool, allowing users to configure and execute documentation generation and code explanation tasks for multiple programming languages. It provides functionality to select project and output directories, choose supported languages and output formats, and manage the execution of both DocGen and ExplainCode processes with progress logging and resumable capabilities. The class handles user interactions through buttons and input fields, manages command construction and execution via a background thread, and updates the UI to reflect the running status of tasks.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:MainWindow:dark_style:024d23387b641216e7d149e6c045b026f1a451318d781be0d3d84d51867f51ef:024d23387b641216e7d149e6c045b026f1a451318d781be0d3d84d51867f51ef": "Function defines a dark theme styling configuration for a graphical user interface, specifying colors and fonts for various widget types including general widgets, line edits, plain text edits, combo boxes, push buttons, and labels. The styling uses a dark color scheme with specific background colors, text colors, border styles, and padding values for different UI elements.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:MainWindow:on_finished:c98dd27bd106b89d8d5059a01d5a7c208db9c09ee3836ee9d932c0f5bdb99f8b:c98dd27bd106b89d8d5059a01d5a7c208db9c09ee3836ee9d932c0f5bdb99f8b": "Function that handles process completion by logging the exit code and updating the running status.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:MainWindow:run_both:123251ea533aa28d4fb511b62f853998d3769fcced0962a00cdc1cb16c3cfef0:123251ea533aa28d4fb511b62f853998d3769fcced0962a00cdc1cb16c3cfef0": "Function executes two commands sequentially using a command builder and clears log before execution.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:MainWindow:run_commands:259d9e78ac20ac9cd282474591a8079c54a2e042ef9670b77335a47dad9adaff:259d9e78ac20ac9cd282474591a8079c54a2e042ef9670b77335a47dad9adaff": "Function executes a series of commands using a command runner, after validating that project and output directories are specified. It updates the UI to indicate running state, connects signal handlers for output and completion events, and initiates the command execution process.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:MainWindow:run_docgen:0249c14aca7d5d21ff6d3b7929c59f2dbc05b970b05e9329f97566991188ecf6:0249c14aca7d5d21ff6d3b7929c59f2dbc05b970b05e9329f97566991188ecf6": "Function executes documentation generation by clearing logs and running the documentation generation command.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:MainWindow:run_docgen_resume:3ccc689d89d3b9b2ab503890dea8bd89d99eb8079f6815145e40aaba2eea6816:3ccc689d89d3b9b2ab503890dea8bd89d99eb8079f6815145e40aaba2eea6816": "Function executes documentation generation with resume option by clearing log and running build command with resume flag.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:MainWindow:run_explain:aaae3953f6dfd026db21ab5cd9b5c637f7a8e0fee01ae706e4db035bf9a67663:aaae3953f6dfd026db21ab5cd9b5c637f7a8e0fee01ae706e4db035bf9a67663": "The function clears the log and executes a command built by `build_explain_cmd()`.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:MainWindow:select_dir:2a0195f8b02fa1d0340ed30e33775539f64b5ddf0498a2fae1d7426f16c229f5:2a0195f8b02fa1d0340ed30e33775539f64b5ddf0498a2fae1d7426f16c229f5": "Function that opens a file dialog to select a directory and sets the selected path to a specified line edit widget.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:MainWindow:select_file:eefcbb0d572a55989ebf1a954aae8e90553ec7f2c5c165ee8e6029c3df4770d3:eefcbb0d572a55989ebf1a954aae8e90553ec7f2c5c165ee8e6029c3df4770d3": "Function that opens a file dialog to select a data file and sets the selected path in a line edit widget. The dialog filters for JSON, CSV, and TXT files, with an option to show all files. If a file is selected, the path is displayed in the provided line edit field.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:MainWindow:set_running:0060e79ba63c4489d68b4a831c921909f5e89ae4a7e0028231ef70a8d4836731:0060e79ba63c4489d68b4a831c921909f5e89ae4a7e0028231ef70a8d4836731": "Function that disables or enables multiple buttons based on a running state flag. Takes a boolean parameter 'running' and iterates through four button objects, setting each button's enabled state to the logical inverse of the running flag. When running is True, all buttons are disabled; when running is False, all buttons are enabled.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:PathLineEdit:__init__:c9e8a7be9ec3c7638ba891fb56438f32b028d50d553e3cf05183fab3aa0b6309:c9e8a7be9ec3c7638ba891fb56438f32b028d50d553e3cf05183fab3aa0b6309": "Initializes a class instance with optional parent parameter, calls parent class initialization, and enables drag-and-drop acceptance functionality.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:PathLineEdit:a4faeb21d15ccb9cef721724b08752ce5b208c00432c7acfc4a514e10bfd8ac4:a4faeb21d15ccb9cef721724b08752ce5b208c00432c7acfc4a514e10bfd8ac4": "The `PathLineEdit` class defines a line edit widget that accepts drag-and-drop operations for files and directories, allowing users to easily input paths by dropping items onto the widget. It handles drag enter and drop events to detect URL data and extract local file paths from dropped URLs, updating the widget's text content accordingly. The class extends standard line edit functionality to support intuitive path selection through graphical drag-and-drop interactions.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:PathLineEdit:dragEnterEvent:362f23d15259d38f2384b97d4fe0df74d022e537eb20da5aa442f957d48d0d35:362f23d15259d38f2384b97d4fe0df74d022e537eb20da5aa442f957d48d0d35": "The function handles the drag enter event for a graphical user interface element. It checks if the dragged data contains URLs and accepts the proposed action if so.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:PathLineEdit:dropEvent:2bae52494ea3b00064a9fc268f5338cc663c0b954be820963c807172bd13b7cf:2bae52494ea3b00064a9fc268f5338cc663c0b954be820963c807172bd13b7cf": "The function handles file drop events by extracting URLs from the event's MIME data. When URLs are present, it sets the widget's text content to the local file path of the first URL in the list.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:__init__:0ce701ba6747e684d5fc9275b9fe6b62dc9fe959cff2506001263387372114f4:0ce701ba6747e684d5fc9275b9fe6b62dc9fe959cff2506001263387372114f4": "Initializes the main window for the DocGen-LM Documentation Tool, setting up the user interface with a header containing a logo and title, project and output directory selectors, DocGen options including private function inclusion and language selection, ExplainCode options for output format and data analysis, a log display area, and control buttons for running DocGen, resuming DocGen, running ExplainCode, or running both tools. The interface uses a dark theme style and includes functionality for browsing directories and files, with conditional enabling of data input fields based on checkbox states.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:__init__:58bf29811c1b3536c5d8a00df09294673026f4fe69945d94b9dd15b8a0c1ef55:58bf29811c1b3536c5d8a00df09294673026f4fe69945d94b9dd15b8a0c1ef55": "Initializes the `MainWindow` class, setting up the graphical user interface for the DocGen-LM documentation tool. The constructor configures the window title, applies a dark theme style, and creates UI elements including a header with logo and title, project and output directory selectors with browse buttons, checkboxes for including private functions and selecting supported languages (Python, MATLAB, C++, Java), options for ExplainCode output format and data inclusion, a log display area, and buttons to run DocGen, resume DocGen, run ExplainCode, or execute both processes. The layout organizes these components vertically, with collapsible sections for DocGen and ExplainCode options.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:__init__:69c0b861f67ef4966bb772c69e8177ced3ed32c521acb39b5c41bd40f53f9963:69c0b861f67ef4966bb772c69e8177ced3ed32c521acb39b5c41bd40f53f9963": "Initializes a `CollapsibleBox` widget with an optional title and parent. Creates a toggle button styled to display the title and an arrow icon, which controls visibility of the content area. The content area is initially hidden. Sets up a vertical layout for the widget, adding the toggle button and content area to it. Connects the toggle button's clicked signal to the `on_toggled` method.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:__init__:6f9ba9c281481c252c098bd3e585410aed7976cac85decaf1d91a0d85184ff58:6f9ba9c281481c252c098bd3e585410aed7976cac85decaf1d91a0d85184ff58": "Initializes a `PathLineEdit` instance, setting up the widget as a line edit that accepts drag-and-drop operations. It inherits from a base class and enables the widget to receive dropped files or directories.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:__init__:95fbf02e6745291af9c5dbb009aa6e5ee8eea7ee2b1aa648f23b6b05703182ab:95fbf02e6745291af9c5dbb009aa6e5ee8eea7ee2b1aa648f23b6b05703182ab": "Initializes a PathLineEdit instance with optional parent widget, calling the parent constructor and enabling drag-and-drop functionality for file path input.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:__init__:9e2628846c54c6724661103463599cc76356740ad4357ab3d862f0a1b6c7d20f:9e2628846c54c6724661103463599cc76356740ad4357ab3d862f0a1b6c7d20f": "Initializes the `CommandRunner` instance with a collection of commands.\n\nSets the instance's `cmds` attribute to the provided `cmds` parameter, inheriting from a parent class using `super()`.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:__init__:a19bf7a5271f6dba6532453e24982b80736e0c65d7b84cbe6fc1ca1ae0c36562:a19bf7a5271f6dba6532453e24982b80736e0c65d7b84cbe6fc1ca1ae0c36562": "Initializes a CollapsibleBox widget with a title and parent. Creates a toggle button styled as a header with an arrow indicator, and a content area that is initially hidden. The toggle button is connected to the on_toggled method to handle visibility changes. Sets up a vertical layout containing the toggle button and content widget.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:__init__:ea8888224d34ad2b834c193fc5934ea4345afb8919d30e5c4182eba5de0e3d92:ea8888224d34ad2b834c193fc5934ea4345afb8919d30e5c4182eba5de0e3d92": "The `__init__` method initializes a `CommandRunner` instance by calling the parent class constructor and storing the provided `cmds` parameter as an instance attribute.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:_reader:1176b052e8c5a24ba9872768ce91cf27ea2fe85f17a07bf931b91b45a0d7a107:1176b052e8c5a24ba9872768ce91cf27ea2fe85f17a07bf931b91b45a0d7a107": "The function `_reader` reads from a given stream character by character and emits output chunks. It handles carriage returns by emitting them separately to support GUI progress bar updates, and ensures any buffered text is flushed when the stream ends. The function maintains a buffer for characters until a newline or carriage return is encountered, at which point it emits the accumulated content plus the special character, then resets the buffer.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:_reader:de92c525d24f918eb920731cfbf6bc6e53f7afb2eb811b9bbf2d67718de4d1b5:de92c525d24f918eb920731cfbf6bc6e53f7afb2eb811b9bbf2d67718de4d1b5": "The function `_reader` is a generator method that reads from a given stream character by character. It accumulates characters into a buffer until it encounters a newline (`\\n`) or carriage return (`\\r`). Upon detecting a newline, it emits the buffered content concatenated with the newline character. If a carriage return is encountered, it emits the current buffer (if not empty), resets the buffer, and then emits the carriage return itself. When the end of the stream is reached, any remaining content in the buffer is emitted. The method uses `self.output.emit()` to send processed chunks and carriage returns to the GUI for progress updates.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:append_log:6ec21f4dac283305c2d6ed3db146c9d3db223e217e5008cac5be9df307d4d061:6ec21f4dac283305c2d6ed3db146c9d3db223e217e5008cac5be9df307d4d061": "The function `append_log` appends text to a log widget while handling carriage return characters. It moves the cursor to the end of the log, splits the input text by carriage returns, and processes each part. For carriage return characters, it removes the current line's content before inserting new text. The function ensures the log scrollbar remains at the maximum position to keep the latest entry visible.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:append_log:c4d191b7cac27c7eafb1e96daf6aba87b0578408f50cff496bd0907631438d4a:c4d191b7cac27c7eafb1e96daf6aba87b0578408f50cff496bd0907631438d4a": "The function `append_log` appends text to a log widget in the main window, ensuring proper cursor positioning and line handling. It moves the cursor to the end of the log, splits the input text by carriage return characters, and processes each part accordingly. If a carriage return is encountered, it clears the current line before inserting new text. Otherwise, it inserts the text directly. Finally, it updates the scroll position of the log widget to ensure the latest entry is visible.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:build_docgen_cmd:0a449e99f479c99fbd7c0b5cc640aab11cdbb691e1eca704c7814cd01d382372:0a449e99f479c99fbd7c0b5cc640aab11cdbb691e1eca704c7814cd01d382372": "The function `build_docgen_cmd` constructs and returns a command list for executing the documentation generation script (`docgenerator.py`). The command includes the project path from `self.project_edit` and the output directory from `self.output_edit`. If the `resume` parameter is True, it appends the `--resume` flag to enable resuming a previous documentation generation process. If the checkbox `self.docgen_private_cb` is checked, it adds the `--include-private` flag to include private members in the documentation. The function does not explicitly specify supported languages, as DocGen-LM now auto-detects them (Python, MATLAB, C++, and Java).",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:build_docgen_cmd:9ed047355fa7366081162ace668b580a8c4f17e99fa34954ff5a278a5b88447d:9ed047355fa7366081162ace668b580a8c4f17e99fa34954ff5a278a5b88447d": "",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:build_explain_cmd:5ee08ab5281fd969f9120c897c1711740e4f4a5d2dee0ef751079bc80cdba57b:5ee08ab5281fd969f9120c897c1711740e4f4a5d2dee0ef751079bc80cdba57b": "The function `build_explain_cmd` constructs and returns a command list for executing the `explaincode.py` script with specified parameters. The command includes the Python interpreter path, script name, project path from `self.project_edit`, output location from `self.output_edit`, and selected output format from `self.format_combo`. If the data inclusion checkbox is checked and a data path is provided in `self.data_edit`, the command also includes the data path as an argument.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:build_explain_cmd:a16e2f4bd7b1ba2ef1fbb00553bb178ca4fe2c789a731c52a180d9ab31d87f7c:a16e2f4bd7b1ba2ef1fbb00553bb178ca4fe2c789a731c52a180d9ab31d87f7c": "The function `build_explain_cmd` constructs and returns a command list for executing the `explaincode.py` script with specified arguments. The command includes the Python interpreter (`pythonw`), the path to the script, project directory from `self.project_edit`, output directory from `self.output_edit`, and the selected output format from `self.format_combo`. If the `include_data_cb` checkbox is checked and the `data_edit` field contains text, it appends the data path to the command. The function returns the constructed command as a list of strings.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:d5ee95e92f24eacff33d0fb777c73f9df05136a43f07a89fc94cedb332f25ff6:d5ee95e92f24eacff33d0fb777c73f9df05136a43f07a89fc94cedb332f25ff6": "The module implements a graphical user interface for running documentation generation and code explanation tools. It defines custom widgets including a path input field that accepts file drops, and a collapsible section for options. A background thread executes shell commands and emits output for display in a log window. The main window contains controls for specifying project and output directories, toggles for DocGen options such as including private functions and language selection, and options for ExplainCode including output format and data file inclusion. Buttons trigger execution of DocGen, ExplainCode, or both tools sequentially. The interface uses a dark theme and handles user interactions for directory and file selection, command execution, and log display with progress updates.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:dark_style:4973eea4736e1bf92944772de7952228d4a62e0b6f9a2c7870513c7808363975:4973eea4736e1bf92944772de7952228d4a62e0b6f9a2c7870513c7808363975": "The function `dark_style` defines a CSS stylesheet for a Qt-based graphical user interface, applying a dark color scheme to various UI elements. It sets the background color to `#1e1e1e`, text color to `#d4d4d4`, and specifies a font family and size. Input fields such as `QLineEdit`, `QPlainTextEdit`, and `QComboBox` are styled with a dark background (`#2d2d2d`), border, and padding. Buttons (`QPushButton`) are given a dark background (`#3a3a3a`) with a hover effect that lightens the color to `#444`. Labels are set to use a normal font weight. The stylesheet is intended for use in a `MainWindow` class to provide a consistent dark-themed appearance for the application's UI components.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:dark_style:cc65fd9ec502cfff5f19eb8316d9fc44c3b4ee81862d37462dac5fd4d15c9bae:cc65fd9ec502cfff5f19eb8316d9fc44c3b4ee81862d37462dac5fd4d15c9bae": "The `dark_style` function returns a CSS-style string that defines the visual appearance of various Qt widget types when using a dark color scheme. The style sets background colors, text colors, fonts, borders, and padding for widgets including general QWidget elements, QLineEdit, QPlainTextEdit, QComboBox, QPushButton, and QLabel components. It specifies a dark gray background (#1e1e1e) with light gray text (#d4d4d4), and defines distinct styling for interactive elements like buttons and input fields with hover effects.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:dragEnterEvent:38539a0da8ad1be0727b80a78eccab0d137d2f4ab86e44e21c1d4e0fe90484fc:38539a0da8ad1be0727b80a78eccab0d137d2f4ab86e44e21c1d4e0fe90484fc": "The `dragEnterEvent` method handles drag-and-drop operations by accepting events that contain URL data, allowing users to drag and drop file paths or URLs into the PathLineEdit widget.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:dragEnterEvent:5b634088cd2de3f4afa43576dbc9e4ffb676cce9be7ba2734108a62073cc7a90:5b634088cd2de3f4afa43576dbc9e4ffb676cce9be7ba2734108a62073cc7a90": "The `dragEnterEvent` method handles drag-and-drop events for the `PathLineEdit` widget. It checks if the dragged data contains URLs and accepts the proposed action if so, enabling the widget to respond to file or directory drops.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:dropEvent:90231b977d7ad880a8ac53d677d1bec8a7a2d78992988c26b116379782267ad4:90231b977d7ad880a8ac53d677d1bec8a7a2d78992988c26b116379782267ad4": "The `dropEvent` method handles drag-and-drop operations on the PathLineEdit widget. When a file or directory is dropped onto the widget, it extracts the local file path from the first URL in the mime data and sets it as the text content of the line edit.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:dropEvent:d45dacef756cdab78a12904698a471d6940093014ade3e92b46e2041b41a1351:d45dacef756cdab78a12904698a471d6940093014ade3e92b46e2041b41a1351": "The `dropEvent` method handles drag-and-drop operations on the `PathLineEdit` widget. When a file or directory is dropped onto the widget, it retrieves the local file path from the first URL in the dropped data and sets it as the text content of the line edit.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:on_finished:23a885f70acbf1d8e20bb0a673ea0a92ce939965da730a42d229837a24b9af8a:23a885f70acbf1d8e20bb0a673ea0a92ce939965da730a42d229837a24b9af8a": "The function `on_finished` is called when a process completes execution. It logs the exit code of the process using the `append_log` method and updates the running state of the application to False using the `set_running` method.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:on_finished:7bd414daeb8477742f06fc78138be25e96526202c1f348054fe18647a25077a5:7bd414daeb8477742f06fc78138be25e96526202c1f348054fe18647a25077a5": "The function `on_finished` is called when a process completes execution. It logs the exit code of the process using the `append_log` method and updates the running status of the application to false using the `set_running` method.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:on_toggled:77bbfa762d380cd259856e21a608162b64b2cb5b04ce9127cefd05dbe277377d:77bbfa762d380cd259856e21a608162b64b2cb5b04ce9127cefd05dbe277377d": "The `on_toggled` method handles the visual update of a collapsible box when its toggle button is pressed. It checks the state of the toggle button and sets the arrow direction of the button to indicate whether the content is expanded or collapsed. It also shows or hides the content area based on the toggle state.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:on_toggled:819338f5e24cf3842312c6e269f900441639626f9090ec12f3d973e20ef43d3e:819338f5e24cf3842312c6e269f900441639626f9090ec12f3d973e20ef43d3e": "The function `on_toggled` handles the toggle state change of a button within the `CollapsibleBox` class. When the button is checked (toggled on), it sets the arrow direction to down and makes the content visible. When unchecked (toggled off), it sets the arrow direction to right and hides the content.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:run:329322d0dcd4092928c266cae06da264a61033f4e16160d073440813b6d44649:329322d0dcd4092928c266cae06da264a61033f4e16160d073440813b6d44649": "The `run` method executes a sequence of shell commands stored in `self.cmds`. For each command, it spawns a subprocess, captures its stdout and stderr using dedicated reader threads, and emits the command's output via `self.output`. It waits for the process to complete and checks its return code. If any command fails (non-zero exit code), the method stops execution. In case of exceptions during command execution, it emits the exception message and sets the return code to -1. Finally, it emits a `finished` signal with the overall return code.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:run:f61b5eb5af84d8df06a806e966bcee70cd3446700f8a8893849ddef2de583d19:f61b5eb5af84d8df06a806e966bcee70cd3446700f8a8893849ddef2de583d19": "The `run` method executes a sequence of commands stored in `self.cmds`. For each command, it emits the command line to `self.output`, spawns a subprocess to execute it, and uses separate threads to read the subprocess's stdout and stderr. It waits for the process to complete and checks its return code. If any command fails (non-zero return code), the method stops execution and emits the final return code via `self.finished`. If an exception occurs during command execution, it emits the exception message, sets the return code to -1, and stops further execution.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:run_both:4f3c7054b0dfd5ec2992e041b9dcc319174f721fecf757b695e4a3ec7fb6fce3:4f3c7054b0dfd5ec2992e041b9dcc319174f721fecf757b695e4a3ec7fb6fce3": "The function `run_both` clears the log and executes two commands sequentially: one for building documentation generation and another for explaining commands.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:run_both:c336893e3c253710e317aa5fe11ea2df6228850929d947e8820d67ceacb6e61b:c336893e3c253710e317aa5fe11ea2df6228850929d947e8820d67ceacb6e61b": "The function `run_both` clears the log and executes two commands sequentially: one for building the documentation generator command and another for building an explanation command. These commands are retrieved using `self.build_docgen_cmd()` and `self.build_explain_cmd()`, respectively. The function is designed to run both documentation generation and explanation tasks in sequence within the application's graphical user interface.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:run_commands:5610fdc252f3a22d55decd0ff166b348bac96d2521bd9b6b29efa7d1580fe91f:5610fdc252f3a22d55decd0ff166b348bac96d2521bd9b6b29efa7d1580fe91f": "The function `run_commands` initiates a command execution process within the `MainWindow` class. It first checks whether the project and output directory fields are set; if not, it logs an error message and exits. If both directories are specified, it sets the UI state to running, creates a `CommandRunner` instance with the provided commands, and connects its `output` signal to the `append_log` method and its `finished` signal to the `on_finished` method. Finally, it starts the runner thread to execute the commands asynchronously.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:run_commands:81028765db2525b8867111dcb8e22a39806f97317d87346a0fe022d78cf0c1e7:81028765db2525b8867111dcb8e22a39806f97317d87346a0fe022d78cf0c1e7": "The function `run_commands` executes a series of commands using a `CommandRunner` object. It first validates that both project and output directory fields are set, displaying an error message and returning early if they are not. If validation passes, it sets the UI to a running state, creates a `CommandRunner` instance with the provided commands, connects its output and finished signals to appropriate handler methods, and starts the runner.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:run_docgen:009a3fefd2b945ba57d47d6520dd76bd681d3391bc828548afcade5a49389423:009a3fefd2b945ba57d47d6520dd76bd681d3391bc828548afcade5a49389423": "The function `run_docgen` clears the log display and executes documentation generation commands by calling `build_docgen_cmd()` to construct the command list and then running those commands through `run_commands()`.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:run_docgen:d868b98d8f39097a6f2e238a9faa3a66846e4e8c6c96798cf611c87753f3eb6f:d868b98d8f39097a6f2e238a9faa3a66846e4e8c6c96798cf611c87753f3eb6f": "The `run_docgen` function clears the log output and executes the documentation generation command built by `build_docgen_cmd()`. It orchestrates the documentation generation process by triggering the command execution through `run_commands`.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:run_docgen_resume:8b8a594a849ecab950c817674c52983f7694e9b4008a5103c2216921a0561877:8b8a594a849ecab950c817674c52983f7694e9b4008a5103c2216921a0561877": "The function `run_docgen_resume` clears the log output and executes documentation generation commands with a resume flag enabled. It calls `build_docgen_cmd` with `resume=True` to construct the command, then runs this command using `run_commands`. The function is designed to resume a previously interrupted documentation generation process.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:run_docgen_resume:c5d18b86049461ba0e10bc7f7737f76ff88ac0f45141041c0903aba0bd77944f:c5d18b86049461ba0e10bc7f7737f76ff88ac0f45141041c0903aba0bd77944f": "The function `run_docgen_resume` clears the log and executes a documentation generation command with the resume option enabled. It uses the `build_docgen_cmd` method to construct the command with `resume=True`, then runs this command through `run_commands`. This allows the documentation generation process to continue from a previously saved state.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:run_explain:3201b92eb3fe3d8370b3c01ce4c9ea7bcf45f4eaef0980f7610960d243bde62a:3201b92eb3fe3d8370b3c01ce4c9ea7bcf45f4eaef0980f7610960d243bde62a": "The `run_explain` function clears the log display and executes a command generated by `build_explain_cmd()`. It uses `run_commands` to process the built command, likely related to generating or displaying explanations within the application's interface.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:run_explain:ca92c569295e31d734b3627e4c04d69bdabd11330f7e91025474bc0d9d4b8b96:ca92c569295e31d734b3627e4c04d69bdabd11330f7e91025474bc0d9d4b8b96": "The `run_explain` function clears the log display and executes a command built by `build_explain_cmd()`. It uses `run_commands` to process the command list containing the single explain command.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:select_dir:37637e46c501c6db7754414cf624c51335dd788be586a314a0ad63804df85103:37637e46c501c6db7754414cf624c51335dd788be586a314a0ad63804df85103": "The function `select_dir` provides a dialog interface for selecting a directory path. It takes a `line_edit` parameter, which is expected to be a Qt line edit widget. When invoked, it opens a file dialog allowing the user to choose an existing directory. If a directory is selected, the function sets the text of the provided `line_edit` widget to the selected directory path. If no directory is selected, the `line_edit` remains unchanged.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:select_dir:6217ec49e0bfb5e86dccf73ffd03d22a905f0e8a17f4f470d5ab3c42b7ca8a4e:6217ec49e0bfb5e86dccf73ffd03d22a905f0e8a17f4f470d5ab3c42b7ca8a4e": "The function `select_dir` provides a dialog for selecting a directory and updates a specified line edit widget with the chosen path. It uses `QFileDialog.getExistingDirectory` to display a file selection dialog, and if a directory is selected, it sets the text of the provided `line_edit` to the selected directory path.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:select_file:1528252ae2f1aa5bc6321116b98e909883666f26e66b1c3a4af6f3d284685a56:1528252ae2f1aa5bc6321116b98e909883666f26e66b1c3a4af6f3d284685a56": "The function `select_file` enables the user to choose a data file through a file dialog window. It accepts a `line_edit` widget as an argument, which is updated with the selected file's path if a file is chosen. The dialog filters for JSON, CSV, and text files, alongside all file types. If no file is selected, the line edit remains unchanged.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:select_file:4d0411d462eb35378391cf58be72a174509539f244aa77963b55fc1e9daeaaf5:4d0411d462eb35378391cf58be72a174509539f244aa77963b55fc1e9daeaaf5": "The function `select_file` creates a file dialog window to allow the user to select a data file. It accepts a `line_edit` parameter, which is expected to be a Qt line edit widget. The dialog filters for JSON, CSV, and TXT files, as well as all files. If a file path is selected, it sets the text of the provided line edit widget to the chosen file path.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:setContentLayout:3914ca5656ea7a791deba62be5cfd8e70607aa3828c14d6357c63b11fe5f9e0d:3914ca5656ea7a791deba62be5cfd8e70607aa3828c14d6357c63b11fe5f9e0d": "The function `setContentLayout` sets the layout for the content area of the `CollapsibleBox` instance. It takes a single argument, `layout`, which is assigned to the `setLayout` method of the `content` attribute of the class. This allows the arrangement and positioning of widgets within the collapsible box's content section to be customized through the provided layout object.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:setContentLayout:53621ec8afc98c9522fbe3029a79d127be119065055660c32704dba5f8d9bbda:53621ec8afc98c9522fbe3029a79d127be119065055660c32704dba5f8d9bbda": "The `setContentLayout` method sets the layout for the content area of the CollapsibleBox widget by assigning the provided layout object to the content's layout property.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:set_running:2b3e01b8dba6008cb1c898fe2242976b5bb72238bb85cf6c67e0e7906163d2ab:2b3e01b8dba6008cb1c898fe2242976b5bb72238bb85cf6c67e0e7906163d2ab": "Sets the enabled state of multiple buttons based on the running parameter. When running is True, disables the buttons (docgen_btn, resume_btn, explain_btn, both_btn). When running is False, enables the buttons.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:set_running:c153e23ef8844907497aa789c1c868c8b117e982b4baf40432cb775dbc82a129:c153e23ef8844907497aa789c1c868c8b117e982b4baf40432cb775dbc82a129": "The function `set_running` enables or disables a set of buttons (`docgen_btn`, `resume_btn`, `explain_btn`, `both_btn`) based on the `running` parameter. If `running` is `True`, the buttons are disabled; if `False`, they are enabled.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\html_writer.py:3e0a79e574fdf9a5116be8a3a5e1b9cee87f67c23446e50ea22dc4ef6e6e3a7c:3e0a79e574fdf9a5116be8a3a5e1b9cee87f67c23446e50ea22dc4ef6e6e3a7c": "Module provides HTML rendering utilities for generating documentation pages from structured data. It includes functions to render navigation trees, highlight code snippets using Pygments, and generate complete HTML pages with templates. The module supports rendering project overviews, module pages with classes, functions, and variables, and handles nested structures through recursive rendering functions. It processes data dictionaries containing documentation elements and outputs styled HTML files with proper escaping and formatting.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\html_writer.py:_flatten_nav_tree:52e88abddca2749ebb020569cd5cbac9a0921fb763751271574cfbf0598b1028:52e88abddca2749ebb020569cd5cbac9a0921fb763751271574cfbf0598b1028": "The function `_flatten_nav_tree` recursively traverses a nested dictionary structure representing a navigation tree and yields tuples of (name, link) for each file entry. It processes the `__files__` key to extract file name-link pairs and recursively iterates through subdirectories, skipping the `__files__` key during recursion. The function returns an iterable of tuples containing the names and links of all files in the tree structure.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\html_writer.py:_highlight:52459cbfce93d778ca81b6488fa6ded15188b461a444a1082ac24409c74b5da3:52459cbfce93d778ca81b6488fa6ded15188b461a444a1082ac24409c74b5da3": "The function `_highlight` takes a string of code and a language identifier, then returns the code formatted with syntax highlighting using the Pygments library. It selects an appropriate lexer based on the language (supporting MATLAB, Python, C++, Java, or plain text), applies an HTML formatter to the highlighted code, and wraps the result in `<pre><code>` tags for proper display.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\html_writer.py:_render:ded409970019cb8802c6ef0cc92a2b39f9e3150e509eedb94cfb5da1d42e2566:ded409970019cb8802c6ef0cc92a2b39f9e3150e509eedb94cfb5da1d42e2566": "The function `_render` recursively generates an HTML unordered list representing a hierarchical structure of files and directories. It takes a dictionary `node` and a boolean `is_root` to determine if the current node is the root of the structure. If `is_root` is True and `include_home` is True, it adds a link to an index page with the label \"\ud83c\udfe0 Project Overview\". For each file in the `__files__` key of the node, it creates an HTML list item with a hyperlink. For each directory key in the node (excluding `__files__`), it creates a collapsible details element containing a summary of the directory name and recursively processes its contents. The result is a nested HTML structure suitable for displaying project navigation.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\html_writer.py:_render_class:af990ba8d80e3587e47d7e54fad9888d899dd3eba4aa5216234ff7b87defe6b4:af990ba8d80e3587e47d7e54fad9888d899dd3eba4aa5216234ff7b87defe6b4": "The function `_render_class` generates HTML content for a class definition and its components, including variables, methods, and subclasses. It takes a dictionary representing the class, the programming language, and an optional nesting level for HTML headers. The output is a list of HTML strings that define the class structure with appropriate headings, documentation, variable details, method summaries, and nested subclass information wrapped in expandable `<details>` elements.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\html_writer.py:_render_function:8e4179007b3255c3490c48d0ec9a7cb13c60f5b77ce5cdfa312a51ff11d4b537:8e4179007b3255c3490c48d0ec9a7cb13c60f5b77ce5cdfa312a51ff11d4b537": "The function `_render_function` generates HTML content for a given function dictionary, including its signature, summary, and source code. It supports nested subfunctions by recursively rendering them within `<details>` and `<summary>` tags. The output is a list of HTML string parts representing the formatted function documentation. The rendering adjusts the heading level based on the provided `level` parameter and applies HTML escaping for safety. If the function contains subfunctions, each is rendered with its own collapsible section.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\html_writer.py:_render_html:957a36bc054f12ca445384d2718e5a780e7085968d634b4ebcc951a69898d021:957a36bc054f12ca445384d2718e5a780e7085968d634b4ebcc951a69898d021": "The function `_render_html` generates an HTML document by formatting a template with provided content. It takes parameters for the page title, header, body content, and navigation HTML, then substitutes these into a template read from a file. The resulting HTML includes a comment indicating generation by DocGen-LM and specifies a static CSS file path. The function returns the complete HTML string with the generated content and formatting.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\html_writer.py:_render_nav_tree:0b327b18af3efa2ddf487d33deb06f0a3b73ab149e355d3c9e7147868360da6d:0b327b18af3efa2ddf487d33deb06f0a3b73ab149e355d3c9e7147868360da6d": "The function `_render_nav_tree` generates HTML code for a nested navigation tree from a dictionary structure. It takes a dictionary `tree` representing the navigation structure and an optional boolean `include_home` to determine whether to include a home link. The function uses a recursive helper `_render` to process nodes, adding links for files and creating collapsible sections for directories. Each directory is rendered as a `<details>` element with a `<summary>` tag, and files are listed as `<li>` elements with hyperlinks. The output is a string containing the complete HTML structure of the navigation tree.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\html_writer.py:write_index:b4fc05debf3d8539f4cde0be449d656b2aeb8f1c333bf1e21562b3de7ac740f9:b4fc05debf3d8539f4cde0be449d656b2aeb8f1c333bf1e21562b3de7ac740f9": "The function `write_index` generates an `index.html` file in the specified output directory. It takes a project summary, a navigation tree, and optional module summaries as inputs. The function creates the output directory if it does not exist, renders the navigation tree into HTML, and constructs a body containing the project summary, a horizontal rule, and a list of modules with links and optional summaries. The final HTML content is generated using a template rendering function and written to `index.html`.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\html_writer.py:write_module_page:49912312ae1e1b288ec6f60035297d02dd5551f664c165e46547b6322cd8907a:49912312ae1e1b288ec6f60035297d02dd5551f664c165e46547b6322cd8907a": "The function `write_module_page` generates an HTML documentation page for a given module based on provided data and navigation structure. It creates the output directory if it does not exist, extracts module details such as name and language, and constructs the page body by rendering class, variable, and function information. The rendered content includes summaries, docstrings, and source code highlights, formatted according to the module's language. A navigation tree is included in the output, and the final HTML is written to a file named after the module.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\llm_client.py:8c10f070f2c8b3e3bde249f5ea3f8fa746a3f3f1de1670c852597f9131c944de:8c10f070f2c8b3e3bde249f5ea3f8fa746a3f3f1de1670c852597f9131c944de": "The module defines an interface for interacting with a local LLM backend, specifically designed for generating code summaries. It includes prompt templates for different code elements such as modules, classes, functions, and README files, along with a system prompt that instructs the model to produce factual, concise descriptions without self-reference or additional commentary. The `LLMClient` class handles communication with the LMStudio API, sending requests and processing responses while managing token counts and retry logic for failed requests. A `sanitize_summary` function cleans generated summaries by removing meta-commentary and prompt-related content that could cause issues downstream. The module uses HTTP requests to interact with the LLM backend and includes utilities for tokenization and FIM token stripping to ensure compatibility with the model's input requirements.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\llm_client.py:LLMClient:353ccfa962e6e71f72d99cab2e019c4386e750622a890af36d6388d3ed459cd0:353ccfa962e6e71f72d99cab2e019c4386e750622a890af36d6388d3ed459cd0": "The `LLMClient` class facilitates communication with a local language model API, enabling connectivity checks and text summarization tasks through HTTP requests. It supports initializing the client with a base URL and model name, pinging the API endpoint to verify connectivity, and summarizing input text using specified prompt templates while handling retries and token budgeting. The class is designed to integrate with tools like LMStudio for generating structured documentation summaries from codebases.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\llm_client.py:LLMClient:__init__:700c23b8c0716a1aaf00c10fbc2e056bef4f6e1dca9c72b739185f920ef55cf8:700c23b8c0716a1aaf00c10fbc2e056bef4f6e1dca9c72b739185f920ef55cf8": "Initializes an object with a base URL, constructs an API endpoint path, and sets a model identifier. The base URL is stripped of any trailing slashes before being stored. The endpoint is formed by appending the chat completions path to the base URL. The model parameter is stored as an instance attribute.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\llm_client.py:LLMClient:ping:3fe5655e89accd067c6ddc9c1cc323c9dd9eac2dea9be6646ea4d470b3e0a436:3fe5655e89accd067c6ddc9c1cc323c9dd9eac2dea9be6646ea4d470b3e0a436": "Function that checks API connectivity by sending an HTTP GET request to a base URL and returning True if successful, raising a ConnectionError with a specific message if the request fails.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\llm_client.py:LLMClient:summarize:d645c0bd2d6fc772b12d74e25271d6590e2e1e37ccdc8d959e6a4fae9a56c574:d645c0bd2d6fc772b12d74e25271d6590e2e1e37ccdc8d959e6a4fae9a56c574": "Function `summarize` generates a summary of input text using a specified prompt template and communicates with a language model API. It constructs a prompt from the input text and a selected template, checks token usage against a budget, and sends a request to an endpoint with system and user messages. The function handles retries on failure, processes streaming responses, and returns sanitized output. It includes logging for prompt size, request progress, and errors, and raises a runtime error if all retry attempts are exhausted.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\llm_client.py:__init__:3bd7418e395ac928a79ff558fc7e3e8733857ef991cb582288de1b4efb50c7dc:3bd7418e395ac928a79ff558fc7e3e8733857ef991cb582288de1b4efb50c7dc": "Initializes the `LLMClient` instance with a specified base URL and model name. Sets up the endpoint for API requests by appending the chat completions path to the base URL, ensuring no trailing slash is present. The model parameter specifies which language model to use for requests.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\llm_client.py:__init__:7bb980db665c5bf9c3abfb882a8a354f91d3c5797ac8f4e6bc17ef9af9b0517f:7bb980db665c5bf9c3abfb882a8a354f91d3c5797ac8f4e6bc17ef9af9b0517f": "Initializes the LLMClient with a base URL and model name. Sets up the endpoint for API requests by appending the chat completions path to the base URL, ensuring no trailing slash exists on the base URL.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\llm_client.py:ping:1432e56d26b59380affae5f35a04e6190cc84a0f0944b51471f4902a9d39d313:1432e56d26b59380affae5f35a04e6190cc84a0f0944b51471f4902a9d39d313": "The function `ping` checks the connectivity of an API endpoint specified by `self.base_url`. It sends an HTTP GET request with a specified timeout and raises a `ConnectionError` if the request fails or the server is unreachable. If the request is successful, it returns `True`. The function uses `requests.get` and handles exceptions using `RequestException` to provide a clear error message indicating the failure to connect to the LMStudio server.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\llm_client.py:ping:76580d4cfebb32c95afa8e6fa9356034814b82596b302988056e85ebbb9ab4e4:76580d4cfebb32c95afa8e6fa9356034814b82596b302988056e85ebbb9ab4e4": "The `ping` method checks if the LLM API is reachable by sending an HTTP GET request to the instance's base URL. It returns `True` if the server responds successfully within the specified timeout period. If the request fails due to network issues or an invalid response, it raises a `ConnectionError` with a descriptive message indicating the failure to reach the LMStudio server.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\llm_client.py:sanitize_summary:2c93577ee3584ff17da17982bfec484c793c30a1f74dd533a9f1159f39bd717b:2c93577ee3584ff17da17982bfec484c793c30a1f74dd533a9f1159f39bd717b": "The function `sanitize_summary` processes a given text string to remove meta-commentary and unwanted content. It first checks if the text is exactly \"project summary\" and returns \"It prints.\" in that case. It then removes FIM special tokens using the `strip_fim_tokens` function to prevent encoding errors. The function filters out lines that match predefined bad start phrases or contain specific unwanted substrings. It also excludes lines that begin with bullet points, or that match patterns related to the summary itself or other meta-commentary. The result is a cleaned version of the input text with such commentary removed.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\llm_client.py:summarize:38db325620e7a6b59a78adda248fa9b9c4b40886936c0f93db606b8eb9a6d035:38db325620e7a6b59a78adda248fa9b9c4b40886936c0f93db606b8eb9a6d035": "The `summarize` method generates a summary of the provided text using a specified prompt template and communicates with a language model via an HTTP endpoint. It constructs a prompt based on the input text and a selected template, checks the token count against a budget, and sends a request to the LLM with system and user messages. The method includes retry logic for handling request failures, processes streaming response data, and returns a sanitized summary string. If all retries fail, it raises a `RuntimeError` with the last error message.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\llm_client.py:summarize:39939b948e23aa652b68a6f98388c052ff8dc4772602ee3435883e6b3644d460:39939b948e23aa652b68a6f98388c052ff8dc4772602ee3435883e6b3644d460": "The `summarize` method generates a summary of the provided text using a specified prompt template and an LLM endpoint. It constructs a prompt from the input text and a selected template, checks token usage against a budget, and sends a request to the LLM with system and user messages. The method handles retries on failure, logs request progress, and returns the sanitized summary content from the model's response. It supports optional parameters for controlling token limits and maximum output tokens.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\manual_utils.py:1a9e3f658f9a14649ee2ba63e5e339212e4e0cfa827ecc803d7ca51083a3738b:1a9e3f658f9a14649ee2ba63e5e339212e4e0cfa827ecc803d7ca51083a3738b": "The module implements functions for splitting documentation into chunks, summarizing those chunks using an LLM client, and merging the results into a structured user manual. It includes logic for handling token and character limits, caching responses, and managing parallel processing of chunks. The process supports automatic chunking based on limits, manual chunking, or no chunking, with fallback behaviors for errors or exceeding limits. Placeholder tokens are identified and handled during the merging phase. The module uses system prompts to guide the LLM in generating content focused on user-level instructions rather than implementation details.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\manual_utils.py:_count_tokens:e7072fb3e09de9b1814db8939822f1c510f9e058915d10aa195019db51f9c827:e7072fb3e09de9b1814db8939822f1c510f9e058915d10aa195019db51f9c827": "The function `_count_tokens` takes a string input `text` and returns an integer representing the approximate number of tokens in that text. It uses a global `TOKENIZER` object to encode the text and then calculates the length of the resulting token sequence.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\manual_utils.py:_split_text:47e10c3a281eb28193456e9370548584cb6de97500016e356147050a39326a04:47e10c3a281eb28193456e9370548584cb6de97500016e356147050a39326a04": "The function `_split_text` splits a given text into chunks based on token and character limits. It takes a string `text`, and optional parameters `max_tokens` (default 2000) and `max_chars` (default 6000). The text is split into paragraphs using double newlines as separators. Each paragraph is evaluated for token and character count, and if it exceeds the limits, it is further chunked using `chunk_text`. Paragraphs are added to chunks while respecting the maximum token and character constraints. If a paragraph alone exceeds the limits, it is directly split into smaller pieces. The function returns a list of text chunks that respect both the token and character limits.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\manual_utils.py:_summarize_manual:908fd3ceb9c6dc8c8eb468d74c974b187dd0f252b3c030ebf8c7d3f3ae1cd7f9:908fd3ceb9c6dc8c8eb468d74c974b187dd0f252b3c030ebf8c7d3f3ae1cd7f9": "The function `_summarize_manual` generates a manual summary of input text using a specified chunking strategy. It accepts an LLM client, a response cache, the input text, and optional parameters for chunking behavior, source identification, and a post-processing hook.\n\nIf the input text is empty, it returns an empty string. It determines whether to use manual or automatic chunking based on token and character limits. For chunked processing, it splits the text into parts, checks the cache for previously generated responses, and processes uncached chunks using a thread pool. Each chunk is summarized with a system prompt, and results are cached.\n\nAfter processing all chunks, if a post-processing hook is provided, it applies the hook to reorder or modify the partial summaries. It then merges the partial summaries iteratively until the combined content fits within token and character limits. Final summarization is performed on the merged content using another system prompt, and the result is cached and returned.\n\nIf chunking is disabled (`chunking=\"none\"`) and the input exceeds limits, a warning is printed. Otherwise, it summarizes the full text directly with a specified system prompt and caches the result. The function includes error handling for chunking failures, summarization errors, and post-processing issues, logging",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\manual_utils.py:chunk_docs:285e901d70821085e59d5cc64e27f36b629bd7d9e23d3205be3ca3f10dc12d87:285e901d70821085e59d5cc64e27f36b629bd7d9e23d3205be3ca3f10dc12d87": "The function `chunk_docs` takes a list of strings (`docs`) and splits them into chunks of approximately `token_limit` tokens. It first joins the input strings with double newlines, filters out empty or whitespace-only strings, and then uses `_split_text` to divide the resulting text into segments that do not exceed the specified token limit. If the input is empty, it returns an empty list.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\manual_utils.py:find_placeholders:c857e13a48e4cb666f301616a0789cbcf90e7f7669fdbaec9fc857daf30fbdf8:c857e13a48e4cb666f301616a0789cbcf90e7f7669fdbaec9fc857daf30fbdf8": "The function `find_placeholders` identifies and returns all unique placeholder tokens of the form `[[TOKEN]]` present in the input string `text`. It uses a regular expression pattern `PLACEHOLDER_RE` to locate these placeholders and returns them as a set, ensuring each token is listed only once regardless of how many times it appears in the text.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\parser_cpp.py:20fbb103bacaa4a0b0e1faa76ad26882965689f182fed8716afa4e58a1cc1689:20fbb103bacaa4a0b0e1faa76ad26882965689f182fed8716afa4e58a1cc1689": "Module implements a line-based parser for C++ source files to extract namespaces, classes, functions, and public variables. It processes comments and code blocks to build structured data containing documentation strings, source code snippets, and element signatures. The parser handles multi-line comments, class member access specifiers, and function signatures while maintaining compatibility with Python parsing structures. Functions include collecting preceding comments, extracting code blocks enclosed in braces, and parsing class bodies for public methods and variables. The main entry point reads a file, identifies top-level elements, and returns a dictionary with module documentation, class definitions, and function declarations.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\parser_cpp.py:_extract_block:9a8c0860907ae746326fceec4f0cabee6383298bcff8c4f806d3e84ca45dea22:9a8c0860907ae746326fceec4f0cabee6383298bcff8c4f806d3e84ca45dea22": "The function `_extract_block` extracts a contiguous block of text from a list of lines, starting at a specified index. It identifies the block by tracking the balance of curly braces `{` and `}`. The function returns the extracted text along with the index of the last line processed. The extraction continues until the brace count reaches zero, indicating the end of the block.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\parser_cpp.py:_get_preceding_comment:bfb4924c7789098bd4f53e5bd2bf061e26de55f5343c1fbc6d64beed620ef1d6:bfb4924c7789098bd4f53e5bd2bf061e26de55f5343c1fbc6d64beed620ef1d6": "The function `_get_preceding_comment` collects contiguous comment lines that appear before a specified index in a list of code lines. It handles both single-line comments (starting with `//`) and multi-line comments (enclosed between `/*` and `*/`). The collected comments are returned as a single string, with each comment line separated by a newline. The function stops collecting when it encounters a non-comment line or reaches the beginning of the list. Empty lines are ignored unless they appear after actual comments, in which case they terminate the comment collection.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\parser_cpp.py:_parse_class_body:4f7f84f6ba7b85cfda47dbd614b45ad7e9746c328aaedbd08e6bbb2bfbf9a44f:4f7f84f6ba7b85cfda47dbd614b45ad7e9746c328aaedbd08e6bbb2bfbf9a44f": "The function `_parse_class_body` parses the body of a class definition from a list of source code lines and extracts public methods and variables. It takes a list of strings representing lines of code, along with start and end indices defining the range to parse. The function returns a tuple containing two lists: one for public methods and one for public variables.\n\nFor each line in the specified range, it tracks access level (public, protected, private) and processes lines accordingly. Public methods are identified by lines ending with `{` and containing parentheses, extracting their signature, name, preceding comment, and source block. Public variables are identified by lines ending with `;` and not containing parentheses, extracting their type, name, and preceding comment. The function uses helper functions `_get_preceding_comment` to retrieve documentation comments and `_extract_block` to extract method source code blocks.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\parser_cpp.py:parse_cpp_file:0b39bd5291c1f32df18577f8d437651c103e0b68e0a2c180186167790066eef5:0b39bd5291c1f32df18577f8d437651c103e0b68e0a2c180186167790066eef5": "The function `parse_cpp_file` reads and parses a C++ source file, extracting structured information about the file's contents. It identifies the module-level comment, namespaces, classes (including their methods and variables), and functions. The function processes the file line by line, using helper functions to extract comments, block structures, and class bodies. The result is a dictionary containing the module documentation string, lists of classes with their details, and a list of functions with their signatures and documentation. If a namespace is found, it is included in the returned dictionary.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\parser_java.py:729faf96c4d338772a690be0eaf2138a3bbdae3288180abc6c0056faa4919469:729faf96c4d338772a690be0eaf2138a3bbdae3288180abc6c0056faa4919469": "Module implements a Java file parser for DocGen-LM that extracts package information, class definitions, public methods, and variables. It uses line-based parsing to identify code elements and their associated documentation comments, including Javadoc and single-line comments. The parser processes source code to build structured data containing element names, signatures, documentation strings, and source code blocks. Functions handle comment extraction, block parsing, and class body analysis. Output format mirrors Python parsing structure with keys for module docstring, classes, and functions, though functions list remains empty for Java files.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\parser_java.py:_extract_block:883450de38a6b9e13f9f1ff8e8cbd3465524d0edcf38a5cd08467afd4bf8ba50:883450de38a6b9e13f9f1ff8e8cbd3465524d0edcf38a5cd08467afd4bf8ba50": "The function `_extract_block` extracts a contiguous block of code from a list of lines starting at a specified index. It takes the starting line and counts the difference between the number of opening and closing braces to determine when the block ends. The function returns the extracted block as a string along with the index of the last line processed.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\parser_java.py:_get_preceding_comment:be89f587df68239102f151387abd7b437ebabf9b66e7d8dbe9dc90a36ebeedd2:be89f587df68239102f151387abd7b437ebabf9b66e7d8dbe9dc90a36ebeedd2": "The function `_get_preceding_comment` extracts and returns comments that appear before a specified line index in a list of code lines. It processes both single-line comments (starting with `//`) and multi-line comments (enclosed in `/* */`). The function collects relevant comment lines, strips away comment delimiters, and joins them into a single string, preserving their order and formatting. It stops collecting when it encounters a non-comment line or an empty line, depending on the context of the comment block.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\parser_java.py:_parse_class_body:299a95f0bc6b827dd0fc28be6723e4305d64090932d53249f70bbed49a771b9b:299a95f0bc6b827dd0fc28be6723e4305d64090932d53249f70bbed49a771b9b": "The function `_parse_class_body` extracts method and variable declarations from a specified range of lines within a class body. It processes each line to identify public methods and variables, capturing their names, signatures, types, docstrings, and source code. Methods are identified by lines starting with \"public \" followed by a function signature, while variables are identified by lines ending with \";\" and containing a type declaration. The function returns two lists: one containing method dictionaries and another containing variable dictionaries, each with keys for name, signature/type, docstring, and source code.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\parser_java.py:parse_java_file:2c8ebfbc6b8c3628bc9d3054a4c66b8ca576180d6fc898c23d762ba01585b8f7:2c8ebfbc6b8c3628bc9d3054a4c66b8ca576180d6fc898c23d762ba01585b8f7": "The function `parse_java_file` reads a Java source file and extracts structural information including the module-level docstring, package declaration, and class definitions. It identifies classes within the file, capturing their names, docstrings, methods, and variables. The function processes lines of the file to skip comments and empty lines at the beginning, determines the package statement if present, and parses each class definition by extracting its body and associated documentation. The result is a dictionary containing the module docstring, a list of classes with their details, and an empty list for functions, as Java parsing does not currently extract function-level information. The function utilizes helper functions `_get_preceding_comment`, `_extract_block`, and `_parse_class_body` to assist in parsing class structures and extracting relevant code blocks and documentation.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\parser_matlab.py:15cf90e58e5b33528fe0fc6fa2e48fa77e43bd0fed902a29ea22b67a2f78ff68:15cf90e58e5b33528fe0fc6fa2e48fa77e43bd0fed902a29ea22b67a2f78ff68": "The module provides a parser for MATLAB `.m` files that extracts file header comments and function declarations. It reads the content of a specified file, identifies leading comment lines as the file header, and parses subsequent lines to find function definitions. Each function entry includes the function name and its arguments, which are extracted and formatted into a list. The parser uses regular expressions to match function declarations and handles both comma- and semicolon-separated argument lists. The output is a dictionary containing the parsed header and a list of functions with their names and argument lists.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\parser_matlab.py:parse_matlab_file:21486602622a50241aea6751e99b09c6dec773921e5162b44336cc369be3633a:21486602622a50241aea6751e99b09c6dec773921e5162b44336cc369be3633a": "The function `parse_matlab_file` reads a MATLAB `.m` file and extracts its header comments and function declarations. It returns a dictionary with two keys: `\"header\"`, containing the leading comment lines from the file, and `\"functions\"`, containing a list of dictionaries, each representing a function declaration with its name and argument list. The parsing process identifies function definitions using a regular expression and handles both comma- and semicolon-separated arguments. Blank lines are allowed within the header comments. If no functions are found, the `\"functions\"` list will be empty.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\parser_python.py:9b7a83be6356666450a5a1a457ffe2e114b6726c1c43053f6e27962b7ce8f0aa:9b7a83be6356666450a5a1a457ffe2e114b6726c1c43053f6e27962b7ce8f0aa": "Module defines a parser for Python files that extracts structured information using the `ast` module. It processes classes and functions, capturing their signatures, docstrings, and source code segments. The parser handles positional-only arguments, default values, variable arguments, keyword-only arguments, and nested definitions. It supports both synchronous and asynchronous function definitions. The output includes module-level docstring, lists of classes and functions, with each containing details about their structure and content.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\parser_python.py:_format_arg:1210326628a1519c410cced6f008fc93d27509e444012ace387112996f0eedf1:1210326628a1519c410cced6f008fc93d27509e444012ace387112996f0eedf1": "The function `_format_arg` takes an `ast.arg` object and returns a string representation of the argument name, optionally including its type annotation if present. If the argument has an annotation, it is appended to the argument name in the format `arg_name: annotation`.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\parser_python.py:_format_arguments:48bc5ae594149dc7005dc1846d2c1bdca280929c7670665961fe497b7ea59036:48bc5ae594149dc7005dc1846d2c1bdca280929c7670665961fe497b7ea59036": "The function `_format_arguments` generates a string representation of Python function arguments defined in an abstract syntax tree (AST). It processes positional-only arguments, regular arguments, default values, `*args`, keyword-only arguments, and `**kwargs`, formatting them according to Python syntax. The function handles argument defaults by unwrapping them using `ast.unparse` and ensures proper separation and labeling of argument types. The result is a comma-separated string that mirrors the signature of a Python function's parameter list.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\parser_python.py:_format_signature:9e5d84d9b472a70bad74ce2511d964875515146845bcfdf60fbb6ad953c08bed:9e5d84d9b472a70bad74ce2511d964875515146845bcfdf60fbb6ad953c08bed": "The function `_format_signature` generates a string representation of a function's signature from an abstract syntax tree (AST) node. It takes a function definition node (`func`) and constructs the signature by formatting its arguments using `_format_arguments`, then appends the return type annotation if present. The resulting string includes the function name, parameter list, and optional return type hint.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\parser_python.py:_parse_classes:a9bffda372aea044c8b938b770f3ac6a24c21bc3f1de5441d280515e35b8127c:a9bffda372aea044c8b938b770f3ac6a24c21bc3f1de5441d280515e35b8127c": "The function `_parse_classes` recursively extracts all `ClassDef` nodes from a list of AST nodes and returns a list of dictionaries representing parsed class information. It processes each node in the input list, and if the node is a class definition, it calls `parse_class` to generate a dictionary for that class. If the node is a function definition, it recursively parses the function's body for nested class definitions. The result is a flattened list of all class definitions found within the provided AST nodes and their nested structures.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\parser_python.py:parse_class:6ee6a9b90bb7d7ea3e2a05d36b4e6a5834b6305eb95db8eabc48ebc9a648fea9:6ee6a9b90bb7d7ea3e2a05d36b4e6a5834b6305eb95db8eabc48ebc9a648fea9": "The function `parse_class` takes an abstract syntax tree (AST) class definition node and the corresponding source code, and returns a dictionary containing information about the class. The dictionary includes the class name, its docstring, a list of methods defined within the class (parsed using `parse_function`), a list of nested subclasses (parsed using `_parse_classes`), and the source code segment corresponding to the class definition.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\parser_python.py:parse_classes:9cf23204b69196d3543a7935c38dbad2bc33bce0ac79b78755bfd53a185e4e69:9cf23204b69196d3543a7935c38dbad2bc33bce0ac79b78755bfd53a185e4e69": "The function `parse_classes` is a public wrapper that extracts class definitions from an abstract syntax tree (AST) node. It takes an AST node and the corresponding source code as input, and returns a list of dictionaries containing information about the parsed classes. The function delegates the actual parsing logic to the private helper function `_parse_classes`, using the `body` attribute of the provided AST node. The source code is passed through to support further processing during class parsing.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\parser_python.py:parse_function:4a7cf082e87b060888092350a8844695abca0a54d6045b7d1501fd909568fb34:4a7cf082e87b060888092350a8844695abca0a54d6045b7d1501fd909568fb34": "The function `parse_function` takes an AST node representing a function or async function and the source code as input, and returns a dictionary containing information about the function. The dictionary includes the function's name, signature, return type, docstring, source code segment, and lists of nested subfunctions and subclasses. It recursively processes the body of the function to identify and include any nested functions and classes.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\parser_python.py:parse_python_file:94490e6ae6690e14e990ad3e3675d43b10d51a7911d5dd3754247b10eeea31c6:94490e6ae6690e14e990ad3e3675d43b10d51a7911d5dd3754247b10eeea31c6": "The function `parse_python_file` reads a Python source file and returns a structured dictionary containing the module's docstring, a list of classes defined in the module, and a list of functions defined in the module. It uses the `ast` module to parse the source code and extracts information from class and function definitions, delegating the parsing of individual classes and functions to helper functions `parse_class` and `parse_function`. The parsed data includes docstrings and other relevant details about each class and function.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\retrofit_sidebar.py:8370d6cbf5c0d9441a1d498ad822f2524357c097e7e2a0b8bbc981c22cc593a9:8370d6cbf5c0d9441a1d498ad822f2524357c097e7e2a0b8bbc981c22cc593a9": "The module implements a tool to replace documentation sidebars with hierarchical lists of modules. It scans a source directory for files, constructs a tree structure from their paths, and generates HTML unordered lists to populate sidebar divs in documentation files. The script uses BeautifulSoup for HTML manipulation and supports command-line arguments for specifying the source and documentation directories. The process involves resolving file paths relative to a base directory, building a nested dictionary representation of the module structure, and converting this structure into HTML list elements with appropriate links to module documentation pages.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\retrofit_sidebar.py:_paths_to_tree:92b7783d03d2f4811fdfaef288771408fb9760dfe28d93e6c89b239bbf78b28c:92b7783d03d2f4811fdfaef288771408fb9760dfe28d93e6c89b239bbf78b28c": "The function `_paths_to_tree` converts a list of file paths into a nested dictionary representing a directory tree structure. Each path is split into its constituent parts, and the function iteratively builds the tree by creating nested dictionaries for each directory level. The final component of each path is added as a key with a value of `None`. The resulting dictionary mirrors the hierarchical organization of the input file paths.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\retrofit_sidebar.py:_tree_to_ul:e5fdefde19e0f2ac4b6e9e8b127aa243d0496847fe3eb107b2342951f1179e93:e5fdefde19e0f2ac4b6e9e8b127aa243d0496847fe3eb107b2342951f1179e93": "The function `_tree_to_ul` recursively constructs HTML `<ul>` elements from a nested dictionary `tree`, using BeautifulSoup to generate the markup. It takes a dictionary representing a hierarchical structure, a BeautifulSoup object for creating tags, and an optional base path to compute relative links. For each entry in the sorted keys of the dictionary, it creates a list item (`<li>`) containing either a nested `<ul>` for sub-dictionaries or an anchor tag (`<a>`) linking to an HTML file derived from the path. The resulting structure reflects the hierarchy of the input tree in HTML format.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\retrofit_sidebar.py:main:b1a193a71a00100fc567783623d061c0ba08979f46c73078d21fa7527249747d:b1a193a71a00100fc567783623d061c0ba08979f46c73078d21fa7527249747d": "The `main` function serves as the entry point for a documentation tool that replaces a sidebar in a documentation directory with a hierarchical module list derived from a source code directory. It uses `argparse` to accept command-line arguments for specifying the source root directory and documentation directory, defaulting to the current directory and \"Docs\", respectively. The function validates that both directories exist and are directories. If validation fails, it prints an error message to stderr and returns an exit code of 1. On successful validation, it calls `retrofit_sidebar` with the paths of the source and documentation directories, then returns an exit code of 0.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\retrofit_sidebar.py:retrofit_sidebar:d465d5eafdfe2b2c20ba5a2c9834961fda6f498b30fa36497470088bcdcce23d:d465d5eafdfe2b2c20ba5a2c9834961fda6f498b30fa36497470088bcdcce23d": "The function `retrofit_sidebar` updates HTML documentation files by replacing existing sidebars with a hierarchical list of modules. It takes the root directory of a source code tree and the directory containing documentation files as inputs. The function scans the source directory to identify module paths, constructs a hierarchical tree from these paths, and then processes each HTML file in the documentation directory. For every HTML file, it locates the sidebar element, clears its contents, and populates it with a structured unordered list generated from the module tree. The updated HTML content is then written back to the respective files.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\reviewer.py:4f9d422499a1acff78c67b05122179a409cbacd25a4c242442e0aef707dbeb81:4f9d422499a1acff78c67b05122179a409cbacd25a4c242442e0aef707dbeb81": "Module defines a documentation reviewer for HTML output generated by DocGen-LM. It identifies assistant-like phrasing, contradictions between summary and detected elements, and hallucinated content. The tool processes HTML files in a directory, reporting issues found. Optional autofix mode rewrites files to sanitize paragraph content using an external client function. Command-line interface accepts a directory path and an autofix flag.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\reviewer.py:_extract_tags:141e7ea8659110afd6fd99db88be7658d999c2aabe77cb34b3b5c3409e84ad96:141e7ea8659110afd6fd99db88be7658d999c2aabe77cb34b3b5c3409e84ad96": "The function `_extract_tags` takes an HTML string and a tag name as input, and returns a list of strings containing the content found between the opening and closing tags of the specified type. It uses a regular expression to match the tag and its content, with flags enabling dotall and case-insensitive matching. The pattern captures content within the tag, including nested elements, and returns all matches found in the input HTML.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\reviewer.py:_find_line_number:28134b2527f131c868603a8b875435a252510b6a43cf128f9b7e954be3012e26:28134b2527f131c868603a8b875435a252510b6a43cf128f9b7e954be3012e26": "The function `_find_line_number` takes an HTML string and a search phrase as inputs. It iterates through each line of the HTML content, checking if the phrase (case-insensitively) is present in the line. If the phrase is found, it returns the line number (1-based indexing). If the phrase is not found after searching all lines, it returns -1.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\reviewer.py:_is_generated_html:fc8d07a586a6ec3863f2159974979a4b300d0957f31ebd15df05385e8382bbd6:fc8d07a586a6ec3863f2159974979a4b300d0957f31ebd15df05385e8382bbd6": "The function `_is_generated_html` determines whether a given HTML text appears to be output generated by DocGen-LM. It checks for the presence of specific markers within the text, including the string \"Generated by DocGen-LM\", the heading \"Project Documentation\", and patterns matching class and method headings with specific naming conventions. The function returns `True` if any of these markers are found, otherwise it returns `False`.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\reviewer.py:_review_file:6e2813ccb97723f863d836a6fde5a92de62124e4934fc0f1841561ea22c2ed69:6e2813ccb97723f863d836a6fde5a92de62124e4934fc0f1841561ea22c2ed69": "The function `_review_file` processes an HTML file at a given path to identify potential issues such as assistant phrasing, contradictions, and hallucinations. It returns a list of strings describing detected issues. If the `autofix` parameter is enabled and issues are found, it also sanitizes paragraph content in the file and writes the updated content back to disk. The function first checks if the file contains generated HTML before proceeding with the review.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\reviewer.py:_sanitize_paragraphs:b0db83d22534c47205e31336ff8613a27978ca47984764355f2381e6fb3c8689:b0db83d22534c47205e31336ff8613a27978ca47984764355f2381e6fb3c8689": "The function `_sanitize_paragraphs` processes an HTML string to sanitize the content within paragraph tags. It uses a regular expression to identify all paragraph elements, extracts their inner content, applies sanitization and stripping operations to that content, and then reconstructs the paragraph tags with the cleaned content. The sanitization removes unwanted formatting while preserving the paragraph structure. The function handles multiline content through the `re.DOTALL` flag and performs case-insensitive matching with `re.IGNORECASE`.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\reviewer.py:_strip_html:86e515db123d06add84f2c52c3bfc0c3bad9b77a1644fe54896265d8df39ce68:86e515db123d06add84f2c52c3bfc0c3bad9b77a1644fe54896265d8df39ce68": "The function `_strip_html` takes a string input and removes all HTML tags from it using a regular expression. It matches any character sequence that starts with \"<\" and ends with \">\", which represents an HTML tag, and replaces such sequences with an empty string, effectively stripping the HTML markup from the text.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\reviewer.py:check_assistant_phrasing:ab16f25f2d65914e8c01d8bae9ac2eb4c494f517740e10a513934b25a9cbbdb3:ab16f25f2d65914e8c01d8bae9ac2eb4c494f517740e10a513934b25a9cbbdb3": "The function `check_assistant_phrasing` takes an HTML string as input and returns a list of strings identifying paragraphs that contain assistant-like phrases. It iterates through paragraphs extracted from the HTML, strips HTML tags from each paragraph, and checks if any of the predefined assistant phrases are present in the lowercase version of the text. If a match is found, it determines the line number of the paragraph and appends a formatted string with the text and line number to the findings list. The function uses helper functions `_extract_tags` to extract paragraphs, `_strip_html` to remove HTML tags, and `_find_line_number` to locate the line number within the original HTML.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\reviewer.py:check_contradictions:255082f3297731f26d7e2200ad6230a188dcfbb2c05e610e14f8c146e329a23d:255082f3297731f26d7e2200ad6230a188dcfbb2c05e610e14f8c146e329a23d": "The function `check_contradictions` analyzes HTML content to identify contradictions between a summary text and the presence of specific code elements. It extracts paragraphs and headers from the HTML, then checks if the summary text contains phrases like \"no methods\", \"no functions\", or \"no classes\". If such phrases are present, it verifies whether corresponding headers for methods, functions, or classes exist in the HTML. If contradictions are found, it returns a list of descriptive strings indicating the mismatches. The function is case-insensitive and operates on stripped and lowercased text for comparison.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\reviewer.py:check_hallucinations:85c778d54c1cf9908f2bed49c2087f9737745a36029962a465acb779e9d8ea4a:85c778d54c1cf9908f2bed49c2087f9737745a36029962a465acb779e9d8ea4a": "The function `check_hallucinations` takes an HTML string as input and returns a list of hallucination phrases detected within the text. It extracts all paragraph elements from the HTML, strips the HTML tags from each paragraph, converts the text to lowercase, and checks for the presence of predefined terms (stored in `HALLUCINATION_TERMS`) within the text. If any of these terms are found, they are added to the list of findings, which is then returned.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\reviewer.py:main:86c501626d56430f49d39ae58db9965910299c34039f283dbf3e0f966acf6ee4:86c501626d56430f49d39ae58db9965910299c34039f283dbf3e0f966acf6ee4": "The function `main` serves as the entry point for reviewing generated HTML documentation. It accepts an optional iterable of command-line arguments and uses `argparse` to parse the directory path containing the HTML output and an optional `--autofix` flag. The parsed directory path is passed to the `review_directory` function, along with the autofix option. The function returns an integer status code of 0 upon completion.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\reviewer.py:repl:1840fbce6e2faf144071d19d13c2f80e84aa01136a976fda157702b22d3a1d87:1840fbce6e2faf144071d19d13c2f80e84aa01136a976fda157702b22d3a1d87": "The function `repl` takes a regex match object as input, extracts the first captured group, sanitizes the content by stripping HTML tags, and wraps the result in a paragraph HTML tag. It returns the cleaned and formatted string.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\reviewer.py:review_directory:cfca12e976eb150d0547396e5888f5dff956b14e38f76c8b65b7edc01f555c56:cfca12e976eb150d0547396e5888f5dff956b14e38f76c8b65b7edc01f555c56": "The function `review_directory` processes all HTML files within a specified directory and its subdirectories. For each HTML file, it calls `_review_file` to analyze the content, optionally applying automatic fixes if the `autofix` parameter is set to True. If an exception occurs during processing, it prints an error message and continues with the next file. The results from each file review are printed line by line.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\sanitize_docs.py:_sanitize_html:b90f1ca4a6a1ec9f78f08cdac1ab9d9eff9a953ac42222906e9b1ea7981a85da:b90f1ca4a6a1ec9f78f08cdac1ab9d9eff9a953ac42222906e9b1ea7981a85da": "The function `_sanitize_html` processes HTML content to clean and sanitize specific tags (`p`, `li`, and heading tags from `h1` to `h6`). It uses a regular expression pattern to identify these tags and their content, removes any nested HTML tags from the content, and applies a `sanitize_summary` function to further clean the text. The result is a modified HTML string where the identified tags contain only sanitized text content.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\sanitize_docs.py:cbc2c687cd4c1464fbfe96caaeab835a5e5cff138095dc8ae251d79701b5b3d4:cbc2c687cd4c1464fbfe96caaeab835a5e5cff138095dc8ae251d79701b5b3d4": "The module provides functionality to sanitize HTML documentation files within a specified directory. It uses a regular expression pattern to identify specific HTML tags (p, li, h1-h6) and applies a cleaning function to their content. The cleaning process removes nested HTML tags from the content and then sanitizes the resulting text using an external `sanitize_summary` function from `llm_client`. The sanitized content replaces the original content in-place within the HTML files. A command-line interface is included to specify the directory containing the HTML files for processing.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\sanitize_docs.py:main:db726bd0fd5121f529a39588df013ff4988cd158b31b95bfb96d6f4ec76dedc7:db726bd0fd5121f529a39588df013ff4988cd158b31b95bfb96d6f4ec76dedc7": "The function `main` is the entry point for a script that sanitizes generated HTML documentation. It accepts an optional list of command-line arguments and uses `argparse` to parse the directory path provided as a positional argument. The parsed directory path is then passed to the `sanitize_directory` function, which presumably processes and cleans up the HTML files in that directory. The function returns an integer status code, indicating successful completion with a return value of 0.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\sanitize_docs.py:repl:07ce4165adb537a228ad3753ab0c32600b6821a6a7ac0b379829e09d13220187:07ce4165adb537a228ad3753ab0c32600b6821a6a7ac0b379829e09d13220187": "The function `repl` takes a regular expression match object and processes its captured groups. It extracts a tag and content from the match, removes any nested HTML tags from the content using substitution, sanitizes the resulting text, and returns a new string with the sanitized content wrapped in the original tag.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\sanitize_docs.py:sanitize_directory:2f11b0678b321ed9239ebd5a7ff3b9614c341523ec952296ea40dabfc00bfb86:2f11b0678b321ed9239ebd5a7ff3b9614c341523ec952296ea40dabfc00bfb86": "The function `sanitize_directory` processes all HTML files within a specified directory and its subdirectories. It reads each HTML file's content, applies an HTML sanitization function `_sanitize_html` to the content, and then writes the sanitized content back to the same file, preserving the original file structure and encoding. The function operates in-place, modifying the files directly without returning any value.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\scanner.py:_is_subpath:500cca1053b8b2b0797a335b22935b6ae2600cb1b551a8c1403827d8d6b86c33:500cca1053b8b2b0797a335b22935b6ae2600cb1b551a8c1403827d8d6b86c33": "The function `_is_subpath` determines whether a given path is equal to or located within a specified parent directory. It takes two arguments: `path` and `parent`, both of type `Path`. The function attempts to compute the relative path of `path` with respect to `parent` using the `relative_to` method. If this operation succeeds without raising a `ValueError`, it indicates that `path` is indeed a subpath of `parent`, and the function returns `True`. Otherwise, if a `ValueError` is raised, the function returns `False`.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\scanner.py:a6d2f1f5582a4ecc843b89dfb8f7747af779e8c3bbcef06f98d1c3bb16723167:a6d2f1f5582a4ecc843b89dfb8f7747af779e8c3bbcef06f98d1c3bb16723167": "Module implements source file discovery for DocGen-LM with recursive directory scanning and ignore rules. It identifies Python, MATLAB, C++, C, and Java files under a base path while excluding specified directories and files. The function supports optional progress bar display during scanning. Scanning respects ignore patterns relative to the base path and excludes .git directories. Results are returned as sorted list of absolute file paths.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\scanner.py:scan_directory:cc711c92e4cb7293a5ce34ed699bc07aedd5696288b9e39df461da546a63f5b5:cc711c92e4cb7293a5ce34ed699bc07aedd5696288b9e39df461da546a63f5b5": "The function `scan_directory` recursively searches for source code files with extensions `.py`, `.m`, `.cpp`, `.h`, and `.java` under a specified base directory. It accepts a base path, a list of paths to ignore during the search, and an optional flag to display progress. The function returns a sorted list of absolute paths to the discovered files, excluding those that match ignored paths or are located within `.git` directories. The scanning process uses `os.walk` to traverse the directory tree, with optional progress indication via `tqdm`.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\setup.py:501f48f7d373462af3d41b0caf7d7e23e2a79c5fe2886cf307b86c01a8b8d82f:501f48f7d373462af3d41b0caf7d7e23e2a79c5fe2886cf307b86c01a8b8d82f": "",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\summarize_utils.py:4695202ac971832489d602c6dda9f1ab07cde64220a89fe58051be341bea87cc:4695202ac971832489d602c6dda9f1ab07cde64220a89fe58051be341bea87cc": "Module implements a chunked text summarization function that uses an LLM client and response cache. It handles text that exceeds token limits by splitting into chunks, summarizing each chunk, and recursively merging summaries. The function manages token overhead from system prompts and templates, falls back to single-summary mode for short texts, and includes error handling for chunking, summarization, and merging steps. Cached responses are sanitized before being returned.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\summarize_utils.py:_merge_recursive:1a960a887989a1cbf589762e54822a2036587669f97c7d126de45bef57214755:1a960a887989a1cbf589762e54822a2036587669f97c7d126de45bef57214755": "The function `summarize_chunked` processes large text inputs by recursively summarizing them using a language model. It handles input that exceeds token limits by splitting it into chunks, summarizing each chunk, and then merging the summaries. The merging process is recursive, combining summaries in a hierarchical manner to maintain coherence while respecting token constraints. If a merged prompt still exceeds the token limit, it further subdivides the input or applies recursive summarization to individual items. The function uses caching to avoid reprocessing identical prompts and supports configurable context and chunk size parameters for fine-tuning performance.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\summarize_utils.py:_summarize:cb2c8e8768f7a1ac55ec1d38cf40207f0e8f107ab1bd7248457495fefe6382d9:cb2c8e8768f7a1ac55ec1d38cf40207f0e8f107ab1bd7248457495fefe6382d9": "The function `_summarize` retrieves or generates a summary for a given text using an LLM client and caches the result. It first checks if a cached response exists for the provided key. If so, it returns the cached summary after sanitizing it. Otherwise, it calls the client to generate a new summary, stores the result in the cache, and returns the generated summary. The function uses a system prompt to guide the summarization process and ensures that cached entries are sanitized before being returned.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\summarize_utils.py:summarize_chunked:608697008310c2d0fde6d98631233d48fc609972c83ddfa2be2dd9a25b981e08:608697008310c2d0fde6d98631233d48fc609972c83ddfa2be2dd9a25b981e08": "The function `summarize_chunked` summarizes input text by either processing it as a single chunk or breaking it into smaller parts if the text exceeds token limits. It uses an LLM client and cache for efficient processing, and employs tokenization to determine appropriate chunk sizes based on context and budget constraints. If the input text fits within the available token limit, it is directly summarized. Otherwise, the text is split into chunks, each of which is summarized individually. These partial summaries are then merged recursively using a merging prompt until a final consolidated summary is produced. In case of failures during chunking, summarization, or merging, the function falls back to returning sanitized text or an empty string. The function supports configurable system prompts and handles token overhead for system and template prompts. It includes error handling for network issues and tokenization errors, ensuring robust operation even when individual steps fail.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_cache.py:86aa81c1534bee80f7374373dc73e2b46ddbf6b59dc85f1dbb7004b4837537bf:86aa81c1534bee80f7374373dc73e2b46ddbf6b59dc85f1dbb7004b4837537bf": "Module defines tests for `ResponseCache` class functionality including cache round-trip operations, handling missing keys, and progress tracking with clearing capabilities.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_cache.py:test_cache_get_missing:54151ac83895e964a800c9e904b0f44ffc6873e499061ff5e0b0e89bf66c026b:54151ac83895e964a800c9e904b0f44ffc6873e499061ff5e0b0e89bf66c026b": "The function `test_cache_get_missing` tests the behavior of a `ResponseCache` object when retrieving a non-existent key. It creates a `ResponseCache` instance using a temporary file path, then calls the `get` method with a key `\"unknown\"` that does not exist in the cache. The assertion checks that the result is `None`, verifying that the cache correctly returns `None` for missing keys.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_cache.py:test_cache_round_trip:a5f8c13981fec3df8e3ab1f443eee51cfc89d62b351884a01b0615e84611104c:a5f8c13981fec3df8e3ab1f443eee51cfc89d62b351884a01b0615e84611104c": "The function `test_cache_round_trip` tests the round-trip functionality of a `ResponseCache` object. It creates a cache file in a temporary directory, initializes a `ResponseCache` with that file, stores a key-value pair (\"file.py\", \"content\" -> \"summary\"), and then reads the data back from the cache file using a new `ResponseCache` instance to verify that the stored value can be retrieved correctly.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_cache.py:test_progress_tracking:b701329d0e49a5d0832075b17b914b07ad523ca42f5b288f666835a59c98e8ae:b701329d0e49a5d0832075b17b914b07ad523ca42f5b288f666835a59c98e8ae": "The function `test_progress_tracking` tests the progress tracking functionality of the `ResponseCache` class. It creates a cache file at a temporary path, initializes a `ResponseCache` object with that file, and sets a progress entry for a module with associated data. It then verifies that the cached data can be retrieved correctly by creating a new `ResponseCache` instance from the same file. Finally, it clears the progress and confirms that the cache is empty.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_chunk_utils.py:eefe3cf76f5068de7a8511c465b25cf82a54fa62b999afa7871de7ddb1327afb:eefe3cf76f5068de7a8511c465b25cf82a54fa62b999afa7871de7ddb1327afb": "Module defines tests for tokenization and text chunking functionality. Tests verify tokenizer round-trip encoding/decoding, removal of FIM tokens, proper reconstruction of text from chunks, splitting of markdown headings, and preservation of code blocks during chunking. Uses `chunk_utils` module for chunking and tokenizer retrieval. Contains four test functions covering different aspects of text processing behavior.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_chunk_utils.py:test_chunk_text_preserves_code_blocks:bb2a016afd04f58e2df6c8faa71679df4a8a65dbda4708588982c0c7842b595e:bb2a016afd04f58e2df6c8faa71679df4a8a65dbda4708588982c0c7842b595e": "The function `test_chunk_text_preserves_code_blocks` tests that text chunking preserves code blocks within the input text. It uses a tokenizer to split a sample text containing a Python code block into chunks of a specified size. The test verifies that the code block remains intact across chunks and that each chunk either contains no code blocks or exactly two backticks (indicating a complete code block).",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_chunk_utils.py:test_chunk_text_reconstructs_content:4ca622a3c80115186405ce93aaa479984749c90529c0af0b94d33d732a87b215:4ca622a3c80115186405ce93aaa479984749c90529c0af0b94d33d732a87b215": "The function `test_chunk_text_reconstructs_content` verifies that text chunking preserves the original content. It uses a tokenizer to split a generated text string into chunks with a specified token limit, then checks that concatenating the chunks reproduces the original text (with leading/trailing whitespace removed) and confirms that multiple chunks are produced.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_chunk_utils.py:test_chunk_text_splits_markdown_headings:900a0115ce2090ddfe4df65bcd7633a84d45fad137429fef115f6d00a86ced85:900a0115ce2090ddfe4df65bcd7633a84d45fad137429fef115f6d00a86ced85": "The function `test_chunk_text_splits_markdown_headings` tests the behavior of the `chunk_text` function when processing Markdown-formatted text containing headings. It verifies that the text is correctly split into chunks based on a specified token limit, ensuring each chunk starts with the appropriate heading. The test uses a tokenizer to determine token counts and checks that the resulting chunks match the expected number and content.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_chunk_utils.py:test_get_tokenizer_roundtrip:c722ccabebf7896811e964196a3b1af068d4615fc31bd6914a7922ed9c065dfd:c722ccabebf7896811e964196a3b1af068d4615fc31bd6914a7922ed9c065dfd": "The function `test_get_tokenizer_roundtrip` tests the round-trip functionality of a tokenizer. It retrieves a tokenizer, encodes a sample text (\"hello world\") into tokens, verifies that the result is a list, decodes the tokens back into text, and asserts that the decoded text matches the original when stripped of whitespace.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_chunk_utils.py:test_get_tokenizer_strips_fim_tokens:91622137e01b6a9dcd261760bf564508d9da96e1b57c40ee140c89d2cd333d65:91622137e01b6a9dcd261760bf564508d9da96e1b57c40ee140c89d2cd333d65": "The function tests that the tokenizer removes FIM (Fill-In-Middle) tokens from text. It retrieves a tokenizer, encodes a string containing FIM tokens, decodes the resulting tokens, and asserts that the decoded output does not contain FIM tokens and matches the expected clean text \"hello world\".",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_docgenerator.py:bd93d1343982129d654c006ec965a99e35d08b1cc647b7560f7fcc9a9e98b43b:bd93d1343982129d654c006ec965a99e35d08b1cc647b7560f7fcc9a9e98b43b": "Module defines test cases for a documentation generator tool. Tests cover handling of invalid Python syntax, generation of class and function summaries, skipping non-UTF8 files, sanitization of project summaries, use of README content, cleaning output directories, chunked text summarization with token budgeting, recursive merging of long texts, structured chunking for functions and classes, subclass method processing, and support for C++ and Java file types. Tests utilize mocking of LLMClient and related functions to isolate functionality and verify correct behavior under various conditions.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_docgenerator.py:fake_sum:5a0ffd86176a820a9aa69ebf42c6c0bc9ab0275390f76dcda41239b05bbf5ccc:5a0ffd86176a820a9aa69ebf42c6c0bc9ab0275390f76dcda41239b05bbf5ccc": "The function `fake_sum` generates a fake summary based on the provided arguments. It retrieves a prompt template corresponding to the given `prompt_type`, calculates the token overhead of the system prompt and template, and determines the available tokens for the input text. It asserts that the input text fits within the available token limit. If the `prompt_type` is \"module\", it returns a repeated string \"summary \". Otherwise, it returns the string \"short\". The function appears to be a placeholder or mock implementation for testing purposes.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_docgenerator.py:fake_sum:82c7af083f82b12d174166f2a6ac6ebf5daa1e412354fe4869584302053d663b:82c7af083f82b12d174166f2a6ac6ebf5daa1e412354fe4869584302053d663b": "The function `fake_sum` generates a fake summary based on the provided arguments. It retrieves a prompt template corresponding to the specified `prompt_type`, calculates the token overhead for system and template prompts, and verifies that the input text fits within the available token context. If the `prompt_type` is \"module\", it returns a long dummy summary consisting of repeated \"long \" strings. For other prompt types, it returns a short dummy summary. The function uses a tokenizer to encode prompts and text arguments for token count calculations.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_docgenerator.py:test_chunking_accounts_for_prompt_overhead:d48c25e72877f9535633393a095166d72f94fa16cfab403660c74da19f3295cc:d48c25e72877f9535633393a095166d72f94fa16cfab403660c74da19f3295cc": "The function `test_chunking_accounts_for_prompt_overhead` tests that the chunking mechanism in `summarize_chunked` properly accounts for prompt overhead when determining chunk sizes. It creates a tokenizer, defines a sample text, and calculates the token overhead from system and template prompts. Using a mocked summary function, it verifies that the text is split into multiple chunks when the maximum context tokens are exceeded due to overhead, ensuring the chunking logic correctly handles prompt-related token usage.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_docgenerator.py:test_clean_output_dir:b5cb1d549e8f4d7431eefa640b911b840e4cd42bba39353ed6c66711159eb483:b5cb1d549e8f4d7431eefa640b911b840e4cd42bba39353ed6c66711159eb483": "The function `test_clean_output_dir` tests the `clean_output_dir` function from the `docgenerator` module. It creates a temporary output directory with subdirectories and files, including an HTML file marked as generated by DocGen-LM, a custom HTML file, and a CSS asset file. After calling `clean_output_dir` on the output directory path, it verifies that the generated HTML file is removed while the custom HTML file and the CSS asset file remain intact.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_docgenerator.py:test_generates_class_and_function_summaries:4548490d47041ef4e8ef2c30eb13c63a391d152fa0e2f2af5cbbf52ed482ce62:4548490d47041ef4e8ef2c30eb13c63a391d152fa0e2f2af5cbbf52ed482ce62": "This function tests the generation of class and function summaries by a documentation generator. It creates a temporary project directory with a Python module containing a class and a function, then invokes the main documentation generation process with a mocked LLM client. The test verifies that the generated HTML output includes expected summary text for the class and function, as well as a module summary in the index page. The mocked client simulates LLM responses for various summarization tasks including module, project, class, and function summaries. The test ensures that the documentation generator correctly processes the source code and incorporates LLM-generated summaries into the output HTML files.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_docgenerator.py:test_handles_class_without_docstring:a31bf82d78c418d22386037b2810c12879447876fe4fd02a1b3db469205079fb:a31bf82d78c418d22386037b2810c12879447876fe4fd02a1b3db469205079fb": "The function `test_handles_class_without_docstring` tests the handling of a class without a docstring during documentation generation. It creates a temporary project directory with a Python module containing a class named `Foo` that has no docstring. The test then runs the main documentation generation process, mocking the LLM client to simulate responses for module, project, and class summaries. After execution, it verifies that the generated HTML output includes the class summary text. The test ensures that the documentation generator correctly processes classes regardless of whether they have docstrings.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_docgenerator.py:test_merge_recurses_when_prompt_too_long:91c39450c1f79163031dd4821dca7f4fbe80898e7b180795887d45d426dc65c8:91c39450c1f79163031dd4821dca7f4fbe80898e7b180795887d45d426dc65c8": "The function `test_merge_recurses_when_prompt_too_long` tests the recursive merging behavior of the `summarize_chunked` utility when the prompt exceeds the maximum context length. It sets up a mock tokenizer and cache, defines a fake summarization function that enforces token limits, and verifies that multiple calls are made with the `\"docstring\"` prompt type when chunking occurs due to exceeding the token budget. The test ensures that the system correctly handles long inputs by recursively processing them in smaller segments.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_docgenerator.py:test_processes_cpp_file:76a82f49d8a95d2b64d2782dc954553cde313f6df060ea0561d972a5b2a88a3e:76a82f49d8a95d2b64d2782dc954553cde313f6df060ea0561d972a5b2a88a3e": "The function `test_processes_cpp_file` tests the processing of a C++ source file within a temporary directory structure. It creates a project directory with a C++ file containing a simple function, then defines a mock parsed representation of the file's contents including a class with a variable. The test patches the C++ parser and LLM client to simulate successful parsing and summarization. It calls the main function with the project and output directories as arguments, asserts that the main function returns zero (indicating success), verifies that the parser was called once, and checks that the expected HTML output file is created.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_docgenerator.py:test_processes_java_file:3a0ee1ed32fd320fef2c4b1e4e1570cf2d261194935871693710a167ac701a53:3a0ee1ed32fd320fef2c4b1e4e1570cf2d261194935871693710a167ac701a53": "The function `test_processes_java_file` tests the processing of a Java source file within a temporary directory structure. It creates a Java class file named `Mod.java` containing a public class `Foo` with a variable and method. The test sets up mocked return values for `parse_java_file` and `LLMClient` to simulate parsing and summarization behavior. After invoking the main function with specified project and output directories, it verifies that the main function returns zero (indicating success), the parser was called once, and the expected HTML output file `Mod.html` is created in the output directory.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_docgenerator.py:test_project_summary_is_sanitized:b516fd651bd46b40545982de5313e1a92b97eb4d245ad6f93c098ffe2721ca82:b516fd651bd46b40545982de5313e1a92b97eb4d245ad6f93c098ffe2721ca82": "The function `test_project_summary_is_sanitized` verifies that the project summary generated by the documentation generator is sanitized of specific phrases. It creates a temporary project directory with a Python module, configures a mocked LLM client to return predefined summaries, and executes the main documentation generation process. The test confirms that the resulting HTML output does not contain the phrase \"You can run this\" while ensuring \"It prints.\" is present. It also checks that the LLM client's `summarize` method was called with \"project\" as an argument during the process.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_docgenerator.py:test_readme_summary_used:e0cca952c7964c49a89bcaee7dcadcf7fe4558158432d388c8c474c8acd95d1f:e0cca952c7964c49a89bcaee7dcadcf7fe4558158432d388c8c474c8acd95d1f": "This function tests the generation of a README summary using a mocked LLM client. It creates a temporary project directory with a Python module and a README file, then invokes the main documentation generation function with specified input and output paths. The test verifies that the generated HTML output contains the expected summary text and that the LLM client's summarize method was called with the correct prompt type (\"readme\"). The test uses mocking to simulate LLM behavior and ensures the integration of README content into the documentation output.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_docgenerator.py:test_single_long_partial_is_recursively_chunked:e9d12394e36134ed094b52cbabd6ca7cfd5b7c32e29790897cfc478a994240b0:e9d12394e36134ed094b52cbabd6ca7cfd5b7c32e29790897cfc478a994240b0": "This function tests that a single long partial text is recursively chunked during summarization. It sets up a mock environment with a fixed token budget and a fake summarization function that enforces token limits. The test verifies that when a text exceeds the token budget, it is split into multiple chunks, as indicated by multiple calls to the `docstring` prompt type in the mocked summarization function. The test ensures recursive chunking behavior under token constraints.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_docgenerator.py:test_skips_invalid_python_file:99d598a988dc86f591bbca3313b2ee53d5d52d8dcfec8a91971a4025e44bf611:99d598a988dc86f591bbca3313b2ee53d5d52d8dcfec8a91971a4025e44bf611": "The function `test_skips_invalid_python_file` tests the behavior of the documentation generator when encountering a Python file with invalid syntax. It creates a temporary project directory containing a file (`bad.py`) with invalid Python syntax (a leading zero in an integer literal). The test runs the main documentation generation process, mocking the LLM client to simulate successful communication and summarization. After execution, it verifies that only the index page is generated in the output directory, confirming that invalid Python files are skipped during processing.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_docgenerator.py:test_skips_non_utf8_file:1399a5b04f1f9fa6d05575104a961b075404ff80f4ef9f19bdd9686eb744678b:1399a5b04f1f9fa6d05575104a961b075404ff80f4ef9f19bdd9686eb744678b": "The function `test_skips_non_utf8_file` tests the handling of non-UTF-8 files during documentation generation. It creates a temporary project directory with a file containing non-UTF-8 bytes, then runs the main documentation generation process. The test verifies that the process completes successfully (return code 0) and that the output directory contains an index.html file while skipping the invalid file (no bad.html is created). The test mocks the LLM client to simulate successful communication and summarization.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_docgenerator.py:test_structured_chunker_keeps_functions_atomic:f01d9d86680ba5d4e881b7230ca5a97076fec4f8e388e81cf33e267c32469540:f01d9d86680ba5d4e881b7230ca5a97076fec4f8e388e81cf33e267c32469540": "The function `test_structured_chunker_keeps_functions_atomic` tests that the chunking mechanism preserves individual functions as atomic units during summarization. It creates a Python source file containing two functions, parses it, and then uses a mocked summarization function to verify that each function is processed as a separate chunk. The test ensures that the token budgeting logic correctly isolates each function's source code when summarizing a module, maintaining the integrity of individual function boundaries within the chunking process. The test checks that exactly two chunks are generated, corresponding to the two functions, and that their sources match the original parsed function sources.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_docgenerator.py:test_structured_chunker_splits_large_class_by_method:9e5d060e795bd630783eae5b484960b8a0edb42811cbb9bdfbab0eb3ac3eaa2b:9e5d060e795bd630783eae5b484960b8a0edb42811cbb9bdfbab0eb3ac3eaa2b": "This function tests the behavior of `_summarize_module_chunked` when processing a large class by splitting it into method-level chunks. It creates a Python class with two methods, parses the source code, and uses a mocked summarization function to verify that each method is processed as a separate chunk. The test ensures that the chunking logic correctly isolates individual methods from a class and passes them to the summarization function with the appropriate token budget and context limits. The assertion confirms that the number of chunks matches the number of methods and that each chunk corresponds to the source code of a method.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_docgenerator.py:test_subclass_methods_are_summarized:a75af9f2653737e8638c9aa2d66960ad12fd3d95f4c81fe649ca60044835a74f:a75af9f2653737e8638c9aa2d66960ad12fd3d95f4c81fe649ca60044835a74f": "The function `test_subclass_methods_are_summarized` tests that methods within nested classes (subclasses) are properly summarized during the documentation generation process. It creates a temporary project directory with a Python module containing a class `A` that includes a nested class `B`, which in turn contains a method `m`. The test mocks the `LLMClient` and summarization functions to simulate LLM interactions and verifies that the method `B:m` is included in the arguments passed to the chunked summarization function. The main execution flow is invoked with the project directory and output directory as command-line arguments, and the test asserts that the return code is zero, indicating successful execution. The assertion checks that the method name `B:m` appears in the arguments of at least one call to `_summarize_chunked`.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_docgenerator.py:test_summarize_chunked_splits_long_text:ae320c93015a1e78afecc966569c938e1469ff8d487e0f753863b5c0de744fb4:ae320c93015a1e78afecc966569c938e1469ff8d487e0f753863b5c0de744fb4": "The function `test_summarize_chunked_splits_long_text` tests the behavior of the `summarize_chunked` utility by verifying that a long text input is split into multiple chunks during summarization. It creates a tokenizer and a cache, then patches the internal `_summarize` function to return a fixed summary. The test calls `summarize_chunked` with a text string consisting of 50 repeated words, a small context size, and a limited chunk budget. It asserts that the mocked `_summarize` function is called more than once, confirming that the input text was divided into multiple chunks for processing.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_docgenerator_subclasses.py:a9e56fb250c2146bacd150cd8d89d139b9ef4116bbde468ba21945e1b4b4b5b1:a9e56fb250c2146bacd150cd8d89d139b9ef4116bbde468ba21945e1b4b4b5b1": "Test function that verifies documentation generation for nested class methods. Creates a temporary project structure with a nested class and method, mocks the LLM client to return predefined summaries, executes the documentation generator main function, and validates that the output HTML contains expected summary markers for both the nested class and its method.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_docgenerator_subclasses.py:test_subclass_docs_and_method_summary:b4dafccfa89d3371a0cbd122364a622d7b1f14117527b3aacc818169f36b1e5b:b4dafccfa89d3371a0cbd122364a622d7b1f14117527b3aacc818169f36b1e5b": "This function tests the documentation generation for a Python project that includes a nested class structure. It creates a temporary project directory with a module containing a class `A` that defines a nested class `B`, which contains a method `m`. The test uses a mocked LLM client to simulate summarization responses and runs the main documentation generation function on the project. It verifies that the generated HTML output correctly includes a summary for the nested class `B` and its method `m`, ensuring that both class and method docstrings are properly captured and formatted in the documentation.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:810610c86fdad6781acb74ecd58be99f6da6b185b3eb5ed893fd2d2a572e7ebe:merge0:abe787a739cc9cbd011d32f3bdc8ed11a1dc10e8765645f037324e38b52ad263": "The code defines a comprehensive testing suite for documentation processing and summarization workflows, encompassing fixture creation and LLM client mocking functionalities. It includes tests for extracting text from various file formats (Markdown, HTML, DOCX), rendering HTML summaries with tables of contents and evidence blocks, generating user manuals in HTML and PDF formats, handling missing dependencies, custom output directories, collecting documentation files, mapping evidence to sections with priority and filtering, limiting snippet lengths, detecting placeholders, parsing manual sections with inferred content, validating references, inferring section content, skipping large files during snippet extraction, and scanning code while excluding non-source directories. Additional test cases cover code documentation generation functionality including snippet categorization, file ranking with language support, LLM placeholder filling with logging, code scan skipping behaviors, fallback mechanisms with limits, code flag interactions, custom output naming, and index insertion features. The suite also verifies automatic chunking and summarization logic in `manual_utils._summarize_manual`, confirming multiple LLM calls during chunking, proper system prompts for chunk and merge operations, logging of chunking steps, application of post-processing hooks, parallel execution of chunk summaries, hierarchical merging with logging, reuse of cached chunk results, absence of LLM calls when chunking is disabled, and sanitization of",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:810610c86fdad6781acb74ecd58be99f6da6b185b3eb5ed893fd2d2a572e7ebe:part0:5516db775b429103a40dd2a03a766cbe0e39e0bdb1b12007edef2db075c1950b": "Defines functions for creating test fixtures and mocking an LLM client. Includes tests for extracting text from Markdown, HTML, and DOCX files, rendering HTML summaries with tables of contents and evidence blocks, generating user manuals in HTML and PDF formats, handling missing dependencies, custom output directories, collecting documentation files, mapping evidence to sections with priority and filtering, limiting snippet lengths, detecting placeholders, parsing manual sections with inferred content, validating references, inferring section content, skipping large files during snippet extraction, and scanning code while excluding non-source directories. Tests cover various edge cases and integration points for documentation processing and summarization workflows.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:810610c86fdad6781acb74ecd58be99f6da6b185b3eb5ed893fd2d2a572e7ebe:part1:f6168ffd0c53de3b16c7a9eebf313f1905a2585db880dd3c97d8a20c97080ce6": "Module defines test cases for code documentation generation functionality. Tests cover snippet categorization, file ranking with specific language support, LLM placeholder filling with logging, code scan skipping behaviors, fallback mechanisms with limits, code flag interactions, custom output naming, and index insertion features. Tests validate various command-line argument combinations and their effects on documentation generation process.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:810610c86fdad6781acb74ecd58be99f6da6b185b3eb5ed893fd2d2a572e7ebe:part2:5dfbe796adcac882bd0d312874f74c28a44bac3c22859ff2d0e1b88a8ca6b599": "Tests verify behavior of automatic chunking and summarization logic in `manual_utils._summarize_manual`. They confirm multiple LLM calls during chunking, proper system prompts for chunk and merge operations, logging of chunking steps, application of post-processing hooks, parallel execution of chunk summaries, hierarchical merging with logging, reuse of cached chunk results, absence of LLM calls when chunking is disabled, and sanitization of output during manual generation with caching.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:Dummy:2660be1fabf77f20709d0e81add6d441e36185a50483b00d0d239ebee3412517:2660be1fabf77f20709d0e81add6d441e36185a50483b00d0d239ebee3412517": "The `Dummy` class is designed to track function or method calls by storing details such as input text, prompt type, and system prompt in a list called `calls`. The `summarize` method records these calls and returns either the string `\"final\"` or the first word of the input text, depending on whether the provided system prompt matches a specific merge prompt. This class serves as a simple recorder for tracking and processing call-related data during documentation generation.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:Dummy:670aa7c3783d3b697d8658978c048ad62f7fcfe3866e01354a56a4ba64397e27:670aa7c3783d3b697d8658978c048ad62f7fcfe3866e01354a56a4ba64397e27": "The `Dummy` class provides a placeholder implementation for a summarization method that generates a fixed output format regardless of input. It includes a `summarize` method which returns a standardized string structure without performing actual text processing. This class serves as a temporary or fallback implementation within the documentation generation system.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:Dummy:67c90d3489b510600e4de7f3924d85b7271ac6b7c70bc750ff2f2260834b0fdb:67c90d3489b510600e4de7f3924d85b7271ac6b7c70bc750ff2f2260834b0fdb": "The `Dummy` class is designed to process and summarize text by replacing placeholder tokens with section identifiers. It uses regular expressions to extract section names and manual text, then substitutes placeholders in the manual text with formatted strings indicating that the section has been filled. The class maintains a list of processed calls and returns the modified manual text as output.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:Dummy:7d4a73895a8359c01073e0d2b82f09c6b5292cd4a77d2d3aa03147f92e1c19ca:7d4a73895a8359c01073e0d2b82f09c6b5292cd4a77d2d3aa03147f92e1c19ca": "The `Dummy` class processes input text through a `summarize` method that behaves differently based on the content of a system prompt. If the system prompt contains \"How to Run\", it returns \"[[NEEDS_RUN_INSTRUCTIONS]]\". If it contains \"enhancing a user manual\", it extracts manual text and replaces \"[[NEEDS_RUN_INSTRUCTIONS]]\" with \"use it\". For all other cases, it simply returns \"x\".",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:Dummy:993a1b2a29c13940e982a4484d5ff8fe3647baed17844e5d6af1eea87a9855f6:993a1b2a29c13940e982a4484d5ff8fe3647baed17844e5d6af1eea87a9855f6": "The `Dummy` class is designed to track function or method calls through a list of dictionaries stored in the `calls` attribute. The `summarize` method records input details and returns either a predefined value (`big`) or the string `\"short\"`, depending on the number of recorded calls. This class appears to be a mock implementation used for testing or demonstration purposes within a documentation generation system.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:Dummy:__init__:db3b131b0ba0f8c19da82c36415f2aba4b713baca985cf65bbd5285ae3759683:db3b131b0ba0f8c19da82c36415f2aba4b713baca985cf65bbd5285ae3759683": "Initializes an instance with an empty list to store call records.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:Dummy:__init__:f73a3a572424de85bb41637ddb7e178958076e112fc4185ac0cea64dae24f819:f73a3a572424de85bb41637ddb7e178958076e112fc4185ac0cea64dae24f819": "Initializes an instance with an empty list to store string values.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:Dummy:d1615581f4a8d5a7b21be8039ab342faecac40349d919a48b127b008189da2f0:d1615581f4a8d5a7b21be8039ab342faecac40349d919a48b127b008189da2f0": "The `Dummy` class is designed to track and log calls made to a summarization process by storing information about each call in an internal list. It provides a method to append call details\u2014such as input text, prompt type, and system prompt\u2014into this list and returns a fixed string `\"done\"` upon completion. This class serves primarily as a monitoring or debugging tool for recording summarization activities without performing actual summarization.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:Dummy:eb1c570e0debacd4c2f38d9e9b92a1e453d2bbd4b23f1af089630d77602bdc8b:eb1c570e0debacd4c2f38d9e9b92a1e453d2bbd4b23f1af089630d77602bdc8b": "The `Dummy` class is designed to track function or method calls by storing information about each call in an internal list. Each call is recorded as a dictionary containing the input text, prompt type, and optional system prompt. The class provides a summarization method that logs these calls and returns a formatted response string indicating the count of recorded calls.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:Dummy:ed808baf5e951f1b229cca6cb67224c2ab9b009a1d123d81d33104580043fbf4:ed808baf5e951f1b229cca6cb67224c2ab9b009a1d123d81d33104580043fbf4": "The `Dummy` class provides a stub implementation of the `summarize` method that returns a fixed, formatted summary string containing structured information about a demo project. The method takes a string input, a prompt type, and an optional system prompt, but is intended only as a placeholder and not for actual use. The returned string includes sections such as overview, purpose, execution instructions, inputs, outputs, system requirements, and examples.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:Dummy:summarize:04a59d6003fc253b7f2d197a32f616e7ff915453a9f3c57ff82078a51f5298ad:04a59d6003fc253b7f2d197a32f616e7ff915453a9f3c57ff82078a51f5298ad": "Function that processes text input to extract and replace placeholders within manual content. Takes a text string, extracts manual text and section information using regular expressions, looks up a placeholder token based on the section, and returns the manual text with the placeholder replaced by a formatted string indicating the section was filled. Maintains a log of all processed texts in a calls list attribute.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:Dummy:summarize:1c3485ae9fe25b29483150d67603501ed1568172205d21f4e8e3ad17380a22ba:1c3485ae9fe25b29483150d67603501ed1568172205d21f4e8e3ad17380a22ba": "Function that returns a fixed summary template string for demonstration purposes, with parameters for text input, prompt type, and system prompt, though the implementation ignores these parameters and always returns the same hardcoded template.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:Dummy:summarize:217d7857c10f60dee6126555c95ee6d774f7a1b5efbbbdd871b2a614670d17b5:217d7857c10f60dee6126555c95ee6d774f7a1b5efbbbdd871b2a614670d17b5": "Function that takes text, prompt type, and optional system prompt as inputs and returns a fixed string response containing an overview and run instructions placeholder.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:Dummy:summarize:627a4b48b32e053af1c9d6db437401aed7de4fd5255c5f50926bd373bb5437df:627a4b48b32e053af1c9d6db437401aed7de4fd5255c5f50926bd373bb5437df": "Function that records text input and associated metadata into a calls list, then returns a response identifier string.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:Dummy:summarize:78ccf80460220118714ea1885eb918e683c83a410b4d03b70aba859a0dca3596:78ccf80460220118714ea1885eb918e683c83a410b4d03b70aba859a0dca3596": "Function that processes text based on prompt type and system prompt content. Returns specific string values depending on whether the system prompt contains \"How to Run\" or \"enhancing a user manual\" keywords. When \"How to Run\" is present, returns \"[[NEEDS_RUN_INSTRUCTIONS]]\". When \"enhancing a user manual\" is present, extracts and processes manual text from the input using regex pattern matching. Returns \"x\" for all other cases.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:Dummy:summarize:ab3f0d9d1c4bec0b699e9e6bebc3161c380bb9121133d634c1d756b9c006db22:ab3f0d9d1c4bec0b699e9e6bebc3161c380bb9121133d634c1d756b9c006db22": "Function that records input parameters in a calls list and returns the string \"done\".",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:Dummy:summarize:ae1d725d03a5a0cb10695a524606bf4c5e3d8c46e6bdd9c322aaf858f0a24d53:ae1d725d03a5a0cb10695a524606bf4c5e3d8c46e6bdd9c322aaf858f0a24d53": "Function that processes input text based on prompt type and system prompt. Appends call information to internal list. Returns \"final\" when system prompt matches a specific merge prompt constant, otherwise returns the first word of the input text.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:Dummy:summarize:cf774a300e22d141c142741d0a158680f066f47fffaea7025f0b4ff13e3ff041:cf774a300e22d141c142741d0a158680f066f47fffaea7025f0b4ff13e3ff041": "Function that appends call information to an internal list and returns different string values based on the number of calls stored.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:SlowClient:1175a3074cc59fe22c603502c57ba2a78f3ab74fe30d91f91c0f384aebc5694d:1175a3074cc59fe22c603502c57ba2a78f3ab74fe30d91f91c0f384aebc5694d": "The `SlowClient` class implements a mock summarization method named `summarize` that conditionally pauses execution based on a system prompt check, but does not perform actual text summarization. The method always returns the string `\"ok\"` regardless of input parameters or conditions. This class serves as a placeholder or simulated client for demonstration or testing purposes within the documentation generation framework.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:SlowClient:summarize:81215f77b5bdc963253a5febc2f86ef614ee2b32b6c5e3234bc2546fea2dcbc1:81215f77b5bdc963253a5febc2f86ef614ee2b32b6c5e3234bc2546fea2dcbc1": "Function that processes text summarization with conditional delay based on system prompt matching, returning a fixed string response.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:Stub:9a1cae6761e216a6f744eca02a6ee2df16be33d4b85f69a0cb31a74e1e957970:9a1cae6761e216a6f744eca02a6ee2df16be33d4b85f69a0cb31a74e1e957970": "The `Stub` class provides a placeholder implementation for a summarization method that currently returns the string `\"guessed\"` regardless of input parameters. It defines a `summarize` method which accepts a prompt, prompt type, and optional system prompt but does not perform any actual summarization. This class serves as a dummy interface for summarization functionality within the documentation generation tool.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:Stub:summarize:34289b97bd6fbcae70ecb22cbadd55985049de1c9d992c034e8b3c85990fb396:34289b97bd6fbcae70ecb22cbadd55985049de1c9d992c034e8b3c85990fb396": "This function takes a prompt string, prompt type string, and an optional system prompt string as input parameters. It returns a hardcoded string value \"guessed\" regardless of the input parameters provided. The function signature indicates it is likely part of a class due to the 'self' parameter, but the implementation does not utilize any of the provided arguments.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:__init__:059f4591a29911081add0ec1d8a24d69c08c0656f3a90d423ba704677f9ffbbe:059f4591a29911081add0ec1d8a24d69c08c0656f3a90d423ba704677f9ffbbe": "Initializes an instance of the `Dummy` class with an empty list to store call references.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:__init__:f03e344d9e51631a2898e02813beea69d412ac45828b332a2ba2e3fe640acac9:f03e344d9e51631a2898e02813beea69d412ac45828b332a2ba2e3fe640acac9": "Initializes an instance of the `Dummy` class with an empty list to store call records. The `calls` attribute is a list of dictionaries, intended to track information about function or method calls.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:_create_fixture:c357c986833f7a2836eaad4eae89e5c6d25562afd9d2ea0f66823aafe66b498d:c357c986833f7a2836eaad4eae89e5c6d25562afd9d2ea0f66823aafe66b498d": "The function `_create_fixture` creates a temporary directory structure and populates it with sample files for testing purposes. It generates a nested directory path, writes an HTML file containing a basic HTML document with a heading, creates a README.md file with structured content including sections for overview, purpose, usage, inputs, outputs, requirements, and examples, and adds a sample JSON file with basic data. The function uses `Path` from the `pathlib` module to manage directory paths and file operations, ensuring proper encoding when writing text files.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:_mock_llm_client:feae4f68170bf00d6cc378391881ace6068a54f4b61c48ed8bcc307e298bd53d:feae4f68170bf00d6cc378391881ace6068a54f4b61c48ed8bcc307e298bd53d": "The function `_mock_llm_client` returns a dummy object that simulates an LLM client for testing purposes. The returned object implements a `summarize` method which takes a text string, a prompt type, and an optional system prompt, and returns a fixed, formatted summary string. This stub implementation is used to avoid actual LLM calls during testing or demonstration scenarios.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:fake_extract:0aaff15745e6fa0465a96baa7f1684956bead311f67cc76dd48136534bc98ca7:0aaff15745e6fa0465a96baa7f1684956bead311f67cc76dd48136534bc98ca7": "The function `fake_extract` takes an iterable of file paths and several configuration parameters, then returns a dictionary mapping the first three paths to predefined string descriptions. The parameters `max_files`, `time_budget`, and `max_bytes` are unused in the implementation. The returned dictionary contains fixed string values for the first three paths in the input iterable, representing simplified actions: \"read input from user\", \"write output\", and \"run the tool\".",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:fake_extract:43bf91818be3038de992db9dd186726b51721ae848214c4587d18e80f268b810:43bf91818be3038de992db9dd186726b51721ae848214c4587d18e80f268b810": "The function `fake_extract` takes an iterable of file paths and extraction parameters, increments a global tracker for the \"extract\" operation, and returns a dictionary mapping the first file in the input to the string \"code\". The function does not actually extract or process the files; it serves as a placeholder implementation.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:fake_extract:6c4faef3438c1b20b68084d67122e4f79747e5781779861b34796c98968d4886:6c4faef3438c1b20b68084d67122e4f79747e5781779861b34796c98968d4886": "The function `fake_extract` takes an iterable of file paths and configuration parameters including maximum number of files, time budget, and maximum bytes. It increments a counter in the global `tracker` dictionary under the key \"extract\" and returns an empty dictionary mapping paths to strings. This implementation appears to be a placeholder or mock version of an extraction function, as it does not perform any actual file reading or content extraction.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:fake_extract:7f459de94c8ab4413b387d5c6eb540dbcda8e5b38c1efe27b3247bac29810a0c:7f459de94c8ab4413b387d5c6eb540dbcda8e5b38c1efe27b3247bac29810a0c": "The function `fake_extract` processes an iterable of file paths and returns a dictionary mapping selected files to the string \"run code\". It updates a global `tracker` object with information about the extraction process, including the number of times it has been called, the arguments provided (`max_files`, `time_budget`), and the list of files scanned up to the maximum allowed. The function limits the processing to `max_files` number of files from the input iterable and does not consider the `max_bytes` parameter in its implementation.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:fake_rank:6d674513011309bb4afd7647e6a7da6b9a84ad5700ce58898037253ab5b5958b:6d674513011309bb4afd7647e6a7da6b9a84ad5700ce58898037253ab5b5958b": "The function `fake_rank` takes a root path and a list of patterns as input, increments a global or external `tracker` dictionary's \"rank\" key by one, and returns a list containing a single Path object pointing to a file named \"script.py\" located within a temporary path (`tmp_path`). The purpose of this function appears to be a placeholder or mock implementation, likely used for testing or simulation purposes.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:fake_rank:6f83c3512f5cf0bf631228f1262430a3b77e3528caa2932717c5ba72b33dd136:6f83c3512f5cf0bf631228f1262430a3b77e3528caa2932717c5ba72b33dd136": "The function `fake_rank` takes a root path and a list of patterns as input, increments a global or shared counter tracked under the key \"rank\", and returns a list containing a single Path object pointing to a temporary file named \"a.py\" within a temporary directory. The function appears to be a placeholder or mock implementation, likely used for testing or demonstration purposes, as it does not utilize the provided root path or patterns in its logic.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:fake_rank:b820f7a3c653c449ea9db1003e4f755131674e78e7cfe895539c9c0a66867b8b:b820f7a3c653c449ea9db1003e4f755131674e78e7cfe895539c9c0a66867b8b": "The function `fake_rank` takes a `Path` object and a list of strings as input parameters. It increments a global or shared variable `tracker[\"rank\"]` by one and returns an empty list of `Path` objects. The function appears to be a placeholder or mock implementation, likely used for testing or simulation purposes, as it does not perform any actual ranking or path processing.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:fake_rank:ff232f8d6d16c678e4718b7a132db70b2c29d6e84a9d3cd6cde4bf3ca6717bfb:ff232f8d6d16c678e4718b7a132db70b2c29d6e84a9d3cd6cde4bf3ca6717bfb": "The function `fake_rank` takes a `Path` object `root` and a list of string patterns, increments a counter in the global `tracker` dictionary under the key `\"rank\"`, and returns the value of the global variable `paths`. The function does not use the `root` or `patterns` parameters in its implementation.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:fake_summarize:e0438296b834dc431957aff4e6bd403dcefcc18b79937b1a435f8f4b56e5a00b:e0438296b834dc431957aff4e6bd403dcefcc18b79937b1a435f8f4b56e5a00b": "",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:hook:3ccc2778562d57b2406689eb571c821cfe192f25f08bd4a28e8505d7dc06429b:3ccc2778562d57b2406689eb571c821cfe192f25f08bd4a28e8505d7dc06429b": "The function `hook` takes a list of strings as input and returns a new list where each string has been converted to uppercase. It applies the `upper()` method to each element in the input list using a list comprehension.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:summarize:2b63aaa5e5c1cf4b211718f82b737e27984879a0c981cd0b65f6fee2b5a9cacc:2b63aaa5e5c1cf4b211718f82b737e27984879a0c981cd0b65f6fee2b5a9cacc": "The `summarize` method processes input text based on the specified prompt type and system prompt. If the system prompt contains \"How to Run\", it returns the string \"[[NEEDS_RUN_INSTRUCTIONS]]\". If the system prompt contains \"enhancing a user manual\", it extracts manual text from the input using a regular expression and replaces occurrences of \"[[NEEDS_RUN_INSTRUCTIONS]]\" with \"use it\" before returning the result. For all other cases, it returns the string \"x\".",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:summarize:2b826f4d89a06dc8e4c80a01c6819b6e9f42c8877fc2ab4d20f5a7ca4cb79047:2b826f4d89a06dc8e4c80a01c6819b6e9f42c8877fc2ab4d20f5a7ca4cb79047": "The function `summarize` is a stub implementation within the `Dummy` class that takes a string input `text`, a `prompt_type`, and an optional `system_prompt`. It returns a fixed, formatted summary string containing structured information about a demo project. The returned string includes sections for overview, purpose, execution instructions, inputs, outputs, system requirements, and examples. The function is marked with a pragma directive indicating it is a simple stub and not intended for actual use.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:summarize:41130c0546c48432f6a7ac453db85faea8321ab731ae6fae66aabf3c1e75d964:41130c0546c48432f6a7ac453db85faea8321ab731ae6fae66aabf3c1e75d964": "The `summarize` method processes a given text string to replace a placeholder token with a specified section identifier. It extracts the section name and manual text from the input using regular expressions, retrieves a placeholder token associated with the section, and substitutes the token in the manual text with a formatted string indicating that the section has been filled. The method appends the input text to a list of calls and returns the modified manual text.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:summarize:440c9631bff1ba2d779ab1e2fb23184d383cf7f7280c44d97c7d8e11686ee711:440c9631bff1ba2d779ab1e2fb23184d383cf7f7280c44d97c7d8e11686ee711": "The function `summarize` is a method of the `SlowClient` class that takes three parameters: `text`, `prompt_type`, and `system_prompt`. It performs a conditional check to see if the `system_prompt` matches a specific constant `explaincode.CHUNK_SYSTEM_PROMPT`. If the condition is true, it pauses execution for a duration defined by the variable `delay` using `time.sleep()`. Regardless of the condition, the function returns the string `\"ok\"`. The purpose of this function appears to be a placeholder or mock implementation, as it does not actually perform any summarization of the input `text`.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:summarize:482c514baffbb11da1178dcb8047c03888edcd5690810bfbc79c13910bb9c587:482c514baffbb11da1178dcb8047c03888edcd5690810bfbc79c13910bb9c587": "The `summarize` method appends a dictionary containing the input `text`, `prompt_type`, and `system_prompt` to the `self.calls` list. If the provided `system_prompt` matches `explaincode.MERGE_SYSTEM_PROMPT`, it returns the string `\"final\"`. Otherwise, it splits the input `text` into words and returns the first word.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:summarize:500b63b75fe4f660b4c8c074bdadddc886b963f09ffd28c8fbe13cabe31df564:500b63b75fe4f660b4c8c074bdadddc886b963f09ffd28c8fbe13cabe31df564": "The function `summarize` accepts a string of text, a prompt type, and an optional system prompt. It appends a dictionary containing these inputs to the instance's `calls` list and returns a string in the format \"respN\", where N is the current number of items in the `calls` list.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:summarize:a7058b72fa0838b4c60e2d04e8d54ee2172d731460ab8b16639b7537eaab4c8b:a7058b72fa0838b4c60e2d04e8d54ee2172d731460ab8b16639b7537eaab4c8b": "The `summarize` method of the `Dummy` class appends a dictionary containing input text, prompt type, and system prompt to an internal list `self.calls`. If the number of entries in `self.calls` is less than or equal to 2, the method returns the value stored in the variable `big`. Otherwise, it returns the string `\"short\"`.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:summarize:bd260dee938900d7213cce7a1b5feb4c68aeb46771fa7c3d6db0b53338e4a495:bd260dee938900d7213cce7a1b5feb4c68aeb46771fa7c3d6db0b53338e4a495": "The `summarize` method is a placeholder implementation within the `Dummy` class that takes a string input `text`, a `prompt_type`, and an optional `system_prompt`. It returns a fixed string output formatted as \"Overview: x\\\\nHow to Run: [[NEEDS_RUN_INSTRUCTIONS]]\", regardless of the input provided. This method appears to be intended for generating a standardized summary structure but currently does not perform any actual summarization of the input text.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:summarize:c56b5906e1de5587d6456fbc353773a76f830fe76886007f0da3035803115f3e:c56b5906e1de5587d6456fbc353773a76f830fe76886007f0da3035803115f3e": "The `summarize` method is a stub implementation within the `Stub` class that takes a `prompt`, `prompt_type`, and an optional `system_prompt` as input parameters and returns the string `\"guessed\"`. This method currently does not perform any actual summarization and serves only as a placeholder.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:summarize:d1220025cfc106a1e4faabe39d41c00dcece23f1677417556efa57850a7b1836:d1220025cfc106a1e4faabe39d41c00dcece23f1677417556efa57850a7b1836": "The function `summarize` is a method of the `Dummy` class that accepts a string `text`, a `prompt_type`, and an optional `system_prompt`. It appends a dictionary containing these parameters to the instance's `calls` list and returns the string `\"done\"`. The purpose of this method appears to be tracking or logging calls made to a summarization process, likely for debugging or monitoring purposes.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:test_cached_chunks_reused:a70b2d5abc4c3460d2097f8b2bb592333dcb1e5689504d81193da85b7b968df3:a70b2d5abc4c3460d2097f8b2bb592333dcb1e5689504d81193da85b7b968df3": "The function `test_cached_chunks_reused` tests the reuse of cached chunks during manual summarization. It creates a large text input composed of repeated paragraphs and uses a dummy client that tracks calls to a summarization method. The test verifies that when the same text is summarized twice with caching enabled, the first call makes three calls to the summarizer, while the second call with the same cache incurs no additional calls, demonstrating that cached results are properly reused. The test ensures that the `ResponseCache` correctly stores and retrieves previous summarization results to avoid redundant processing.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:test_chunk_edit_hook_applied:7e53f3039497a6590e5d8cdf3cb700904aa2359c879b4cb9abd2792df1ad4082:7e53f3039497a6590e5d8cdf3cb700904aa2359c879b4cb9abd2792df1ad4082": "The function `test_chunk_edit_hook_applied` tests the application of a chunk editing hook during manual text summarization. It creates two long paragraphs of repeated text, joins them with double newlines, and defines a dummy client class that tracks calls made to its `summarize` method. The `summarize` method appends call details to a list and returns either the first word of the input text or \"final\" when a specific system prompt is matched.\n\nA hook function is defined to convert all chunks to uppercase. This hook is passed to `_summarize_manual`, which processes the text with automatic chunking and applies the hook to the chunks before summarization. The test asserts that the final result equals \"final\", indicating the merge system prompt was used, and checks that the last call's text input was transformed to uppercase (\"AAA\\n\\nBBB\") by the hook.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:test_chunking_none_no_llm_calls:4d051d09245720ef05e7644d3f35b37c5494e65b6356b32f9bd72f4cc8abf70b:4d051d09245720ef05e7644d3f35b37c5494e65b6356b32f9bd72f4cc8abf70b": "The function `test_chunking_none_no_llm_calls` is a test case that verifies the behavior of the documentation generation process when chunking is set to \"none\" and no LLM calls are expected. It creates a large text file (`README.md`) with repeated content, patches the `LLMClient` to intercept LLM calls, and runs the main documentation generation process with the specified chunking option. The test asserts that exactly five LLM calls are made and checks that the first call's system prompt contains the word \"Overview\".",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:test_chunking_triggers_multiple_calls_and_logs:51dabb5b21acf7871f436501766afffd87ae0c523354c019306ceb148ba61825:51dabb5b21acf7871f436501766afffd87ae0c523354c019306ceb148ba61825": "This function tests the behavior of manual summarization with automatic chunking, verifying that multiple calls are made to a dummy language model client and that appropriate system prompts are used. It checks that the text is split into chunks, each processed with a chunk system prompt, and then merged using a merge system prompt. The test also ensures that log output includes messages about chunking and merging. The function uses a mock client to simulate LLM interactions and verifies the structure of calls and final output.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:test_collect_docs_filters:4d25545e70b1dc986e9cf917154e0deae4d6139cf73913637f147b0074232931:4d25545e70b1dc986e9cf917154e0deae4d6139cf73913637f147b0074232931": "The function `test_collect_docs_filters` tests the `explaincode.collect_docs` utility by creating a temporary directory structure with multiple files of different extensions. It verifies that `collect_docs` correctly identifies and returns only files with the `.md` extension, excluding those with other extensions such as `.txt`. The test confirms that the function filters files based on their extensions, ensuring that only Markdown files are included in the returned list.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:test_custom_output_directory:efc6c430633579051db23b75a763681673b95df573c0c929727281105821bfdd:efc6c430633579051db23b75a763681673b95df573c0c929727281105821bfdd": "The function `test_custom_output_directory` tests the functionality of specifying a custom output directory for documentation generation. It creates a temporary test environment using `_create_fixture`, sets up a target output directory within the temporary path, and mocks the `LLMClient` class from the `explaincode` module with a placeholder implementation `_mock_llm_client`. The main documentation generation process is invoked with command-line arguments specifying the source path and output path. The test verifies that the expected output files, namely `user_manual.html` and `user_manual_evidence.json`, are created in the specified custom output directory.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:test_custom_title_and_filename:18f38b77657cacbbef2d98a96be3c1930e1229a24d46b12a2112284e64047c80:18f38b77657cacbbef2d98a96be3c1930e1229a24d46b12a2112284e64047c80": "The function `test_custom_title_and_filename` tests the generation of an HTML documentation file with a custom title and filename. It creates a temporary test fixture, mocks the LLM client, and invokes the main documentation generation process with a specified title. The test verifies that the output HTML file and an associated evidence JSON file are created, and that the HTML file contains the expected custom title within an `<h1>` heading element.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:test_detect_placeholders:1eb6b9853e8a2e3062946352fdc11be67526189423f74178d1e1a6870e6701c4:1eb6b9853e8a2e3062946352fdc11be67526189423f74178d1e1a6870e6701c4": "The function `test_detect_placeholders` tests the `detect_placeholders` function from the `explaincode` module. It verifies that the function correctly identifies placeholder strings in a given text, specifically `\"[[NEEDS_OVERVIEW]]\"` and `\"[[NEEDS_OUTPUTS]]\"`, and returns a set containing the corresponding placeholder names, `\"Overview\"` and `\"Outputs\"`. The test ensures that the detection logic accurately extracts these placeholders from a formatted input string.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:test_docs_index_default_and_injection:3437dea2c31a31aa0bcdfd4271c9ad6bfdfa568c3f6e82e2fa8b2130bcf4c07a:3437dea2c31a31aa0bcdfd4271c9ad6bfdfa568c3f6e82e2fa8b2130bcf4c07a": "The function `test_docs_index_default_and_injection` tests the behavior of documentation generation when inserting a new entry into an existing index file. It creates a temporary directory structure with a fixture, sets up a mock LLM client, and runs the main documentation generation process with the `--insert-into-index` flag. The test verifies that the generated HTML documentation and evidence files are created, and checks that the navigation element in the index.html file correctly includes a link to the generated user manual.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:test_extract_snippets_skips_large_file:3bfa48dbcf8a2afb42c80d681e3c5553f2a50e4adee29db0c7eace49fb0c2b84:3bfa48dbcf8a2afb42c80d681e3c5553f2a50e4adee29db0c7eace49fb0c2b84": "The function `test_extract_snippets_skips_large_file` tests the behavior of the `explaincode.extract_snippets` function when processing a file that exceeds a specified size limit. It creates a large Python file filled with repeated bytes, then calls `extract_snippets` with parameters that restrict the maximum file size. The test verifies that the large file is excluded from the returned snippets and that an appropriate log message indicating the file size exceeded the limit is generated.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:test_extract_text_docx_preserves_headings:a7b0796e36149def08af45c4804f35b35f9d3bddd12367d29aceb619f5fbea97:a7b0796e36149def08af45c4804f35b35f9d3bddd12367d29aceb619f5fbea97": "The function `test_extract_text_docx_preserves_headings` tests the extraction of text from a `.docx` file while preserving heading formatting. It creates a Word document with a level 1 heading and a paragraph, saves it to a temporary path, and then uses `explaincode.extract_text` to extract the content. The test verifies that the extracted text has the heading formatted as a Markdown-style header (`# Title`) and that the paragraph text is present in the output. The test skips execution if the `python-docx` library is not installed.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:test_extract_text_html_preserves_headings_and_code:fc708913e43456db04155e342e01abb41987525a94c81c4defd70ea4979bc2fb:fc708913e43456db04155e342e01abb41987525a94c81c4defd70ea4979bc2fb": "",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:test_extract_text_markdown_preserves_headings_and_code:0c25a5fcfb381479938ceba76dcbe6609b064663e2ddeec3842eac626d564a0d:0c25a5fcfb381479938ceba76dcbe6609b064663e2ddeec3842eac626d564a0d": "The function `test_extract_text_markdown_preserves_headings_and_code` tests the functionality of extracting text from a Markdown file while preserving headings and code blocks. It creates a temporary Markdown file with a title, some text, and a Python code block. The test verifies that the extracted text contains the title, the code block marker, and the code content. The function uses `explaincode.extract_text` to perform the extraction and asserts the presence of specific strings in the output.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:test_force_code_flag_triggers_code_fallback:e1462cd5c9c5d61256ce5c01a0c7c3eaf6e151772647d7b3314fc4ba940f9246:e1462cd5c9c5d61256ce5c01a0c7c3eaf6e151772647d7b3314fc4ba940f9246": "This function tests that the `--force-code` flag triggers a code fallback mechanism during documentation generation. It sets up a temporary test environment, patches functions responsible for ranking code files and extracting snippets, and verifies that these functions are called exactly once when the flag is enabled. The test also confirms that appropriate log messages indicating the code scan trigger and pass completion are recorded. The function uses `pytest` fixtures for managing the temporary path, mocking behavior, and capturing logs.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:test_full_docs_no_code_scan:25dc6aa5e7fed3ae7fb6d5a41db52b0e529c2c28c14f31f52469d19aa2fe0417:25dc6aa5e7fed3ae7fb6d5a41db52b0e529c2c28c14f31f52469d19aa2fe0417": "This function tests the behavior of the documentation generation process when code scanning is explicitly disabled. It creates a temporary test directory with fixture files, then patches key functions in the `explaincode` module to simulate skipping file ranking and snippet extraction. The test verifies that these operations are not performed by checking that their respective counters remain at zero. It also confirms that the process logs \"DOC PASS\" and \"Code scan skipped\" messages, ensuring the correct execution path is taken when code scanning is disabled.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:test_graceful_missing_docx:3023ef08856cfe0a059924dac84aa88dd5ef52718aa79ae2636aa93afc92758b:3023ef08856cfe0a059924dac84aa88dd5ef52718aa79ae2636aa93afc92758b": "The function `test_graceful_missing_docx` tests the behavior of the documentation generation process when the `python-docx` library is unavailable. It creates a temporary directory fixture, simulates the absence of the `Document` class from `docx` by setting it to `None`, and mocks the `LLMClient` from the `explaincode` module. The function then invokes the main documentation generation entry point with the path set to the temporary directory. It asserts that the expected output files, `user_manual.html` and `user_manual_evidence.json`, are created in the directory, ensuring the process handles missing dependencies gracefully.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:test_hierarchical_merge_logged:37bb6f1ce8f9e7fa170074d6361d5899df453510bd841db34184a219a74cc469:37bb6f1ce8f9e7fa170074d6361d5899df453510bd841db34184a219a74cc469": "The function `test_hierarchical_merge_logged` tests the hierarchical merging behavior of a manual summarization process. It creates a large text input composed of repeated content, then uses a dummy client that tracks calls made during summarization. The test verifies that the summarization process results in a shortened output after multiple call iterations, and confirms that logging includes a message indicating a \"Hierarchical merge pass\" was performed. The test also ensures that the number of calls made by the dummy client exceeds three, validating the multi-step nature of the summarization logic. A response cache is utilized during the test to store intermediate results.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:test_html_summary_creation:0c89e326f9aa7b068da284553dd00b88db2a0d34240a6fa3df0ec6dcce792916:0c89e326f9aa7b068da284553dd00b88db2a0d34240a6fa3df0ec6dcce792916": "",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:test_infer_sections_infers_entries:2440868161015fad407202c5eb61e7af457191e91f2550f7f6bbceb44b6b8c99:2440868161015fad407202c5eb61e7af457191e91f2550f7f6bbceb44b6b8c99": "The function `test_infer_sections_infers_entries` tests the behavior of the `explaincode.infer_sections` function. It verifies that when given a context string, the function returns a dictionary of sections where:\n\n\nThis test ensures that the section inference logic correctly populates sections based on the input context and applies consistent formatting to inferred content.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:test_infer_sections_no_context_defaults:ce6e3344a72df77868ffa4825f182d996c6ae46dc8ed576ac1cb974087f136f0:ce6e3344a72df77868ffa4825f182d996c6ae46dc8ed576ac1cb974087f136f0": "The function `test_infer_sections_no_context_defaults` tests the behavior of the `explaincode.infer_sections` method when called with an empty string as input. It verifies that all values in the returned dictionary are set to the default message \"No information provided.\" This ensures consistent handling of empty or null input by the section inference logic.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:test_insert_into_index:f81d5717393bbb05403a49e04e4840d5551293ddf61d7f1976dd49a5c7770e2e:f81d5717393bbb05403a49e04e4840d5551293ddf61d7f1976dd49a5c7770e2e": "The function `test_insert_into_index` tests the functionality of inserting a link into an existing HTML index file during documentation generation. It creates a temporary directory structure with a fixture, sets up an output directory, and initializes an index.html file with basic HTML content. The test mocks the `LLMClient` to avoid actual LLM calls, then executes the main documentation generation process with the `--insert-into-index` flag. After execution, it reads the updated index file and asserts that a specific link (`<a href=\"user_manual.html\">User Manual</a>`) has been inserted into the HTML content.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:test_insert_into_root_index:ee23537c2ae0fb65b5aa6731a1bc1828efa5688ff7b59c120334e2693a0b12e7:ee23537c2ae0fb65b5aa6731a1bc1828efa5688ff7b59c120334e2693a0b12e7": "The function `test_insert_into_root_index` tests the functionality of inserting a generated documentation file into the root index of a project. It creates a temporary directory structure with a fixture, writes a basic HTML index file containing a navigation element, and mocks the `LLMClient` to simulate language model interactions. The test then runs the main documentation generation process with the `--insert-into-index` flag, which should generate a user manual and evidence files in a `docs` subdirectory. It verifies that these files are created and checks that the navigation element in the index HTML has been updated with a link to the generated manual file. The test ensures that the documentation generation process correctly integrates the new documentation into the existing index structure.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:test_llm_fill_placeholders_per_section_logging:c63bc3bcf5b7297112d87c5db896077d9d707e849f4e2555748f8105ae159daf:c63bc3bcf5b7297112d87c5db896077d9d707e849f4e2555748f8105ae159daf": "The function `test_llm_fill_placeholders_per_section_logging` tests the behavior of `explaincode.llm_fill_placeholders` by simulating an LLM client and verifying placeholder replacement and logging. It uses a dummy client that processes input text to identify section placeholders and replaces them with filled values. The test ensures that placeholders for \"Inputs\" and \"Outputs\" are correctly replaced and that corresponding log messages are generated indicating the source files used for each replacement. The function also verifies that the LLM client is called twice, once for each section.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:test_llm_generate_manual_sanitizes_and_caches:edc2e1f25e691afb8a305f380e8b94a1c1ac347c6bf51f40da8be02caef58142:edc2e1f25e691afb8a305f380e8b94a1c1ac347c6bf51f40da8be02caef58142": "The function `test_llm_generate_manual_sanitizes_and_caches` tests the behavior of the `llm_generate_manual` function in the `explaincode` module. It verifies that the output from the language model is sanitized to remove specific prompt-related text and that the results are properly cached.\n\nThe test:\n\nThis test ensures that the LLM output is sanitized and that caching works correctly for manual documentation generation.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:test_map_evidence_overview_priority_and_filters:c6acb71ad91cb97ca18e4024597ad2bd26a13e2c8578dd0666dc86c1b32fffc0:c6acb71ad91cb97ca18e4024597ad2bd26a13e2c8578dd0666dc86c1b32fffc0": "The function `test_map_evidence_overview_priority_and_filters` tests the behavior of `explaincode.map_evidence_to_sections` by evaluating how it processes a set of documentation files and organizes them under the \"Overview\" section. It verifies that certain files, specifically those located in `tests/`, `examples/`, and `fixtures/` directories, are excluded from the results, while files in `README.md`, `docs/guide.md`, and `src/other.md` are included. The test ensures that the priority of inclusion is maintained, with `README.md` and `docs/guide.md` appearing first in the list of sources, followed by `src/other.md`. The function does not return any value but asserts the expected filtering and ordering behavior of the mapping process.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:test_map_evidence_snippet_limits:b1f84b078f8fb3b8e1dc4354d3860a14bdd739f7f54fe9e8d3cfe1a9a0c3c43c:b1f84b078f8fb3b8e1dc4354d3860a14bdd739f7f54fe9e8d3cfe1a9a0c3c43c": "The function `test_map_evidence_snippet_limits` tests the behavior of the `map_evidence_to_sections` function when processing documentation content that exceeds a maximum line limit for snippets. It creates two mock documentation files (`src/long.md` and `tests/short.md`) with content containing more lines than the defined maximum (`explaincode.MAX_SNIPPET_LINES`). The test verifies that:\n\n2. The last line within the allowed limit is included in the snippet for `src/long.md`.\n3. The snippet for `tests/short.md` is correctly truncated to only the initial section header (`# Inputs`).\n\nThis ensures that the function properly enforces the maximum snippet line limit when mapping evidence to sections.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:test_missing_run_triggers_code_fallback_with_limits:3aec55c8a1542f7bbb35a5faecbe606dac843911697df2a6cc0a190cd1b21d3b:3aec55c8a1542f7bbb35a5faecbe606dac843911697df2a6cc0a190cd1b21d3b": "This function tests the behavior of the documentation generator when run instructions are missing and code fallback is triggered, with specified limits on code files and time budget. It sets up a dummy language model that simulates summarization responses, patches file ranking and code extraction functions to track their calls and parameters, and executes the main documentation generation process with specific flags. The test verifies that the generated HTML does not contain unresolved placeholders, checks that the code extraction was invoked with correct parameters, confirms the expected number of files were scanned, and ensures relevant log messages are present indicating the fallback mechanism was activated.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:test_no_code_flag_skips_code_fallback:97a4c23f1432e041afe1e51022c0a4cdf1ce75d75b50833f132c7dd7138f455e:97a4c23f1432e041afe1e51022c0a4cdf1ce75d75b50833f132c7dd7138f455e": "The function `test_no_code_flag_skips_code_fallback` is a test case that verifies the behavior of the documentation generator when the `--no-code` flag is used. It ensures that code scanning and extraction are skipped under this condition.\n\nThe test:",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:test_parallel_chunk_summarization:ba6b1cb71df1ea418e3860eab13b5fb4a016332b78912765938c709845372c2c:ba6b1cb71df1ea418e3860eab13b5fb4a016332b78912765938c709845372c2c": "The function `test_parallel_chunk_summarization` tests the parallel chunk summarization functionality by creating a large text input composed of repeated paragraphs and simulating a slow LLM client. It verifies that the summarization process completes within a specified time threshold, ensuring that chunking and caching mechanisms operate efficiently in parallel. The test uses a mock client that introduces a delay for specific system prompts and measures the total execution time to confirm parallel processing behavior.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:test_parse_manual_infers_missing_sections:493989549c000b5193480da3c4dbdafac4e154dae6814aa37f1d72615f88d3a7:493989549c000b5193480da3c4dbdafac4e154dae6814aa37f1d72615f88d3a7": "The function `test_parse_manual_infers_missing_sections` tests the behavior of the `explaincode.parse_manual` function when processing a manually provided code overview. It verifies that the function correctly extracts the \"Overview\" section and infers the \"Inputs\" section by appending \"(inferred)\" to it, while ensuring that the placeholder text \"No information provided.\" does not appear in the inferred section. The test uses a stub client that returns a fixed response to simulate the behavior of a language model.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:test_pdf_summary_creation:97f1bee77d4d96ba1fc401bf590493d7b3968cebe6817fc5ebd158bc77adfbbf:97f1bee77d4d96ba1fc401bf590493d7b3968cebe6817fc5ebd158bc77adfbbf": "This function tests the creation of a PDF summary by verifying that the `reportlab` library is available, setting up a temporary directory with fixture data, mocking the LLM client, and executing the main documentation generation process with the PDF output format. It asserts that both the generated PDF file and an associated evidence JSON file are created in the specified output directory.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:test_rank_code_files_supports_cpp_h_java:c8c640f159451278b8cf9bb64c7d7bbc849c3cb3b93be3388e1ac5dba650ac5a:c8c640f159451278b8cf9bb64c7d7bbc849c3cb3b93be3388e1ac5dba650ac5a": "The function `test_rank_code_files_supports_cpp_h_java` tests the `rank_code_files` function from the `explaincode` module. It creates a temporary directory with multiple files of different types, including Python (.py), C++ source (.cpp), C++ header (.h), and Java (.java) files, as well as an ignored text file (.txt). The test calls `rank_code_files` on the temporary directory and verifies that the returned list of files includes the code files (main.py, lib.cpp, lib.h, Main.java) while excluding the non-code file (ignore.txt). The assertion confirms that the code files are present in the ranked output and that the text file is not included.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:test_render_html_includes_toc_and_sources_block:fdbfe3c482b5a376c187211ed8b71642043fc1d7a59d8b02e60341573d566bb7:fdbfe3c482b5a376c187211ed8b71642043fc1d7a59d8b02e60341573d566bb7": "The function `test_render_html_includes_toc_and_sources_block` tests the rendering of HTML output by the `explaincode.render_html` function. It verifies that the generated HTML includes a table of contents (TOC) with links to sections and source code blocks referencing the files used in the evidence. The test creates mock data for sections and their corresponding evidence, renders the HTML, parses it using BeautifulSoup, and asserts the presence of navigation links and source file references within the output.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:test_render_html_renders_markdown_headings_and_code:6f460e3837f0d4f831b900c3aa34599bb2b7b3eaeeeaea0ca1c6fea4c8ff1f3c:6f460e3837f0d4f831b900c3aa34599bb2b7b3eaeeeaea0ca1c6fea4c8ff1f3c": "The function `test_render_html_renders_markdown_headings_and_code` tests the rendering of HTML content generated by the `explaincode.render_html` function. It verifies that markdown headings and code blocks are correctly processed. The test creates a dictionary with a single section containing a markdown title and a Python code block. It then checks that the resulting HTML contains an `<h1>` element with the title \"Title\" and that the code block is rendered as a `<pre><code>` structure with the correct content.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:test_scan_code_categorizes_snippets:f193175eac812b03514471b7316a3ba0b6bb387b5e1433034ec862ee01d8093a:f193175eac812b03514471b7316a3ba0b6bb387b5e1433034ec862ee01d8093a": "The function `test_scan_code_categorizes_snippets` tests the `scan_code` function from the `explaincode` module. It creates three empty Python files in a temporary directory, patches several functions in `explaincode` to return predefined values, and then calls `scan_code` with specific categories and parameters. The test verifies that the output of `scan_code` correctly maps file paths to their respective snippet content based on the provided categories. Specifically, it checks that the \"Inputs\" category contains the snippet from the first file, \"Outputs\" from the second file, and \"How to Run\" from the third file.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:test_scan_code_skips_non_source_dirs:7363f2f2a1dc9580679cb2039fddb5ad6afdad629f42060bf79d77a3a40a3fc6:7363f2f2a1dc9580679cb2039fddb5ad6afdad629f42060bf79d77a3a40a3fc6": "The function `test_scan_code_skips_non_source_dirs` tests that the `scan_code` function correctly excludes non-source directories (such as `tests` and `examples`) when analyzing a project structure. It creates a temporary directory with source code in a `src` folder and test/example files in `tests` and `examples` folders, then verifies that only files from the `src` directory are included in the scan results under the \"How to Run\" category. The test uses `monkeypatch` to mock the `collect_docs` function and ensures that `scan_code` respects directory filtering based on the provided configuration.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:test_validate_manual_references_flags_missing:0ecf0fc740c58dc98c1891d2808c61e60d9e38e3728d348645fc01342ffc6f3b:0ecf0fc740c58dc98c1891d2808c61e60d9e38e3728d348645fc01342ffc6f3b": "The function `test_validate_manual_references_flags_missing` tests the behavior of `validate_manual_references` when processing manual references in documentation sections. It creates a temporary Python file (`exists.py`) with minimal content, defines a section containing references to both an existing file (`exists.py`) and a missing file (`missing.py`). The function then calls `validate_manual_references` to process these references, updating the section text and evidence dictionary. The test asserts that the existing file reference is preserved in the updated section, the missing file reference is appended with `[missing]`, and the evidence dictionary correctly records the missing reference. This validates the handling of missing file references during documentation generation.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_html_writer.py:ed039a0da27df295cd81a8ab2de805295849fc310d9e7141db11366b1d14bd1b:ed039a0da27df295cd81a8ab2de805295849fc310d9e7141db11366b1d14bd1b": "Module defines tests for HTML documentation generation functions. Tests cover index page creation with nested module structures, module page rendering including classes, functions, variables, and their documentation, subfunction and subclass handling, and syntax highlighting for C++ and Java code snippets. Test functions validate HTML output structure, content encoding, navigation links, code formatting, and proper display of documentation elements.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_html_writer.py:test_cpp_java_highlighting:f5dba7443a1adb6fcbbfc4721aa95690aae92d8a727ee819ecdc895f245d8885:f5dba7443a1adb6fcbbfc4721aa95690aae92d8a727ee819ecdc895f245d8885": "The function `test_cpp_java_highlighting` tests the highlighting functionality for C++ and Java code. It takes no parameters and returns no value. The function calls a `_highlight` function with sample C++ and Java code strings along with their respective language identifiers, then asserts that the resulting HTML output contains `<span` tags, indicating successful syntax highlighting.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_html_writer.py:test_subclass_rendering:d0f3ef368089235af61149b18816e1bb7a65c5f295518c958e93e9fb152da639:d0f3ef368089235af61149b18816e1bb7a65c5f295518c958e93e9fb152da639": "The function `test_subclass_rendering` tests the rendering of a subclass within a module's HTML documentation. It creates a mock module data structure containing a class `A` with a subclass `B`, which includes a method `m`. The test invokes `write_module_page` to generate an HTML file at the specified temporary path using this module data and a tree structure. It then reads the generated HTML content and asserts the presence of specific elements: the use of `<details>` tags, the class name \"Class: B\", the subclass summary \"B summary\", the method signature \"def m(self)\", and exactly one code block formatted with `<pre><code>`. This validates that the HTML output correctly represents the hierarchical structure and content of the subclass and its method.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_html_writer.py:test_subfunction_rendering:70c37a4a2abe313f5612625a74f6660b419f21239f0da7cbb54dc5404fa89bff:70c37a4a2abe313f5612625a74f6660b419f21239f0da7cbb54dc5404fa89bff": "The function `test_subfunction_rendering` tests the rendering of subfunctions within a module's HTML documentation. It creates a mock module structure containing an outer function with a nested inner function, then invokes `write_module_page` to generate HTML output. The test verifies that the generated HTML includes expected elements such as a details section, subfunction header, and summary text. It also checks that both the outer and inner function sources are properly highlighted with code blocks.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_html_writer.py:test_write_index:25721678b2eac3b91f2de8381f7b8dab2006aadf3a43d5ba3cb5f82c6ea706f6:25721678b2eac3b91f2de8381f7b8dab2006aadf3a43d5ba3cb5f82c6ea706f6": "The function `test_write_index` tests the `write_index` function by creating a mock directory structure and summary data, then verifying that the generated HTML index file contains expected content and formatting. It checks for proper escaping of special characters, correct inclusion of module links and details sections, and accurate placement of elements within the HTML output. The test ensures the index generation respects nested package structures and correctly formats project summaries and module descriptions.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_html_writer.py:test_write_module_page:608a5c185f755549b8015c560ef96ee305d0c342eb443c406c217a37ef3a9d27:608a5c185f755549b8015c560ef96ee305d0c342eb443c406c217a37ef3a9d27": "The function `test_write_module_page` tests the generation of an HTML module page by verifying that the output contains expected content and formatting. It creates a mock module data structure and a file tree, then calls `write_module_page` to generate an HTML file at a temporary path. The test checks for specific HTML elements and content within the generated file, including proper escaping of special characters, presence of links, section headers, and code blocks. The assertions confirm that the generated HTML includes correct module summaries, class and method information, variable details, and formatting such as preformatted code blocks.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_integration.py:7610cd2fce0cd37892fc17f69cefa5dc0c0897e6aab60df5a0bd194234f19d04:7610cd2fce0cd37892fc17f69cefa5dc0c0897e6aab60df5a0bd194234f19d04": "Module defines tests for the `docgenerator` tool, verifying HTML generation from code files in multiple languages including Python, MATLAB, C++, and Java. Tests check that output HTML files are created with expected content and that static assets like CSS are copied correctly regardless of current working directory. The tests mock an LLM client to simulate documentation generation without external dependencies.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_integration.py:test_docgenerator_generates_html:f2da5083e0f792c2708ca445da01269c2128c22862fed49c51911ebfca1b6112:f2da5083e0f792c2708ca445da01269c2128c22862fed49c51911ebfca1b6112": "This function tests the HTML documentation generation capability of the DocGen-LM tool. It creates a temporary project directory containing sample source files in Python, MATLAB, C++, and Java, then invokes the main documentation generation function with mocked LLM client behavior. The test verifies that the tool successfully generates HTML output files for each source file, ensuring that the generated content includes the expected summary text from the mocked language model. The test confirms the tool's ability to process multiple programming languages and produce structured HTML documentation with embedded summaries.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_integration.py:test_static_copied_from_any_cwd:61532a443ebf8a55c078b28ba49119b91f1eb14eb0b0f01908874fb180d781a1:61532a443ebf8a55c078b28ba49119b91f1eb14eb0b0f01908874fb180d781a1": "The function `test_static_copied_from_any_cwd` is a test case that verifies the copying of static assets, specifically `style.css`, to the output directory regardless of the current working directory. It creates a temporary project structure with a Python module, sets up a mock LLM client to simulate successful ping and summarize operations, changes the working directory to the temporary path, and executes the main documentation generation function with specified input and output paths. The test confirms that the `style.css` file is present in the expected location within the output directory after execution.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_llm_client.py:82628573795fc440ac97b2cf7aa97bb506079f91432da86bdb370078b9e5cc90:82628573795fc440ac97b2cf7aa97bb506079f91432da86bdb370078b9e5cc90": "Module defines tests for an LLM client that interacts with a remote API to summarize code. Tests cover successful and failed ping operations, retry behavior during summarization, error handling for HTTP errors, and filtering of summary text. It verifies correct prompt template usage based on entity type and ensures proper sanitization of output. The module uses mocking to isolate the client logic from external dependencies.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_llm_client.py:test_ping_failure:04ba41e7cd0a61995026b900bf2a7db309c4d914438fc13e5e346dde0a1a0151:04ba41e7cd0a61995026b900bf2a7db309c4d914438fc13e5e346dde0a1a0151": "The function `test_ping_failure` tests the behavior of the `ping` method in the `LLMClient` class when a connection fails. It creates an `LLMClient` instance with a fake URL, patches the `requests.get` function to raise a `RequestException`, and asserts that calling `client.ping()` raises a `ConnectionError`.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_llm_client.py:test_ping_success:6b0f7e575090f4456697201bed9931613cb121024708b5c6c9c570592d81530a:6b0f7e575090f4456697201bed9931613cb121024708b5c6c9c570592d81530a": "The function `test_ping_success` tests the `ping` method of the `LLMClient` class to verify successful connectivity. It creates a mocked HTTP client configured with a fake URL, sets up a mock response object that simulates a successful HTTP request, and patches the `requests.get` function to return this mock response. The test asserts that the `ping` method returns `True`, confirms that `requests.get` was called exactly once with the correct URL and a 2-second timeout, and verifies that `raise_for_status` was invoked on the mock response. This ensures the client correctly handles successful HTTP responses during connectivity checks.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_llm_client.py:test_prompt_varies_by_type:9fbb1854382daca0a42b7ca593cfa86c3b5294f5b140cbf2ab3c33a1ba6f4dac:9fbb1854382daca0a42b7ca593cfa86c3b5294f5b140cbf2ab3c33a1ba6f4dac": "The function `test_prompt_varies_by_type` tests that the prompt template used by the `LLMClient` varies depending on the type of code element being summarized. It creates a mock LLM client and verifies that when summarizing with types \"class\" and \"function\", the respective prompts are correctly formatted using `PROMPT_TEMPLATES` and that the class and function prompts are distinct. The test patches the HTTP post request to simulate API responses and checks the content of the second message in the JSON payload sent to the LLM, ensuring it matches the expected template for each element type.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_llm_client.py:test_readme_prompt_template_used:e7ba5432f3f10c6639ef00e3b4312e4b0d462972dd9e99486c73b353d81a7956:e7ba5432f3f10c6639ef00e3b4312e4b0d462972dd9e99486c73b353d81a7956": "The function `test_readme_prompt_template_used` tests that the correct prompt template is applied when summarizing text for a README file using an `LLMClient`. It creates a mock LLM client, simulates an API response, and verifies that the second message in the JSON payload sent to the client uses the `readme` prompt template formatted with the input text. The test ensures proper integration of the prompt template with the summarization process.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_llm_client.py:test_sanitize_summary_filters_ai_language_model:76f83d29b21058a171b6d40e683a37bb2423a1ac43e83511051659996fae7b34:76f83d29b21058a171b6d40e683a37bb2423a1ac43e83511051659996fae7b34": "",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_llm_client.py:test_sanitize_summary_filters_altered_prompt_line:765eff83cd038da43af1f7762c8bd06ca286c2573ae653f2c780414b67efae0c:765eff83cd038da43af1f7762c8bd06ca286c2573ae653f2c780414b67efae0c": "",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_llm_client.py:test_sanitize_summary_filters_phrases:170cb82f29cd95e0aa6e5d83ce85a87a1784de5eb73903dd689ea247c64fb879:170cb82f29cd95e0aa6e5d83ce85a87a1784de5eb73903dd689ea247c64fb879": "",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_llm_client.py:test_sanitize_summary_filters_truncated_prompt_line:10207b8425c8611348cb1fc7636b45ad5970cef9e8c0bccf6f6d66de1ff0ea85:10207b8425c8611348cb1fc7636b45ad5970cef9e8c0bccf6f6d66de1ff0ea85": "The function `test_sanitize_summary_filters_truncated_prompt_line` tests the `sanitize_summary` function to ensure it removes a specific prompt line from the input text. The test provides a string containing two lines: a prompt line \"Do not say what is or isn't included in the code\" and a content line \"Defines a class.\" The assertion verifies that `sanitize_summary` returns only the content line, filtering out the prompt.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_llm_client.py:test_sanitize_summary_removes_fim_tokens:85bba61aaecb30810c244374dd70f79f6ddba4cd7089fc1c5e57a20ebb606bfa:85bba61aaecb30810c244374dd70f79f6ddba4cd7089fc1c5e57a20ebb606bfa": "The function `test_sanitize_summary_removes_fim_tokens` tests that the `sanitize_summary` function removes FIM (Fix, Insert, Modify) reserved tokens from input text to prevent tokenizer errors. It asserts that when given the input string \"Defines \u3008fim_prefix\u3009a class.\", the output is \"Defines a class.\".",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_llm_client.py:test_sanitize_summary_removes_prompt_lines:529359085f4e7ff6d7b0d6f60270dc65fd899b2f6f029a1c859383d045c1998a:529359085f4e7ff6d7b0d6f60270dc65fd899b2f6f029a1c859383d045c1998a": "The function `test_sanitize_summary_removes_prompt_lines` tests the `sanitize_summary` function to ensure it removes prompt-related lines from input text. The test provides a string containing multiple lines, including instructions and prompts, and asserts that the output of `sanitize_summary` contains only the line \"Defines a class.\" This demonstrates that the function correctly filters out lines beginning with \"- Do not\" or similar prompt directives, retaining only the core content.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_llm_client.py:test_summarize_does_not_stream_on_http_error:08f20f4a0a095b127db347d369cc97c7b60d5fe6336068ea0ef4ea34ff6821e3:08f20f4a0a095b127db347d369cc97c7b60d5fe6336068ea0ef4ea34ff6821e3": "The function `test_summarize_does_not_stream_on_http_error` tests that the `summarize` method of the `LLMClient` class does not attempt to stream a response when an HTTP error occurs. It creates a mock `LLMClient` instance with a fake URL, configures a mock HTTP response to raise an `HTTPError` and return a text body, and patches the `requests.post` call to return this mock response. The test verifies that calling `client.summarize` raises a `RuntimeError` with the expected error message and ensures that `iter_content` is not called on the mock response, confirming no streaming occurs during HTTP failures.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_llm_client.py:test_summarize_raises_runtime_error_with_message:d920e7dd7a99dffa43619a60a471f059fbd6ad4096bc85f562d4a6ad59595925:d920e7dd7a99dffa43619a60a471f059fbd6ad4096bc85f562d4a6ad59595925": "The function `test_summarize_raises_runtime_error_with_message` tests the behavior of the `summarize` method in the `LLMClient` class when an HTTP error occurs during a request. It creates a mock HTTP response that simulates an error condition, including a non-success status code and a text message indicating \"server exploded\". The test patches the `requests.post` call to return this mock response and also patches `time.sleep` to avoid delays during the test. It then asserts that calling `client.summarize` with dummy arguments raises a `RuntimeError` with the expected error message \"server exploded\".",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_llm_client.py:test_summarize_retries_and_returns_summary:77640a5697d15b526270e8a543f91f76b2b8ba43e7b02e1f833e9faef7054049:77640a5697d15b526270e8a543f91f76b2b8ba43e7b02e1f833e9faef7054049": "The function `test_summarize_retries_and_returns_summary` tests the retry mechanism and response handling of the `summarize` method in the `LLMClient` class. It creates a mock HTTP client that simulates a failed request followed by a successful one. The test verifies that the client correctly retries the request, extracts the summary from the response, and ensures the prompt is properly formatted. The test checks that the method returns the expected summary text, that the request was made twice due to the retry, and that a sleep delay of 1 second occurs between attempts. It also confirms that the prompt sent to the LLM matches the expected template for the module summarization task.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_manual_utils.py:_count:5f8254c0d713cdf755a537c085ee566dc25a4fb0c4cd057feb83e7d78005b376:5f8254c0d713cdf755a537c085ee566dc25a4fb0c4cd057feb83e7d78005b376": "The function `_count` takes a string input `text` and returns the number of tokens in the string by encoding it using `manual_utils.TOKENIZER` and calculating the length of the resulting token sequence.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_manual_utils.py:b152f93e4ae2356d36a0553ec3d878edb1db688524cfd71c19fb6ea54af90bc5:b152f93e4ae2356d36a0553ec3d878edb1db688524cfd71c19fb6ea54af90bc5": "Module defines tests for document chunking and placeholder finding functionality. Includes a helper function that counts tokens in text using a tokenizer, and two test functions that verify chunking respects token limits and that placeholder detection correctly identifies specific patterns in text.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_manual_utils.py:test_chunk_docs_respects_token_limit:0616f70f4c18b75e848edea85010cd2fe93d8bff761bcccb680e780f22ad9265:0616f70f4c18b75e848edea85010cd2fe93d8bff761bcccb680e780f22ad9265": "The function `test_chunk_docs_respects_token_limit` tests the behavior of the `chunk_docs` utility function from the `manual_utils` module. It verifies that when a list of document strings is chunked with a specified token limit of 2000, the resulting chunks respect this limit. The test creates three document strings, each consisting of repeated words, and passes them to `chunk_docs`. It asserts that the number of chunks produced equals the number of input documents and that each chunk contains no more than 2000 tokens.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_manual_utils.py:test_find_placeholders:2a8e89c09bd4b6560e07fe57714cc558c0787014ff3f8b3ebbd8a122387781be:2a8e89c09bd4b6560e07fe57714cc558c0787014ff3f8b3ebbd8a122387781be": "The function `test_find_placeholders` tests the `find_placeholders` utility by asserting that it correctly identifies and returns a set of placeholder strings enclosed in double square brackets from a given input text. The test verifies that placeholders such as `[[NEEDS_OVERVIEW]]` and `[[FOO]]` are extracted from the string \"Intro [[NEEDS_OVERVIEW]] middle [[FOO]] end\".",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_parser_cpp.py:7bf655540a7446dfdc4c0a3d20712a34c8c0cefe70fdce7aa5e2197a6cc58f87:7bf655540a7446dfdc4c0a3d20712a34c8c0cefe70fdce7aa5e2197a6cc58f87": "Test function that validates parsing of C++ source code containing a namespace, function, and class with documentation comments. The test creates a temporary C++ file with documented code elements, parses it using `parse_cpp_file`, and verifies that the parsed output correctly extracts module documentation, namespace name, function details including name, docstring, and source code, and class details including name, docstring, member variables, and methods with their respective documentation and source code.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_parser_cpp.py:test_parse_cpp:893849a5dc5df184845fb8de821b35416fbb3a4901806f1c531af3b986395606:893849a5dc5df184845fb8de821b35416fbb3a4901806f1c531af3b986395606": "The function `test_parse_cpp` tests the parsing of a C++ source file by verifying that the `parse_cpp_file` function correctly extracts documentation strings, function details, class information, and member variables and methods. It creates a temporary C++ file with a namespace, function, and class containing docstrings, then asserts that the parsed output matches expected values for module comments, namespace, functions, classes, variables, and methods. The test checks for correct extraction of names, docstrings, and source code snippets from the parsed C++ file.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_parser_java.py:81c91b4467b1272b3aee2c23a686157de0d00112a71e34af42e7260d11e289fb:81c91b4467b1272b3aee2c23a686157de0d00112a71e34af42e7260d11e289fb": "Test function that validates parsing of a Java source file containing a package declaration, class definition with fields and methods, and associated documentation comments. The test checks extraction of module docstring, package name, class details including name and docstring, field information such as name, type, and source code, and method details including name and source code. Uses a temporary file to store test Java content and verifies parsed output against expected values.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_parser_java.py:test_parse_java:84d7c08c7bcfcd15f78a911660c32b55cdf8490ff224c75a23253b0eb04cb57b:84d7c08c7bcfcd15f78a911660c32b55cdf8490ff224c75a23253b0eb04cb57b": "The function `test_parse_java` tests the parsing of a Java source file to extract documentation strings, package information, class details, field declarations, and method signatures. It creates a temporary Java file with a package declaration, a class containing a field and a method, each with associated docstrings. The test verifies that the `parse_java_file` function correctly identifies and extracts the module docstring, package name, class name, class docstring, field details including name, type, and source code, and method details including name and source code. The test ensures accurate parsing of Java files for documentation generation purposes.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_parser_matlab.py:d371df41f01bfadecc63c5f1bddb7b77eb2309a17405bffe247ca4a3e17973bd:d371df41f01bfadecc63c5f1bddb7b77eb2309a17405bffe247ca4a3e17973bd": "Module defines tests for parsing MATLAB files. Includes test cases for parsing a simple MATLAB file with one function and header comments, and another test case for parsing a file containing multiple functions. Both tests use temporary files and validate parsed output structure including header text and function metadata such as names and argument lists. Uses `parse_matlab_file` function from `parser_matlab` module.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_parser_matlab.py:test_parse_multiple_functions:4afc2d912e02b3d9b5ffc242e39a5a398d7f3a8fa554fbd6492764bbde3eef60:4afc2d912e02b3d9b5ffc242e39a5a398d7f3a8fa554fbd6492764bbde3eef60": "The function `test_parse_multiple_functions` tests the parsing of multiple MATLAB functions from a file. It creates a temporary MATLAB file containing two functions, `compute` and `square`, with specified inputs and outputs. The test verifies that the parser correctly identifies the functions, their arguments, and that the header is empty. The assertion checks that exactly two functions are parsed, with the correct names and argument lists.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_parser_matlab.py:test_parse_simple_matlab:0b404d5afea04d51bc03d75da87cc0ae31a3c9682e5e35df551bced44a578f3b:0b404d5afea04d51bc03d75da87cc0ae31a3c9682e5e35df551bced44a578f3b": "The function `test_parse_simple_matlab` tests the parsing of a simple MATLAB file. It creates a temporary MATLAB file with a header comment and a function definition, then parses the file using `parse_matlab_file`. The test verifies that the parsed result contains the correct header text and that one function is identified with the correct name and argument list.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_parser_python.py:0656a74b22ae45e63880587901e7b10ae787467de6bd22083f6803af85bd3957:0656a74b22ae45e63880587901e7b10ae787467de6bd22083f6803af85bd3957": "Module defines test cases for parsing Python files using a `parse_python_file` function. Tests cover simple modules with functions and classes, including docstrings and signatures. Additional tests handle complex function signatures with positional-only, keyword-only, and variable arguments. Nested structures such as inner functions, nested classes, and classes defined inside methods are also tested. Each test validates specific aspects of the parsed output like names, signatures, docstrings, and source code inclusion.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_parser_python.py:test_class_inside_method:bff545c297df7d61e8d2319ff3c6ef32801bb86c1254af6d7d42bff1b0393022:bff545c297df7d61e8d2319ff3c6ef32801bb86c1254af6d7d42bff1b0393022": "The function `test_class_inside_method` tests the parsing of a Python file that contains a class defined inside a method of another class. It creates a temporary Python file with nested class definitions, parses the file using `parse_python_file`, and verifies that the parsed result correctly identifies the outer class `A`, its nested subclass `B`, and the method `m` within `B`. The test ensures that the parser accurately captures the hierarchical structure of nested classes and their methods.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_parser_python.py:test_deeply_nested_classes:24c32b744fb73eef573ebdab183fd49b365d07ba681f46a6e7aa97577d5471e8:24c32b744fb73eef573ebdab183fd49b365d07ba681f46a6e7aa97577d5471e8": "The function `test_deeply_nested_classes` tests the parsing of deeply nested class structures in a Python source file. It creates a temporary Python file containing a class `A` with nested classes `B` and `C`, where class `C` contains a method `inner`. The test parses this file using `parse_python_file`, then verifies that the parsed structure correctly represents the nested classes and their methods by asserting the names of the innermost class `C` and its method `inner`.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_parser_python.py:test_parse_complex_signature:f1eca78a72f23fd2214bd59a45c7e362ae38c423bb249f1b3e22c6fc3af626a8:f1eca78a72f23fd2214bd59a45c7e362ae38c423bb249f1b3e22c6fc3af626a8": "The function `test_parse_complex_signature` tests the parsing of a Python function signature that includes complex parameter types such as positional-only, keyword-only, default values, and arbitrary keyword arguments. It creates a temporary Python file with a defined function, parses the file using `parse_python_file`, and verifies that the parsed signature, docstring, and source code match expected values. The test ensures correct handling of function signatures with mixed parameter types and documentation extraction.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_parser_python.py:test_parse_nested_structures:9890ef8ccd304bdc3832b3d81fef4ff2bb6c3ae9ced897533779d3a4b1b8091e:9890ef8ccd304bdc3832b3d81fef4ff2bb6c3ae9ced897533779d3a4b1b8091e": "The function `test_parse_nested_structures` tests the parsing of nested Python structures, including nested functions and classes. It creates a temporary Python file with an outer function containing an inner function, and a class `A` containing a nested class `B` with a method. The test verifies that the parser correctly identifies and extracts these nested elements, checking the names and source code of the inner function, as well as the structure of the nested class and its method. The test ensures proper handling of function and class hierarchies during parsing.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_parser_python.py:test_parse_simple_module:fb13e5d1081c3d3f327e29cabb91d94077aa9b5a3034b098c28674aa24230ecd:fb13e5d1081c3d3f327e29cabb91d94077aa9b5a3034b098c28674aa24230ecd": "The function `test_parse_simple_module` tests the parsing of a simple Python module using the `parse_python_file` function. It creates a temporary Python file with a module docstring, a function `add`, and a class `Greeter` with a method `greet`. The test verifies that the parsed result correctly extracts:\n\n\nThe test ensures that all extracted elements match their expected values, confirming correct parsing of Python code structures.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_resume_progress.py:3378cf564c2528ac12231265bea97bb649e9510221272bb4eb3d44bdd0ec5d5d:3378cf564c2528ac12231265bea97bb649e9510221272bb4eb3d44bdd0ec5d5d": "Test function that verifies resume functionality of the documentation generator. Sets up a project with two Python modules and simulates a failure during caching of progress. After the failure, it checks that only the first module's progress is recorded in the cache. Then, it runs the generator again with resume flag, verifying that only the second module is processed and both HTML files are generated. The test confirms that the cache state is properly managed across failures and resumptions.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_resume_progress.py:crashing_set_progress:1c1adda047e9019cdbe222a6e8f5432f8eccb42f4eea4f4e23026989d79c72b5:1c1adda047e9019cdbe222a6e8f5432f8eccb42f4eea4f4e23026989d79c72b5": "The function `crashing_set_progress` overrides the behavior of `original_set_progress` by first calling it with the provided arguments `path` and `module_data`. It then increments a counter stored in the global dictionary `calls` under the key `\"count\"`. If this counter reaches the value 1, the function raises a `RuntimeError` with the message \"boom\". This implementation appears to be designed to simulate or induce an error on the first invocation while allowing subsequent calls to proceed normally.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_resume_progress.py:fake_rewrite_docstring:20fe2b1196d8e5edcf1f198b86799b25d12b61c3d21a7134340286960ecb2838:20fe2b1196d8e5edcf1f198b86799b25d12b61c3d21a7134340286960ecb2838": "The function `fake_rewrite_docstring` is defined to accept any number of positional and keyword arguments, but always returns `None`. It appears to be a placeholder or dummy implementation that does not perform any actual docstring rewriting functionality.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_resume_progress.py:fake_summarize_chunked:9d79aeb6579bb6287e13da6482f1c67ddd6968de08dc0e7e34121cb57bc4cdba:9d79aeb6579bb6287e13da6482f1c67ddd6968de08dc0e7e34121cb57bc4cdba": "The function `fake_summarize_chunked` is a placeholder implementation that takes parameters related to client configuration, caching, text processing, and summarization settings, but always returns the string \"summary\" regardless of the input. It appears to be used for testing or demonstration purposes where actual summarization logic is not required.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_resume_progress.py:fake_summarize_module:45943186f6271b9049f905072f0fe67f639a5fa2139dc5b00a85add3fe7c1acc:45943186f6271b9049f905072f0fe67f639a5fa2139dc5b00a85add3fe7c1acc": "The function `fake_summarize_module` is a placeholder implementation that simulates the behavior of a module summarization process. It takes several parameters including a client, cache, key prefix, module text, module name, tokenizer, maximum context tokens, and chunk token budget. The function extracts a path from the key prefix, appends it to a global list `module_calls`, and returns a static string \"summary\". This implementation does not perform actual summarization but serves as a mockup for testing or demonstration purposes.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_resume_progress.py:test_resume_progress:ec3683db5d129d4a2cd1b64dc920db4ebe13e4caa5863a8730d47567b9b32d14:ec3683db5d129d4a2cd1b64dc920db4ebe13e4caa5863a8730d47567b9b32d14": "The function `test_resume_progress` tests the resumption of documentation generation progress after a failure. It sets up a temporary project directory with two Python modules, then mocks several functions from the `docgenerator` module to simulate summarization and docstring rewriting. A `ResponseCache` method is also mocked to simulate a failure during progress saving after processing the first module. The test verifies that the first module's progress is saved in the cache and that the second module is processed upon resuming. It confirms that both modules are eventually documented and that the cache is cleared after successful completion.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_retrofit_sidebar.py:1bf15c5133a6a7aec0257f049acf91d95813b55f0aa675712737cb388b83a26e:1bf15c5133a6a7aec0257f049acf91d95813b55f0aa675712737cb388b83a26e": "The module defines tests for the `retrofit_sidebar` function and its associated `main` function. The tests verify that `retrofit_sidebar` correctly updates HTML documentation files by inserting a sidebar with links to Python source files and their submodules. It checks that the sidebar structure is built properly, with correct file paths and names. The tests also confirm that `main` exits with an error code and reports appropriate errors when the source or documentation directories are missing.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_retrofit_sidebar.py:test_main_missing_docs:d1e1387f212755fc1f36e875dab4083b17e4d00fb5e562e7fcb32d1bdc7b2a0d:d1e1387f212755fc1f36e875dab4083b17e4d00fb5e562e7fcb32d1bdc7b2a0d": "The function `test_main_missing_docs` tests the behavior of the `main` function when required documentation directories are missing. It creates a temporary source directory, sets up command-line arguments to point to non-existent documentation and source paths using `monkeypatch.setattr`, and asserts that `main()` returns 1 (indicating an error). It also captures stderr output and verifies that the error message contains \"docs directory\".",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_retrofit_sidebar.py:test_main_missing_source:73abce3cc88c62c6d32b33b8c10d18f9d380290220b38610839e77698d0b2280:73abce3cc88c62c6d32b33b8c10d18f9d380290220b38610839e77698d0b2280": "The function `test_main_missing_source` tests the behavior of the `main` function when a specified source directory is missing. It creates a temporary path with a documentation directory and a missing source directory, sets the command-line arguments to point to these directories using `monkeypatch.setattr`, and asserts that `main()` returns `1` (indicating an error). It then captures the error output using `capsys.readouterr().err` and verifies that the error message contains the phrase \"source directory\".",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_retrofit_sidebar.py:test_retrofit_sidebar:6991a89edce541a385900609a6b2aa3366f99e594a27ae68666f6f9b436408ac:6991a89edce541a385900609a6b2aa3366f99e594a27ae68666f6f9b436408ac": "The function `test_retrofit_sidebar` tests the `retrofit_sidebar` utility by creating a temporary directory structure with Python source files and an existing HTML documentation page. It verifies that the `retrofit_sidebar` function correctly updates the sidebar content in the HTML file with links to the Python modules and submodules, preserving the original main content. The test checks that module and package links are properly added to the sidebar's unordered list, ensuring correct navigation paths for the documented files.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_reviewer.py:_make_module:1201a062a7f986a519322e32d6b31bec31945680f5b80fafdf31f36c66aebcb4:1201a062a7f986a519322e32d6b31bec31945680f5b80fafdf31f36c66aebcb4": "The function `_make_module` creates a module documentation page at a specified temporary path. It constructs a data dictionary containing the module's name, summary, and empty lists for classes and functions. If methods are provided, it adds a class named \"Foo\" with those methods to the data. The function then writes the module page using `write_module_page`, which generates an HTML file based on the provided data and a predefined file structure. Finally, it returns the path to the generated HTML file for the module.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_reviewer.py:ee26fa5464fc70b28f10aacbe4841efa3653709226aabf0b93d13f159939e2db:ee26fa5464fc70b28f10aacbe4841efa3653709226aabf0b93d13f159939e2db": "Module defines tests for detecting specific phrases and issues in documentation files. Tests check for assistant phrasing, contradictions, and hallucinations using a reviewer tool. The module includes functions to generate HTML module pages and run the reviewer on specified paths. It verifies detection of problematic text patterns and ensures autofix functionality removes assistant phrasing from generated HTML.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_reviewer.py:test_assistant_phrasing_detected:68e86a7df5855efc0a82c50b2431856b690a479f88e9ebdc36b36729982e5bcd:68e86a7df5855efc0a82c50b2431856b690a479f88e9ebdc36b36729982e5bcd": "The function `test_assistant_phrasing_detected` tests whether the documentation generator detects assistant phrasing in the output. It creates a temporary Python module with a specific comment, runs the main documentation generation process on the module, captures the output, and asserts that the output contains both \"[ASSISTANT]\" and \"mod.html\". This verifies that the tool correctly identifies and processes assistant-generated text during documentation creation.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_reviewer.py:test_autofix_removes_phrasing:ae41ac58a0a970b352c68fabbb5f85d17ab02dd5e3f5f17cb989b0b29de1d6e1:ae41ac58a0a970b352c68fabbb5f85d17ab02dd5e3f5f17cb989b0b29de1d6e1": "The function `test_autofix_removes_phrasing` tests the removal of phrasing by the autofix feature. It creates an HTML documentation file containing the text \"You can call this.\" using a helper function `_make_module`, then runs the main documentation generation process with the `--autofix` flag. After processing, it reads the generated HTML content and asserts that the phrase \"You can\" has been removed from the output.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_reviewer.py:test_contradiction_detected:d004428717db0eeb3575676f43b8ec1a228f9d7328a316ee0b4dfaef06314e8c:d004428717db0eeb3575676f43b8ec1a228f9d7328a316ee0b4dfaef06314e8c": "The function `test_contradiction_detected` tests for the detection of a contradiction in documentation generation. It creates a module with a method named \"bar\" using `_make_module`, then invokes the `main` function with the path to the created module. After execution, it captures the output using `capsys.readouterr().out` and asserts that the string \"[CONTRADICTION]\" is present in the output, indicating that a contradiction was detected during the documentation generation process.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_reviewer.py:test_hallucination_detected:9b63220e9ee57234bcc4d2d31f960ec6fe8fc7685032642ad04fa4d54be15df3:9b63220e9ee57234bcc4d2d31f960ec6fe8fc7685032642ad04fa4d54be15df3": "The function `test_hallucination_detected` tests for the detection of hallucinations during documentation generation. It creates a temporary module with a specific description, runs the main documentation generation process on it, captures the output, and asserts that the string \"[HALLUCINATION]\" appears in the output. This indicates that the system correctly identifies potential hallucinations in the generated documentation.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_sanitize_docs.py:daf0cc4cb1542634a8ecb3a034b33efb1836feaeeec74e75b676987d2f6b2104:daf0cc4cb1542634a8ecb3a034b33efb1836feaeeec74e75b676987d2f6b2104": "Tests for the sanitize_docs utility that verify removal of AI disclaimers from HTML files in a directory. The tests check handling of paragraph elements, headings, and list items, ensuring disclaimer text is removed while preserving relevant content. Tests use temporary directories and validate the output after processing.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_sanitize_docs.py:test_sanitize_directory_handles_headings_and_list_items:5e3f2606069ff26cc1c627d1350300c58f9ee7d404dfa5957d9e99c9011537fd:5e3f2606069ff26cc1c627d1350300c58f9ee7d404dfa5957d9e99c9011537fd": "The function `test_sanitize_directory_handles_headings_and_list_items` tests the sanitization of HTML content within a temporary directory. It creates an HTML file with heading and list items containing text that should be sanitized, then invokes the main documentation generation process. The test verifies that specific phrases are removed from the output while preserving the sanitized content within the HTML tags.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_sanitize_docs.py:test_sanitize_directory_removes_ai_disclaimer:9a43ae076f28040aefd1bb140e4d2f63212a6deced029668f037cd5992c16cbf:9a43ae076f28040aefd1bb140e4d2f63212a6deced029668f037cd5992c16cbf": "The function `test_sanitize_directory_removes_ai_disclaimer` tests the removal of an AI disclaimer from HTML content during documentation generation. It creates a temporary HTML file containing text with an AI disclaimer, invokes the main documentation generation process, and verifies that the disclaimer is removed while preserving relevant content. The test ensures that the sanitization feature correctly filters out AI-generated disclaimers from the output documentation.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_scanner.py:9fb66b0d67a215b5195a4a239c0f088601d37be9f219b4e6b10e9a18e33b8b13:9fb66b0d67a215b5195a4a239c0f088601d37be9f219b4e6b10e9a18e33b8b13": "Module defines tests for a `scan_directory` function that identifies specific file types while ignoring designated folders. Tests verify behavior with ignored directories, mixed file extensions, Git folder exclusion, and support for C++, C++, and Java file types. Helper function `create_files` generates test files in specified paths. Tests use `tmp_path` fixture for temporary directories and assert expected file paths are returned.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_scanner.py:create_files:3e81d70154d4bc2ea5cb8eef4bb26dc88305aaad2db80abf7ed2c592e8a3fc66:3e81d70154d4bc2ea5cb8eef4bb26dc88305aaad2db80abf7ed2c592e8a3fc66": "The function `create_files` creates a list of files at a specified base directory path. It takes a base path and a list of relative file paths as input. For each relative path in the list, it constructs the full path by joining it with the base path, ensures the parent directories exist by creating them if necessary, and writes an empty text file at that location.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_scanner.py:test_scan_directory_ignore_folder:b5a2a7fed17838f9451d6da18f1893c51ea64780c9786c5dbc1e5635576eded4:b5a2a7fed17838f9451d6da18f1893c51ea64780c9786c5dbc1e5635576eded4": "The function `test_scan_directory_ignore_folder` tests the behavior of `scan_directory` by verifying that it correctly ignores specified folders during file traversal. It creates a temporary directory structure with files in the root and a subdirectory named \"ignore_me\", then calls `scan_directory` with the path to the temporary directory and a list containing \"ignore_me\" as the folder to ignore. The result is compared against an expected set of file paths that excludes those within the ignored folder, confirming that only files from the root and other subdirectories are returned.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_scanner.py:test_scan_directory_mixed_file_types:276a535dde2ce0fa9626a5012daab3f670b91c2ae6aec5f17643701ba19d2f17:276a535dde2ce0fa9626a5012daab3f670b91c2ae6aec5f17643701ba19d2f17": "The function `test_scan_directory_mixed_file_types` tests the `scan_directory` function by creating a temporary directory structure containing files of various types (Python, MATLAB, text, Markdown) in both root and nested directories. It then calls `scan_directory` to retrieve a list of file paths and asserts that the result matches an expected set of Python and MATLAB files, excluding text and Markdown files. The test verifies that `scan_directory` correctly identifies and returns only files with supported extensions (`.py` and `.m`) while ignoring others.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_scanner.py:test_scan_directory_skips_git_folder:ebe94ca862525450a39a6d42b16c2b763f1c2b6aa42c60b5017f900cd0eaea13:ebe94ca862525450a39a6d42b16c2b763f1c2b6aa42c60b5017f900cd0eaea13": "The function `test_scan_directory_skips_git_folder` tests the behavior of `scan_directory` to ensure it excludes files located within a `.git` folder. It creates a temporary directory structure containing a Python file in the root and additional Python files nested under `.git` and `.git/sub`. After calling `scan_directory` on the temporary path, it verifies that the path to `good.py` is present in the result and that no paths containing `.git` are included. This confirms that the scanning process correctly ignores Git-related directories.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_scanner.py:test_scan_directory_supports_cpp_h_java:3022596fa8bfbb2b4d79fb71e2b00fa99579948515059c9d57d5e7b37e74e431:3022596fa8bfbb2b4d79fb71e2b00fa99579948515059c9d57d5e7b37e74e431": "The function `test_scan_directory_supports_cpp_h_java` tests the `scan_directory` functionality to ensure it correctly identifies and returns paths of files with extensions `.cpp`, `.h`, and `.java` within a given directory and its subdirectories. It creates a temporary directory structure containing these file types along with other files (like `.txt`) that should be ignored. The test verifies that `scan_directory` returns only the expected paths for the supported file types, confirming proper filtering behavior.",
  "PROJECT:f6876f91ad9e64bfb86b9c836e5de2ac23255ffd739589ea4c99c74034ea5105:f6876f91ad9e64bfb86b9c836e5de2ac23255ffd739589ea4c99c74034ea5105": "This project generates documentation for codebases by analyzing source files and producing structured summaries. It supports multiple programming languages including Python, C++, Java, and MATLAB, using language-specific parsers to extract function and class definitions along with their comments. The system employs LLM-based summarization to create high-level overviews and detailed docstrings, with caching mechanisms to store intermediate results and avoid redundant processing. A graphical user interface allows users to configure paths and execute documentation generation tasks. The output is rendered into HTML pages with navigation structures, and includes utilities for reviewing generated content, sanitizing AI-generated text, and integrating documentation into existing projects.",
  "README:abc7b46bf1e1abf5d8dc9e32f23239bd1a52480863bbb7dd2329f0e1067ec767:abc7b46bf1e1abf5d8dc9e32f23239bd1a52480863bbb7dd2329f0e1067ec767": "DocGen-LM is a tool that generates static HTML documentation for Python, MATLAB, C++, and Java projects by analyzing source files and summarizing them with a local language model. It supports nested structures like functions and subclasses, rendering them as expandable sections in the output. The tool includes features such as automatic progress saving, resumable runs, and integration with LMStudio for local LLM access.\n\nThe documentation generator provides both command-line and graphical user interface options, allowing users to configure settings like output directories, ignored paths, and LLM parameters. It also offers utilities for sanitizing existing documentation, retrofitting sidebars, and generating project summaries with optional code fallback mechanisms.\n\nKey functionalities include token-based chunking for large inputs, automatic detection of supported languages, and flexible summarization modes that can handle various content sizes and structures. The system maintains cached progress to support interrupted runs and provides options for controlling code scanning behavior during documentation generation.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\cache.py:ResponseCache:6e8c2e42633f49496cea58dcadcff0afbb62d6b1782009c6150f015775dc1c55:9b5a313b238d9e9df6d7f1f8612c9fb584df39f70a688b080a30b119baa79c33": "The `ResponseCache` class provides a persistent cache for storing and retrieving LLM responses using stable keys derived from file paths and content hashes. It supports operations to get and set cached values, manage progress tracking for processed modules, and persist all data to a JSON file. The class ensures data integrity by loading existing cache files on initialization and saving changes automatically upon modification.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\cache.py:__init__:183aae9b51416ded7b5224de60556fe4218ff38e30ce6cf93a85a3fe20c33f95:c4d58b8535ada306aaf2a97ab106ba3b576593a2e321f214579a35d19d48934e": "Initializes the `ResponseCache` instance with a specified file path. Loads existing cache data from the file if it exists and is valid JSON; otherwise, initializes an empty cache. Ensures that a progress tracking dictionary (`__progress__`) exists within the cache data.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\cache.py:_save:ab8ead979cd453de51c019a42f621a8a75613ac2ee1fd7a2cc307cadf2be1000:f08335b43310a01da84f932656a859b59aeee08899925ed59f4935f7f2c2f09e": "The `_save` method in the `ResponseCache` class serializes the cached data stored in `self._data` to a JSON-formatted string with sorted keys and two-space indentation, then writes this string to a file specified by `self.file`. The file is encoded using UTF-8. This method persists the current state of the cache to disk.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\cache.py:clear_progress:69234139b54009ea5f1a2d790dadb60fe8413ac16cfdcce415aac8e9ae873efb:22f5c1683c22418cb5017a23c09cb473e291816a942a1193cab3752f31b77e84": "The `clear_progress` method removes all saved progress information by resetting the `__progress__` key in the internal data dictionary to an empty dictionary and then saving the updated cache state.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\cache.py:get:aa84d6be0051fd2bdb6970b1a12bfff7b12f7bfdc37171f76f32844e141044a1:a860f34471b6f403591e0e3740b30b123147a1eee1b271a5094fc15ffe8cae05": "The `get` method retrieves a cached value associated with the specified key from the internal data storage of the `ResponseCache` instance. If the key exists in the cache, the corresponding value is returned; otherwise, `None` is returned. This method provides access to stored response data using a string key.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\cache.py:get_progress:708abc297206b581a3e1cfdac65f1f6e4ee873923174d640d53e801bdbead1cb:31a8d000010ab148dffa1134e724aec27e9b5f44050750afea49d8c23fef9b9c": "The `get_progress` method retrieves and returns a shallow copy of the progress tracking data stored in the cache. The progress data maps processed module paths to their associated information. If no progress data exists, it returns an empty dictionary. This ensures that external code cannot inadvertently modify the internal progress state.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\cache.py:make_key:9a4226bd00e628842cafce80d7a8456cfdff26bb0df509aa76c4b4db2ea9b6fb:13752a4a49d9969b13fce88ff5820f5f0b4522bf812bab6720d7ef6ae43cd237": "The function `make_key` generates a deterministic cache key based on a file path and its content. It computes a SHA-256 hash of the content encoded in UTF-8 and combines it with the file path using a colon as a separator. The resulting string serves as a unique identifier for the file-content pair, ensuring consistent key generation for the same input.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\cache.py:set:4d18e1245ba239fa23d2f490e8ebd1fc5b4e39288b6d12567dd1b50f09dea5e0:2d3d2c77e79cae4fe72187d2c6a96decd07d2111268835e2ae7803ec56e6944a": "The `set` method stores a string value under a specified key in the cache and persists the updated cache data to disk. It updates the internal data dictionary with the new key-value pair and triggers a save operation to ensure the change is written to the persistent storage.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\cache.py:set_progress_entry:38be6f94846411fd50804722b916eba55b37b6b4b7ac2f6e037a8189f5e9a829:a0f32a07e8b549bb7bf58bcf91838223956767e54477d883936d846d6113f38c": "The function `set_progress_entry` records module data associated with a given file path in the progress tracking structure of the `ResponseCache` instance. It updates the internal data dictionary under the key `\"__progress__\"` by setting the value for the specified path to the provided module data. After updating the progress entry, it persists the changes to disk by calling the `_save()` method.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\chunk_utils.py:_split_blocks:006716a917fb0592a47fd963b1570232a8a3fa609b29d118ba2e76299947d314:1a296d05778138018414482442af6bda8df4552e2321aaff7ecf11398988c4e8": "",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\chunk_utils.py:_split_long_block:f024db4f3882cd3000d8cc51991e417e7e5f0af37a6f917a323d9440f75d68a6:805be32dcbf01cbfea4c38662b3f0dd1eabf92e16fa63be31416db31a57f4a15": "The function `_split_long_block` splits a text block into smaller chunks based on a token limit using a character-based approximation when the token count exceeds the specified chunk size. It encodes the input block using a provided tokenizer, calculates an average character length per token, and determines the maximum number of characters allowed per chunk. The block is then divided into segments of this maximum character length. If the token count is less than or equal to the chunk size, the original block is returned as a single-element list.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\chunk_utils.py:chunk_text:016fcc621f1f7486a71fd29f0a4441cfcdb7ca1cfaeed8e9b5ffa9835dc79459:14b009256b504ce6d9fc7fde828500bd4c7b9df5e55daca33d18b943a4ce3004": "The function `chunk_text` divides a given text into segments, where each segment contains approximately a specified number of tokens. It processes the text by first splitting it into logical blocks using `_split_blocks`, then iterates through these blocks to form chunks. If adding a block would exceed the token limit, the current chunk is finalized and added to the result list. Blocks that are larger than the token limit are further split using `_split_long_block`. The function ensures natural breakpoints like blank lines, Markdown headings, and code fences are respected when forming chunks.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\chunk_utils.py:decode:0363f10f7aa0f5eb8f9901c1ffa866325b0d1bca40b81ad761d3ece3577ea2ea:39d09c7c6e0ef8cf7df992dbe5fccc10af1880d357abcc1679dfe9fa8e6ec1f6": "The `decode` method takes a list of tokens as input and returns a single string by joining the tokens with spaces. It reconstructs the original text from its tokenized form.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\chunk_utils.py:encode:e159ff5ec458c7bf9e74456e7a205cd48cee6e4e33acba1d1fe092739155e780:1549fbbf0f7a13eb02a2acf37943763e3f093b1f0854e2973c42c0365218cd6a": "The `encode` function takes a string input, removes FIM tokens using the `strip_fim_tokens` utility, and splits the resulting string into a list of words based on whitespace.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\chunk_utils.py:get_tokenizer:43e185cfdb57c06f677c0cae09116c89e13eadabaa4d6d2c8765cc997f6a8681:a4d901e0a13a5708cad04a8f2d38645783bcf54235409263a0d15df1dd97eacb": "The function `get_tokenizer` returns a tokenizer object for estimating token counts. It attempts to use the `tiktoken` library to load the `cl100k_base` encoding, with fallback to `gpt-3.5-turbo` if the former fails. To prevent network-related warnings during testing, it temporarily suppresses unraisable hook errors. If `tiktoken` is unavailable or fails to load, it provides a simple fallback tokenizer that splits text by whitespace for encoding and joins tokens with spaces for decoding. A warning is printed to standard error if `tiktoken` cannot be used.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\chunk_utils.py:strip_fim_tokens:38d4e8c678573d4d054f524debbc22202bb9e7da344c951e676735315ba85994:0f06c5f2f53a03394c10c32b60695002d26c1373fdb0f5d3a2f60ed155e558e9": "The function `strip_fim_tokens` removes FIM (Fill-In-the-Middle) special tokens from a given string. It takes a string input and returns the string with all FIM tokens stripped out using a regular expression substitution. The regular expression pattern used for this purpose is stored in the global variable `FIM_RE`.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\docgenerator.py:_build_function_prompt:38e9a422536a264dc8b184e58d32a5362f6d96e5b56b6423364286c7792f237a:e124063a5d8ca7931de79b5771e30c2ce6dae7db7ff1ac9009564bc5364b44fe": "The function `_build_function_prompt` generates a context-enriched prompt for summarizing a given function's source code. It accepts the function's source code and optional class and project context details, then constructs a structured prompt string that includes information about the function's class, class summary, and project summary if provided. The prompt instructs the documentation generator to summarize the function based on its source code while adhering to specific formatting and content guidelines. The final prompt is returned as a single string with appropriate markdown formatting for code inclusion.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\docgenerator.py:_chunk_module_by_structure:f36945a40c75ccb3efb2e72382cd2bca2509fcb2e44bf6a1ecad8c8775c4f8b9:28c3f3f45331ad8a959f0c7a5c62f62f7768e4a33e856a73410a0e36df3262e2": "The function `_chunk_module_by_structure` takes a parsed module dictionary, a tokenizer, and a maximum chunk size in tokens. It organizes the module's content into text chunks that do not exceed the specified token limit. The function processes module-level docstrings, class definitions, methods, variables, and functions, constructing blocks of source code or documentation. For large blocks exceeding the token limit, it recursively splits them using a helper function `chunk_text`. It maintains a running total of tokens in the current chunk and appends completed chunks to the result list when adding a new block would exceed the limit. The output is a list of text chunks suitable for processing by a language model.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\docgenerator.py:_rewrite_docstring:d60f48c49931b752b35c74776faaf6b329d70a68f18915e16518cfd9d3d35258:4249a1353397da5e9172dc699e2c440c00dea9f3117c4da6d2ca7760b2d53ed6": "The function `_rewrite_docstring` updates the docstring of a given code item by generating a new docstring using a language model. It accepts an LLM client, cache, file path, and item dictionary containing source code and existing docstring. Optional context such as class name, class summary, and project summary can be provided to enhance the docstring generation.\n\nThe function first checks for the presence of source code or docstring; if neither exists, it issues a warning and exits. If only source code is present, it returns early without modifying the docstring. When context is provided, it constructs a prompt using `_build_function_prompt` and computes a cache key based on the item's name and content. Otherwise, it uses a default prompt format.\n\nThe function then calls `_summarize_chunked` to generate a new docstring via the LLM, using the computed prompt and cache key. The result is sanitized and assigned back to the `docstring` field of the input item. If no summary is generated, it defaults to \"No summary available.\"",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\docgenerator.py:_summarize_class_recursive:1e304688f5fd140c1e8e3d06c253cfaab88dfc60448ea52c4f566b9688ce61f7:db470155994a433d3491dfdcb45c3f19fcf3a285032dacd1af754fb383ce875c": "The function `_summarize_class_recursive` recursively summarizes a class by processing its members, methods, and variables, and then generates a docstring for the class and its components. It first processes all members of the class using `_summarize_members_recursive`. It constructs formatted text for methods and variables, including their summaries if available. Using a class prompt template, it generates a summary for the class by calling `_summarize_chunked`, which handles token budgeting and caching. The resulting summary is sanitized and stored in the class data. If an original docstring exists, it is preserved, and the function calls `_rewrite_docstring` to update the docstrings of the class, its methods, and its variables with the new summaries. Finally, it recursively processes any subclasses of the class.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\docgenerator.py:_summarize_function_recursive:a68581cc3828cf30fb71196f3267c23ae5e5d354817cbc1153c8e0fbc0c5b5b7:e110bf2c3df6875a654c6616d3dc4a316dc4761b278d4f62b111f3f6ff62627c": "The function `_summarize_function_recursive` recursively summarizes a given function and its nested components. It takes a function dictionary, path, LLM client, cache, tokenizer, and context limits as inputs. The function constructs a prompt using the function's source or signature, retrieves or generates a summary via `_summarize_chunked`, and optionally rewrites the docstring using `_rewrite_docstring`. It then recursively processes any subfunctions and subclasses within the function, applying the same summarization logic to each. The function modifies the input `func` dictionary in place by adding a \"summary\" key and potentially updating the docstring.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\docgenerator.py:_summarize_members_recursive:fd8505afa381fbcea493791e5d58706e04e356d99ae745dc40f384cc0acb2fa9:8654da784669578bf9785877f93635aba705d0bb141b67703be7b9d81e70ef6f": "The function `_summarize_members_recursive` recursively summarizes the methods and variables of a given class and its subclasses. For each method, it retrieves or constructs source code, generates a summary using a chunked summarization process, and assigns the summary as both the \"summary\" and \"docstring\" fields. It then performs a recursive function summarization on each method. Similarly, for each variable, it generates a summary and assigns it to the \"summary\" and \"docstring\" fields. The function also recursively processes any subclasses of the class, applying the same summarization steps. The summarization uses an LLM client, a response cache, and token budgeting to manage context length.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\docgenerator.py:_summarize_module_chunked:2600656a86f7220f986aa9ab35118c30f24517509969dc2595723fb17ac02caa:17dfe3e1942eafc94458643b05cd009b0aa981be5f86059db662d8259b0f0b05": "The function `_summarize_module_chunked` summarizes a module by using structure-aware chunking to handle large inputs within token limits. It first checks if the entire module text fits within the available token budget; if so, it summarizes directly. Otherwise, it splits the module into chunks based on its structure, summarizes each chunk, and then merges the partial summaries into a final summary. If structure-based chunking fails, it falls back to summarizing the full module text. The merging process recursively combines summaries to stay within token limits, using a prompt to guide the combination. In case of failures during summarization or merging, it returns sanitized summaries of partial results or an empty summary.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:Config:0b3ed3eff1c79c43fbe5d931fef9fce219dad2ae4a03975c80a50074ce4a92d9:594733ac4138c0c5ad11ce6e6840136f00c85e7c41a44ed0802b36201d93f5ba": "The `Config` class defines a configuration structure for managing settings derived from command-line arguments. It includes attributes for file paths, output formatting, title, and various flags controlling code processing behavior. The class uses type hints to specify the expected types for each configuration parameter.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:_edit_chunks_in_editor:96f6df95a8facb456beb1b709b079d60b2eb74b2a6f724aeea273005124bb88c:6e6e8831792ee7c780677eabf55517c04ad86f16645568a786e07b737b4c0bf8": "The function `_edit_chunks_in_editor` takes a list of strings (`chunks`) and opens them in a user's preferred text editor for modification. The chunks are joined with a separator line (`---`) and written to a temporary file. The user's editor is determined by environment variables `EDITOR` or `VISUAL`, defaulting to `vi` if neither is set. After the editor is closed, the modified content is read from the temporary file, split back into chunks using the separator, and returned as a list of non-empty, stripped strings. The temporary file is deleted after use.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:collect_docs:7e21c3289c00d5c19dc68797147efe87faa23444011f8bba8a01473e948d79af:590dd718371773127f7360206268fbc73af48ddcf2b2d1f646257506382f2ab5": "The function `collect_docs` gathers documentation files located under a specified base directory. It identifies files matching certain patterns in two locations: the project root and a `docs` subdirectory. Specifically, it includes files with extensions `.md`, `.txt`, `.html`, and `.docx` in the root, as well as all `.html` and `.md` files recursively under the `docs` directory. The function ensures that each file is only included once by tracking seen paths and returns a list of unique documentation file paths.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:collect_files:bbef7f461d0a643d85d963c4b7c14c1926c84a0f950cfd1cabfdc06d6b967dd4:a65905d3323d9312332bd48934ed51dcf691690e9b0acd73d96d522a31600955": "The function `collect_files` takes a base directory path and an optional list of additional file patterns, then returns a list of unique file paths within the base directory that match the specified patterns. It first defines a default set of file patterns including common documentation and data files, then collects all matching files using recursive globbing. If extra patterns are provided, those are also used to find additional files. The function ensures that each file path appears only once in the returned list by tracking seen paths.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:detect_placeholders:3702ea49b313d0f772979011482ec9b26bdf4f507f47f90eca21f0f79978e241:2c7b3d7808259f114d0d3baefe05fd63e74d2f7272735807608882d0849eb4a8": "The function `detect_placeholders` identifies and returns a list of section names from a given text that are still marked by placeholder tokens. It works by first calling `find_placeholders` to locate all placeholder tokens present in the input text, then filters these tokens against a predefined dictionary `SECTION_PLACEHOLDERS` to return only those section names associated with the found tokens.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:extract_snippets:5847af5df1bb76771c6be5c1eee7cd5f3f5937babdc55ed08a03204a6051a12b:7a6166e4507a06624e95d62abd95059cea965cf4fcd642ec29ff0a08bbd0706f": "The function `extract_snippets` processes an iterable of file paths to extract and summarize code snippets. It iterates through the files, respecting limits on the number of files, total time, and individual file sizes. For each file, it reads the content and parses Python files using the `ast` module to extract docstrings from modules, classes, and functions, as well as identify I/O signatures and CLI parser definitions. It also captures the `__main__` block in Python files. Non-Python files are included in their entirety. The extracted content is stored in a dictionary mapping file paths to their respective snippet strings. The function includes logging for tracking progress and reasons for skipping files, and it uses `tqdm` for progress indication during file scanning.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:extract_text:a1fb0ba487b2ab8ce3064da1cbda66bdaa7d62cf64d7376a8fc1ed9b474bba45:9f2cab5dbe76ac6dd25dd89c4e0ecec436c9a110e446f192cc3c2afa06eb124f": "The function `extract_text` reads and extracts plain text from a file located at the specified path, handling different file types based on their suffix. For HTML files, it parses the content using BeautifulSoup, converts headings to Markdown-style headers, wraps code blocks in triple backticks, and returns the cleaned text. For Markdown files (`.md`), it directly returns the file's content. For Word documents (`.docx`), it extracts paragraphs, converts heading styles to Markdown headers, and appends regular text lines. For all other file types, it reads the file as plain text. If any error occurs during processing, it returns an empty string.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:infer_sections:c1651515bc9b237394716f1b8bd5bb2f628b364815c924eb1cf0fd7300238a7f:bddca2c6344757c3851325c1fd202bc6a97e11a3ef0365131c9e03e171230170": "The function `infer_sections` takes a string input `text` and returns a dictionary mapping section names to their corresponding content. If the input text is non-empty, it assigns the text to the \"Overview\" section and populates the remaining required sections with placeholder content indicating that the details were inferred. If the input text is empty, all required sections are assigned a message stating that no information is provided. The function uses a global constant `REQUIRED_SECTIONS` to determine which sections to include in the output dictionary.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:inject_user_manual:e0b24bb17b17a1acb3905e182d839a189b59fd85e1032b3f4c8cccdced25b3ce:c989b3887a39d15d9b0f24e6d975db262d1fa4d162b28cd9df45617dc2501726": "The function `inject_user_manual` inserts a hyperlink to a user manual into an HTML file specified by `index_path`. The link, with the text defined by `title` and pointing to `filename`, is added as the first item in the first navigation element (`<nav>` or `<ul>`) found in the document. If no such elements exist, the link is inserted at the beginning of the first element within the `<body>` tag or the document root. The function uses BeautifulSoup to parse and modify the HTML content, and it handles potential read errors by silently returning on exception.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:insert_into_index:4c7e7684e35f7fc81111717b1c1e072e0b85c825205d3055b80b2bad4d455d62:9fd0e0e677c8dff8c21089d3ae23dc39493be24b14291f63cd3f4d2f853ccd1c": "The function `insert_into_index` appends a navigation link to an HTML file. It takes the path to an index file, a title for the link, and the filename to link to. The function reads the HTML content of the index file, parses it using BeautifulSoup, and finds either a `<ul>` or `<nav>` element to insert the new link into. If a link with the same `href` already exists, it does nothing. Otherwise, it creates a new `<a>` tag with the provided title and filename, wraps it in a `<li>` tag if the container is a `<ul>`, and appends it to the container. Finally, it writes the modified HTML back to the index file. If any error occurs during parsing or writing, the function silently returns without making changes.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:llm_fill_placeholders:bedb588352ebacd1b376e59d6c29a85d3a311756675883be5965e8c26fd839c4:ba726c6dbcc2eea6bada8d961e7d4d6df8340f3c3b43226e30751373d03ce291": "The function `llm_fill_placeholders` updates a manual text by replacing placeholders with relevant code snippets using an LLM. It takes a manual text, a dictionary of code snippets organized by section, and LLM client and cache objects. For each section, it constructs a prompt that includes the manual text and code snippets, then uses `summarize_chunked` to process the input within token limits. If the combined token count exceeds the maximum context size, it first summarizes the code snippets before incorporating them into the final prompt. The result is an updated manual text with placeholders filled based on the provided code evidence.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:llm_generate_manual:d03d4e3089999a3380fb9a5383cee034b6192213eb9c5ddc248ef1b842bdba3c:1c59c1c5ae17732fabe4df7db69aa406fb43fecdb809658f28b4fd4de91a4c06": "The function `llm_generate_manual` generates a user manual from provided documentation snippets by mapping them to predefined sections, performing LLM-based summarization per section, and assembling the final manual text. It takes a dictionary of documentation snippets indexed by path, an LLM client for generating summaries, a response cache for storing and retrieving prior results, and an optional chunking strategy.\n\nThe function first maps evidence snippets to manual sections using `map_evidence_to_sections`. For each required section, it checks if there are entries; if not, it uses a placeholder. If entries exist, it constructs a prompt from the snippets and sends it to the LLM with a system prompt that restricts responses to only the provided information.\n\nFor large prompts exceeding token limits, it uses `summarize_chunked` to process the content in chunks. Smaller prompts are either retrieved from or stored in the cache before being processed by the LLM. The output of each section is parsed and sanitized, with placeholders replaced if necessary. The function returns the assembled manual text, a mapping of source files to sections they contributed to, and an evidence map indicating which snippets were used for each section.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:map_evidence_to_sections:5fa346d6b8346abeab764a109054fc6d1843a2473f8fd8bb94f631068cd55e2e:996a48fe0d4205c6ad5bda667ae16186594dd7f60c6a82c15963cb39feb94f1d": "The function `map_evidence_to_sections` maps documentation snippets from source files to predefined manual sections based on keyword matching. It takes a dictionary of file paths to their content and returns a tuple containing:\n\n1. A mapping (`section_map`) from section names to lists of tuples, where each tuple consists of a file path and a snippet of text belonging to that section.\n2. A mapping (`file_map`) from each file path to the set of sections it contributed to.\n\nThe function processes each source file, skipping directories named \"tests\", \"examples\", or \"fixtures\". For each line in a file, it checks if any section keyword is present. If found, it collects a snippet of code or documentation following that line up to a specified maximum number of lines (`MAX_SNIPPET_LINES`), excluding empty lines and lines starting with `#` or HTML heading tags.\n\nOnly the top 10 snippets per section are retained, sorted by relevance:\n\nThe function ensures that snippets from excluded directories are not included in the \"Overview\" section.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:parse_manual:9dd17fb2d807ebc9c4cda30de2a7682a4556b31030689ae0e67c4be9afb8ce0f:cbe2fcd05b6ee4f8355466bb6c77f20762318b235134ea2cc0d48ddeadde6738": "The function `parse_manual` takes a string input `text` and an optional language model client, and parses the text into structured sections based on colon-separated headings. It splits the input on lines containing a colon and organizes the content under corresponding section keys. If `infer_missing` is enabled and required sections are missing, it uses the language model to generate inferred content for those sections, marking them as `(inferred)`. The function returns a dictionary of section names mapped to their respective content.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:rank_code_files:93fc93ad81906fd364eff7ee4f84234c2e162096c8af480f7d86f837c3d7ac5c:bd612723b4b18e4115b9b44f91ebd74fa8661876e5e53750917ef0b18bd87819": "The function `rank_code_files` takes a root directory path and a list of patterns, then returns a list of code file paths under the root directory ranked by a simple heuristic. It supports Python (.py), MATLAB (.m), Jupyter notebook (.ipynb), C++ (.cpp), C header (.h), and Java (.java) files.\n\nThe function excludes certain directories such as venv, .git, __pycache__, node_modules, dist, build, tests, test, examples, example, samples, sample, fixtures, and fixture from traversal. It also filters out directories ending with .egg-info.\n\nFiles are scored based on whether they match keywords like \"run\", \"main\", \"cli\", \"config\", \"io\", \"dataset\", \"reader\", \"writer\", or \"pipeline\" in their relative path, with a score of 2 for each match. Additionally, files are given a score of 1 if any pattern from the input list is found in their relative path.\n\nRanked files are sorted first by descending score and then lexicographically by path name. The function returns only the file paths, ordered according to this scoring mechanism.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:render_html:3c8940d3bb9e0a19d5e321526fa72f9405a41854cfa9f0664d627dce1c8a3e58:3e4915376b2a09024c47993f646616216786a8e24f0d99c716b531d7f1358037": "The `render_html` function generates an HTML document from a dictionary of sections, each containing content and optional evidence snippets. It constructs a navigable HTML page with a title, a table of contents, and section headers. For each section, it creates an anchor link in the navigation and renders the section's content, either using Markdown formatting if available or escaping the text directly. If a section has no content but contains evidence snippets, those snippets are displayed instead. The function also includes basic CSS styling for the output document. The `evidence_map` parameter allows associating source files and code snippets with each section to provide context when content is missing.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:scan_code:b24fa427a349d99c722fbc4864e4394d1e3403aa42ca4e446c6a1d74fd58a575:68e5d1c66484b938003fa6bd6cbb4691cee192e1bc511582602de1976df716f3": "The function `scan_code` collects source code snippets from a specified base directory, organizing them by manual sections based on keyword matching. It accepts parameters to limit the number of files processed, time spent scanning, and maximum file size. The function identifies relevant files by analyzing documentation files for patterns and ranks them accordingly. It then extracts code snippets from these files, categorizing them into sections defined by `SECTION_KEYWORDS`. The result is a dictionary mapping section names to dictionaries of file paths and their corresponding code snippets, excluding empty sections.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:slugify:4adb09b73f55eee2bc6d69d21a7ed789065bdc7016947a7f1e9bbe22bbf0f7bc:99ab1395d03f9d0d8b550f5200fd2955c36819b730606b12489a77702ca33701": "The function `slugify` takes a string input and converts it into a filesystem-friendly identifier by replacing non-alphanumeric characters with underscores. It converts the input to lowercase, removes leading and trailing underscores, and returns the resulting string. If the result is empty after processing, it defaults to returning \"user_manual\".",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:validate_manual_references:7e7a9366d32811e38852ebdbd85a6686988b5865d2590a679ca88e4d8fb8b34b:8b74090425b7e4f874ca52885483b7c52a67e0c8c737bf97014c4952b941a103": "The function `validate_manual_references` identifies and flags file references within section texts that do not correspond to existing files in a project. It takes a dictionary of sections, a project root path, and an optional evidence map. For each section, it scans the text for substrings matching file patterns (e.g., `.py`, `.m`, `.md`) and checks if these references exist relative to the project root. If a reference is missing, it appends `[missing]` to the reference in the text and optionally logs the missing references in the evidence map under the section's key. The input `sections` dictionary is modified in place to reflect these changes.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:write_pdf:17de2846369d6f4afcbc096cf3777f7c2b30123b02fdd4abd0d45910b11a05cb:e9855c83e5c47d1b9e9f951a86729443a3750cab0e7d0651cfb733698a450d18": "The function `write_pdf` converts HTML content into a PDF file using the ReportLab library. It takes an HTML string and a file path as inputs, parses the HTML to extract text, and writes the text to a PDF document with a specified page size. The function returns `True` if successful, or `False` if the required `canvas` module is not available. The text is written line-by-line using a text object positioned on the page.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:__init__:47d927abdcfd70895fc96ad1c53131bc44214864b7bdadc47b0a0f7441a6380b:8c90e3ffacd132435531243bacd4c39ae31f60195b2c7c26684736f54657ace3": "Initializes a `PathLineEdit` instance, setting up the widget to accept drag-and-drop operations for files and directories. The constructor calls the parent class initializer and enables drag-and-drop functionality by setting `setAcceptDrops(True)`.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:__init__:4ee689f026116737d750e0c11136d9e4aa33252c66f10edc3be040aac60f47f4:2c73f29d9a5289f5b7ef26d7cd85a7d72daf194159bc162f35f618018136f8ba": "The `__init__` method initializes a `CommandRunner` instance with a sequence of shell commands. It inherits from a base class and stores the provided list of commands in the instance variable `self.cmds`.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:__init__:5ebf4c92405bf42478be11b05efb1c93706615ecea61dfe8b04db4730946b993:1031d49fec66a62ed6c6ad06521cb251a19df13c52644236b8adba317bc4e882": "The `__init__` method initializes a `CollapsibleBox` widget with a toggleable content area. It creates a styled `QToolButton` as the header, which displays the provided title and an arrow icon indicating the expand/collapse state. The button is configured to be checkable and connected to the `on_toggled` slot to handle state changes. A `QWidget` is created to serve as the content area, initially hidden. The layout manager arranges the toggle button and content area vertically within the widget, with no spacing around the edges.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:__init__:6093ebcf7c4dae829b3cb67b31e5bdc6b0c5ea6c94c4b0757cfe6e5270cfc73b:a1cb89c3578456c74bbd894a50b965de1df6252432318aeb259f1b3eb716bfcb": "Initializes the `MainWindow` class, setting up the graphical user interface for the DocGen-LM documentation tool. The constructor configures the window title and dark theme styling, creates a header with a logo and title, and sets up input fields for project and output directories with browse buttons. It includes options for DocGen, such as including private functions and selecting supported languages (Python, MATLAB, C++, Java), and options for ExplainCode, including output format selection and optional data analysis settings. A log display area is added to show execution progress, along with buttons to run DocGen, resume DocGen, run ExplainCode, or execute both processes. All UI elements are organized into a vertical main layout.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:_reader:84209affb9b4ca7a59078a4a9f187fea954a74e22b02fb34fa752749d96df7ce:3197ebce4a028c7038ecf1b5ef90032e6796a58f76ba3f9b0f9d5c476c546bb7": "The function `_reader` is a method of the `CommandRunner` class that reads from a given stream character by character. It accumulates characters into a buffer until it encounters a newline (`\\n`) or carriage return (`\\r`). Upon detecting a carriage return, it emits the current buffer content followed by the carriage return itself. When a newline is encountered, it emits the buffered content concatenated with the newline and resets the buffer. Any remaining buffered text is emitted when the stream ends. This implementation supports real-time output processing with support for progress updates via carriage returns.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:append_log:3976a0e72280c5c4064bf9770c9f93da87b0102ce59602d0cfc71c2e61dd2190:cefdd2d9802c47181cbac4726ac68555e806006c6a4a0216e7a01521601224f5": "The `append_log` function appends text to the log display in the `MainWindow` GUI, ensuring that the view scrolls to the end after each update. It processes the input text by splitting it on carriage return characters (`\\r`) and handles these characters by removing the current line before inserting new content. The function maintains the cursor at the end of the text and adjusts the vertical scroll bar to reflect the latest log entry.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:build_docgen_cmd:45d8efca01278305ec9d146fcfeeea9fa5c6161581a28fe06dcbcbf083db87ed:1b6ac49bf0724997896f80fd58c5d2d5700a90b8698ad5aae51725165577426e": "The function `build_docgen_cmd` constructs a command list for executing the documentation generation process using the `docgenerator.py` script. It includes the Python interpreter path, the script name, the project directory from `self.project_edit`, and the output directory from `self.output_edit`. If the `resume` parameter is True, it appends the `--resume` flag to enable resumable execution. If the checkbox `self.docgen_private_cb` is checked, it adds the `--include-private` flag to include private members in the documentation. The function does not explicitly specify supported languages, as DocGen-LM now auto-detects them (Python, MATLAB, C++, Java). The constructed command is returned as a list of strings.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:build_explain_cmd:b7109ddc5828996588773db1ae1ce5029a79ba8f3541501be194e51e681e397b:69e0dff130042e71fda1f11db5fc03eeb8afa95865b5bf9d77b674160fd4baa1": "The `build_explain_cmd` function constructs a command list for executing the `explaincode.py` script. It includes arguments for the project path, output directory, and output format, retrieved from the GUI input fields. If the data inclusion checkbox is checked and a data path is provided, it appends the data path to the command. The function returns the constructed command as a list of strings.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:dark_style:46692ac8ab1b2be003f5978380d7c6f4e66b043dd28324a4bff821f50ec09860:6462d8a12c0f2be43a6543629a7c4099cdf9684820edde85aaab1daa3a77a786": "The `dark_style` function returns a CSS-style string that defines the visual appearance of GUI elements in the `MainWindow` class when using a dark theme. The style specifies background colors, text colors, fonts, and border styles for widgets such as `QWidget`, `QLineEdit`, `QPlainTextEdit`, `QComboBox`, `QPushButton`, and `QLabel`. It ensures a consistent dark-themed interface with appropriate padding, hover effects for buttons, and font settings suitable for code documentation tools.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:dragEnterEvent:a911fde0231429dc24a418828312f7aaa1922680c73b5c931f387abaad180ddf:50b0dff7060011a25f57e46c1bc470844013a6324cb08146863621014b8c8a60": "The `dragEnterEvent` method in the `PathLineEdit` class accepts drag events that contain URL data. If the dragged data includes URLs, it allows the drop action to proceed by calling `event.acceptProposedAction()`. This enables users to drag and drop files or directories onto the widget for path input.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:dropEvent:cad707a201df56ee68ed4688a0c463830baf05dd2e9b7b5a4bc3014c693ae3a3:708196425815fc2910f2440a2fe6b707e71efb98c6075c13d80532318494a14d": "The `dropEvent` function handles the drop event for the `PathLineEdit` widget. It retrieves the URLs from the drag-and-drop operation's MIME data and, if any URLs are present, sets the text of the line edit to the local file path of the first URL. This enables the widget to accept file or directory drops and automatically populate the input field with the corresponding local path.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:on_finished:a1d7c728891585a98ae60d0d7977cc08beeb525a0eeaba8afd699c63cf135bfc:ed24926005572e8dc92311ad2b462096921f144aa9c1d345bb773324fed0eeb1": "The function `on_finished` is called when a process completes execution. It logs the exit code of the process into the application's log and updates the running status of the application to false, indicating that no process is currently active.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:on_toggled:b2a28a831802c54d9694ea8d16dce4ea2f5ca5f68e7b838a206fb24442f3fa04:5dbddb82594f2335eedb28765b071c80ea488ce4b390f9bcec22c8384b86bd37": "The `on_toggled` method updates the visual state of the toggle button and shows or hides the content area based on whether the button is checked. It sets the arrow direction of the button to indicate the collapse or expand state and adjusts the visibility of the content area accordingly.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:run:6a2adc647801a1e3ea55d375e58c12eb9e3fc98a6b515136f075f4181143734d:897a9c618c8454c586bebe0b850e76fe52843b3f27cc461ed0265a451f432a16": "The `run` method in the `CommandRunner` class executes a sequence of shell commands provided in `self.cmds`. For each command, it emits the command line to the output, initiates a subprocess, and starts two reader threads to capture stdout and stderr in real-time. The method waits for the process to complete and checks its return code. If any command fails (non-zero return code), the execution stops. If an exception occurs during command execution, it emits the exception message and sets the return code to -1. After processing all commands or upon failure, it emits the final return code via `self.finished`.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:run_both:c346c6344053a43fdd7922c85393660dad92dbe373a6e7cf79459a48529ebef5:9baacc18034cf7731e924b1a20dcc1c6f14e46c421d96c973b1bb5423b21e244": "The `run_both` function clears the log display and executes both the documentation generation and code explanation commands sequentially by calling `run_commands` with a list containing the output of `build_docgen_cmd()` and `build_explain_cmd()`.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:run_commands:b9e83fa103b3862b850593a6e98d93f807eb5c7c34f5e501b2d2bcaf574f6266:6440218f28a6de3e5d5c3cb299018d1c007a314b8af1109d0da1f50802ae2c2d": "The `run_commands` function initiates the execution of a list of commands through a `CommandRunner` instance. It first checks whether the project and output directory fields are set; if not, it logs an error message and exits. If both directories are specified, it sets the UI to a running state, creates a `CommandRunner` with the provided commands, connects its `output` signal to the `append_log` method for logging, and connects its `finished` signal to the `on_finished` method. Finally, it starts the runner in a background thread.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:run_docgen:7afba28ab0a49adcb67f03645e91c2b6124b6aee2b8d9b53aa4b479f4f78607b:bd875ae496430ab652eb901a2c5f32c58033e035b460607b9fe325e5c6a1ba6b": "The `run_docgen` function clears the log output and executes the documentation generation process by running the command constructed through `build_docgen_cmd()`. It utilizes a list of commands to initiate the DocGen task within the application's UI.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:run_docgen_resume:8d8115dbd9ba41e2e27dbf065620a9fc079c07da5eaa12ef69ca74d8062e029c:70e2eade69cf4cd348b6c2448f948ac2e4f2e512ae0cc1af389b0fe21c76bdbf": "The function `run_docgen_resume` clears the log display and initiates the documentation generation process in resume mode by executing the command built through `self.build_docgen_cmd(resume=True)`. It uses `self.run_commands` to run the constructed command, enabling the continuation of a previously interrupted documentation generation task.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:run_explain:ac12ee903ac7fca9bb6d3ef062a9dc0c8ad02344cc985e6aa63988064c132d18:1958129212e241fa13a2a43e2774bf6efa3b36847f5f50610673177cb0507e43": "The `run_explain` function clears the log output and initiates the execution of an explanation command generated by `build_explain_cmd()`. It uses `run_commands` to execute the command, likely in a background thread, and updates the UI to reflect the running status. The function is part of the `MainWindow` class and supports the graphical interface for managing code explanation tasks.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:select_dir:a4c8aecb937421ce39ae89de931284d462ed1c91d7c43148b8c744d9c87c0aff:c1fbddf2c7801ea93554b131ba8bf97a258fa6ee9ca10b44e3a3ee478e40c52d": "The function `select_dir` provides a dialog for selecting a directory and updates a specified line edit field with the chosen path. It uses `QFileDialog.getExistingDirectory` to open a directory selection dialog and sets the text of the provided `line_edit` widget to the selected directory path if a directory is chosen.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:select_file:a37802c52eaafaa6263a4225a0cf7c734c6075b4202f4724d44c1059178b2eb4:7da1b110809cc40babdf9a833aa0c21863353f888de4fcfb4ae74448148baa13": "The function `select_file` provides a file selection dialog for the user to choose a data file. It updates the specified `line_edit` widget with the selected file's path if a file is chosen. The dialog filters for JSON, CSV, and text files, and allows selection of all file types. If no file is selected, the line edit remains unchanged.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:setContentLayout:e720067defef9de228cfd8adf6e11551b8d6822babc8896d2692f4c4532e66c4:9e098d7cd654c1249f7eac52e8207c561ce6eaabe792432890adbb59151109d0": "The `setContentLayout` method assigns a specified layout object to the content area of the `CollapsibleBox` widget. It takes a single parameter, `layout`, which is expected to be a layout object (e.g., `QVBoxLayout`, `QHBoxLayout`) and sets it as the layout for the internal `content` widget. This allows customization of how the content within the collapsible box is arranged and displayed.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:set_running:46b1d6f64c6ec5f4f8c35b3442204d2e4bb35dd15cf838a8c2103cc08a03217d:080f347598e4e2b0699e4bbb5cc1a9d7ad3337f96909f833f01b2fd7151ced01": "The `set_running` function enables or disables multiple UI buttons (`docgen_btn`, `resume_btn`, `explain_btn`, `both_btn`) based on the `running` status. If `running` is `True`, the buttons are disabled; if `False`, they are enabled. This prevents user interaction with these buttons during the execution of documentation generation or code explanation tasks.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\html_writer.py:_highlight:da5cd6a50a3f9c051fb0e87cb1227f6298434e3aaeaa9cd724983534b0f9d863:52459cbfce93d778ca81b6488fa6ded15188b461a444a1082ac24409c74b5da3": "The function `_highlight` takes a string of code and a language identifier, then returns the code formatted with syntax highlighting using the Pygments library. It selects an appropriate lexer based on the language (supporting MATLAB, Python, C++, Java, or plain text), applies an HTML formatter to the highlighted code, and wraps the result in `<pre><code>` tags for proper display.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\html_writer.py:_render_class:97a164a296732f2b63815a6ea094a56ae7b07973ba779ffdcaea8238b318911b:af990ba8d80e3587e47d7e54fad9888d899dd3eba4aa5216234ff7b87defe6b4": "The function `_render_class` generates HTML content for a class and its nested elements, including subclasses, methods, and variables. It takes a dictionary representing the class, the programming language, and an optional nesting level. The output is a list of HTML strings that define the class structure with appropriate heading tags, documentation, variable listings, and method details. Subclasses are rendered within `<details>` and `<summary>` tags to allow for expandable sections. Each element is properly escaped for HTML safety.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\html_writer.py:_render_function:54c4bdc9e28564dab0d57ef6b53f3ccf5911064edb2d8f1da83206c982d46026:8e4179007b3255c3490c48d0ec9a7cb13c60f5b77ce5cdfa312a51ff11d4b537": "The function `_render_function` generates HTML content for a given function dictionary, including its signature, summary, and source code. It supports nested subfunctions by recursively rendering them within `<details>` and `<summary>` tags. The output is a list of HTML string parts representing the formatted function documentation. The rendering adjusts the heading level based on the provided `level` parameter and applies HTML escaping for safety. If the function contains subfunctions, each is rendered with its own collapsible section. The language parameter is used to highlight the source code block.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\html_writer.py:_render_nav_tree:498a867e515b6f7b3af203c7815d1f8f53ced79cca9a514a4a210c34c939c2b2:0b327b18af3efa2ddf487d33deb06f0a3b73ab149e355d3c9e7147868360da6d": "The function `_render_nav_tree` generates HTML code for a nested navigation tree from a dictionary structure. It takes a dictionary `tree` representing the navigation structure and an optional boolean `include_home` to determine whether to include a home link. The function uses a nested helper function `_render` to recursively process the tree, creating HTML list items for files and collapsible sections for directories. Files are rendered as links, while directories are shown as expandable summary elements with nested lists. The output is a string containing the complete HTML structure for the navigation tree.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\html_writer.py:write_index:86910bc7abce346a33c31396100a74087b42a8ca663b8b32173462fda353377c:b4fc05debf3d8539f4cde0be449d656b2aeb8f1c333bf1e21562b3de7ac740f9": "The function `write_index` generates an `index.html` file in the specified output directory. It uses a project summary, a navigation tree, and optional module summaries to construct the page content. The function creates HTML markup including a project summary paragraph, a horizontal rule, a heading for modules, and a list of module links with associated summaries. Navigation links are derived from the flattened navigation tree, and each module item includes an optional summary rendered in small text. The final HTML content is constructed using a helper function `_render_html` that incorporates a title, body, and navigation bar, which is then written to `index.html`. Directory creation is ensured with parent directories included.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\html_writer.py:write_module_page:1357dbc836e92127ccab73bb4ad745e6888052692e42763898308c6ba69f989b:49912312ae1e1b288ec6f60035297d02dd5551f664c165e46547b6322cd8907a": "The function `write_module_page` generates an HTML documentation page for a given module based on provided data and navigation structure. It creates the output directory if it does not exist, extracts module details such as name and language, and constructs the page body by rendering class, variable, and function information. The rendered content includes summaries, docstrings, and source code highlights, formatted according to the module's language. A navigation tree is included in the output, and the final HTML is written to a file named after the module.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\llm_client.py:LLMClient:9086fe6d0aa4aad556d06744f699ce311e195429fe4c45bc9bd606ed6044b040:b119b81ce87856ab8f9a73d218c0a23edea1037962ac564ed23e34440ccc5293": "The `LLMClient` class provides a wrapper for interacting with the LMStudio HTTP API, offering methods to check API availability and generate text summaries using configured prompts and models. The `ping` method verifies connectivity to the LMStudio server, raising a `ConnectionError` if the server is unreachable. The `summarize` method constructs a prompt from a template, checks token usage against a budget, sends a request to the API with retry logic, and returns a sanitized summary response.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\llm_client.py:__init__:97ea51ce81e1e850181775c04f40f26115a184cacbd9cf623a20dab903aa98eb:82a1b7cdac1493d20a8088df794694840e6f85e7f487ff95ab403956cb142291": "Initializes the `LLMClient` instance with a specified base URL and model name. Sets up the API endpoint for chat completions by appending the `/v1/chat/completions` path to the base URL, ensuring any trailing slashes are removed from the base URL. The model name is stored for use in API requests.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\llm_client.py:ping:45122faa4e58c377079a43e1a4b14f9be37265df467335e4894a73c341f72101:ef9de62e60ea9161bb7fe9b0bd1b742c85e8ba5e52e7e1326901a636078d5d17": "The `ping` method checks the connectivity of the local language model API by sending an HTTP GET request to the specified base URL. It returns `True` if the API is reachable and responds without errors, and raises a `ConnectionError` if the server cannot be contacted or if the request fails. The method uses a configurable timeout value for the HTTP request.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\llm_client.py:sanitize_summary:d8dd5733b136305f1814cae013c4e04f1a088155a811b8a3cc521ef026c7cf8a:2c93577ee3584ff17da17982bfec484c793c30a1f74dd533a9f1159f39bd717b": "",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\llm_client.py:summarize:87052665e5570592c2604efc5849f5df4101e668c50563d5c7e1e5a2ee3513f7:3f2cdcdf9eb1ae9feeeb0c1144be5123e8ba3ef7bd00f2903c39a7e4424b2861": "The `summarize` method of the `LLMClient` class generates a summary of input text using a specified prompt template and communicates with a local language model API. It constructs a prompt from the input text and a selected template, checks the token count against a budget, and sends a POST request to the LLM endpoint with system and user messages. The method includes retry logic for failed requests, handles streaming response data, and sanitizes the final output before returning it. If all retries are exhausted, it raises a `RuntimeError` with the last error message.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\manual_utils.py:_count_tokens:d53c56301eb31134ce4c454637109b61f421239f216692778ac4a238de4e43ef:e7072fb3e09de9b1814db8939822f1c510f9e058915d10aa195019db51f9c827": "The function `_count_tokens` takes a string input `text` and returns an approximation of the number of tokens in that text. It uses a tokenizer object named `TOKENIZER` to encode the text and then calculates the length of the resulting encoded sequence to determine the token count.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\manual_utils.py:_split_text:dbc79ca325bdb3ae9111854fe629228ae6a882552bf4cae81cf2a669d5196089:47e10c3a281eb28193456e9370548584cb6de97500016e356147050a39326a04": "The function `_split_text` splits a given text into chunks based on token and character limits. It takes a string `text`, and optional parameters `max_tokens` (default 2000) and `max_chars` (default 6000). The text is split into paragraphs using double newlines as delimiters. Each paragraph is evaluated for token and character count, and if it exceeds the limits, it is further chunked using `chunk_text`. Paragraphs are added to chunks until adding another would exceed either limit. When a limit is exceeded, the current chunk is finalized and a new one begins. The function returns a list of text chunks that respect both token and character constraints.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\manual_utils.py:_summarize_manual:fb30f944d41e9d20072bb4bb1130e261e2eb9a2ec0db2271054e8e2a5a39499e:908fd3ceb9c6dc8c8eb468d74c974b187dd0f252b3c030ebf8c7d3f3ae1cd7f9": "The function `_summarize_manual` generates a manual summary of input text using a specified chunking strategy. It supports three chunking modes: \"manual\", \"auto\", and \"none\". For \"manual\" or \"auto\" modes, if the input exceeds token or character limits, it splits the text into chunks, processes each chunk with an LLM client, caches responses, and merges results hierarchically until the final summary fits within limits. If caching is enabled and a cached response exists, it returns the sanitized cached result. For \"none\" mode, it directly summarizes the full text without chunking, provided it meets size constraints. The function handles exceptions during chunking, summarization, and post-processing, logging warnings when failures occur. It uses system prompts tailored for chunking and merging operations and sanitizes outputs to prevent reserved-token issues.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\manual_utils.py:chunk_docs:33f9e82ddaa78c335b576d7cecc23e04c94b11faff9b044fe7db0bcc7a8fdddc:285e901d70821085e59d5cc64e27f36b629bd7d9e23d3205be3ca3f10dc12d87": "The function `chunk_docs` takes a list of document strings and splits them into chunks based on a specified token limit. It joins the input documents with double newlines, filters out empty or whitespace-only entries, and then uses an internal helper function `_split_text` to divide the combined text into segments that do not exceed the given token limit. If the input list is empty or contains only empty strings, it returns an empty list.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\manual_utils.py:find_placeholders:eb1308ffbf38c9ccdc7ec894789b0578a0d7efb49fd8f661d56b4d6c052450fd:c857e13a48e4cb666f301616a0789cbcf90e7f7669fdbaec9fc857daf30fbdf8": "The function `find_placeholders` takes a string input and returns a set of placeholder tokens formatted as `[[TOKEN]]` that are found within the input text. It uses a regular expression defined as `PLACEHOLDER_RE` to identify these tokens.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\parser_cpp.py:_extract_block:30deb09597454ab0cf4f3fa17fb25f563ae7b25eef7664219cb4fe8e7399b190:9a8c0860907ae746326fceec4f0cabee6383298bcff8c4f806d3e84ca45dea22": "The function `_extract_block` extracts a contiguous block of text from a list of lines, starting at a specified index. It identifies the block by tracking the balance of curly braces `{` and `}`. The function returns the extracted text along with the index of the last line included in the block. The extraction continues until the brace count reaches zero, indicating the end of the block.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\parser_cpp.py:_get_preceding_comment:f418dceb93df695c092663d53ed238b3519f8df7719601019752ba6ca4c2cecf:bfb4924c7789098bd4f53e5bd2bf061e26de55f5343c1fbc6d64beed620ef1d6": "The function `_get_preceding_comment` collects contiguous comment lines that appear before a specified index in a list of code lines. It handles both single-line comments (starting with `//`) and multi-line comments (enclosed between `/*` and `*/`). The collected comments are returned as a single string, with each comment line separated by a newline. The function stops collecting when it encounters a non-comment line or reaches the beginning of the list. Empty lines are ignored unless they appear after actual comments, in which case they terminate the comment collection.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\parser_cpp.py:_parse_class_body:9c626247d99d8b7afef472ef4cb5f4225038b288f226adfe8515b20b69f5ee00:4f7f84f6ba7b85cfda47dbd614b45ad7e9746c328aaedbd08e6bbb2bfbf9a44f": "The function `_parse_class_body` parses the body of a class definition to extract public methods and variables. It takes a list of lines representing the class body, along with start and end indices defining the range to parse. The function returns two lists: one containing dictionaries for each public method, including its name, signature, docstring, and source code; and another containing dictionaries for each public variable, including its name, type, docstring, and source line. The parsing respects access modifiers (`public`, `protected`, `private`) and only processes items marked as `public`. Method detection is based on lines ending with `{` and containing parentheses, while variable detection is based on semicolon-terminated lines without parentheses. Comments preceding each item are collected as docstrings using the helper function `_get_preceding_comment`. Blocks of code for methods are extracted using the helper function `_extract_block`.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\parser_cpp.py:parse_cpp_file:2f28367db981ce182b4ced7352fd16217dfb7bb3574ee098334cc0011583cf47:0b39bd5291c1f32df18577f8d437651c103e0b68e0a2c180186167790066eef5": "The function `parse_cpp_file` reads and parses a C++ source file, extracting structured information about the file's contents. It identifies the module-level comment, namespaces, classes, and functions. For each class, it captures the class name, documentation string, methods, variables, and source code block. For each function, it records the function name, signature, documentation string, and source code block. The parsed data is returned as a dictionary containing the module docstring, lists of classes and functions, and the namespace if present.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\parser_matlab.py:parse_matlab_file:6c587ddd51a2e0b1db06205c64897e8400b8bf0b5d056473cdee237f54c37e05:21486602622a50241aea6751e99b09c6dec773921e5162b44336cc369be3633a": "The function `parse_matlab_file` reads a MATLAB `.m` file and extracts its structure, returning a dictionary with the file's header comments and any function declarations found. It identifies function definitions using a regular expression to capture the function name and its arguments, handling both comma- and semicolon-separated argument lists. The header comments are collected from the beginning of the file until the first non-comment, non-blank line is encountered. The returned dictionary contains the extracted header as a string and a list of dictionaries, each representing a function with its name and argument list.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\parser_python.py:_format_arg:85fe39de2dbbe75cb6d9d07c6aad092e751c973598c5e2a4dd5b9fad235a2e6d:1210326628a1519c410cced6f008fc93d27509e444012ace387112996f0eedf1": "The function `_format_arg` takes an `ast.arg` object and returns a string representation of the argument name, optionally including its type annotation if present. If the argument has an annotation, it appends the annotation to the argument name in the format `arg: annotation`. Otherwise, it returns just the argument name.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\parser_python.py:_format_arguments:29f41e6da7b7b091563b7fb321c86a9620ebcb8c756c3972b737416094c4b49f:48bc5ae594149dc7005dc1846d2c1bdca280929c7670665961fe497b7ea59036": "The function `_format_arguments` generates a string representation of Python function arguments defined in an abstract syntax tree (AST). It processes positional-only arguments, regular arguments, default values, `*args`, keyword-only arguments, and `**kwargs`, formatting them according to Python syntax. The function handles argument defaults by unwrapping them using `ast.unparse` and ensures proper separation with commas. It also appends a forward slash `/` after positional-only arguments and a `*` before keyword-only arguments when needed. The result is a comma-separated string that reflects the signature of a Python function's argument list.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\parser_python.py:_format_signature:374cc7b6fc74a61c30679e02a439bfa454a88d694c76a27329036288d14fbc98:9e5d84d9b472a70bad74ce2511d964875515146845bcfdf60fbb6ad953c08bed": "The function `_format_signature` generates a string representation of a function's signature from an abstract syntax tree (AST) node. It takes a function definition node (`func`) and constructs the signature by formatting its arguments using `_format_arguments`, then appends the return type annotation if present. The resulting string includes the function name, parameter list, and optional return type annotation.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\parser_python.py:_parse_classes:d9cc86257b6c0fe062b614c3d84126d300541632c903862c13d271eb0ab8474d:a9bffda372aea044c8b938b770f3ac6a24c21bc3f1de5441d280515e35b8127c": "The function `_parse_classes` recursively extracts all `ClassDef` nodes from a list of AST nodes and returns a list of dictionaries representing parsed class information. It processes each node in the input list, and if the node is a class definition, it calls `parse_class` to generate a dictionary for that class. If the node is a function definition, it recursively parses the function's body for nested class definitions. The function supports both regular and asynchronous function definitions.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\parser_python.py:parse_class:4a673e42aa103ce99a4beb7be81806fc0dd834f586de09841a0d3ad09fc1bc5e:6ee6a9b90bb7d7ea3e2a05d36b4e6a5834b6305eb95db8eabc48ebc9a648fea9": "The function `parse_class` takes an abstract syntax tree (AST) class definition node and the source code as input, and returns a dictionary containing information about the class. The dictionary includes the class name, its docstring, a list of methods defined within the class (parsed using `parse_function`), a list of nested subclasses (parsed using `_parse_classes`), and the source code segment corresponding to the class definition. The function iterates through the body of the class node to identify and process function definitions and nested class definitions.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\parser_python.py:parse_classes:fc8b9fcb03f57154b6c9705b24fc589d7251a4e5a0480fbe384d17de8f2a53b6:9cf23204b69196d3543a7935c38dbad2bc33bce0ac79b78755bfd53a185e4e69": "The function `parse_classes` is a public wrapper that extracts class definitions from an abstract syntax tree (AST) node. It takes an AST node and the corresponding source code as input, and returns a list of dictionaries containing information about the parsed classes. The function delegates the actual parsing logic to the private helper function `_parse_classes`, using the `body` attribute of the provided AST node. If the node does not have a `body` attribute, it defaults to an empty list.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\parser_python.py:parse_function:31c7e1f9d87a3d670c36799b3d7bc06ba871e68bfc1ba79df6d3449dc75c9767:4a7cf082e87b060888092350a8844695abca0a54d6045b7d1501fd909568fb34": "The function `parse_function` takes an AST node representing a function or asynchronous function and the source code as input, and returns a dictionary containing information about the function. The dictionary includes the function's name, signature, return type, docstring, source code segment, and lists of nested subfunctions and subclasses. It recursively processes the body of the function to identify and include any nested functions and classes.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\parser_python.py:parse_python_file:cc1bfeecc2e88c7c1db88a719fef4740b54c14bcca5f3e080e6daf17dc9de6c2:94490e6ae6690e14e990ad3e3675d43b10d51a7911d5dd3754247b10eeea31c6": "The function `parse_python_file` reads a Python source file and returns a dictionary containing the module's docstring, a list of classes, and a list of functions. It uses the `ast` module to parse the source code and iterates through the abstract syntax tree's body to identify class and function definitions. Each identified class or function is parsed using helper functions `parse_class` and `parse_function`, respectively, which are not defined in the provided code snippet. The returned dictionary includes the module docstring retrieved via `ast.get_docstring`, along with lists of parsed classes and functions.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\retrofit_sidebar.py:_paths_to_tree:be24719eb43da6c8874700113ab68a3b11950c920aed864b5fc709119c3e9fa3:92b7783d03d2f4811fdfaef288771408fb9760dfe28d93e6c89b239bbf78b28c": "The function `_paths_to_tree` converts a list of file system paths into a nested dictionary representation. Each path is broken into its constituent parts using `Path.parts`, and each part is recursively added as a key in the dictionary. The final part of the path is set to `None` to indicate a leaf node. This creates a hierarchical structure where keys represent directory or file names, and values are either nested dictionaries (for directories) or `None` (for files).",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\retrofit_sidebar.py:_tree_to_ul:75e1618142addcfcf583ce6b93bc8bc999d72b6aa5d9120d39e7f32255516d0b:e5fdefde19e0f2ac4b6e9e8b127aa243d0496847fe3eb107b2342951f1179e93": "The function `_tree_to_ul` recursively constructs an HTML `<ul>` element from a nested dictionary `tree`. Each key in the dictionary corresponds to a list item (`<li>`) in the resulting HTML structure. If a dictionary value is itself a non-empty dictionary, the function creates a nested `<ul>` for its contents. Otherwise, it creates a hyperlink (`<a>`) pointing to an HTML file derived from the path. The `base` parameter specifies the current directory path, used to construct relative links to the HTML documentation files. The function uses BeautifulSoup to generate and manipulate HTML tags.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\retrofit_sidebar.py:retrofit_sidebar:e5a00100fd573ebc975bb644435f713c5e241c1da2b3317389e5fcb97f15bbec:d465d5eafdfe2b2c20ba5a2c9834961fda6f498b30fa36497470088bcdcce23d": "The function `retrofit_sidebar` replaces existing documentation sidebars in HTML files with a hierarchical module list. It takes a source root directory and a documentation directory as inputs. The function scans the source directory to identify modules, constructs a tree structure from their paths, and then processes each HTML file in the documentation directory. For each HTML file, it locates the sidebar element, clears its contents, and populates it with a structured unordered list generated from the module tree. The updated HTML content is then written back to the respective files.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\reviewer.py:_is_generated_html:0a145c50396f3cff9becb23bce662e0b43960d0fd63fa3b33d8a82b4e9466d4c:fc8d07a586a6ec3863f2159974979a4b300d0957f31ebd15df05385e8382bbd6": "The function `_is_generated_html` determines whether a given HTML text appears to be output generated by DocGen-LM. It checks for the presence of specific markers within the text, including the string \"Generated by DocGen-LM\", the heading \"Project Documentation\", and patterns matching class and method headings with specific naming conventions. The function returns `True` if any of these markers are found, otherwise it returns `False`.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\reviewer.py:check_assistant_phrasing:d29469b3dbcfbdee46e52b40a4994e999e2aa466b91d305e03f46c2c0567837f:ab16f25f2d65914e8c01d8bae9ac2eb4c494f517740e10a513934b25a9cbbdb3": "The function `check_assistant_phrasing` takes an HTML string as input and returns a list of strings identifying paragraphs that contain assistant-like phrases. It extracts all paragraph elements from the HTML, strips their HTML tags to obtain plain text, and checks if any of the predefined assistant phrases are present in the lowercase version of the text. For each matching paragraph, it determines the line number of the paragraph within the HTML and appends a formatted string containing the paragraph text and its line number to the findings list. The function uses helper functions `_extract_tags`, `_strip_html`, and `_find_line_number` to process the HTML and locate phrases.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\reviewer.py:check_contradictions:9eb188f6af00b9203b34dc4683585c2b70072c384a82c8a10023c690bf63a9ab:255082f3297731f26d7e2200ad6230a188dcfbb2c05e610e14f8c146e329a23d": "The function `check_contradictions` analyzes HTML content to identify contradictions between a summary text and the presence of specific code elements. It extracts paragraphs and header tags from the HTML, then checks for inconsistencies such as statements claiming no methods, functions, or classes exist while corresponding headers are present. The function returns a list of strings describing each identified contradiction.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\reviewer.py:check_hallucinations:3d5efbe0b046608ca0ee383a8b65ef0ffdf953b5cd547c9e4cc0cd93688b225c:85c778d54c1cf9908f2bed49c2087f9737745a36029962a465acb779e9d8ea4a": "The function `check_hallucinations` takes an HTML string as input and returns a list of hallucination phrases detected within the text. It extracts all paragraph elements from the HTML, strips the HTML tags from each paragraph, converts the text to lowercase, and checks for the presence of predefined terms (stored in `HALLUCINATION_TERMS`). If any of these terms are found in the text, they are added to the list of findings, which is then returned.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\scanner.py:_is_subpath:4c43b05219568605bed09a7a3574273d96c87dc09d8d6862849bd6600cb25c14:500cca1053b8b2b0797a335b22935b6ae2600cb1b551a8c1403827d8d6b86c33": "The function `_is_subpath` determines whether a given path is equal to or located within a specified parent path. It takes two arguments: `path` and `parent`, both of type `Path`. The function attempts to compute the relative path of `path` with respect to `parent` using the `relative_to` method. If this operation succeeds without raising a `ValueError`, it indicates that `path` is indeed a subpath of `parent`, and the function returns `True`. Otherwise, if a `ValueError` is raised, the function returns `False`.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\scanner.py:scan_directory:7c7bdbb02120af32c6dff583f5b3ac02c8259c796b623c770709dd487955c724:cc711c92e4cb7293a5ce34ed699bc07aedd5696288b9e39df461da546a63f5b5": "The function `scan_directory` recursively searches for source code files with extensions `.py`, `.m`, `.cpp`, `.h`, and `.java` within a specified directory. It takes a base path, a list of paths to ignore, and an optional progress display flag. The function returns a sorted list of absolute paths to the discovered files, excluding those specified in the ignore list and skipping `.git` directories. It uses `os.walk` to traverse the directory tree and optionally displays a progress bar using `tqdm`.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\summarize_utils.py:summarize_chunked:12317445b02ef948f14f3d1245d435fb060203be8ea0cb54c4dfc718ccca074b:608697008310c2d0fde6d98631233d48fc609972c83ddfa2be2dd9a25b981e08": "The function `summarize_chunked` summarizes input text by either processing it as a single chunk or breaking it into smaller parts if the text exceeds token limits. It uses an LLM client and response cache for efficient processing, encoding the text with a tokenizer to determine token counts. If the total tokens fit within the available context, it directly summarizes the text. Otherwise, it splits the text into chunks based on a token budget and summarizes each chunk separately. The partial summaries are then merged recursively using a merging prompt until a final summary is produced. If any step fails, it falls back to returning sanitized text or an empty string. The function supports configurable system prompts, maximum context sizes, and chunk budgets.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:__init__:2ce74883893c6aa289d70ab4ebad667e240870913532447ab936d08ea6dace46:c50027e58b7f960d04877e92ae8f57aa41e095784c7cd532df334109834db318": "The `__init__` method initializes an instance of the `Dummy` class. It sets up an attribute called `calls`, which is initialized as an empty list. This list is intended to store dictionaries containing details about function or method calls, such as input text, prompt type, and system prompt.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:__init__:64afe75a4152f018898d1aacaac21f04e0389eb206a86c37786ef9f7662ec5a3:64cb6f0ff06c1b23645be8141c2f1d4a69ccb47f695a6e99e2db607c28e05550": "The `__init__` method initializes an instance of the `Dummy` class. It sets up an empty list named `calls`, which is intended to store processed calls or references. This list serves as a tracking mechanism for the operations performed by the class during text processing and summarization tasks. The attribute is initialized as an empty list and will be populated as the class processes sections and replaces placeholders in manual text.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:__init__:65041a5f3a73f27fe828c5d81464fdf66620235d6cd975a52f3a8ff3b035262f:63ea04ad6838630a0edb0f927bac23f6154af452f53f8822f988b0d6c9c82bb3": "The `__init__` method initializes an instance of the `Dummy` class. It establishes an internal attribute named `calls`, which is initialized as an empty list. Each element in this list will store a dictionary representing a recorded function or method call, containing details such as input text, prompt type, and an optional system prompt.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:__init__:684058ea950f7bf4791b8f49caec6e2baded1b24910bf07dbe6c782233129554:a1c1f3e4562e14a95c77f54796f16e9b5a577c836fe283316b5d018516b38a5f": "The `__init__` method initializes an instance of the `Dummy` class. It establishes an internal attribute named `calls`, which is initialized as an empty list. This list is intended to store dictionaries containing details about calls made to a summarization process. Each dictionary will hold information such as input text, prompt type, and system prompt, as tracked by the class. The method does not accept any parameters beyond the instance reference (`self`) and returns no value.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:__init__:856b79b0fc3d1728ffece37d3babb30613fff0d1ec2cfbfe3564e12a218b0c7c:d646cbbbac18fd66ada1cc37e38202a10ddc15c95e16e3ca7589da437c006ba1": "The `__init__` method initializes an instance of the `Dummy` class. It sets up the `calls` attribute as an empty list of dictionaries, which is used to track function or method calls. This attribute will store details about each recorded call in the form of dictionary entries.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:summarize:0720ef524223a95ac014c54f29755b177352a3d7c303c0c1d1b0bd963975f9a0:2beaa0a2e8474b4c8a29a73745554994cd8b887d975e41456cd38b0d7eaf817d": "The `summarize` method is a stub implementation within the `Dummy` class that returns a fixed, formatted string containing structured information about a demo project. It accepts a text input, a prompt type, and an optional system prompt, though these parameters are unused in the implementation. The returned string includes predefined sections such as overview, purpose, execution instructions, inputs, outputs, system requirements, and examples, all presented in a consistent format. This method serves as a placeholder and is not intended for actual use.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:summarize:08421a0b747a4f845d3d3478a098c806e7add193425273f673c7cfdcbda71d09:a09cf69a4628f3176656988f34741b667eeb94abca0d0b3e9d52d25fd91e9739": "The `summarize` method is a placeholder implementation within the `Stub` class that returns the string `\"guessed\"` regardless of the input parameters. It accepts a `prompt`, `prompt_type`, and an optional `system_prompt`, but does not perform any actual summarization. This method serves as a dummy interface for summarization functionality in the documentation generation tool.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:summarize:0a937ee9b72213583f1abc45649a4c525990d7acde7d35911b086ec8dac70a3e:3a9892b30f0c15e3dc806300969db7cf0a0041d3af2bfe00cc2b262e646179e2": "The `summarize` method processes a given text string to replace placeholder tokens with section identifiers. It extracts the manual text and section name using regular expressions, retrieves a token associated with the section from `explaincode.SECTION_PLACEHOLDERS`, and substitutes the token in the manual text with a formatted string indicating that the section has been filled. The input text is appended to the instance's `calls` list. The method returns the modified manual text with placeholders replaced.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:summarize:1f55e134b1bda074bab991bc5a63d866d13e91fdc357f085c32008314192ac35:e3f57bc9fa4b68b05f95b2ae2bb11cc44c2340e4a8eee82693b195dc91a7308a": "The `summarize` method of the `Dummy` class processes input text based on the content of a system prompt. If the system prompt contains \"How to Run\", it returns the string \"[[NEEDS_RUN_INSTRUCTIONS]]\". If the system prompt contains \"enhancing a user manual\", it extracts manual text from the input using a regular expression, replaces occurrences of \"[[NEEDS_RUN_INSTRUCTIONS]]\" with \"use it\", and returns the modified text. For all other cases, it returns the string \"x\".",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:summarize:8123e67bd5d8d3c398166d86e726afdb65a783656cb95b869fcc4c4f5c2c6f2e:a825a530e27e18060d66126598502f8341098ccd02c74dd6a70b2e2ed0eca5f3": "The `summarize` method of the `Dummy` class records call details by appending a dictionary containing the input `text`, `prompt_type`, and `system_prompt` to the `calls` list. It returns the string `\"final\"` if the provided `system_prompt` matches `explaincode.MERGE_SYSTEM_PROMPT`; otherwise, it returns the first word of the input `text`.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:summarize:84e6aabe489c035e0547ae1e603703f48c16ec7bc0728e02d7700e4c87440323:03987cc0a6eafa7e1390645e9da45f4cab415ca6c098d5d2c0096f7815b7856f": "The `summarize` method of the `Dummy` class returns a fixed string output formatted as \"Overview: x\\\\nHow to Run: [[NEEDS_RUN_INSTRUCTIONS]]\", regardless of the input parameters. It takes a text string, a prompt type, and an optional system prompt, but does not use them in the return value. This implementation serves as a placeholder that provides a consistent response structure without performing any actual summarization or processing of the input text.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:summarize:9a0963d7f74d96f1796f2c02820ebe40d12598b97646daa54112f7ac0e7debf7:747f39386ef03d2100655bced8ac778ebf489c002cf8bed3b8ce0bb9355fb105": "The `summarize` method appends a dictionary containing the input `text`, `prompt_type`, and `system_prompt` to the `self.calls` list. It then returns the string `\"done\"`. This method is used to log details of a summarization call without performing the actual summarization.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:summarize:a652cdf5a8af25753ce7fbc4cd8563cded4be62c79e293ebe104ed21dacb4797:10fad00cba7984aea762dbccacad1da66fe63479dc03c0ab987cb23105696d07": "The `summarize` method records information about a function or method call by appending a dictionary to the `self.calls` list. The dictionary contains the input `text`, the `prompt_type`, and an optional `system_prompt`. The method returns a string in the format `\"resp{N}\"`, where `N` is the current count of recorded calls.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:summarize:c6d1ec801ec874bed3fcfc066096802a2b55fab0f82a92eea8dd78d3bc549f5e:4a742771da9dbf9210023c6375079a82c79b004c6d02fe437737ea78e68f8faf": "The `summarize` method of the `SlowClient` class is a placeholder implementation that simulates a summarization process. It accepts a text input, a prompt type, and an optional system prompt. If the provided system prompt matches a specific chunk system prompt constant (`explaincode.CHUNK_SYSTEM_PROMPT`), the method introduces a delay using `time.sleep(delay)` before proceeding. Regardless of the input parameters or conditions, the method always returns the string `\"ok\"`. This implementation does not perform actual text summarization but serves as a mock client for testing or demonstration purposes within a documentation generation framework.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:summarize:d62b1aa7c215193b3dcb72421c826370408792d45a2d3503c32b8f940e1eadf4:295ea1c8208948efe0c9c9cd0616cc4abfc02396de8b143e0406678c9366134c": "The `summarize` method of the `Dummy` class records input details in the `calls` attribute as a dictionary containing `text`, `prompt_type`, and `system_prompt`. It returns the value of the variable `big` if the number of recorded calls is less than or equal to 2; otherwise, it returns the string `\"short\"`.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_llm_client.py:test_sanitize_summary_removes_fim_tokens:46657290d9a08dcb6020b86308758d6b20dc65e874884d2ab4cd158439a5f7ae:85bba61aaecb30810c244374dd70f79f6ddba4cd7089fc1c5e57a20ebb606bfa": "The function `test_sanitize_summary_removes_fim_tokens` tests that the `sanitize_summary` function removes FIM (Fix, Improve, Modify) reserved tokens from input text to prevent tokenizer errors. It asserts that when given the input string \"Defines \u3008fim_prefix\u3009a class.\", the output is \"Defines a class.\".",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_llm_client.py:test_summarize_does_not_stream_on_http_error:37ee74916efbb2697c43ad14da27492ff254de182e5b57fca1d566c4fd514d38:08f20f4a0a095b127db347d369cc97c7b60d5fe6336068ea0ef4ea34ff6821e3": "The function `test_summarize_does_not_stream_on_http_error` tests that streaming is not attempted when an HTTP request fails during the `summarize` operation. It creates a mock `LLMClient` with a fake HTTP endpoint, configures a mock response to raise an `HTTPError` and return a text error message, and patches the `requests.post` call to return this mock response. The test verifies that calling `client.summarize` raises a `RuntimeError` with the expected error message and ensures that `iter_content` is not called on the response, confirming no streaming occurs on HTTP failure.",
  "__progress__": {}
}