{
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\cache.py:ResponseCache:__init__:283588304f15e4b8f02e0474286ba4c1200ccede12e8640bd9d91f3295183773:283588304f15e4b8f02e0474286ba4c1200ccede12e8640bd9d91f3295183773": "Initializes an object with a file path. Loads JSON data from the file if it exists, otherwise initializes an empty dictionary. Ensures a \"__progress__\" key is present in the data dictionary, creating it if necessary.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\cache.py:ResponseCache:_save:d6c96e0258c810e9fec48856af580533cfc0aa8f13ea666bb1d396aa4abe5e41:d6c96e0258c810e9fec48856af580533cfc0aa8f13ea666bb1d396aa4abe5e41": "Writes the contents of `_data` to a file using JSON format with an indentation of 2 spaces and sorted keys. The file is encoded in UTF-8.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\cache.py:ResponseCache:b3c26f16b3f5ba57028ad791b37c078237183bde22e90e37cf8021d40ce50e5c:b3c26f16b3f5ba57028ad791b37c078237183bde22e90e37cf8021d40ce50e5c": "The `ResponseCache` class manages caching mechanisms for responses in a project that generates static HTML documentation for various programming languages using an LLM. It provides functionalities such as initializing with existing data, generating unique keys for cache entries, retrieving and storing cached values, managing progress maps, and saving the cache state to disk.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\cache.py:ResponseCache:clear_progress:4afabd3c72dd7481e402d4d9e731329ea3d6f3c362d796a37005901574f205f9:4afabd3c72dd7481e402d4d9e731329ea3d6f3c362d796a37005901574f205f9": "Removes all saved progress information from the instance and saves the changes.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\cache.py:ResponseCache:get:eeb84b4591575a8ed2767f4abac56f1f2dd0697e81322599734b8b31e94ddcce:eeb84b4591575a8ed2767f4abac56f1f2dd0697e81322599734b8b31e94ddcce": "Returns the cached value for a given key if it exists in the cache.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\cache.py:ResponseCache:get_progress:39ba9bd1b428ced00430a3d9e89153d2e8ee91f6f6623d13eafd158f4de0b69a:39ba9bd1b428ced00430a3d9e89153d2e8ee91f6f6623d13eafd158f4de0b69a": "The function `get_progress` retrieves and returns a dictionary representing the progress of processed module paths. It accesses a private attribute `_data` for this information, specifically looking for a key named \"__progress__\". If this key exists, it returns a shallow copy of its value as a new dictionary to prevent accidental modification of the original data.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\cache.py:ResponseCache:make_key:4f63c9f618b20a79035ed49cae07b9b800a46f352498e23dc8700f47c38fe96d:4f63c9f618b20a79035ed49cae07b9b800a46f352498e23dc8700f47c38fe96d": "Function `make_key` takes a file path and content as input, computes the SHA-256 hash of the content, and returns a deterministic key formatted as \"file_path:hash\".",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\cache.py:ResponseCache:set:0bc8af7637662ae14e3eca8604a4d7155ff442d423955a243d6b586ffee8d8ba:0bc8af7637662ae14e3eca8604a4d7155ff442d423955a243d6b586ffee8d8ba": "Stores a `value` associated with a `key` in an internal dictionary `_data`, then persists the changes to disk by calling `_save()`.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\cache.py:ResponseCache:set_progress_entry:5213bc08e476bb362c55f096cf9227f60da37d1862f66ae21b376f8dbf55a79f:5213bc08e476bb362c55f096cf9227f60da37d1862f66ae21b376f8dbf55a79f": "Records `module_data` for a given `path` in a progress map and saves the updated data.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\cache.py:__init__:65e99db4e0154f5162844567b3b5898687f3c5ba589620bb23bbf1c373488d26:65e99db4e0154f5162844567b3b5898687f3c5ba589620bb23bbf1c373488d26": "Initializes a `ResponseCache` instance with a file path. If the file exists, it reads and parses JSON data into `_data`. If the file does not exist or contains invalid JSON, `_data` is initialized as an empty dictionary. Ensures that a progress map is present in `_data`, creating it if necessary.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\cache.py:__init__:7248cf135f7f7618aa9a0d6511b056e99a1c6a6aa46c7a2975ec424a41b6e0e7:7248cf135f7f7618aa9a0d6511b056e99a1c6a6aa46c7a2975ec424a41b6e0e7": "Initializes a `ResponseCache` instance with a specified path. Reads an existing JSON file if it exists, parsing its contents into a dictionary. If the file does not exist or is invalid JSON, initializes an empty dictionary. Ensures that a progress map is present in the data dictionary.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\cache.py:_save:658fa165379c4016cf5c1380d9c835936da5ffe3d69e9cdcb8c98eecfa577ca9:658fa165379c4016cf5c1380d9c835936da5ffe3d69e9cdcb8c98eecfa577ca9": "This function `_save` is a method of the `ResponseCache` class. It saves the data stored in the `_data` attribute to a file using the `file` attribute. The data is serialized to JSON format with an indentation of 2 spaces and sorted keys for better readability. The encoding used for writing the file is UTF-8.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\cache.py:_save:a2df77d674fbd042d8e9c130d7c1a0b4fa99e84e12ae946948d9f840202dc04a:a2df77d674fbd042d8e9c130d7c1a0b4fa99e84e12ae946948d9f840202dc04a": "The function `_save` writes the contents of `self._data`, formatted as JSON with an indentation of 2 spaces and sorted keys, to a file using `self.file.write_text`. The text is encoded in UTF-8.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\cache.py:b7996266039c2634cf466bed532ccc6ffe7e701fec85156374b5bb40d1ebd2f5:b7996266039c2634cf466bed532ccc6ffe7e701fec85156374b5bb40d1ebd2f5": "A simple on-disk cache for Language Model (LLM) responses. Implements methods to store and retrieve LLM responses using deterministic keys derived from file paths and content. Includes functionality to manage progress data for processed modules. Cache is persisted to disk in JSON format.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\cache.py:clear_progress:6115facec5a1571f710a59a500c3368ee7051d7273455b591b8cf69f3f2a1de9:6115facec5a1571f710a59a500c3368ee7051d7273455b591b8cf69f3f2a1de9": "This function, `clear_progress`, is part of the `ResponseCache` class. It removes all saved progress information from the cache by setting the value associated with the key `\"__progress__\"` to an empty dictionary. After updating the data, it calls the `_save` method to persist the changes.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\cache.py:clear_progress:a29c32a93a66463da7daaa6e77d580c9d5067f7b0ed9e68f44ba217bc443a2b9:a29c32a93a66463da7daaa6e77d580c9d5067f7b0ed9e68f44ba217bc443a2b9": "The `clear_progress` method in the `ResponseCache` class removes all saved progress information by setting the value of the key `\"__progress__\"` to an empty dictionary within the `_data` attribute. It then calls the `_save` method to persist these changes.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\cache.py:get:5e3adbdd1b27b9c841c70a509672834f7faa862e62344e6babe6e338ad232941:5e3adbdd1b27b9c841c70a509672834f7faa862e62344e6babe6e338ad232941": "This function is part of the `ResponseCache` class. It defines a method to retrieve a cached value associated with a given key. The method takes one parameter, `key`, which is a string representing the cache key. If the key exists in the `_data` dictionary of the `ResponseCache` instance, it returns the corresponding cached value; otherwise, it returns `None`.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\cache.py:get:ba2551f915aeffa334341b44e9c94784caea65ed774339df7eaf1fc7245bb1f5:ba2551f915aeffa334341b44e9c94784caea65ed774339df7eaf1fc7245bb1f5": "The function `get` in the class `ResponseCache` retrieves the cached value associated with a given key. It returns the value if it exists, otherwise, it returns `None`.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\cache.py:get_progress:5dabcf90a5b8a0c9b02bc5fb7b8f47c0f25933bc5231970524288b333c8d903a:5dabcf90a5b8a0c9b02bc5fb7b8f47c0f25933bc5231970524288b333c8d903a": "This function `get_progress` is part of the `ResponseCache` class. It returns a dictionary representing the progress of processed module paths and their associated data. The function retrieves this information from an internal `_data` attribute, specifically accessing the value associated with the key `\"__progress__\"`. If no such key exists, it defaults to an empty dictionary. To prevent accidental modification of the returned data, the function returns a shallow copy of the progress dictionary using `dict(progress)`.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\cache.py:get_progress:7fcc4a0b6edaca23a4505c81e1855c0238456d6c55ea38ce3fea22db19b5a1aa:7fcc4a0b6edaca23a4505c81e1855c0238456d6c55ea38ce3fea22db19b5a1aa": "The function `get_progress` in the class `ResponseCache` returns a dictionary representing the progress of processed module paths and their associated data. It retrieves this information from an internal `_data` attribute, specifically accessing the value associated with the key `\"__progress__\"`. If no such key exists, it defaults to an empty dictionary. The function then returns a shallow copy of this progress dictionary to prevent accidental modifications by external code.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\cache.py:make_key:1f593e8984573caf6e9db1a32bad2683b02c2ff19e073a331d96f7495d50aabd:1f593e8984573caf6e9db1a32bad2683b02c2ff19e073a331d96f7495d50aabd": "The function `make_key` in the class `ResponseCache` generates a deterministic key based on a file path and its content. It uses SHA-256 hashing to create a unique digest for the content, then combines this digest with the file path using a colon as a separator. This key can be used to cache responses or data associated with specific files and their contents.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\cache.py:make_key:a56639922e4392a86c5162a144306d0167b4ad39e8da78747f6c40800d978c9b:a56639922e4392a86c5162a144306d0167b4ad39e8da78747f6c40800d978c9b": "This function generates a deterministic key for a given file path and content. It uses the SHA-256 hash algorithm to create a unique digest of the content, then combines this digest with the file path to form a key. The key is returned as a string in the format \"file_path:digest\".",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\cache.py:set:44bf080ec4fbf07efb86c4ba4fcdbb7043e56d5ff4f9d797beb85c4131876e51:44bf080ec4fbf07efb86c4ba4fcdbb7043e56d5ff4f9d797beb85c4131876e51": "This function is part of a class `ResponseCache` and is named `set`. It takes two parameters: `key` (a string) and `value` (a string). The function stores the provided `value` under the specified `key` within an internal data structure (`self._data`). After storing the value, it calls another method `_save()` to persist this change to disk.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\cache.py:set:ff82763ae925b6c4225c75e7586458b4704ca83db1b771fa7b90c2804419741d:ff82763ae925b6c4225c75e7586458b4704ca83db1b771fa7b90c2804419741d": "Stores a `value` under a specified `key` in the cache and persists the changes to disk.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\cache.py:set_progress_entry:170c49963f34f58824d57a89431a62d594b5113ea23f20d959a02ea7a4141513:170c49963f34f58824d57a89431a62d594b5113ea23f20d959a02ea7a4141513": "Records `module_data` for a given `path` in the progress map and saves the updated progress.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\cache.py:set_progress_entry:18ee10626740a9d7bf29e77e0640a07c3d138e1deb592be6f9d39ed460b3b0e5:18ee10626740a9d7bf29e77e0640a07c3d138e1deb592be6f9d39ed460b3b0e5": "Records `module_data` for a given `path` in the progress map and saves the changes.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\chunk_utils.py:9148eb950a26929210792751150dea2da5c0a8399b370e1ed539eb2faeed37b0:9148eb950a26929210792751150dea2da5c0a8399b370e1ed539eb2faeed37b0": "The module provides utility functions for tokenization and text chunking. It includes:\n\n1. `strip_fim_tokens(text: str) -> str`: Removes FIM special tokens from the input text.\n2. `get_tokenizer()`: Returns a tokenizer object used for estimating token counts, using `tiktoken` if available or a simple character-based tokenizer otherwise.\n3. `_split_blocks(text: str) -> List[str]`: Splits Markdown text into paragraphs, headings, and fenced code blocks.\n4. `_split_long_block(block: str, tokenizer, chunk_size_tokens: int) -> List[str]`: Fallback splitter that uses a character-based approximation to split long blocks exceeding the specified token size.\n5. `chunk_text(text: str, tokenizer, chunk_size_tokens: int) -> List[str]`: Splits text into chunks roughly of the specified token size, honoring natural break points like blank lines, Markdown headings, and fenced code blocks. If a single block exceeds the token size, it falls back to splitting by approximate character length.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\chunk_utils.py:_Simple:8214eca705f75142b5f7b3127e0df9db8b3486e2ff4789ead63c33a51c8dce9c:8214eca705f75142b5f7b3127e0df9db8b3486e2ff4789ead63c33a51c8dce9c": "The `_Simple` class in the project provides utility methods for encoding and decoding text. The `encode` method removes FIM tokens from a given string and splits it into a list of words, while the `decode` method joins a list of tokens back into a single string with spaces.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\chunk_utils.py:_Simple:decode:0063ff559a778604c0b04e065f2daad212b42862c65cdd97a4fe338261b13bd3:0063ff559a778604c0b04e065f2daad212b42862c65cdd97a4fe338261b13bd3": "The function `decode` takes a list of tokens as input and returns a string where each token is separated by a space.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\chunk_utils.py:_Simple:encode:aa827c73b9b4f1291471e35dcaad0a352e62db69ae2c71f3c7bf8ac77bf42653:aa827c73b9b4f1291471e35dcaad0a352e62db69ae2c71f3c7bf8ac77bf42653": "The function `encode` takes a string `text` as input. It first removes any FIM tokens from the text using the `strip_fim_tokens` function. Then, it splits the cleaned text into a list of words and returns this list.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\chunk_utils.py:_split_blocks:e10ee3688728cbf950eeb0c4fb6c590496fa42bddbdc6ecc84cea6314784ff0d:e10ee3688728cbf950eeb0c4fb6c590496fa42bddbdc6ecc84cea6314784ff0d": "The `_split_blocks` function takes a string of Markdown text and splits it into paragraphs, headings, and code blocks. It returns a list of these blocks as strings. The function processes the input line by line, identifying code fences (indicated by triple backticks), empty lines, and heading lines (indicated by hash symbols). It constructs each block based on these delimiters and appends them to a list, which is then returned after filtering out any empty strings.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\chunk_utils.py:_split_long_block:5faeee8fdfafab78a7dd2dbd1d3116108749ee3dbb9a779ae99708faa8b9e745:5faeee8fdfafab78a7dd2dbd1d3116108749ee3dbb9a779ae99708faa8b9e745": "This function `_split_long_block` takes a string `block`, a tokenizer, and an integer `chunk_size_tokens`. It encodes the block into tokens using the provided tokenizer. If the number of tokens is less than or equal to `chunk_size_tokens`, it returns the original block as a single element list. Otherwise, it calculates an average character size per token and determines a maximum character length for each chunk based on this average. The function then splits the block into chunks of up to `max_chars` characters and returns these chunks as a list.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\chunk_utils.py:chunk_text:aae8d2596c0690cc1b3e498828c252bd6850dc29ec0e434893c4b75fd7aafac8:aae8d2596c0690cc1b3e498828c252bd6850dc29ec0e434893c4b75fd7aafac8": "The function `chunk_text` splits a given text into chunks of approximately specified token size. It uses a tokenizer to determine the number of tokens in each block and ensures natural break points such as blank lines, Markdown headings, and fenced code blocks are respected. If a single block exceeds the token limit, it is further split by character length. The function returns a list of text chunks.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\chunk_utils.py:decode:6e7cddbf1dae594101b04816037acd1f331da96fa0f9d586ad14abb8c67f7a8b:6e7cddbf1dae594101b04816037acd1f331da96fa0f9d586ad14abb8c67f7a8b": "This function `decode` takes a list of tokens as input and returns a single string by joining all the tokens with spaces in between.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\chunk_utils.py:encode:05c1461c94870abb3c6fff8b74720eae59c21c3fd12868b78d9ee6d3e3147253:05c1461c94870abb3c6fff8b74720eae59c21c3fd12868b78d9ee6d3e3147253": "The `encode` method in the `_Simple` class takes a string `text` as input. It first removes any FIM tokens from the text using the `strip_fim_tokens` function. Then, it splits the cleaned text into a list of words and returns this list.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\chunk_utils.py:get_tokenizer:252099efcefb2bdd13b9af01b036c26a92c4f6cd8dc2a0b1733e0bccdb09b479:252099efcefb2bdd13b9af01b036c26a92c4f6cd8dc2a0b1733e0bccdb09b479": "The function `get_tokenizer` returns a tokenizer object used for estimating token counts. It first attempts to use the `tiktoken` library with the encoding \"cl100k_base\". If successful, it wraps the tokenizer in a `_EncodingWrapper` class that strips FIM tokens and handles decoding. If `tiktoken` is not available or fails, it falls back to a simple tokenizer that splits text into words and joins them back together.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\chunk_utils.py:strip_fim_tokens:b6002f9ad8bc5856406a4f468773d932628efeb07bb5b88fdb60b8ff26099b7b:b6002f9ad8bc5856406a4f468773d932628efeb07bb5b88fdb60b8ff26099b7b": "The function `strip_fim_tokens` removes any FIM special tokens from the input string `text`. It uses a regular expression defined in `FIM_RE` to identify and replace these tokens with an empty string.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\docgenerator.py:790e84c9f06963fa4a190b32761e9ec794933f749bba99c58330687b57f958c9:merge0:ee6b906d428e21c50efd63ddd6052cf2252523b40ad18128f5682c03e655a725": "This module provides a command-line interface for generating HTML documentation from source code files. It scans directories for Python, MATLAB, C++, and Java files, parses them, requests summaries from a running language model (LLM), and writes the summaries to HTML files. The module includes functions for summarizing classes and methods recursively, rewriting docstrings with context, and parsing various programming languages. It handles command-line arguments for specifying the source directory, output directory, and other options. The script processes Python, C++, Java, and MATLAB files, generating summaries and HTML pages based on the parsed data.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\docgenerator.py:790e84c9f06963fa4a190b32761e9ec794933f749bba99c58330687b57f958c9:part0:6f455d4018be53ca6673dae7ee8ef8ea25ac236aa3f05027ef856efdd324c009": "This module provides a command-line interface for generating HTML documentation from source code files. It scans directories for Python, MATLAB, C++, and Java files, parses them, requests summaries from a running language model (LLM), and writes the summaries to HTML files.\n\nThe module includes several functions:",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\docgenerator.py:790e84c9f06963fa4a190b32761e9ec794933f749bba99c58330687b57f958c9:part1:2525e47e8dcb5b6e66d4b57e251aaa6fe5dc924d2317c8b1b62328461a5d13f9": "This code defines a script for generating HTML documentation using a local language model (LLM). It includes functions for summarizing classes and methods recursively, rewriting docstrings with context, and parsing various programming languages. The script also handles command-line arguments for specifying the source directory, output directory, and other options. It processes Python, C++, Java, and MATLAB files, generating summaries and HTML pages based on the parsed data.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\docgenerator.py:_build_function_prompt:5d55327afc8e8d938bdad0afd3b133535d142332da56ec01baf975b51ddb67aa:5d55327afc8e8d938bdad0afd3b133535d142332da56ec01baf975b51ddb67aa": "This function `_build_function_prompt` constructs a context-enriched prompt for summarizing a given Python function. It takes four parameters: `source` (the function's source code), `class_name` (optional, the name of the class containing the function), `class_summary` (optional, a summary of the class), and `project_summary` (optional, a summary of the project). The function returns a string that includes these contextual elements followed by the prompt to summarize the function based on its source code.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\docgenerator.py:_chunk_module_by_structure:3efe396b5851381dc0cef1bfd9d4662c1a7630c273356c856129925c26b89e6c:3efe396b5851381dc0cef1bfd9d4662c1a7630c273356c856129925c26b89e6c": "The function `_chunk_module_by_structure` processes a parsed Python module and divides its content into text chunks based on the specified token size. It first extracts the module's docstring and adds it to the blocks list if present. Then, it iterates through classes, methods, variables, and functions within the module, adding their source code to the blocks list. The function then processes these blocks to create chunks that do not exceed the given token size. If a block exceeds the token size, it is further chunked using another function (`chunk_text`). The resulting chunks are returned as a list.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\docgenerator.py:_insert:8956bc54c38b988eda41663bcd16d0c7d12542e816c2dc0bcda5316acc7eabd3:8956bc54c38b988eda41663bcd16d0c7d12542e816c2dc0bcda5316acc7eabd3": "This function `_insert` inserts a file or directory structure into a nested dictionary (`tree`). It takes three parameters: `tree`, which is the nested dictionary representing the file system; `parts`, which is a list of strings representing the path to the file or directory; and `name`, which is the name of the file or directory, and `link`, which is likely a URL or other reference. The function recursively navigates through the `tree` based on the elements in `parts`. When it reaches the last element in `parts`, it inserts `(name, link)` into the dictionary at that location under the key `\"__files__\"`. If any intermediate keys do not exist in the `tree`, they are created as empty dictionaries.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\docgenerator.py:_merge_recursive:7bcd694793bc49c1e49896c04efdc2f5f919b18e58ce51003bf6fcab7b4358ce:7bcd694793bc49c1e49896c04efdc2f5f919b18e58ce51003bf6fcab7b4358ce": "The function `_merge_recursive` is designed to merge a list of strings (likely documentation snippets) into a single string that fits within specified token limits. It uses recursion to handle the merging process, breaking down larger groups when necessary. The function generates prompts by joining the items with bullet points and checks if the prompt length exceeds the allowed token budget. If it does, it further breaks down the list until all parts fit within the limit. This ensures that the generated documentation is concise yet comprehensive.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\docgenerator.py:_rewrite_docstring:aad406573763aadd41f04af30655d132e152aba79e42582c25f15da649e0ea12:aad406573763aadd41f04af30655d132e152aba79e42582c25f15da649e0ea12": "The function `_rewrite_docstring` rewrites the docstring of a code item using optional context provided by class and project summaries. It uses an LLM client to generate a new docstring based on the source code, existing docstring, and additional context if available. The function handles caching of responses to avoid redundant computations. If no source or docstring is found, it prints a warning.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\docgenerator.py:_summarize:75165a2e152d96253493883a701f189426be8578f837fd76d51c3e8d6df84cbd:75165a2e152d96253493883a701f189426be8578f837fd76d51c3e8d6df84cbd": "The function `_summarize` takes an `LLMClient`, a `ResponseCache`, a `key`, a `text`, and a `prompt_type`. It checks if the summary for the given key is cached. If it is, it sanitizes the cached text to avoid tokenizer errors. If not, it generates a new summary using the LLM client and caches it before returning it.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\docgenerator.py:_summarize_class_recursive:878f0b9558c1bcfd9a93d799c87b33db9b4a4dfa6fd0063878829245956641c4:878f0b9558c1bcfd9a93d799c87b33db9b4a4dfa6fd0063878829245956641c4": "This function `_summarize_class_recursive` is designed to recursively summarize a class and its members, including methods and variables. It takes in the class data, path, project summary, tokenizer, LLM client, response cache, maximum context tokens, and chunk token budget as parameters.\n\nThe function first calls `_summarize_members_recursive` to handle summaries of methods and variables within the class. It then constructs a prompt using a predefined `CLASS_PROMPT` format, which includes the class name, project summary, method summaries, and variable summaries. This prompt is used to generate a summary for the class itself.\n\nThe function uses a cache key to retrieve or generate a summary for the class using `_summarize_chunked`, ensuring that the summary is sanitized with `sanitize_summary`. It then updates the class data with the new summary, replacing both the original docstring and the summary field. If an original docstring exists, it calls `_rewrite_docstring` to rewrite the docstring of the class.\n\nThe function also iterates over each method and variable within the class, calling `_rewrite_docstring` for them, passing along the class name, class summary, and project summary. Finally, if the class has subclasses, the function recursively calls itself to summarize each subclass",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\docgenerator.py:_summarize_function_recursive:eef049e609a3c46a5467570ace9a50bad3351783f6eb6ce7f3e395ce0c3b4766:eef049e609a3c46a5467570ace9a50bad3351783f6eb6ce7f3e395ce0c3b4766": "This function, `_summarize_function_recursive`, is designed to recursively summarize a given function (`func`) and its associated subfunctions and subclasses. It utilizes an LLM client for generating summaries and a caching mechanism to store previously generated responses.\n\nThe function takes several parameters:\n\nThe function performs the following steps:\n1. Constructs a prompt for summarizing the function using `_build_function_prompt`.\n2. Generates a cache key using the path, function name, and prompt.\n3. Summarizes the function using `_summarize_chunked` and",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\docgenerator.py:_summarize_members_recursive:cbed4a3cb8c45058ffeaac575fb1ecef0b81d83c5b17195485fe28ed284a4a22:cbed4a3cb8c45058ffeaac575fb1ecef0b81d83c5b17195485fe28ed284a4a22": "This function recursively summarizes methods and variables within a class, including their subclasses. It uses an LLMClient to generate summaries for each method and variable, caching results to avoid redundant requests. The function iterates through all methods and variables in the provided class data, generating summaries using the `_summarize_chunked` function. For each method or variable, it updates the `summary` and `docstring` fields with the generated summary. The function also recursively processes any subclasses of the current class, ensuring that all members are summarized.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\docgenerator.py:_summarize_module_chunked:569d525efd3a2b269d06ba1fc012fd35309db90c0849236507ffbf0308055c4d:569d525efd3a2b269d06ba1fc012fd35309db90c0849236507ffbf0308055c4d": "This function `_summarize_module_chunked` is designed to summarize a Python module by breaking it into manageable chunks and using an LLM (Language Model) for summarization. It handles the following steps:\n\n1. **Template Preparation**: Prepares a template for summarizing modules.\n2. **Token Budget Calculation**: Calculates available tokens based on the maximum context size and overhead from system prompt and template.\n3. **Chunking**: If the module text is too large, it attempts to chunk the module by structure using `_chunk_module_by_structure`. If this fails, it falls back to summarizing the entire module.\n4. **Recursive Summarization**: For each chunk, it recursively summarizes them into a single technical paragraph.\n5. **Merging Summaries**: Combines all partial summaries into a final summary, ensuring it fits within the available token budget.\n\nThe function uses caching (`ResponseCache`) to avoid redundant summarizations and handles exceptions gracefully by logging warnings and sanitizing outputs in case of failures.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\docgenerator.py:clean_output_dir:0698a0448ba76969fbb6317fc3e2da8e5010839d0a2e765f1c4638aae7068025:0698a0448ba76969fbb6317fc3e2da8e5010839d0a2e765f1c4638aae7068025": "The function `clean_output_dir` takes a string representing the path to an output directory and iterates through all files within that directory. If a file has a `.html` extension, it reads the first line of the file. If the first line contains the string \"Generated by DocGen-LM\", the file is deleted. Any exceptions encountered during this process are caught and printed as warnings.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\docgenerator.py:main:a8fa4e8f4e601316247fb5cac88262735ce29b9bc989194ab67329f560babf6e:a8fa4e8f4e601316247fb5cac88262735ce29b9bc989194ab67329f560babf6e": "The `main` function serves as the entry point for generating HTML documentation using a local LLM. It parses command-line arguments to configure settings such as source directory, output path, and LLM parameters. The function initializes an LLM client, sets up tokenization, and manages caching for progress and responses.\n\nIt processes files in the specified source directory, parsing them based on their file extensions (Python, C++, Java, MATLAB) using corresponding parser functions. Each parsed file is summarized using a chunked approach to handle large texts efficiently. The summaries are stored in a cache for potential reuse.\n\nThe function constructs a navigation tree and project outline, which are used to generate the HTML documentation structure. It also processes Markdown files within the source directory, summarizing their content if they exist.\n\nAfter generating summaries for classes and functions, the main function writes the index page and individual module pages to the output directory. If not resuming from previous progress or clearing it explicitly, it clears the cache after processing all files. The function returns 0 upon successful completion.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:5c43aa85822144159cdb19689df89d86e6e5d4d653e2c12166248aeee5cd442a:merge0:65bda65c617cf61e8d3ed0d02e4da5224323d8fd9dea408a3c76b14a53ae00dd": "This module provides a comprehensive system for generating project summaries from existing documentation and sample files. It includes classes and functions for parsing configuration, collecting relevant files, slugifying text, inserting links into indices, extracting text from various file types, detecting placeholders, mapping evidence to sections, ranking code files, and more. Specifically, it offers functionalities such as `extract_snippets` to extract code snippets from specified files within given constraints, `scan_code` to collect source code snippets from a base directory grouped by manual sections based on predefined keywords, and `llm_generate_manual` to generate a user manual from collected documentation snippets using an LLM. Additionally, it provides utilities for rendering HTML from structured sections of a manual, parsing plain text into structured sections, validating references within sections, inferring missing sections, and converting HTML to PDF. The module also interacts with an LLMClient for generating summaries and inferring missing sections when required. Finally, the `main` function sets up command-line arguments for summarizing project documentation, collects documentation files, extracts text from them, generates a manual using an LLM client, fills placeholders if necessary, renders the manual in HTML or PDF format, inserts a link to the manual into an index file if specified, and saves the evidence map as a",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:5c43aa85822144159cdb19689df89d86e6e5d4d653e2c12166248aeee5cd442a:part0:cad03170c79ae4f0d1d2f36c57f3909c62a26464f20a175abadc08436cee8417": "This module defines a system to generate project summaries from existing documentation and sample files. It includes classes and functions for parsing configuration, collecting relevant files, slugifying text, inserting links into indices, extracting text from various file types, detecting placeholders, mapping evidence to sections, ranking code files, and more.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:5c43aa85822144159cdb19689df89d86e6e5d4d653e2c12166248aeee5cd442a:part1:1d7f8b24a1310f8f2ff2b36d1a1e2d3af8011bf41c2706426d0f025a6d5852db": "The module provides functions to extract relevant code snippets from files, collect these snippets into sections based on keywords, and generate a manual from the collected snippets using an LLM (Large Language Model). It includes:\n\n1. `extract_snippets`: Extracts code snippets from specified files within given constraints such as maximum number of files, time budget, and file size.\n2. `scan_code`: Collects source code snippets from a base directory grouped by manual sections based on predefined keywords.\n3. `llm_generate_manual`: Generates a user manual from collected documentation snippets using an LLM, mapping snippets to sections and assembling the final text.\n4. `llm_fill_placeholders`: Fills placeholder tokens in the generated manual with relevant information from code snippets using another LLM call.\n5. `_edit_chunks_in_editor`: Opens chunks of text in the user's editor for optional modification and returns the edited chunks after editing is complete.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:5c43aa85822144159cdb19689df89d86e6e5d4d653e2c12166248aeee5cd442a:part2:728ef003d9b9cf619f2797bd3f130e29e504e38c3a5e8a9633d300640b8df8a4": "This module provides functions to render HTML from structured sections of a manual, parse plain text into structured sections, validate references within sections, infer missing sections, and convert HTML to PDF. It includes utilities for slugifying text, escaping HTML, and handling Markdown conversion. The module also interacts with an LLMClient for generating summaries and inferring missing sections when required.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:5c43aa85822144159cdb19689df89d86e6e5d4d653e2c12166248aeee5cd442a:part3:a9277aadc6312b031707b1eddb8a882d73e638ba5c39005838093b1f6829288b": "This module defines a `main` function that sets up command-line arguments for summarizing project documentation. It uses the `argparse` library to parse these arguments and configures a `Config` object with the provided values. The function then collects documentation files, extracts text from them, and generates a manual using an LLM (Large Language Model) client. If placeholders are missing in the generated manual, it scans project code to fill these gaps. Finally, it renders the manual in either HTML or PDF format, optionally inserting a link to the manual into an index file, and saves the evidence map as a JSON file.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:Config:066c59da22b2047b39a6fbbbd52fd3fa465ad446e16bd9ca79e88394368fc9e7:066c59da22b2047b39a6fbbbd52fd3fa465ad446e16bd9ca79e88394368fc9e7": "The `Config` class in the DocGen-LM project is designed to manage configuration settings for generating static HTML documentation from source files. It supports various functionalities including nested structures, language-specific parsers, caching mechanisms, and user interface options for customization and progress tracking.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:_edit_chunks_in_editor:be5b68768f9b9778c86b837e1ccc0c49900f88f9ee628de064a064d02e157af0:be5b68768f9b9778c86b837e1ccc0c49900f88f9ee628de064a064d02e157af0": "This function `_edit_chunks_in_editor` takes a list of string chunks, opens them in the user's default editor for optional modification, and returns the edited chunks. Chunks are separated by lines containing `---`. Empty chunks are discarded after editing. The function uses Python's `tempfile.NamedTemporaryFile` to create a temporary file with the initial content, invokes the editor specified by the environment variables `EDITOR` or `VISUAL`, reads the modified content back from the file, and then cleans up the temporary file before returning the edited chunks.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:_slugify:4047290d43e7a5b29de69bb9d1fa064b70058652d001657cf5f805e43e5d7dbc:4047290d43e7a5b29de69bb9d1fa064b70058652d001657cf5f805e43e5d7dbc": "The `_slugify` function takes a string `text` as input and returns a URL-friendly slug. It converts the text to lowercase and replaces all non-alphanumeric characters with hyphens, then trims any leading or trailing hyphens from the result.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:collect_docs:2a886c87a23d399bff59a9bc7d4849728f618d198ba3429716d2c73f90f34009:2a886c87a23d399bff59a9bc7d4849728f618d198ba3429716d2c73f90f34009": "The `collect_docs` function scans a project directory for documentation files. It looks for files with extensions like `.md`, `.txt`, `.html`, and `.docx` in the project root and in a subdirectory named `docs`. The function uses glob patterns to match these file types and collects them into a list, ensuring that each file is only included once even if it appears multiple times under different patterns.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:collect_files:c8a2ce253854d9ece7e518ee3bb431551ea241c2d474e40c3e34226999afd1df:c8a2ce253854d9ece7e518ee3bb431551ea241c2d474e40c3e34226999afd1df": "The `collect_files` function returns a list of file paths from the specified base directory that are relevant for summarization. It starts with a default set of patterns to include files like README.md, text files (*.txt), HTML files (*.html), Word documents (*.docx), CSV files (*.csv), JSON files (*.json). If additional patterns are provided through `extra_patterns`, it includes those as well. The function ensures that only unique files are returned by using a set to track seen files and filtering out duplicates.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:detect_placeholders:8eb95fc0a1c02dfbb6d726abcc89aaf5258e4a30265ad21e7d748624affdfffd:8eb95fc0a1c02dfbb6d726abcc89aaf5258e4a30265ad21e7d748624affdfffd": "The `detect_placeholders` function takes a string of text as input and returns a list of section names that are still marked with placeholder tokens. It does this by first calling the `find_placeholders` function to identify all placeholder tokens present in the text. Then, it filters these tokens against a predefined dictionary `SECTION_PLACEHOLDERS`, which maps section names to their corresponding placeholder tokens. The function returns a list of section names for which the placeholder token is found in the input text.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:extract_snippets:b962e207250625a6ec74ec9be8e11c987fe15db00e7222bee638efe23e861b42:b962e207250625a6ec74ec9be8e11c987fe15db00e7222bee638efe23e861b42": "The `extract_snippets` function processes a list of Python files to extract relevant code snippets. It iterates through each file, checking for a maximum number of files (`max_files`) and a time budget (`time_budget`). For each file, it reads the text up to a maximum byte size (`max_bytes`). If the file is a Python script, it parses the AST to find docstrings and specific patterns related to I/O operations, command-line interfaces (CLI), and the `__main__` block. The extracted snippets are stored in a dictionary with the file path as the key.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:extract_text:7d9b846d5d317aba9ec60db5c23057c9d1b350de6c05815894ee8ad9485c495f:7d9b846d5d317aba9ec60db5c23057c9d1b350de6c05815894ee8ad9485c495f": "The `extract_text` function reads and processes the content of a file located at the given `path`. It determines the file type based on its suffix and applies specific processing to extract plain text. For HTML files, it uses BeautifulSoup to clean up the content by converting headings and code blocks into Markdown format, then extracts and returns the plain text. For Markdown files, it simply reads and returns the text. For DOCX files (if the `Document` class is available), it parses the document, identifies headings, and converts them into Markdown format before returning the extracted text. If any exceptions occur during processing, the function returns an empty string.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:infer_sections:f71c459bc0710b67cf1d0f410c2ee478d90b53a045ae00f86db65b017d4eecec:f71c459bc0710b67cf1d0f410c2ee478d90b53a045ae00f86db65b017d4eecec": "The `infer_sections` function takes a string of plain text and attempts to infer manual sections from it. If the input text is non-empty, it places the entire text under an \"Overview\" section and generates placeholder content labeled \"(inferred)\" for any other required sections. If the input text is empty, it initializes all required sections with a default message indicating that no information is available. The function returns a dictionary where keys are section names and values are the corresponding content.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:inject_user_manual:4129f6632ed802108dc5bce130559ba569e27ce894dcee73c5d1982eaa04245d:4129f6632ed802108dc5bce130559ba569e27ce894dcee73c5d1982eaa04245d": "Inserts a top-level link to a user manual into an HTML file. The link is added to the first navigation element (`<nav>` or `<ul>`) if present; otherwise, it is inserted at the start of the first element in `<body>` or the document root.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:insert_into_index:af6d1533eb9d02e388a3161d531f5caac2d2f8fd3bfd2d3329e2749f1f64da77:af6d1533eb9d02e388a3161d531f5caac2d2f8fd3bfd2d3329e2749f1f64da77": "This function `insert_into_index` appends a navigation entry linking to a specified file into an HTML index file. It takes three parameters: `index_path`, which is the path to the HTML index file; `title`, which is the title of the navigation entry; and `filename`, which is the name of the file being linked. The function reads the content of the index file using BeautifulSoup, searches for a container element (`ul` or `nav`), and checks if an existing link with the same filename exists. If not, it creates a new anchor tag with the specified title and href attribute, appends it to the appropriate container, and writes the modified HTML back to the index file.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:llm_fill_placeholders:b68c38d5d50d94fbc61d5cc418e109558a51201fc6925ba2ba6832d0538a4eea:b68c38d5d50d94fbc61d5cc418e109558a51201fc6925ba2ba6832d0538a4eea": "The `llm_fill_placeholders` function fills placeholder tokens in a manual text using code snippets. It maps section names to dictionaries of file paths and corresponding text containing evidence for those sections. The function iterates over each section, concatenating the code snippets into a single string. If the combined token usage exceeds the maximum context tokens, it summarizes the chunked snippet before sending it to an LLM for processing. A prompt is created by combining the manual text, section name, and code snippets. The function then updates the manual by replacing the placeholder with relevant information from the code snippets using another call to `summarize_chunked`. It logs the filled section and the files used for filling.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:llm_generate_manual:413789d1396ac9034cac8252b60b97895a90042275951a2f560f9cbfdf954477:413789d1396ac9034cac8252b60b97895a90042275951a2f560f9cbfdf954477": "The `llm_generate_manual` function processes documentation snippets to generate a user manual. It maps snippets to sections, performs LLM calls per section, and assembles the final manual text. The function returns the manual text, a mapping of source files to sections, and an evidence map capturing used snippets.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:main:84cb97c33067c31097a4687d42a5842af384be59ae8758688141cbdee1c83959:84cb97c33067c31097a4687d42a5842af384be59ae8758688141cbdee1c83959": "The `main` function serves as the entry point for the DocGen-LM tool. It parses command-line arguments to configure options such as project path, output format, and various scanning and chunking settings. The function initializes a configuration object based on these arguments and proceeds with the following steps:\n\n1. Collects documentation files from the specified project directory.\n2. Reads and extracts text from these documentation files.\n3. Initializes an LLM client for generating summaries.\n4. Uses the LLM to generate an initial summary of the collected documentation, handling chunking as configured.\n5. Detects any placeholders in the generated summary that need further processing.\n6. Optionally scans project code if required to fill missing sections or update placeholders.\n7. Validates references within the manual and generates HTML content from the parsed sections.\n8. Writes the final HTML or PDF document to the specified output directory.\n9. Optionally inserts a link to the generated manual into an index file.\n10. Saves evidence data related to the documentation process.\n\nThe function handles exceptions gracefully, falling back to generating a summary based on collected text if LLM summarization fails. It also ensures that the output files are correctly named and formatted according to the specified options.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:map_evidence_to_sections:4f9906a81fb0139e98bd8bf69d66ec85ede4f0be14ec2e1bf727d27874715c2c:4f9906a81fb0139e98bd8bf69d66ec85ede4f0be14ec2e1bf727d27874715c2c": "The `map_evidence_to_sections` function processes documentation snippets from a dictionary of paths to text content. It maps these snippets to specific sections based on keywords and organizes them into two dictionaries: `section_map` and `file_map`. The function filters out snippets from excluded directories, such as \"tests\", \"examples\", and \"fixtures\". It then identifies relevant sections by searching for keywords in each line of the text. Snippets are collected up to a maximum length per section, with an exception for the \"Overview\" section where snippets from excluded directories are not considered. The function sorts snippets within each section based on priority and length before returning the final mappings.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:parse_manual:db022d270e94e87d4be6169cfb19bcc232d61a3573d8e31443bf78bc1938b7f7:db022d270e94e87d4be6169cfb19bcc232d61a3573d8e31443bf78bc1938b7f7": "The `parse_manual` function processes text from a language model to extract and structure it into sections. It splits the input text on lines containing a colon (`Section: content`) and organizes them into a dictionary where keys are section titles and values are their corresponding content. If specified, it infers missing required sections using an LLM client, marking them as \"(inferred)\" if no content is provided.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:rank_code_files:5110464215378846e79b03694eef1104b56d36d31452b0f6ab0f88284a23c3ca:5110464215378846e79b03694eef1104b56d36d31452b0f6ab0f88284a23c3ca": "The `rank_code_files` function ranks Python code files under a specified root directory based on simple heuristics. It supports various file extensions including `.py`, `.m`, `.ipynb`, `.cpp`, `.h`, and `.java`. The function skips certain directories like `venv`, `.git`, and `tests` during the ranking process. It uses regular expressions to search for keywords related to code execution, configuration, and data handling in file paths. Additionally, it checks if specified patterns are present in the file paths to further boost their scores. The files are ranked based on a score that combines these factors, with higher scores indicating more relevant or important code files.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:render_html:938d4a878ca5b0c2fd6f8a119a175d92ed6b47ed90e708db6ad1b3c51b0cde4d:938d4a878ca5b0c2fd6f8a119a175d92ed6b47ed90e708db6ad1b3c51b0cde4d": "The `render_html` function generates HTML content for a documentation page based on provided sections, title, and an optional evidence map. It constructs the HTML by iterating over each section, creating anchor links for navigation, and rendering the content. If a section is empty or lacks information, it substitutes with evidence snippets from the evidence map. The function uses Markdown for rendering code blocks and tables if available, otherwise escaping the text. It includes CSS styling for basic formatting of the HTML document.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:scan_code:4ccc31f40a18072c566325c3981a7ca8d67d229a2827b50290823637c7e17a3b:4ccc31f40a18072c566325c3981a7ca8d67d229a2827b50290823637c7e17a3b": "The `scan_code` function collects source code snippets from a specified base directory, grouped by manual sections. It searches through files for keywords associated with the given sections (or all known sections if none are provided) and returns a dictionary mapping section names to dictionaries of relative file paths and their corresponding snippet texts.\n\nHere's a breakdown of its functionality:\n1. **Collect Patterns**: The function first collects patterns from documentation files located in the base directory. It extracts text from these files, finds matches using regular expressions, and adds them to a list of patterns.\n2. **Rank Code Files**: It then ranks code files based on these patterns.\n3. **Extract Snippets**: The function extracts snippets from the ranked files within specified limits (number of files, time budget, and maximum bytes per file).\n4. **Categorize Snippets**: Finally, it categorizes the extracted snippets by the desired sections, creating a dictionary where each section maps to another dictionary of relative file paths and their snippet texts.\n\nThe function uses helper functions like `collect_docs`, `extract_text`, `rank_code_files`, `extract_snippets`, and `tqdm` for various tasks. It also utilizes constants like `SECTION_KEYWORDS` to define keywords associated with different sections.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:slugify:f4ff94c25e8d13bc17d260547062a03a56bc937e40ccae66b0b0f888055fc270:f4ff94c25e8d13bc17d260547062a03a56bc937e40ccae66b0b0f888055fc270": "Converts a given string into a filesystem-friendly slug by replacing non-alphanumeric characters with underscores and ensuring the result is lowercase. If the resulting slug is empty, returns \"user_manual\".",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:validate_manual_references:66ebf3e12eaf276c6767972e70bb56a8f82576dd93b9212c6e1d20f3bbe2bf79:66ebf3e12eaf276c6767972e70bb56a8f82576dd93b9212c6e1d20f3bbe2bf79": "This function `validate_manual_references` checks for missing file references in documentation sections. It scans the text of each section for substrings that resemble file paths or module names. If a referenced file is not found under the specified project root, it appends `[missing]` to the reference in the section text. The function modifies the input `sections` dictionary in place. Additionally, if an `evidence_map` is provided, it records missing references under the corresponding section's `missing_references` list.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:write_pdf:50d247b1d65d35d403ce8eef36afb76c7611a48017e9e2b4a32bf311bd407f69:50d247b1d65d35d403ce8eef36afb76c7611a48017e9e2b4a32bf311bd407f69": "The `write_pdf` function takes an HTML string and a file path as input. It checks if the `canvas` module is available; if not, it returns `False`. The function converts the HTML to plain text using BeautifulSoup, then creates a PDF document using ReportLab's canvas module. Each line of text from the HTML is written to the PDF at specified coordinates. Finally, the PDF is saved to the provided path and the function returns `True` on success.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:5926181734a7563ef6f4826600a07d1f6edba568682c797aef063109cf81a3a3:5926181734a7563ef6f4826600a07d1f6edba568682c797aef063109cf81a3a3": "A PyQt5 application for running DocGen and ExplainCode tools. Features include:",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:CollapsibleBox:2cfdcd055c7fd3037afdc27a859afa7dc44872d0f05dc699a6026643640e3630:2cfdcd055c7fd3037afdc27a859afa7dc44872d0f05dc699a6026643640e3630": "The `CollapsibleBox` class defines a user interface component that allows for the creation of expandable sections, typically used in documentation tools to organize complex structures into collapsible boxes. It includes methods for initializing the box with an optional toggle button, handling the toggling of content visibility, and setting the layout for the content area within the box.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:CollapsibleBox:__init__:3872795cd50f67882abd634cee89722f78baef841dae8e915249543f655adece:3872795cd50f67882abd634cee89722f78baef841dae8e915249543f655adece": "A class constructor that initializes a custom widget with a toggle button and a content area. The toggle button is styled to have no border, light gray text, and bold font weight. It displays the provided title and has an arrow icon on its right side. When clicked, it triggers the `on_toggled` method. The content area starts hidden and can be shown or hidden based on the toggle button's state.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:CollapsibleBox:on_toggled:f90ec87aaa91989724254207a4e933efac34041b0616a24b2d270248eb906904:f90ec87aaa91989724254207a4e933efac34041b0616a24b2d270248eb906904": "Toggles the appearance and visibility of a content area based on the state of a toggle button. When the toggle button is checked, it displays an arrow pointing down and shows the content; when unchecked, it displays an arrow pointing right and hides the content.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:CollapsibleBox:setContentLayout:ac9bfe1723225a787e6fed8f56df1803aac7bf21a8460cdab57bb446c2364b27:ac9bfe1723225a787e6fed8f56df1803aac7bf21a8460cdab57bb446c2364b27": "Sets the content layout of an object.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:CommandRunner:33fab6c53aec69455118be49fdac09519e863bf20ad7f36127fda1fc6329a71d:33fab6c53aec69455118be49fdac09519e863bf20ad7f36127fda1fc6329a71d": "The `CommandRunner` class manages the execution of a list of commands asynchronously, handling their output and updating progress through a GUI. It ensures that standard output and error are read separately to prevent blocking and provides mechanisms for error handling and final result reporting.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:CommandRunner:__init__:e101f462c35c5d2aea35db85e4ee5dd50b4513aa99b522541dc82c8e27a017f4:e101f462c35c5d2aea35db85e4ee5dd50b4513aa99b522541dc82c8e27a017f4": "Initializes an object with a list of commands.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:CommandRunner:_reader:8cbfd3ce114ed1c88228963326a3e4e5c43e87fbd062a6965099f60e48b826d6:8cbfd3ce114ed1c88228963326a3e4e5c43e87fbd062a6965099f60e48b826d6": "The `_reader` function reads characters from a stream one by one and emits chunks. It handles carriage returns to update the GUI progress bar, flushes any buffered text when the stream ends, and emits new lines as they appear.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:CommandRunner:run:c94857cc54e41729c04041a0a02b8ef637ddeb94d917c5048d30a4c9036c500a:c94857cc54e41729c04041a0a02b8ef637ddeb94d917c5048d30a4c9036c500a": "The function `run` executes a list of commands stored in `self.cmds`. It iterates over each command, emitting the command string to an output stream. For each command, it starts a subprocess and captures both standard output and standard error using separate threads. If any command fails (non-zero return code), the loop breaks, and the function emits the final return code. If an exception occurs during execution, it catches the exception, emits its string representation, sets the return code to -1, and breaks the loop. Finally, it emits a signal indicating that the process has finished with the computed return code.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:MainWindow:__init__:d09dab32ae9ef4e133e914ec11d6c84613bb775ec3893e18fb08391be630cfaa:d09dab32ae9ef4e133e914ec11d6c84613bb775ec3893e18fb08391be630cfaa": "Initializes a GUI window for the DocGen-LM Documentation Tool. Sets up the window title and style. Includes components for selecting project and output directories, configuring DocGen options (including language selection and private function inclusion), setting output format for ExplainCode, including input data analysis, logging area, and buttons to run various operations (DocGen, Resume DocGen, ExplainCode, Run Both).",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:MainWindow:ae8ef3cfdea5cff74a7d634a037df6047659f2a1998e5950d9fd2eb41de444c6:ae8ef3cfdea5cff74a7d634a037df6047659f2a1998e5950d9fd2eb41de444c6": "The `MainWindow` class in the DocGen-LM project defines a graphical user interface for configuring and executing code documentation generation tasks using Python, MATLAB, C++, and Java. It provides functionality to select project and output directories, configure options such as languages and private functions, and run commands to generate summaries or user manuals using an LLM. The class includes methods for building and running these commands, updating a log area with output, and managing the state of running processes.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:MainWindow:append_log:479035b003afdc113e4797fee7c099619ef8d0c73b903f780a2ffa361feaaf55:479035b003afdc113e4797fee7c099619ef8d0c73b903f780a2ffa361feaaf55": "Appends text to a log widget while handling carriage return characters by clearing the current line before inserting new text. Automatically scrolls the log widget to the bottom after appending.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:MainWindow:build_docgen_cmd:0bb90693d605ca6dd10cc8c288bcba60e30d0e2879a67edc4e2df09ee6cb5998:0bb90693d605ca6dd10cc8c288bcba60e30d0e2879a67edc4e2df09ee6cb5998": "This function constructs a command for running a document generator. It starts with the `pythonw` interpreter and specifies the script `docgenerator.py`. It includes project and output paths from GUI elements. If the `resume` parameter is true, it adds the `--resume` flag. If a checkbox indicating private documentation is checked, it appends the `--include-private` flag. The command does not explicitly specify supported languages as they are now auto-detected by DocGen-LM.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:MainWindow:build_explain_cmd:7b8696f7337008622c6bc5488b4fc92413596481c1750330bdc72564631f2cb5:7b8696f7337008622c6bc5488b4fc92413596481c1750330bdc72564631f2cb5": "Constructs a command to run `explaincode.py` with specified options based on user input. The command includes the path to a project, an output file, and an output format. Optionally, it can include additional data if selected by the user.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:MainWindow:dark_style:024d23387b641216e7d149e6c045b026f1a451318d781be0d3d84d51867f51ef:024d23387b641216e7d149e6c045b026f1a451318d781be0d3d84d51867f51ef": "Returns a string containing CSS styles for a dark-themed user interface.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:MainWindow:on_finished:c98dd27bd106b89d8d5059a01d5a7c208db9c09ee3836ee9d932c0f5bdb99f8b:c98dd27bd106b89d8d5059a01d5a7c208db9c09ee3836ee9d932c0f5bdb99f8b": "Function `on_finished` logs the exit code of a process and sets the running state to False.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:MainWindow:run_both:123251ea533aa28d4fb511b62f853998d3769fcced0962a00cdc1cb16c3cfef0:123251ea533aa28d4fb511b62f853998d3769fcced0962a00cdc1cb16c3cfef0": "Clears the log and runs both the document generation command and the explanation command.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:MainWindow:run_commands:259d9e78ac20ac9cd282474591a8079c54a2e042ef9670b77335a47dad9adaff:259d9e78ac20ac9cd282474591a8079c54a2e042ef9670b77335a47dad9adaff": "The function `run_commands` takes a list of commands (`cmds`) as input. It checks if project and output directories are set; if not, it logs an error message and returns. Otherwise, it sets the running state to true, initializes a `CommandRunner` with the provided commands, connects its output signal to a log appending method, connects its finished signal to a handler method, and starts the command runner.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:MainWindow:run_docgen:0249c14aca7d5d21ff6d3b7929c59f2dbc05b970b05e9329f97566991188ecf6:0249c14aca7d5d21ff6d3b7929c59f2dbc05b970b05e9329f97566991188ecf6": "The function `run_docgen` clears the log and then runs a command to generate documentation.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:MainWindow:run_docgen_resume:3ccc689d89d3b9b2ab503890dea8bd89d99eb8079f6815145e40aaba2eea6816:3ccc689d89d3b9b2ab503890dea8bd89d99eb8079f6815145e40aaba2eea6816": "Clears the log and runs a command to generate a resume using docgen.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:MainWindow:run_explain:aaae3953f6dfd026db21ab5cd9b5c637f7a8e0fee01ae706e4db035bf9a67663:aaae3953f6dfd026db21ab5cd9b5c637f7a8e0fee01ae706e4db035bf9a67663": "Clears the log and runs a command to explain something.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:MainWindow:select_dir:2a0195f8b02fa1d0340ed30e33775539f64b5ddf0498a2fae1d7426f16c229f5:2a0195f8b02fa1d0340ed30e33775539f64b5ddf0498a2fae1d7426f16c229f5": "Function `select_dir` opens a file dialog to select an existing directory. If a directory is selected, it sets the text of the provided `QLineEdit` widget to the path of the selected directory.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:MainWindow:select_file:eefcbb0d572a55989ebf1a954aae8e90553ec7f2c5c165ee8e6029c3df4770d3:eefcbb0d572a55989ebf1a954aae8e90553ec7f2c5c165ee8e6029c3df4770d3": "A function named `select_file` that opens a file dialog for selecting data files (JSON, CSV, TXT) or all files. If a file is selected, it sets the text of a provided `QLineEdit` widget to the path of the selected file.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:MainWindow:set_running:0060e79ba63c4489d68b4a831c921909f5e89ae4a7e0028231ef70a8d4836731:0060e79ba63c4489d68b4a831c921909f5e89ae4a7e0028231ef70a8d4836731": "The function `set_running` takes a boolean parameter `running`. It iterates over a tuple of button objects (`docgen_btn`, `resume_btn`, `explain_btn`, `both_btn`) and sets each button's enabled state to the opposite of the `running` value. If `running` is `True`, buttons are disabled; if `False`, they are enabled.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:PathLineEdit:5931958914becd4b2269e54be686075b2a0f2be75193acc557e68f2ea8645a09:5931958914becd4b2269e54be686075b2a0f2be75193acc557e68f2ea8645a09": "The `PathLineEdit` class defines a widget that supports drag-and-drop functionality for URLs, specifically handling file paths by setting them as the widget's text when files are dropped onto it. This allows for easy file path input through user interface interaction.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:PathLineEdit:__init__:c9e8a7be9ec3c7638ba891fb56438f32b028d50d553e3cf05183fab3aa0b6309:c9e8a7be9ec3c7638ba891fb56438f32b028d50d553e3cf05183fab3aa0b6309": "Initializes an object with optional parent. Sets the object to accept drag-and-drop events.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:PathLineEdit:dragEnterEvent:362f23d15259d38f2384b97d4fe0df74d022e537eb20da5aa442f957d48d0d35:362f23d15259d38f2384b97d4fe0df74d022e537eb20da5aa442f957d48d0d35": "Handles the `dragEnterEvent` by accepting the proposed action if the event contains URLs.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:PathLineEdit:dropEvent:2bae52494ea3b00064a9fc268f5338cc663c0b954be820963c807172bd13b7cf:2bae52494ea3b00064a9fc268f5338cc663c0b954be820963c807172bd13b7cf": "The function `dropEvent` processes a drop event in a graphical user interface. It retrieves URLs from the event's MIME data and sets the text of an object to the local file path of the first URL if any URLs are present.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:__init__:16299510ff2d6902a46f7d19af36156fc96f24be2ff34f95dbc47807d1ae491e:16299510ff2d6902a46f7d19af36156fc96f24be2ff34f95dbc47807d1ae491e": "The `__init__` method initializes the user interface for a documentation tool named \"DocGen-LM Documentation Tool\". It sets up various UI components including labels, buttons, checkboxes, and layout managers to allow users to select project and output directories, configure DocGen and ExplainCode options, and run different operations. The interface includes a header with a logo and title, sections for selecting project and output directories, options for DocGen and ExplainCode settings, a log area for displaying messages, and buttons to trigger different actions like running DocGen, ExplainCode, or both.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:__init__:46a0f54509df68ac82d6dde1a3332e9dbb8a45e59787e1ad93b7517abebdfd2e:46a0f54509df68ac82d6dde1a3332e9dbb8a45e59787e1ad93b7517abebdfd2e": "Initializes a new instance of the `CommandRunner` class with a list of commands. The constructor calls the superclass constructor and stores the list of commands in an instance variable.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:__init__:5811e7358d79dd74c3d5ce6b76cbbd5fc5455196f4c7f0bab124fd9ad3a676ca:5811e7358d79dd74c3d5ce6b76cbbd5fc5455196f4c7f0bab124fd9ad3a676ca": "Initializes a `CollapsibleBox` with an optional title and parent widget. Sets up a toggle button to control the visibility of content below it. The button is styled and configured to show text beside an icon, initially displaying a right arrow. Connects the button's click event to the `on_toggled` method. Adds the toggle button and content area to a vertical layout with no margins.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:__init__:5d7df1958c9be53f080ddfc289e311a701c087fe55d59b498fbe469536f7e01f:5d7df1958c9be53f080ddfc289e311a701c087fe55d59b498fbe469536f7e01f": "This function initializes the `MainWindow` class, setting up the user interface for the DocGen-LM documentation tool. It includes components for selecting project and output directories, configuring options for code documentation (including languages and private functions), specifying output format and data analysis, displaying a log area, and providing buttons to run different operations such as running DocGen, resuming DocGen, running ExplainCode, or running both. The interface is structured with collapsible sections for DocGen and ExplainCode options and uses a dark-themed style.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:__init__:95fbf02e6745291af9c5dbb009aa6e5ee8eea7ee2b1aa648f23b6b05703182ab:95fbf02e6745291af9c5dbb009aa6e5ee8eea7ee2b1aa648f23b6b05703182ab": "Initializes a `PathLineEdit` instance. Sets the widget to accept drag-and-drop events.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:__init__:a550106ae65a25dcf2ee2de12be2400d12d2246ffbcf8fa72058768c0174caae:a550106ae65a25dcf2ee2de12be2400d12d2246ffbcf8fa72058768c0174caae": "Initializes a `PathLineEdit` object with optional parent widget. Sets drag-and-drop functionality to accept drops.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:__init__:ac7ac9fe8787d56dd769ea498f528da93310f5870d1fd8c2748f4b995a6d61cf:ac7ac9fe8787d56dd769ea498f528da93310f5870d1fd8c2748f4b995a6d61cf": "This function initializes an instance of the `CollapsibleBox` class. It sets up a toggle button with optional text and makes it checkable. The button is styled to have no border, light gray text, and bold font weight. It uses a right arrow icon and connects its click event to a method named `on_toggled`. Below the toggle button, there is a content widget that is initially hidden. The function arranges these components in a vertical layout with no margins.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:__init__:ea8888224d34ad2b834c193fc5934ea4345afb8919d30e5c4182eba5de0e3d92:ea8888224d34ad2b834c193fc5934ea4345afb8919d30e5c4182eba5de0e3d92": "Initializes a new instance of `CommandRunner` with a list of commands. The constructor takes one parameter: `cmds`, which is a list of commands to be executed. It then calls the superclass constructor and assigns the `cmds` parameter to an instance variable.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:_reader:1176b052e8c5a24ba9872768ce91cf27ea2fe85f17a07bf931b91b45a0d7a107:1176b052e8c5a24ba9872768ce91cf27ea2fe85f17a07bf931b91b45a0d7a107": "The `_reader` method reads a stream character by character, emitting chunks as it goes. It handles carriage returns to update progress bars in the GUI and flushes any buffered text when the stream ends.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:_reader:6710c7b57bcbf3d1557727abdf4767a9b9a325a6695f969fa112e31f34482d24:6710c7b57bcbf3d1557727abdf4767a9b9a325a6695f969fa112e31f34482d24": "The `_reader` method reads characters from a stream one by one and emits chunks of text. It handles carriage returns (`\\r`) to update the GUI progress bar, flushes any buffered text when the stream ends, and ensures that new lines are properly emitted with the preceding text.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:append_log:72586774fcd7cb577c19a3ece7c17113a25a66119a9326cf980cd3df4c4faef1:72586774fcd7cb577c19a3ece7c17113a25a66119a9326cf980cd3df4c4faef1": "Appends text to a log widget in the `MainWindow` class. It uses a regular expression to split the input text at carriage return characters, then iterates through each part. If a part is a carriage return, it moves the cursor to the start of the line and clears any existing text there. Otherwise, it inserts the text at the current cursor position. Finally, it sets the cursor back to the log widget and scrolls the vertical scrollbar to the bottom.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:append_log:ac390063f53d40ffd6a8829ed54a0d13eddd8eb49fbb24127405775d6edd8343:ac390063f53d40ffd6a8829ed54a0d13eddd8eb49fbb24127405775d6edd8343": "The `append_log` function appends text to a log widget in a GUI application. It uses the `QTextCursor` class from the `QtGui` module to manipulate the cursor's position and insert text into the log widget. The function splits the input text using regular expressions to handle carriage return characters (`\\r`). For each part of the split text, if it is a carriage return, it moves the cursor to the start of the line, selects the entire line, and removes it. If it is not a carriage return, it inserts the text at the current cursor position. After appending all parts, it sets the log widget's cursor back to the end and scrolls the vertical scrollbar to its maximum value to ensure the latest log entry is visible.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:build_docgen_cmd:3b68ecd85910e61a80b864359476b02362d17bb9d508033464fed4739ee9fea8:3b68ecd85910e61a80b864359476b02362d17bb9d508033464fed4739ee9fea8": "The `build_docgen_cmd` function constructs a command to run the `docgenerator.py` script for generating documentation. It takes a boolean parameter `resume` indicating whether to resume an existing process. The function initializes a list `cmd` with the command `pythonw` and the script path `docgenerator.py`. It then appends the project edit text and output edit text as arguments. If `resume` is `True`, it adds the `--resume` flag. Additionally, if a checkbox indicating private documentation inclusion is checked, it adds the `--include-private` flag. The function returns the constructed command list.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:build_docgen_cmd:9ed047355fa7366081162ace668b580a8c4f17e99fa34954ff5a278a5b88447d:9ed047355fa7366081162ace668b580a8c4f17e99fa34954ff5a278a5b88447d": "The function `build_docgen_cmd` constructs a command list for running the `docgenerator.py` script with parameters based on the state of the `MainWindow`. It includes the project path, output directory, and optionally flags for resuming previous operations or including private members in documentation. The command is designed to be executed using `pythonw` to prevent opening a console window on Windows.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:build_explain_cmd:5ee08ab5281fd969f9120c897c1711740e4f4a5d2dee0ef751079bc80cdba57b:5ee08ab5281fd969f9120c897c1711740e4f4a5d2dee0ef751079bc80cdba57b": "This function constructs a command list for running the `explaincode.py` script. It includes the Python interpreter (`pythonw`), the script path, project path from `project_edit`, output path from `output_edit`, and output format from `format_combo`. If data is included and provided in `data_edit`, it adds the `--data` flag followed by the data text to the command list. The function returns the constructed command list.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:build_explain_cmd:84494eb638e4c22ada73e3afc3e90086ac65a35cedf8e5f846326fae1e09fb2f:84494eb638e4c22ada73e3afc3e90086ac65a35cedf8e5f846326fae1e09fb2f": "This function `build_explain_cmd` constructs a command to run the `explaincode.py` script for generating user manuals from code. It collects parameters such as project path, output directory, and format from GUI elements (`project_edit`, `output_edit`, `format_combo`). If data inclusion is enabled and data text is provided, it adds a data parameter to the command. The function returns the constructed command list.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:dark_style:cc65fd9ec502cfff5f19eb8316d9fc44c3b4ee81862d37462dac5fd4d15c9bae:cc65fd9ec502cfff5f19eb8316d9fc44c3b4ee81862d37462dac5fd4d15c9bae": "The `dark_style` function returns a string containing CSS code that defines the appearance of various widgets in a PyQt or PySide application. The style includes dark colors for backgrounds and text, with specific styles applied to `QWidget`, `QLineEdit`, `QPlainTextEdit`, `QComboBox`, and `QPushButton`. It also sets hover effects for buttons and normal font weights for labels.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:dark_style:e94ab0ebebdbe726468be27277a473f7de17e1b584d78c7453f992a872085afc:e94ab0ebebdbe726468be27277a473f7de17e1b584d78c7453f992a872085afc": "This function `dark_style` returns a string containing CSS styles for various Qt widgets. The styles define the appearance of a dark theme, with specific colors and fonts applied to `QWidget`, `QLineEdit`, `QPlainTextEdit`, `QComboBox`, `QPushButton`, and `QLabel`. The function is part of the `MainWindow` class in the DocGen-LM project.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:dragEnterEvent:2ceb573e1b1a234270bc82f7fb07a9182db630eea7fd34981f4830cb0f0b38ea:2ceb573e1b1a234270bc82f7fb07a9182db630eea7fd34981f4830cb0f0b38ea": "This function `dragEnterEvent` is a method of the class `PathLineEdit`. It handles the event when a drag-and-drop operation enters the widget. The function checks if the mime data being dragged contains URLs. If it does, the function accepts the proposed action, allowing the drop to proceed.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:dragEnterEvent:38539a0da8ad1be0727b80a78eccab0d137d2f4ab86e44e21c1d4e0fe90484fc:38539a0da8ad1be0727b80a78eccab0d137d2f4ab86e44e21c1d4e0fe90484fc": "This function `dragEnterEvent` is part of the class `PathLineEdit`. It handles the event when a drag operation enters the widget. The function checks if the MIME data contains URLs using `event.mimeData().hasUrls()`. If it does, it accepts the proposed action for the drag event with `event.acceptProposedAction()`, allowing the drop to proceed.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:dropEvent:2f3a67e1699bccc504bdd4904650fda5a39681c972982b116c97c6e5aeff91f4:2f3a67e1699bccc504bdd4904650fda5a39681c972982b116c97c6e5aeff91f4": "This function `dropEvent` is part of a class named `PathLineEdit`. It handles the event when files are dropped onto an instance of `PathLineEdit`. The function checks if any URLs are included in the event's MIME data. If URLs are present, it sets the text of the `PathLineEdit` to the local file path of the first URL in the list.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:dropEvent:90231b977d7ad880a8ac53d677d1bec8a7a2d78992988c26b116379782267ad4:90231b977d7ad880a8ac53d677d1bec8a7a2d78992988c26b116379782267ad4": "The `dropEvent` method handles a drop event in a `PathLineEdit` widget. It extracts URLs from the dropped data and sets the text of the line edit to the local file path of the first URL.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:on_finished:23a885f70acbf1d8e20bb0a673ea0a92ce939965da730a42d229837a24b9af8a:23a885f70acbf1d8e20bb0a673ea0a92ce939965da730a42d229837a24b9af8a": "This function is called when a process finishes. It appends a log entry indicating the exit code of the process and sets the running state to False.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:on_finished:85a35a8d855a1337a9c81522aa515bdfa633ffaa977ebef2afba86e496ff5377:85a35a8d855a1337a9c81522aa515bdfa633ffaa977ebef2afba86e496ff5377": "This function `on_finished` is a method of the class `MainWindow`. It takes an integer parameter `code`, which represents the exit code of a process. The function appends a log message to the log area indicating that the process has finished with the given exit code and then sets the running state of the main window to False, indicating that no process is currently active.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:on_toggled:6fe83efa08a2e218ba121bb5675cedc80266410d232e179d6710449e271efde8:6fe83efa08a2e218ba121bb5675cedc80266410d232e179d6710449e271efde8": "Toggles the visibility of content within a collapsible box based on the state of a toggle button. When the button is checked, it displays an arrow pointing down and shows the content; when unchecked, it displays an arrow pointing right and hides the content.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:on_toggled:e697bb2dafe4354d313d2cdbd3d332902b03944b2f4c25d7e15adc12add176c7:e697bb2dafe4354d313d2cdbd3d332902b03944b2f4c25d7e15adc12add176c7": "This function `on_toggled` is a method of the `CollapsibleBox` class. It handles the toggling of the visibility of content within the box when a toggle button is clicked. The function checks whether the toggle button is currently checked or not. If it is checked, it sets the arrow icon on the toggle button to point down (`QtCore.Qt.DownArrow`) and makes the content area visible. If the toggle button is unchecked, it sets the arrow icon to point right (`QtCore.Qt.RightArrow`) and hides the content area.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:run:32c259333ec13026a23eded1de2ddcdb8e5d6093d4cd6cd6e49fac893e542148:32c259333ec13026a23eded1de2ddcdb8e5d6093d4cd6cd6e49fac893e542148": "This function `run` is part of the `CommandRunner` class. It executes a list of commands (`self.cmds`) and handles their output asynchronously using threads. The function emits each command being executed, reads both standard output and standard error in separate threads to avoid blocking, waits for all processes to complete, and then emits the return code of the last process. If any process returns a non-zero exit code or an exception occurs, the function breaks out of the loop and sets the return code to -1 before emitting the final result.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:run:f61b5eb5af84d8df06a806e966bcee70cd3446700f8a8893849ddef2de583d19:f61b5eb5af84d8df06a806e966bcee70cd3446700f8a8893849ddef2de583d19": "The `run` method of the `CommandRunner` class executes a list of commands sequentially. For each command, it starts a subprocess and reads both standard output and standard error concurrently using separate threads. The method captures any exceptions that occur during the execution and emits an error message if an exception is caught. If a command returns a non-zero exit code, the loop breaks early. After all commands are executed or an error occurs, the `finished` signal is emitted with the final return code.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:run_both:0c23139093c9df53018b02b8b8b8564b8920fece55429538ea1fa7eed47ed567:0c23139093c9df53018b02b8b8b8564b8920fece55429538ea1fa7eed47ed567": "The `run_both` method in the `MainWindow` class clears the log and then runs two commands: one for building the documentation generator (`build_docgen_cmd`) and another for explaining code using an LLM (`build_explain_cmd`).",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:run_both:4f3c7054b0dfd5ec2992e041b9dcc319174f721fecf757b695e4a3ec7fb6fce3:4f3c7054b0dfd5ec2992e041b9dcc319174f721fecf757b695e4a3ec7fb6fce3": "The `run_both` method in the `MainWindow` class clears the log and then runs two commands: one for building documentation and another for explaining content.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:run_commands:649a8028351ea86624e41be8fa133aa0d238883243cc22e663d9636d5f5c0c2c:649a8028351ea86624e41be8fa133aa0d238883243cc22e663d9636d5f5c0c2c": "The `run_commands` method in the `MainWindow` class is designed to execute a series of commands related to code documentation generation. It first checks if both the project directory and output directory are set by the user. If either is missing, it logs an error message and returns without executing any commands.\n\nIf both directories are set, it proceeds to set the running state of the application to `True` to indicate that a process is underway. It then creates an instance of `CommandRunner`, passing the list of commands (`cmds`) to be executed.\n\nThe method connects the `output` signal of the `CommandRunner` instance to the `append_log` method, which is presumably used to update the user interface with the output of the commands as they are generated. It also connects the `finished` signal of the `CommandRunner` to another method named `on_finished`, which would be responsible for handling any cleanup or final actions after the commands have completed execution.\n\nFinally, it starts the command runner by calling its `start` method, initiating the process of executing the provided commands.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:run_commands:81028765db2525b8867111dcb8e22a39806f97317d87346a0fe022d78cf0c1e7:81028765db2525b8867111dcb8e22a39806f97317d87346a0fe022d78cf0c1e7": "This function `run_commands` in the class `MainWindow` is designed to execute a list of commands (`cmds`). It first checks if both project and output directories are set. If not, it logs an error message. If they are set, it sets the interface to running mode, initializes a `CommandRunner` with the provided commands, connects the runner's output signal to a method that appends log messages, and connects the finished signal to another method. Finally, it starts the command execution.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:run_docgen:009a3fefd2b945ba57d47d6520dd76bd681d3391bc828548afcade5a49389423:009a3fefd2b945ba57d47d6520dd76bd681d3391bc828548afcade5a49389423": "The function `run_docgen` clears the log of the `MainWindow` instance and then runs a command to generate documentation.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:run_docgen:618f5fba1e155b2abc629f6e1f3084d5f84310b897af149c63474e435c507af1:618f5fba1e155b2abc629f6e1f3084d5f84310b897af149c63474e435c507af1": "The `run_docgen` method in the `MainWindow` class clears the log and executes a command to build documentation using the `build_docgen_cmd` method.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:run_docgen_resume:8b8a594a849ecab950c817674c52983f7694e9b4008a5103c2216921a0561877:8b8a594a849ecab950c817674c52983f7694e9b4008a5103c2216921a0561877": "Clears the log and runs a command to generate documentation with a resume option.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:run_docgen_resume:e627e22d166193f7cb71db1abaf65d085d7d4b1e62dc19c4c1a7607bf430a379:e627e22d166193f7cb71db1abaf65d085d7d4b1e62dc19c4c1a7607bf430a379": "This function, `run_docgen_resume`, is a method of the `MainWindow` class. It clears the log and then runs a command to generate documentation with the option to resume. The command is constructed by calling `build_docgen_cmd` with the `resume` parameter set to `True`.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:run_explain:6d47a43df77fb53ad16bfe10d93def2dcac2992bdbde7abd4dd7d776ad31fae7:6d47a43df77fb53ad16bfe10d93def2dcac2992bdbde7abd4dd7d776ad31fae7": "The `run_explain` method in the `MainWindow` class clears the log and then executes a command to build an explanation. It uses the `build_explain_cmd` method to generate the command and passes it to the `run_commands` method for execution.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:run_explain:ca92c569295e31d734b3627e4c04d69bdabd11330f7e91025474bc0d9d4b8b96:ca92c569295e31d734b3627e4c04d69bdabd11330f7e91025474bc0d9d4b8b96": "Clears the log and runs a command to explain something.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:select_dir:37637e46c501c6db7754414cf624c51335dd788be586a314a0ad63804df85103:37637e46c501c6db7754414cf624c51335dd788be586a314a0ad63804df85103": "This function `select_dir` is a method of the `MainWindow` class. It opens a file dialog to allow the user to select an existing directory. If a directory is selected, it sets the text of the provided `QLineEdit` widget to the path of the selected directory.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:select_dir:8b9378131a596410be8a1ef3d524a71af21e03ef293c430c992b9dabc2368642:8b9378131a596410be8a1ef3d524a71af21e03ef293c430c992b9dabc2368642": "This function `select_dir` is part of a class named `MainWindow`. It allows the user to select an existing directory through a file dialog and sets the selected directory path in a provided `QLineEdit` widget.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:select_file:4d0411d462eb35378391cf58be72a174509539f244aa77963b55fc1e9daeaaf5:4d0411d462eb35378391cf58be72a174509539f244aa77963b55fc1e9daeaaf5": "This function `select_file` is a method of the `MainWindow` class. It opens a file dialog for selecting data files with extensions `.json`, `.csv`, or `.txt`. If a file is selected, it sets the text of the provided `QLineEdit` widget to the path of the selected file.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:select_file:6da3e27ee05fc8a270734f9980498d96d54ae8909e99f2dff87b16660ca313f8:6da3e27ee05fc8a270734f9980498d96d54ae8909e99f2dff87b16660ca313f8": "This function `select_file` is part of the `MainWindow` class in the DocGen-LM project. It opens a file dialog for selecting data files (JSON, CSV, TXT) or any other type of file. If a file is selected, it sets the text of the provided `QLineEdit` widget to the path of the selected file.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:setContentLayout:53621ec8afc98c9522fbe3029a79d127be119065055660c32704dba5f8d9bbda:53621ec8afc98c9522fbe3029a79d127be119065055660c32704dba5f8d9bbda": "Sets the content layout of the collapsible box.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:setContentLayout:7bd9dd9e20164b32ca56150c563dc0487da752576deb5586103ecb4c859d6480:7bd9dd9e20164b32ca56150c563dc0487da752576deb5586103ecb4c859d6480": "This method sets the content layout for a `CollapsibleBox` instance. It takes a `layout` parameter and assigns it to the `content` attribute of the class.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:set_running:2b3e01b8dba6008cb1c898fe2242976b5bb72238bb85cf6c67e0e7906163d2ab:2b3e01b8dba6008cb1c898fe2242976b5bb72238bb85cf6c67e0e7906163d2ab": "This function `set_running` in the class `MainWindow` takes a boolean parameter `running`. It iterates over four buttons (`docgen_btn`, `resume_btn`, `explain_btn`, and `both_btn`) and sets their enabled state based on the value of `running`. If `running` is `True`, all buttons are disabled; if `False`, all buttons are enabled.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:set_running:610f909d8027e18f4648becabda2bdcf8077495b8943a20de18452d88cce4552:610f909d8027e18f4648becabda2bdcf8077495b8943a20de18452d88cce4552": "The `set_running` method is a part of the `MainWindow` class. It takes a boolean parameter `running`. The method iterates over a tuple containing four button instances (`self.docgen_btn`, `self.resume_btn`, `self.explain_btn`, and `self.both_btn`). For each button in the tuple, it sets the `setEnabled` attribute to the negation of the `running` parameter. This effectively disables all buttons when `running` is `True` and enables them when `running` is `False`.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\html_writer.py:3e0a79e574fdf9a5116be8a3a5e1b9cee87f67c23446e50ea22dc4ef6e6e3a7c:3e0a79e574fdf9a5116be8a3a5e1b9cee87f67c23446e50ea22dc4ef6e6e3a7c": "This module provides utilities for rendering documentation pages using simple template substitution. It includes functions for rendering navigation trees, highlighting code snippets, and generating HTML content based on structured data representing project modules, classes, methods, and variables. The module also includes functions to write index and module-specific documentation pages to output directories.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\html_writer.py:_flatten_nav_tree:c83d5cf005dd92137a01bb134c3bb716f6a48e1f7101244860f3d46af9de1bc7:c83d5cf005dd92137a01bb134c3bb716f6a48e1f7101244860f3d46af9de1bc7": "The function `_flatten_nav_tree` takes a dictionary `tree` representing a navigation tree and yields tuples of file names and links. It iterates through the keys of the dictionary, checking for the presence of a special key `\"__files__\"` which contains pairs of file names and their corresponding links. For each pair found, it yields them as tuples. Additionally, if the key is not `\"__files__\"`, it recursively calls itself on the sub-dictionary to handle nested structures, ensuring all file-name-link pairs are yielded.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\html_writer.py:_highlight:d199f9925f17bd0e78943acf5311b4683682594378654b1e3ae7e763703aab7e:d199f9925f17bd0e78943acf5311b4683682594378654b1e3ae7e763703aab7e": "The function `_highlight` takes a string `code` and a string `language` as input. It returns the code highlighted for the specified language using Pygments. The function selects an appropriate lexer based on the language, formats the highlighted code with HTML, and wraps it in `<pre><code>` tags. If the language is not supported, it uses a generic `TextLexer`.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\html_writer.py:_render:15784a0e5f653f5c7666a4592373afd876ee82a88fef5a7aecf9cf565efcfc1a:15784a0e5f653f5c7666a4592373afd876ee82a88fef5a7aecf9cf565efcfc1a": "This function `_render` is designed to generate HTML list items representing a hierarchical structure of files and directories. It takes two parameters: `node`, which is a dictionary representing the current node in the hierarchy, and `is_root`, a boolean indicating whether the current node is the root of the hierarchy.\n\nThe function constructs an HTML unordered list (`<ul>`) by iterating over the keys of the `node` dictionary. If the `node` represents the root and includes a home page (`include_home` is True), it adds a list item for the home page. It then iterates over any files associated with the current node, adding them as list items with hyperlinks.\n\nFor each directory within the current node (excluding the special key `__files__`), the function creates a nested HTML details element (`<details>`) containing a summary and recursively calls itself to render the contents of that directory. The resulting parts are joined into a single string, which is wrapped in an unordered list and returned as the output.\n\nThis function is used to generate the navigation structure for static HTML documentation, allowing users to explore files and directories interactively through expandable sections.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\html_writer.py:_render_class:eee7b9789e76c32ac8a47d103e51972954c20778b4c22776d222b57abf191629:eee7b9789e76c32ac8a47d103e51972954c20778b4c22776d222b57abf191629": "The function `_render_class` generates HTML content for a class and its subclasses. It takes a dictionary representing the class, a programming language string, and an optional heading level as input. The function returns a list of HTML strings.\n\n\nThe function uses nested lists and string formatting to construct the HTML parts, ensuring that each class, variable, method, and subclass is represented in a structured format suitable for static HTML documentation.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\html_writer.py:_render_function:0bd8276f85cea708295cb05dbbc89b208fdd7138242f45d763e19103fd8a24cc:0bd8276f85cea708295cb05dbbc89b208fdd7138242f45d763e19103fd8a24cc": "This function `_render_function` generates HTML parts for a given function and its nested subfunctions. It takes a dictionary representing the function, a programming language string, an optional heading level (default is 3), and an optional prefix string. The function constructs HTML elements based on the function's signature, summary, source code, and any nested subfunctions. It uses HTML tags to structure the output, including headings, paragraphs, and details/summary elements for subfunctions.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\html_writer.py:_render_html:2c3e37e67841e017c2ff6fda81a369f68edc25865baa880a61fe150d5797c9e0:2c3e37e67841e017c2ff6fda81a369f68edc25865baa880a61fe150d5797c9e0": "The function `_render_html` takes four parameters: `title`, `header`, `body`, and `nav_html`. It reads a template file specified by `_TEMPLATE_PATH` and uses the provided parameters to format the template. The formatted content is then returned as an HTML string, prefixed with a comment indicating it was generated by DocGen-LM.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\html_writer.py:_render_nav_tree:a9c2b14efafa5a5d856c9d510088b776cd94c3fd02769ff9db619deb084c0b85:a9c2b14efafa5a5d856c9d510088b776cd94c3fd02769ff9db619deb084c0b85": "This function `_render_nav_tree` generates HTML for a nested navigation tree based on the provided `tree` dictionary. It includes an optional \"\ud83c\udfe0 Project Overview\" link at the root if specified. The function recursively processes each node in the tree, rendering files and subdirectories as list items with expandable details sections.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\html_writer.py:write_index:692863def5651c9c2c20e667c786021cee760180289210ea322d120cef49fef4:692863def5651c9c2c20e667c786021cee760180289210ea322d120cef49fef4": "This function `write_index` generates the content for an `index.html` file. It takes three parameters: `output_dir`, `project_summary`, and `nav_tree`. The optional parameter `module_summaries` provides additional summaries for modules.\n\nThe function creates a directory at the specified `output_dir` if it doesn't exist. It then renders a navigation tree using `_render_nav_tree(nav_tree)` and constructs the body of the HTML document with the project summary, a horizontal rule, and a heading for modules. For each item in the flattened navigation tree, it generates an HTML list item with a link to the module and an optional summary.\n\nIf there are any module items, they are wrapped in an unordered list. The final HTML content is generated using `_render_html` and written to `index.html` in the output directory.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\html_writer.py:write_module_page:d6ca1682ee0bcd054c531dab74c7815bfefe6666fe9c19a79bdf16c4bbecd0fe:d6ca1682ee0bcd054c531dab74c7815bfefe6666fe9c19a79bdf16c4bbecd0fe": "This function `write_module_page` generates an HTML documentation page for a module based on provided data. It takes three parameters: `output_dir`, `module_data`, and `nav_tree`. The function creates the output directory if it doesn't exist, extracts necessary information from `module_data`, renders a navigation tree using `_render_nav_tree`, and constructs the body of the HTML page by iterating over classes, variables, and functions in `module_data`. Each class and function is rendered using helper functions `_render_class` and `_render_function`. The final HTML content is then written to a file named after the module.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\llm_client.py:8c10f070f2c8b3e3bde249f5ea3f8fa746a3f3f1de1670c852597f9131c944de:8c10f070f2c8b3e3bde249f5ea3f8fa746a3f3f1de1670c852597f9131c944de": "This module provides an interface to a local language model backend (LMStudio) for generating summaries of code files. It includes:",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\llm_client.py:LLMClient:5dcec17e9272eb655b5c9ba8b2177b841b0245d1779c1c7255262f09772cdee4:5dcec17e9272eb655b5c9ba8b2177b841b0245d1779c1c7255262f09772cdee4": "The `LLMClient` class is designed to interact with a language model for generating summaries of code. It includes methods for initializing the client, checking API reachability, and summarizing text using an LLM. The class handles request encoding, error management, and response processing to ensure robust communication with the language model.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\llm_client.py:LLMClient:__init__:700c23b8c0716a1aaf00c10fbc2e056bef4f6e1dca9c72b739185f920ef55cf8:700c23b8c0716a1aaf00c10fbc2e056bef4f6e1dca9c72b739185f920ef55cf8": "Initializes an object with a base URL and a model. The base URL is stored after removing any trailing slashes, and the endpoint for chat completions is constructed using this base URL. The model type is also stored.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\llm_client.py:LLMClient:ping:3fe5655e89accd067c6ddc9c1cc323c9dd9eac2dea9be6646ea4d470b3e0a436:3fe5655e89accd067c6ddc9c1cc323c9dd9eac2dea9be6646ea4d470b3e0a436": "Function `ping` checks if the API is reachable by sending a GET request to the server. It takes an optional `timeout` parameter with a default value of 2.0 seconds. If the server responds successfully, it returns `True`. If there's an issue connecting to the server, it raises a `ConnectionError` with a message indicating that the server cannot be reached.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\llm_client.py:LLMClient:summarize:d645c0bd2d6fc772b12d74e25271d6590e2e1e37ccdc8d959e6a4fae9a56c574:d645c0bd2d6fc772b12d74e25271d6590e2e1e37ccdc8d959e6a4fae9a56c574": "The function `summarize` generates a summary for a given text using a specified prompt template. It constructs a prompt by formatting the input text with the chosen template and prepending an optional system prompt. The function then tokenizes the prompt and checks if its size exceeds a specified budget, logging a warning if it does. It prepares a payload to send to a language model API endpoint, specifying parameters such as the model, temperature, maximum tokens, and messages. The function attempts to make up to three requests to the API, handling potential errors like HTTP errors or request exceptions by retrying with a one-second delay each time. If all attempts fail, it raises a `RuntimeError` with the last error message.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\llm_client.py:__init__:1cddc382ef9228ff8529c3818b437c09634bd60abbe520453630fa5d0146361a:1cddc382ef9228ff8529c3818b437c09634bd60abbe520453630fa5d0146361a": "Initializes an instance of the `LLMClient` class with a base URL and a model. The base URL is stripped of any trailing slashes, and the endpoint for chat completions is constructed using this base URL. The model specifies which language model to use for generating summaries.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\llm_client.py:__init__:7bb980db665c5bf9c3abfb882a8a354f91d3c5797ac8f4e6bc17ef9af9b0517f:7bb980db665c5bf9c3abfb882a8a354f91d3c5797ac8f4e6bc17ef9af9b0517f": "Initializes an instance of `LLMClient` with a base URL and a model. The base URL is trimmed to remove any trailing slashes, and the endpoint for chat completions is set accordingly. The model type is also initialized.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\llm_client.py:ping:16efd301a7f29275254599e971a2d648dc8bc0d3983d97985aed9d0a59e6f759:16efd301a7f29275254599e971a2d648dc8bc0d3983d97985aed9d0a59e6f759": "This function `ping` checks if the API is reachable by sending a GET request to the server. It takes an optional `timeout` parameter with a default value of 2.0 seconds. If the server responds successfully, it returns `True`. If there is a connection error or any other exception during the request, it raises a `ConnectionError` with a message indicating that the server cannot be contacted at the specified URL.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\llm_client.py:ping:76580d4cfebb32c95afa8e6fa9356034814b82596b302988056e85ebbb9ab4e4:76580d4cfebb32c95afa8e6fa9356034814b82596b302988056e85ebbb9ab4e4": "The `ping` method in the `LLMClient` class checks if the API is reachable by sending a GET request to the base URL with an optional timeout. It returns `True` if the server responds successfully, otherwise it raises a `ConnectionError`.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\llm_client.py:sanitize_summary:15e0f08951869cf68da74b4d3167b4ecf4839b6727108957fb94dffca06af955:15e0f08951869cf68da74b4d3167b4ecf4839b6727108957fb94dffca06af955": "The `sanitize_summary` function processes a given text to remove unwanted commentary and meta-information. It first checks if the input is \"project summary\" and returns \"It prints.\" if true. Then, it strips FIM special tokens from the text. The function defines lists of bad start phrases and contains phrases that are removed from the text. It splits the text into lines, filters out lines starting with \"-\", \"*\", or any bad start phrases, and removes lines containing specific bad phrases or patterns. Finally, it joins the filtered lines back into a single string and returns it.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\llm_client.py:summarize:117009dbd00dddc6390a8ecc126e756e3571d31973a49d91c58244c9bb9698c6:117009dbd00dddc6390a8ecc126e756e3571d31973a49d91c58244c9bb9698c6": "The function `summarize` in the class `LLMClient` generates a summary for a given text using an LLM (Language Model). It takes parameters such as the text to summarize, the type of prompt template, and optional system instructions. The function constructs a prompt by formatting the input text with the specified template and prepending any system instructions. It then encodes the prompt and checks if its size exceeds a specified budget, logging a warning if it does.\n\nThe function prepares a payload for sending to an LLM endpoint, including the model name, temperature, maximum tokens, and messages (system and user prompts). It attempts to send this payload using the `requests` library, handling potential exceptions such as HTTP errors or request exceptions. If successful, it processes the response by iterating over chunks of content received from the LLM, logging progress every few seconds. The function sanitizes the summary content before returning it.\n\nIf all attempts fail after three retries, the function logs an error and raises a `RuntimeError` with the accumulated error message.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\llm_client.py:summarize:39939b948e23aa652b68a6f98388c052ff8dc4772602ee3435883e6b3644d460:39939b948e23aa652b68a6f98388c052ff8dc4772602ee3435883e6b3644d460": "The `summarize` method in the `LLMClient` class generates a summary for a given text using a specified prompt type. It constructs a prompt by formatting a template with the input text and optionally appending a system prompt. The method then encodes the prompt into tokens, logs its size, and checks if it exceeds a specified token budget. If the prompt is within budget, it sends a request to an endpoint with parameters including the model, temperature, maximum tokens, and messages (system and user prompts). It handles potential errors during the request, such as HTTP errors or request exceptions, by retrying up to three times before raising a runtime error if all attempts fail. The response is parsed for content, sanitized, and returned as the summary.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\manual_utils.py:1a9e3f658f9a14649ee2ba63e5e339212e4e0cfa827ecc803d7ca51083a3738b:1a9e3f658f9a14649ee2ba63e5e339212e4e0cfa827ecc803d7ca51083a3738b": "This module provides functions for splitting text into chunks, summarizing documents using a language model, and merging summaries. It includes utilities for token counting, text chunking based on token limits, finding placeholder tokens, and caching responses to avoid redundant requests to an LLM (Language Model). The module uses concurrent processing with `ThreadPoolExecutor` to handle multiple summarization tasks in parallel.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\manual_utils.py:_count_tokens:f05a692d308dbe59f5cd69eb834deee967656b153ff7b04ee229e4a3ecc6582d:f05a692d308dbe59f5cd69eb834deee967656b153ff7b04ee229e4a3ecc6582d": "This function `_count_tokens` takes a string `text` as input and returns an integer representing the approximate number of tokens in the text. It uses a tokenizer to encode the text into tokens and then calculates the length of this encoded list, which corresponds to the token count.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\manual_utils.py:_split_text:7833d99b3c4b8d74dfaeb28ea288be2d1f3f4d4a80fcaa13e2b6bc442b9aadee:7833d99b3c4b8d74dfaeb28ea288be2d1f3f4d4a80fcaa13e2b6bc442b9aadee": "This function `_split_text` splits a given text into chunks while respecting specified maximum token and character limits. It first splits the text into paragraphs, then iterates through each paragraph to determine if it can be added to the current chunk without exceeding the limits. If adding the paragraph would exceed the limits, it starts a new chunk. The function uses regular expressions to split the text into paragraphs and counts tokens using `_count_tokens`. It ensures that chunks are separated by two newline characters and maintains the total token and character count within specified limits.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\manual_utils.py:_summarize_manual:d5947c0222571c34bd65d6ec14bcce85c52d1d5237396073aecf610c4f75f4e9:d5947c0222571c34bd65d6ec14bcce85c52d1d5237396073aecf610c4f75f4e9": "The `_summarize_manual` function generates a manual summary for the provided text using an LLM (Language Model) client and a caching mechanism. It handles different chunking strategies: \"auto\", \"manual\", and \"none\". The function splits the text into manageable parts if necessary, submits them to the LLM for summarization, caches the responses, and merges them back together if needed. It also includes error handling for network failures and token/character limits.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\manual_utils.py:chunk_docs:abac3a85c857f4736e9a289d686a7899a1258a9c0f29be55a5183cb416531f5e:abac3a85c857f4736e9a289d686a7899a1258a9c0f29be55a5183cb416531f5e": "The `chunk_docs` function takes a list of strings (`docs`) and an optional integer (`token_limit`) with a default value of 2000. It joins the non-empty strings in `docs` with double newlines for separation, then splits the resulting text into chunks that are roughly within the specified token limit. The `_split_text` function is used to perform the actual splitting based on token count and character length.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\manual_utils.py:find_placeholders:ac03fb7c4ced1cc2a0dd33a814cb0b62a0557c0fcb7b28ffdebaa961257c9995:ac03fb7c4ced1cc2a0dd33a814cb0b62a0557c0fcb7b28ffdebaa961257c9995": "The function `find_placeholders` searches for placeholder tokens within a given text. It uses a regular expression defined by `PLACEHOLDER_RE` to identify tokens enclosed in double backticks followed by two square brackets, such as ``[[TOKEN]]``. The function returns a set of these placeholder tokens found in the input text.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\parser_cpp.py:20fbb103bacaa4a0b0e1faa76ad26882965689f182fed8716afa4e58a1cc1689:20fbb103bacaa4a0b0e1faa76ad26882965689f182fed8716afa4e58a1cc1689": "This Python module provides a simple parser for C++ files used by DocGen-LM. It employs line-based parsing to extract namespaces, classes, functions, and public variables from the source code. The parser returns a structured dictionary containing `module_docstring`, `classes`, and `functions`. Each class and function includes their respective `source` snippets and any leading documentation comments.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\parser_cpp.py:_extract_block:7fab4fad4a948f6f343d5776f96d72910be9ff03cb480122abc22e6835dcfbc0:7fab4fad4a948f6f343d5776f96d72910be9ff03cb480122abc22e6835dcfbc0": "The function `_extract_block` takes a list of strings `lines` and an integer `start`. It extracts a block of text starting from the index `start`, which is expected to be the beginning of a code block. The function counts the number of opening and closing braces `{}` in the starting line to determine when the block ends. It iterates through the subsequent lines, adding them to `text_lines` until it encounters a line that closes all open braces. The function returns the extracted text as a single string and the index of the last line included in the block.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\parser_cpp.py:_get_preceding_comment:0b53ee1b41e16e2462f0f8a08976545d7ddeb91da7698ddf47969cc677ef5532:0b53ee1b41e16e2462f0f8a08976545d7ddeb91da7698ddf47969cc677ef5532": "The `_get_preceding_comment` function collects contiguous comment lines appearing before a specified index in a list of code lines. It handles both single-line (`//`) and multi-line (/* ... */) comments, ensuring that the collected comments are returned as a single string. The function iterates backward through the lines until it encounters a non-comment line or reaches the beginning of the list.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\parser_cpp.py:_parse_class_body:298176184be9c1a67cd03c14d3e1ab70b7d5ba3207d12d3556df24a76b0b6b64:298176184be9c1a67cd03c14d3e1ab70b7d5ba3207d12d3556df24a76b0b6b64": "The function `_parse_class_body` parses the body of a class from a list of source code lines. It identifies and extracts public methods and variables within the specified range of lines. The function returns two lists: one for methods and another for variables, each containing dictionaries with details such as name, signature/docstring, type/source code.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\parser_cpp.py:parse_cpp_file:f025c120cc6069c6e15ffe3ea770d364281e3a6c276ff9d00a82284470f414df:f025c120cc6069c6e15ffe3ea770d364281e3a6c276ff9d00a82284470f414df": "This function `parse_cpp_file` takes a path to a C++ source file and returns a dictionary containing structured information about the file. The dictionary includes:",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\parser_java.py:729faf96c4d338772a690be0eaf2138a3bbdae3288180abc6c0056faa4919469:729faf96c4d338772a690be0eaf2138a3bbdae3288180abc6c0056faa4919469": "This Python module provides a simple parser for Java files used by DocGen-LM. It extracts the package name, classes, public methods, and variables from Java source code using naive line-based parsing. The output mirrors the structure of `parse_python_file`, with keys for `module_docstring`, `classes`, and `functions`. Each class entry includes its source code and leading documentation comments (Javadoc or `//`).",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\parser_java.py:_extract_block:7dffb2a582b41c4d1da68cc1246bdb4a8b1fd1441d789cea13240cb2842f14a3:7dffb2a582b41c4d1da68cc1246bdb4a8b1fd1441d789cea13240cb2842f14a3": "The function `_extract_block` extracts a block of code from a list of lines starting at a given index. It reads lines until the balance of opening and closing braces returns to zero, indicating the end of the block. The extracted block is returned along with the index of the last line read.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\parser_java.py:_get_preceding_comment:26d02d7e005cecd73e10cddc2efdb3113ceed0560bc7e1d6b28d57d6ff194852:26d02d7e005cecd73e10cddc2efdb3113ceed0560bc7e1d6b28d57d6ff194852": "The function `_get_preceding_comment` retrieves the preceding comment(s) from a list of lines at a given index. It iterates backward through the lines, collecting single-line and multi-line comments until it encounters a non-comment line or reaches the beginning of the file. The collected comments are then joined into a single string and returned, stripped of leading/trailing whitespace.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\parser_java.py:_parse_class_body:09ed1d7a283e14b279aff54ff1aee7bb7508c82985700b75cd09493e339f292e:09ed1d7a283e14b279aff54ff1aee7bb7508c82985700b75cd09493e339f292e": "The function `_parse_class_body` extracts methods and variables from a block of code within a class. It takes three parameters: `lines`, which is a list of strings representing the lines of code; `start`, which is the starting index of the block to parse; and `end`, which is the ending index of the block to parse.\n\nThe function initializes two empty lists, `methods` and `variables`, to store dictionaries containing information about each method and variable found in the class body. It then iterates over the lines from the specified start index to the end index.\n\nFor each line, it checks if the line starts with \"public \". If it does, the function further checks if the line contains a method signature (indicated by parentheses) or a variable declaration (indicated by a semicolon). Based on this check, it extracts the relevant information:\n\n\nThe function uses helper functions `_extract_block` to extract the method body if it spans multiple lines, and `_get",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\parser_java.py:parse_java_file:0c05f352f49d980b098bc968be5c17636edc113c40ba017bf2015f739cb79a89:0c05f352f49d980b098bc968be5c17636edc113c40ba017bf2015f739cb79a89": "The `parse_java_file` function reads a Java source file from the specified path and parses it to extract information about packages, classes, methods, and variables. It returns a dictionary containing these parsed elements.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\parser_matlab.py:15cf90e58e5b33528fe0fc6fa2e48fa77e43bd0fed902a29ea22b67a2f78ff68:15cf90e58e5b33528fe0fc6fa2e48fa77e43bd0fed902a29ea22b67a2f78ff68": "The module provides a function `parse_matlab_file` that parses MATLAB `.m` files and extracts basic structure. It reads the file content, identifies leading comment lines as the file header, and uses regular expressions to find and parse function declarations, extracting their names and arguments. The result is returned as a dictionary containing the file header comments and a list of functions with their respective argument lists.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\parser_matlab.py:parse_matlab_file:3b663fe94e185ddfb4a37507623ba5d1831e24425e819bac8e0315d2cce9fc0d:3b663fe94e185ddfb4a37507623ba5d1831e24425e819bac8e0315d2cce9fc0d": "The function `parse_matlab_file` reads and parses a MATLAB `.m` file to extract its structure. It returns a dictionary containing the file's header comments and any function declarations found within the file. The header is extracted as lines starting with `%`, and function declarations are identified using a regular expression that matches lines defining functions, capturing their names and arguments.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\parser_python.py:9b7a83be6356666450a5a1a457ffe2e114b6726c1c43053f6e27962b7ce8f0aa:9b7a83be6356666450a5a1a457ffe2e114b6726c1c43053f6e27962b7ce8f0aa": "This module provides a parser for Python files using the `ast` module. It extracts structured information about classes and functions according to the Software Requirements Specification (SRS). The parser can handle both synchronous and asynchronous functions. It includes utilities to format function signatures, parse class definitions, and recursively parse nested classes and functions within a Python file. The main entry point is `parse_python_file`, which takes a file path as input and returns a dictionary containing module docstring, classes, and functions with detailed information such as names, signatures, return types, docstrings, source code segments, subfunctions, and subclasses.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\parser_python.py:_format_arg:616829b8d441118422484f3131f73a16fc08e4e1e6ee9b8772fe4c3094b0ba5a:616829b8d441118422484f3131f73a16fc08e4e1e6ee9b8772fe4c3094b0ba5a": "This function formats an argument from an AST (Abstract Syntax Tree) node. It takes an `ast.arg` object as input and returns a string representation of the argument, including its name and type annotation if present. The function uses `ast.unparse` to convert the annotation into a string format.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\parser_python.py:_format_arguments:a3e722842d20ddc25aaa4e0234c5a93cc90388112edb0201d9209f2ebf2fabca:a3e722842d20ddc25aaa4e0234c5a93cc90388112edb0201d9209f2ebf2fabca": "This function `_format_arguments` takes an `ast.arguments` object as input and returns a string representation of the arguments it contains. The function processes positional-only arguments, regular arguments, variable positional arguments, keyword-only arguments, and variable keyword arguments, formatting each according to its type and default value if provided. It constructs a list of formatted argument strings and joins them with commas to form the final output.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\parser_python.py:_format_signature:4647761b3c61666dbf5cb900769ab8948e9dfbc7a2989604752ec4344fcdfeef:4647761b3c61666dbf5cb900769ab8948e9dfbc7a2989604752ec4344fcdfeef": "This function `_format_signature` takes an `ast.FunctionDef` or `ast.AsyncFunctionDef` object as input and returns a string representing the signature of the function. The signature includes the function name, its parameters formatted by `_format_arguments`, and the return type if specified.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\parser_python.py:_parse_classes:be79acca09f413dad4643407f102fc7f7968c1267e74b592d2979b06b4764bb9:be79acca09f413dad4643407f102fc7f7968c1267e74b592d2979b06b4764bb9": "This function `_parse_classes` recursively parses all `ClassDef` nodes within a given list of AST nodes. It iterates through each item in the input list and checks if it is an instance of `ast.ClassDef`. If so, it calls another function `parse_class` to parse the class node and appends the result to the `classes` list. If the item is an instance of `ast.FunctionDef` or `ast.AsyncFunctionDef`, it recursively calls itself with the body of the function as the new input nodes. Finally, it returns the list of parsed classes.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\parser_python.py:parse_class:1896976d4b637d72faacc3237d9d9d1a012023c704205dc71dd549f646604fe4:1896976d4b637d72faacc3237d9d9d1a012023c704205dc71dd549f646604fe4": "The function `parse_class` takes an AST node representing a class definition and the source code as input. It returns a dictionary containing information about the class, including its name, docstring, methods, subclasses, and source code segment.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\parser_python.py:parse_classes:6042838bf6f5a3f6ec5162734589d90aafef1e1a8889d309e03a6e1c73e8fde9:6042838bf6f5a3f6ec5162734589d90aafef1e1a8889d309e03a6e1c73e8fde9": "The `parse_classes` function serves as a public interface for parsing classes within a Python code node. It takes two parameters: `node`, which is an abstract syntax tree (AST) node representing the Python code, and `source`, a string containing the source code itself. The function calls a private helper function `_parse_classes`, passing it the body of the AST node (`getattr(node, \"body\", [])`) and the source code. It returns a list of dictionaries, where each dictionary represents a class found in the code.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\parser_python.py:parse_function:64e1621a42bb79d013386d235621cc0b5f74d7a4c098f331fcba744116944c51:64e1621a42bb79d013386d235621cc0b5f74d7a4c098f331fcba744116944c51": "This function `parse_function` takes an abstract syntax tree (AST) node representing a function definition (`ast.FunctionDef` or `ast.AsyncFunctionDef`) and the source code as input. It returns a dictionary containing information about the function, including its name, signature, return type, docstring, source code segment, subfunctions, and subclasses.\n\nThe function initializes a dictionary `func_info` with keys for the function's name, signature, return type, docstring, source code, subfunctions, and subclasses. It then iterates through the body of the function node to find any nested function definitions (`ast.FunctionDef` or `ast.AsyncFunctionDef`) and adds their parsed information to the `subfunctions` list.\n\nAdditionally, it calls a helper function `_parse_classes` to extract subclass information from the function's body and stores it in the `subclasses` key of the dictionary. Finally, the function returns the populated `func_info` dictionary.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\parser_python.py:parse_python_file:0a18b234f784169fbe2f9c368551ec551edbe3a15b7712ee2a1da9a0f63e82aa:0a18b234f784169fbe2f9c368551ec551edbe3a15b7712ee2a1da9a0f63e82aa": "The function `parse_python_file` reads a Python source file and extracts structured information. It takes the file path as input and returns a dictionary containing the module docstring, classes, and functions. The function uses the `ast` module to parse the source code and iterates through the nodes to identify class definitions and function definitions, which are then parsed using helper functions `parse_class` and `parse_function`.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\retrofit_sidebar.py:_paths_to_tree:26375594e84c89e562e72e0b2662457b7674f193a84c36de73d8bbe64eab0d8c:26375594e84c89e562e72e0b2662457b7674f193a84c36de73d8bbe64eab0d8c": "Converts a list of file paths into a nested dictionary tree. Each path is split into parts, and the function builds a dictionary structure where each key represents a directory or file name, with nested dictionaries representing subdirectories. The final part of each path becomes a leaf node in the tree.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\retrofit_sidebar.py:_tree_to_ul:6b1a7b3733a2ec870d4489e8363678f1cd76bbf185dd5594e8dec6854d3683ad:6b1a7b3733a2ec870d4489e8363678f1cd76bbf185dd5594e8dec6854d3683ad": "This function recursively constructs an unordered list (`<ul>`) from a nested dictionary structure. It iterates through the keys of the dictionary, creating list items (`<li>`) for each key and appending them to the `<ul>`. If a value is another dictionary, it calls itself recursively to create nested lists. The resulting `<ul>` element is returned.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\retrofit_sidebar.py:bb2d558188c65f42b73962b7e4617313b7ad1bc9b43ffb25fab458b70e980851:bb2d558188c65f42b73962b7e4617313b7ad1bc9b43ffb25fab458b70e980851": "This module defines a script to replace documentation sidebars with a hierarchical module list. It includes functions for converting file paths into a nested dictionary tree and recursively building unordered lists from this tree. The `retrofit_sidebar` function scans a source directory for Python modules, constructs a hierarchical structure, and updates HTML files in the documentation directory by replacing existing sidebars with the new hierarchical module list. The script is executed via the command line with optional arguments for specifying the source root directory and the documentation directory.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\retrofit_sidebar.py:main:bb768d57119cf56136bbcb2d440422de0d1cc2a8a5efc62520e883a32baf8318:bb768d57119cf56136bbcb2d440422de0d1cc2a8a5efc62520e883a32baf8318": "The `main` function sets up an argument parser to handle command-line arguments for specifying the source root directory and the documentation directory. It then calls the `retrofit_sidebar` function with these arguments to modify a sidebar with documentation information based on the hierarchical module list of the project.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\retrofit_sidebar.py:retrofit_sidebar:de510187fda02dd2f0254fb1bd5fd1afb2857a7d6b2cb9095837cc538f79b0e2:de510187fda02dd2f0254fb1bd5fd1afb2857a7d6b2cb9095837cc538f79b0e2": "The function `retrofit_sidebar` takes two parameters: `source_root` and `docs_dir`. It scans the directory specified by `source_root` to find all Python files. These file paths are converted into a hierarchical tree structure using `_paths_to_tree`. The HTML markup for this tree is then generated using `_tree_to_ul`.\n\nThe function iterates over all `.html` files in the directory specified by `docs_dir`. For each HTML file, it finds the `<div>` element with the class \"sidebar\" and replaces its content with the newly generated sidebar markup. The modified HTML file is then saved back to disk.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\reviewer.py:4f9d422499a1acff78c67b05122179a409cbacd25a4c242442e0aef707dbeb81:4f9d422499a1acff78c67b05122179a409cbacd25a4c242442e0aef707dbeb81": "This module provides a tool to review HTML documentation generated by DocGen-LM. It includes functions to check for assistant-like phrases, contradictions, and hallucinations in the HTML content. The `check_assistant_phrasing` function identifies paragraphs containing specific phrases that may indicate automated assistance. The `check_contradictions` function looks for inconsistencies between the summary and actual documented elements like methods, functions, and classes. The `check_hallucinations` function searches for terms that are unlikely to appear in documentation, such as game titles or food recipes. The module also provides a command-line interface (`main`) to review all HTML files in a specified directory and optionally fix issues by sanitizing the paragraphs using a function from `llm_client`.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\reviewer.py:_extract_tags:33189896e2466a63bb14c3152e93b83ab0bbfbccc73d70d0c15dd891894c5ec1:33189896e2466a63bb14c3152e93b83ab0bbfbccc73d70d0c15dd891894c5ec1": "The function `_extract_tags` extracts all occurrences of a specified HTML tag and its content from a given HTML string. It uses a regular expression pattern to match the opening and closing tags along with their attributes and inner text. The `re.findall` method is used to find all matches, returning them as a list of strings. This function is case-insensitive due to the `re.IGNORECASE` flag and can handle multiline content within tags thanks to `re.DOTALL`.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\reviewer.py:_find_line_number:1723524fbc7b1022b4cc8cb0bffd8cebe4417989bad63ceea287649b63767db1:1723524fbc7b1022b4cc8cb0bffd8cebe4417989bad63ceea287649b63767db1": "The function `_find_line_number` searches for a specified phrase within an HTML string and returns the line number where the phrase is found. If the phrase is not found, it returns -1. The search is case-insensitive.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\reviewer.py:_is_generated_html:a4544b4407820d7954654c77febb1e28054ed953d287ef74d60d55564624745e:a4544b4407820d7954654c77febb1e28054ed953d287ef74d60d55564624745e": "Function `_is_generated_html` checks if a given string `text` appears to be output from DocGen-LM, a tool for generating static HTML documentation. It returns `True` if the text contains specific markers indicating it was produced by DocGen-LM: the phrase \"Generated by DocGen-LM\", an `<h1>` heading titled \"Project Documentation\", and headings for classes (`<h2> Class:`) and methods (`<h3> Method:`).",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\reviewer.py:_review_file:0028961dc3214be03d160b83df262a3c61def03f346ef60986ca0bd302330926:0028961dc3214be03d160b83df262a3c61def03f346ef60986ca0bd302330926": "The function `_review_file` reads an HTML file from a specified path, checks for assistant phrasing, contradictions, and hallucinations within the HTML content. It returns a list of issues found. If `autofix` is enabled and issues are detected, it sanitizes the paragraphs in the HTML and writes the changes back to the file.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\reviewer.py:_sanitize_paragraphs:7abd5b696dad4c12c4f0bcaa5b2d4b8536d45a55a533f0b5512e59e78ed160a1:7abd5b696dad4c12c4f0bcaa5b2d4b8536d45a55a533f0b5512e59e78ed160a1": "The function `_sanitize_paragraphs` takes an HTML string as input and sanitizes the content within paragraph tags. It uses a regular expression to find all paragraph tags and applies a replacement function `repl` to each match. The replacement function strips HTML from the text inside the paragraph, sanitizes it using another function `sanitize_summary`, and then wraps the sanitized text back in paragraph tags. This ensures that all paragraphs within the input HTML are cleaned and formatted correctly.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\reviewer.py:_strip_html:ee5b4d1a40f6e6d0ef768da7c9e1b760c2be06783712b50b885b56b52d61d9ae:ee5b4d1a40f6e6d0ef768da7c9e1b760c2be06783712b50b885b56b52d61d9ae": "The function `_strip_html` takes a string `text` as input and returns a new string with all HTML tags removed. It uses the `re.sub` function from the `re` module to substitute any sequence of characters enclosed in angle brackets (`<...>`) with an empty string, effectively removing them from the text.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\reviewer.py:check_assistant_phrasing:cd9c7dcd28070558c6f41acec412aa78b3e739fb6c34a37be07fedec09cac867:cd9c7dcd28070558c6f41acec412aa78b3e739fb6c34a37be07fedec09cac867": "This function `check_assistant_phrasing` takes an HTML string as input and returns a list of phrases that appear to be assistant-like. It searches for paragraphs (`<p>` tags) in the HTML, strips out any HTML tags from the text within these paragraphs, converts the text to lowercase, and checks if any predefined assistant phrases are present. If a match is found, it appends the phrase along with its line number in the original HTML to the findings list.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\reviewer.py:check_contradictions:5c0ff3fad6e4312918d61688eb73d60b86866c44781959aeb6bdd133498feb03:5c0ff3fad6e4312918d61688eb73d60b86866c44781959aeb6bdd133498feb03": "Function `check_contradictions` analyzes HTML content to identify contradictions based on the presence of specific tags and text. It extracts paragraphs, method headers, function headers, and class headers from the HTML. The function checks if the summary text states there are no methods, functions, or classes but finds corresponding headers in the HTML. If such contradictions are found, it appends descriptions of these contradictions to a list and returns this list.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\reviewer.py:check_hallucinations:cbb513d54bf725b3378b7368212e1ea100dfeaa772a4797ac5a11ff106de525b:cbb513d54bf725b3378b7368212e1ea100dfeaa772a4797ac5a11ff106de525b": "This function `check_hallucinations` analyzes an HTML string to detect the presence of hallucination phrases. It returns a list of detected hallucination terms. The function iterates over paragraph tags (`<p>`) extracted from the HTML, strips any HTML tags, converts the text to lowercase, and checks for the presence of predefined hallucination terms in each paragraph. If a term is found, it is added to the list of findings, which is then returned.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\reviewer.py:main:79279fec222022919f1ef78ea36d4b878a571861a09ba701f66aa6dd86d98e71:79279fec222022919f1ef78ea36d4b878a571861a09ba701f66aa6dd86d98e71": "The `main` function sets up an argument parser to accept a directory path and an optional flag for automatic file fixing. It then calls the `review_directory` function with the provided directory and the autofix option, returning 0 upon completion.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\reviewer.py:repl:8d4be81bb720308ba4b490d2737e75ac0b9394e5cde13a9ec29de5cef2c99298:8d4be81bb720308ba4b490d2737e75ac0b9394e5cde13a9ec29de5cef2c99298": "The function `repl` takes a match object as input, extracts the first group from it, strips HTML from this group using `_strip_html`, sanitizes the resulting text using `sanitize_summary`, and then returns the sanitized text wrapped in paragraph tags.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\reviewer.py:review_directory:763b94cc1f65e984ca085972293661564a5d98be56e86a1d3475e97456a4f798:763b94cc1f65e984ca085972293661564a5d98be56e86a1d3475e97456a4f798": "The `review_directory` function iterates through all HTML files within a specified directory and its subdirectories. For each file, it calls the `_review_file` function to review and potentially autofix any issues found. If an error occurs during the review process, it prints an error message and continues with the next file. The results of the review are printed line by line.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\sanitize_docs.py:_sanitize_html:9f089834b1ed466c433ce75a622924cf7b72fa7b24ec460543d953961ac83799:9f089834b1ed466c433ce75a622924cf7b72fa7b24ec460543d953961ac83799": "The function `_sanitize_html` sanitizes HTML content by removing unwanted tags and cleaning the inner text of specific HTML elements. It uses a regular expression pattern to match paragraph (`<p>`), list item (`<li>`), and heading (`<h1>` to `<h6>`) tags. For each matched tag, it extracts the inner content, removes any nested HTML tags using another regular expression, cleans the remaining text with `sanitize_summary`, and then reconstructs the tag with the cleaned content. The function returns the sanitized HTML string.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\sanitize_docs.py:cbc2c687cd4c1464fbfe96caaeab835a5e5cff138095dc8ae251d79701b5b3d4:cbc2c687cd4c1464fbfe96caaeab835a5e5cff138095dc8ae251d79701b5b3d4": "This module provides a script to sanitize existing HTML documentation. It defines functions to sanitize individual HTML files and entire directories containing HTML files. The sanitization process involves removing unwanted tags from the content within specific HTML elements (like `<p>`, `<li>`, and headers) and then applying a summary sanitization function (`sanitize_summary` from `llm_client`) to the cleaned content. The script can be run as a command-line tool, accepting a directory path as an argument.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\sanitize_docs.py:main:26c077579ab7ad4544a4bca617c056fc9f689aba829036973173ab1c31861994:26c077579ab7ad4544a4bca617c056fc9f689aba829036973173ab1c31861994": "The `main` function is the entry point of a Python script designed to sanitize generated HTML documentation. It takes an optional list of command-line arguments (`argv`) and returns an integer status code.\n\n1. The function creates an argument parser using `argparse.ArgumentParser`, providing a description for the script.\n2. It defines a required argument `directory` which specifies the path to the HTML output directory that needs sanitization.\n3. The parsed arguments are stored in the `args` variable.\n4. The function calls `sanitize_directory(Path(args.directory))`, passing the path to the directory containing the HTML files for sanitization.\n5. Finally, it returns 0, indicating successful execution of the script.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\sanitize_docs.py:repl:0e85ef240a6b1fce85b6eaf1f0ee1b59cecd5ac7c47b340d34255ed381642d07:0e85ef240a6b1fce85b6eaf1f0ee1b59cecd5ac7c47b340d34255ed381642d07": "The function `repl` takes a regular expression match object as input, extracts the tag and content from it, removes any HTML tags from the content, sanitizes the remaining text using the `sanitize_summary` function, and returns the cleaned text wrapped in the original tag.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\sanitize_docs.py:sanitize_directory:24d54612adc512cbd3fb3bcdb46359735fd422346bdeb720cbfe94a2fe10224d:24d54612adc512cbd3fb3bcdb46359735fd422346bdeb720cbfe94a2fe10224d": "The function `sanitize_directory` takes a directory path as input and iterates over all HTML files within that directory and its subdirectories using `rglob`. For each HTML file, it reads the content, sanitizes it by calling `_sanitize_html`, and then writes the sanitized content back to the file.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\scanner.py:_is_subpath:cd4abce83e2437bd2cff4b3e6a5bb751f788e423ebfdd771e2b8745e51654866:cd4abce83e2437bd2cff4b3e6a5bb751f788e423ebfdd771e2b8745e51654866": "This function checks whether a given `path` is either equal to or located within the directory specified by `parent`. It uses the `relative_to` method of the `Path` class to determine if `path` can be made relative to `parent`. If successful, it returns `True`, indicating that `path` is a subpath of `parent`. If a `ValueError` is raised during this process, it means that `path` is not within or equal to `parent`, and the function returns `False`.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\scanner.py:a6d2f1f5582a4ecc843b89dfb8f7747af779e8c3bbcef06f98d1c3bb16723167:a6d2f1f5582a4ecc843b89dfb8f7747af779e8c3bbcef06f98d1c3bb16723167": "This module provides a function to recursively discover source files within a directory structure. It supports ignoring specified paths and can optionally display a progress bar during the scan. The supported file extensions are `.py`, `.m`, `.cpp`, `.h`, and `.java`. The function returns a sorted list of absolute paths to the discovered source files.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\scanner.py:scan_directory:15a3652a23dcce3da26e749b314d15a7e1a0d88a5619afef5f3dd6fada53bb85:15a3652a23dcce3da26e749b314d15a7e1a0d88a5619afef5f3dd6fada53bb85": "The function `scan_directory` recursively discovers Python, MATLAB, C++, header, and Java files within a specified directory. It skips directories and files listed in the `ignore` parameter. If `show_progress` is set to True, it displays a progress bar during the scan. The function returns a sorted list of absolute paths to discovered source files.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\setup.py:501f48f7d373462af3d41b0caf7d7e23e2a79c5fe2886cf307b86c01a8b8d82f:501f48f7d373462af3d41b0caf7d7e23e2a79c5fe2886cf307b86c01a8b8d82f": "This Python script uses `setuptools` to define a package with three modules: `explaincode`, `parser_cpp`, and `parser_java`. It includes a conditional block that runs the `setup` function from `setuptools` when the script is executed directly.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\summarize_utils.py:4695202ac971832489d602c6dda9f1ab07cde64220a89fe58051be341bea87cc:4695202ac971832489d602c6dda9f1ab07cde64220a89fe58051be341bea87cc": "This module provides functions for summarizing text using a language model client, with caching to avoid redundant requests. It includes:\n\n1. `_summarize`: Summarizes a single piece of text.\n2. `summarize_chunked`: Sums up large pieces of text by breaking them into smaller chunks and then recursively merging the summaries.\n\nThe module uses a tokenizer for tokenization operations, handles caching to store previously summarized texts, and manages chunking and merging processes to ensure efficient summarization even for long texts.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\summarize_utils.py:_merge_recursive:1573262705fa7acc3539badb3c4159161cb7464631906900df02533f5082deae:1573262705fa7acc3539badb3c4159161cb7464631906900df02533f5082deae": "The function `summarize_chunked` is designed to recursively merge and summarize text chunks using an LLM (Language Model). It takes a list of items (text chunks) and attempts to merge them into a single summary that fits within the specified context length. If merging fails due to exceeding the context length, it splits the chunks further and recursively merges the resulting groups until all chunks are summarized. The function uses caching to store intermediate results for efficiency.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\summarize_utils.py:_summarize:b48f8612a2cd5114a9eb4abadf44ccf0a7cd9f0ff51c8e352c183b857e7b6635:b48f8612a2cd5114a9eb4abadf44ccf0a7cd9f0ff51c8e352c183b857e7b6635": "The `_summarize` function interfaces with an LLMClient to generate a summary of provided text. It uses a ResponseCache to store and retrieve summaries based on a unique key. If the summary is found in the cache, it sanitizes the cached version before returning it. If not found, it generates a new summary using the client's `summarize` method with specified prompt type and system prompt, caches the result, and then returns it.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\summarize_utils.py:summarize_chunked:b7e6e2d53844ad6971eb9cc9932a7466eb404bf329902ff93e31328cd17ec920:b7e6e2d53844ad6971eb9cc9932a7466eb404bf329902ff93e31328cd17ec920": "This function `summarize_chunked` is designed to summarize a given text by chunking it if necessary and then combining the summaries into a single technical paragraph. It uses an LLMClient for generating summaries, a ResponseCache for caching responses, and various parameters for controlling the summarization process.\n\nThe function first checks if the text can be summarized in one go without exceeding the available token budget. If not, it chunks the text into manageable parts using `chunk_text`. Each chunk is then summarized individually. The summaries are combined recursively to form a final technical paragraph, ensuring that the total length does not exceed the available tokens.\n\nThe function handles exceptions during chunking and summarization, providing fallback mechanisms to sanitize any disclaimers or unwanted content in the final summary.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_cache.py:86aa81c1534bee80f7374373dc73e2b46ddbf6b59dc85f1dbb7004b4837537bf:86aa81c1534bee80f7374373dc73e2b46ddbf6b59dc85f1dbb7004b4837537bf": "This module defines a `ResponseCache` class for caching responses and progress data, along with test functions to verify its functionality. The `test_cache_round_trip` function checks that data can be set and retrieved from the cache. The `test_cache_get_missing` function verifies that attempting to retrieve a non-existent key returns `None`. The `test_progress_tracking` function tests setting and clearing progress data in the cache.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_cache.py:test_cache_get_missing:c26df8b42de2eecbb5143e92756ad7977554d170c1bd7d0f444830704d9fb5d0:c26df8b42de2eecbb5143e92756ad7977554d170c1bd7d0f444830704d9fb5d0": "The function `test_cache_get_missing` tests the behavior of a caching mechanism when attempting to retrieve a value for a key that does not exist in the cache. It creates an instance of `ResponseCache` with a temporary file path and asserts that calling `get` with a non-existent key returns `None`.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_cache.py:test_cache_round_trip:21dbcd22bbc7134ffe6f345d3a74c4937745b54fe2e443e29b589f6844881572:21dbcd22bbc7134ffe6f345d3a74c4937745b54fe2e443e29b589f6844881572": "This function tests the round-trip functionality of a caching mechanism. It creates a temporary file to store cache data, initializes a `ResponseCache` object with this file path, and sets a key-value pair in the cache. Then, it reads the cache from the same file using a new `ResponseCache` instance and asserts that the value retrieved matches the originally stored value.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_cache.py:test_progress_tracking:1e5308033f2ee20f34d089f78f03c9827eaf43793d04ccb76abd3f2f1eb299c8:1e5308033f2ee20f34d089f78f03c9827eaf43793d04ccb76abd3f2f1eb299c8": "The function `test_progress_tracking` tests the functionality of a caching mechanism for progress tracking in code documentation. It creates a temporary cache file, sets a progress entry for a module, and then verifies that the progress can be retrieved correctly. After clearing the progress, it confirms that the cache is empty again.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_chunk_utils.py:eefe3cf76f5068de7a8511c465b25cf82a54fa62b999afa7871de7ddb1327afb:eefe3cf76f5068de7a8511c465b25cf82a54fa62b999afa7871de7ddb1327afb": "The module contains tests for a tokenizer and a text chunking utility. The tokenizer is expected to encode and decode text correctly, stripping finalization tokens while preserving spaces. The text chunking function should split text into chunks of a specified length, ensuring that markdown headings and code blocks are not broken across chunks.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_chunk_utils.py:test_chunk_text_preserves_code_blocks:84e911fc5850b4c582111708672893f3a8f5c58b469595400f72a6d6ed483d60:84e911fc5850b4c582111708672893f3a8f5c58b469595400f72a6d6ed483d60": "",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_chunk_utils.py:test_chunk_text_reconstructs_content:1037c6415e96ba1c931a3bf25517608bb4421a96ff20887afbd6c2de6389b8e6:1037c6415e96ba1c931a3bf25517608bb4421a96ff20887afbd6c2de6389b8e6": "This function tests the `chunk_text` utility by ensuring it correctly splits a long string into smaller chunks and then reconstructs the original content. It uses a tokenizer to determine chunk boundaries, verifies that the reconstructed text matches the original, and checks that multiple chunks were created.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_chunk_utils.py:test_chunk_text_splits_markdown_headings:f8b7305130d8eeddda82664568eeacab334f3a5ca7ede388600bc7d6c997fcf2:f8b7305130d8eeddda82664568eeacab334f3a5ca7ede388600bc7d6c997fcf2": "This function tests the `chunk_text` function to ensure it correctly splits text into manageable parts while preserving markdown headings. It uses a tokenizer obtained from `get_tokenizer()` and specifies a chunk size of 4. The test asserts that the text is split into two chunks, with each chunk starting with a markdown heading (`# H1` and `# H2`).",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_chunk_utils.py:test_get_tokenizer_roundtrip:3f93aab1252fe9030985f2ddc3fab01e055ab7cb0c8435da65b7ac3e28e8f2ae:3f93aab1252fe9030985f2ddc3fab01e055ab7cb0c8435da65b7ac3e28e8f2ae": "The function `test_get_tokenizer_roundtrip` tests the round-trip encoding and decoding functionality of a tokenizer. It retrieves a tokenizer instance using the `get_tokenizer` function, encodes a sample text \"hello world\" into tokens, asserts that the result is a list, decodes the tokens back to text, and verifies that the decoded text matches the original input after stripping any leading or trailing whitespace.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_chunk_utils.py:test_get_tokenizer_strips_fim_tokens:d13f3676a922747034177d26ec0d938c0a2763912711e12912fad29e39c831df:d13f3676a922747034177d26ec0d938c0a2763912711e12912fad29e39c831df": "The function `test_get_tokenizer_strips_fim_tokens` tests whether a tokenizer removes specific token markers (fim tokens) from encoded and then decoded text. It asserts that the decoded text does not contain any fim tokens and is free of extra spaces, ensuring consistent formatting.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_docgenerator.py:bd93d1343982129d654c006ec965a99e35d08b1cc647b7560f7fcc9a9e98b43b:bd93d1343982129d654c006ec965a99e35d08b1cc647b7560f7fcc9a9e98b43b": "The module contains unit tests for a documentation generation tool. It uses the `unittest.mock` library to patch dependencies and test various scenarios, such as handling invalid Python files, generating summaries for classes and functions, skipping non-UTF8 files, and processing different types of source files like C++, Java, and Python. The tests ensure that the tool correctly identifies and processes code elements, generates summaries using an LLMClient, and handles edge cases gracefully.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_docgenerator.py:fake_sum:907ad79019658e09a87793688d60b2c12c225d6e2be20dbd0ad08c5edd28dd34:907ad79019658e09a87793688d60b2c12c225d6e2be20dbd0ad08c5edd28dd34": "The `fake_sum` function is designed to generate a summary of text using an LLM client. It takes parameters including the client, cache object, key, text argument, and prompt type. The function uses a template based on the prompt type, calculates the overhead for system and template prompts, determines the available tokens, and asserts that the length of the text argument does not exceed these available tokens. If the prompt type is \"module,\" it returns a string of 30 \"summary\" words; otherwise, it returns \"short.\"",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_docgenerator.py:fake_sum:d767a94db52b59530e002bc5eb7f969c97a4081898e1e6b37b70cd37040f6e5c:d767a94db52b59530e002bc5eb7f969c97a4081898e1e6b37b70cd37040f6e5c": "The function `fake_sum` is designed to interact with an LLM client, utilizing a cache object and a key for managing responses. It takes parameters including the client, cache object, key, text argument, prompt type, and an optional system prompt.\n\n1. The function retrieves a template based on the provided prompt type from a dictionary of prompt templates.\n2. It calculates the overhead by encoding the system prompt and the empty template using a tokenizer, then adding their lengths.\n3. It determines the available context tokens by subtracting the overhead from a predefined maximum context token limit.\n4. The function asserts that the length of the encoded text argument does not exceed the available context tokens.\n5. Depending on the prompt type, it returns either \"long \" repeated 200 times or \"short\".",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_docgenerator.py:test_chunking_accounts_for_prompt_overhead:eb4f99a0aa4b8cbc3fcbf9c328b92fa9816111c18dc876a3c1b1a86c1e7e521e:eb4f99a0aa4b8cbc3fcbf9c328b92fa9816111c18dc876a3c1b1a86c1e7e521e": "This function tests the `summarize_chunked` function from the `llm_client.py` module. It sets up a tokenizer, defines a text string, and creates a cache object. The function calculates the prompt overhead by encoding the system prompt and a template with an empty text value. It then sets the maximum context tokens to be greater than this overhead plus 10. Using a mock for the `_summarize` function from `summarize_utils.py`, it calls `summarize_chunked` with specified parameters, including a client object, cache, key prefix, text, prompt type, and maximum context tokens. The test asserts that the `_summarize` function was called more than once, indicating that the text was chunked and summarized appropriately.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_docgenerator.py:test_clean_output_dir:9178269d761b19381b9700dcadb89e6afe17b9fefcd057032e868662c2a89f16:9178269d761b19381b9700dcadb89e6afe17b9fefcd057032e868662c2a89f16": "The function `test_clean_output_dir` tests the `clean_output_dir` function from the `docgenerator` module. It creates a temporary directory with files and subdirectories, simulating an output directory for documentation. The function is then called to clean this directory. After cleaning, it asserts that the file generated by DocGen-LM (`old.html`) has been removed, while other files (`custom.html` and `style.css`) remain unchanged.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_docgenerator.py:test_generates_class_and_function_summaries:ba9b3edc67fa9b226b4ded7bd6b3e4fa429965b5c8dc743f7bec2f0f9a78a2ac:ba9b3edc67fa9b226b4ded7bd6b3e4fa429965b5c8dc743f7bec2f0f9a78a2ac": "The function `test_generates_class_and_function_summaries` is a unit test for generating class and function summaries using the `docgenerator.py` module. It creates a temporary project directory with a Python file containing a class and a function, then calls the `main` function to generate documentation. The test uses a mock LLM client to simulate responses for different types of summaries. After running the main function, it checks that the generated HTML files contain the improved class and function summaries as well as the module summary.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_docgenerator.py:test_handles_class_without_docstring:8b5c1b3aeece9db0db2f325956e3586c589f1dc18a8b7b77fc2c25a524a1990c:8b5c1b3aeece9db0db2f325956e3586c589f1dc18a8b7b77fc2c25a524a1990c": "This function tests the handling of a class without a docstring by creating a temporary project directory with a Python file containing an unannotated class. It then invokes the `main` function from the `docgenerator.py` module, mocking the LLM client to return predefined summaries for different parts of the project. The test asserts that the output HTML file includes the summary for the class.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_docgenerator.py:test_merge_recurses_when_prompt_too_long:63995c13931fc4f780da35a7e9dc90774c1aeb81af8212115abc106b4aacc0dd:63995c13931fc4f780da35a7e9dc90774c1aeb81af8212115abc106b4aacc0dd": "This function `test_merge_recurses_when_prompt_too_long` tests the behavior of merging summaries when the prompt is too long. It uses a fake summarization function to simulate responses and asserts that the merge operation occurs multiple times. The test ensures that the system can handle large inputs by breaking them into manageable chunks and recursively summarizing them.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_docgenerator.py:test_processes_cpp_file:a16c53c309cb844bbeb6b6887b4513d11c885f2ef974b424dd290f77831db292:a16c53c309cb844bbeb6b6887b4513d11c885f2ef974b424dd290f77831db292": "The function `test_processes_cpp_file` is a unit test for processing a C++ file using the DocGen-LM tool. It sets up a temporary project directory with a single C++ source file named `mod.cpp`. The function then calls the `main` function of the `docgenerator` module, passing the path to the project directory and specifying an output directory for documentation.\n\nThe test uses mock objects to simulate the behavior of the `parse_cpp_file` function from the `docgenerator` module and an instance of the `LLMClient` class. The mock client is configured to return a predefined parsed structure and a summary string when called.\n\nAfter executing the main function, the test asserts that the return value is 0 (indicating success) and that the `parse_cpp_file` function was called exactly once. Finally, it checks that an HTML file named `mod.html` has been created in the output directory.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_docgenerator.py:test_processes_java_file:f750f8a68fbf65b2720669c7c3259629cea642ae1820dcdb1b61ec6a4afa2289:f750f8a68fbf65b2720669c7c3259629cea642ae1820dcdb1b61ec6a4afa2289": "The function `test_processes_java_file` tests the process of generating documentation for a Java file using the DocGen-LM tool. It sets up a temporary project directory with a Java class file, simulates parsing and summarization processes, and verifies that the output HTML file is generated successfully. The test uses mocking to isolate dependencies and assert the expected behavior of the main function and its components.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_docgenerator.py:test_project_summary_is_sanitized:ef9f511bdf67cd4b8c9e265f12c664690fff3e97fc61c8739884fec79169bfcb:ef9f511bdf67cd4b8c9e265f12c664690fff3e97fc61c8739884fec79169bfcb": "The function `test_project_summary_is_sanitized` tests the sanitization of project summaries generated by the `docgenerator` tool. It creates a temporary project directory with a Python module, invokes the main function with this project as input and an output directory specified, and then checks that the HTML output does not contain unwanted content like \"You can run this\" but includes expected content like \"It prints.\" The test also verifies that the LLMClient's `summarize` method was called with the correct arguments.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_docgenerator.py:test_readme_summary_used:36920ca8595df4419ab3ced5eeee34af26ed7a6809ff4961fb9e5cb603995008:36920ca8595df4419ab3ced5eeee34af26ed7a6809ff4961fb9e5cb603995008": "This function tests the generation of a README summary using the `docgenerator` module. It creates a temporary project directory with a Python file and a README.md file. The function then calls the `main` function from the `docgenerator` module, passing the path to the project directory and specifying an output directory for the documentation. A mock LLM client is used to simulate responses during the summarization process. The test asserts that the return value of the `main` function is 0 (indicating success) and that the generated HTML file contains a summary of the README content, specifically checking if \"readme summary\" is present in the HTML text. Additionally, it verifies that the LLM client's `summarize` method was called with \"readme\" as one of its arguments.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_docgenerator.py:test_single_long_partial_is_recursively_chunked:b678a1a86f186431b8c0b6d555cac7375340f02542e185b058a84ac478539f03:b678a1a86f186431b8c0b6d555cac7375340f02542e185b058a84ac478539f03": "This function `test_single_long_partial_is_recursively_chunked` tests the recursive chunking of a long text into manageable parts using an LLM client. It uses a mock summary function to simulate responses from the LLM and asserts that the text is split into multiple chunks when necessary. The test checks if the number of calls made to the mock summary function for docstring prompts is greater than one, indicating successful recursive chunking.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_docgenerator.py:test_skips_invalid_python_file:632912593f28f7dbbeec71ad6d079fd7757b08ac85e27bbdcd85a2903d06bd6c:632912593f28f7dbbeec71ad6d079fd7757b08ac85e27bbdcd85a2903d06bd6c": "The function `test_skips_invalid_python_file` tests the behavior of a code documentation tool when encountering an invalid Python file. It creates a temporary project directory with an invalid Python file (`bad.py`) that contains syntax errors due to a leading zero in a numeric literal. The function then calls the main function of the documentation generator with this project directory and specifies an output directory. A mock LLM client is used to simulate successful pinging and summarization. After running the main function, the test asserts that only the index page (`index.html`) is generated in the output directory, while no HTML file for the invalid Python file (`bad.py`) is created.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_docgenerator.py:test_skips_non_utf8_file:a3d1ffdc0918858db9b16db3247cf1c0f82e30d48882c6da8904580f0387a87e:a3d1ffdc0918858db9b16db3247cf1c0f82e30d48882c6da8904580f0387a87e": "The function `test_skips_non_utf8_file` tests the behavior of a code documentation tool when encountering non-UTF-8 encoded files. It creates a temporary project directory with a file that contains non-UTF-8 bytes, simulates an LLM client that responds to summarization requests, and runs the main function of the documentation generator with the specified project and output directories. The test asserts that the main function returns 0 (indicating success) and that only an `index.html` file is generated in the output directory, while a non-UTF-8 file (`bad.py`) does not produce any output.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_docgenerator.py:test_structured_chunker_keeps_functions_atomic:5eab3dab186f2ca533ae98eae442b3b8182ae83d17db4f699316f91a7515db65:5eab3dab186f2ca533ae98eae442b3b8182ae83d17db4f699316f91a7515db65": "This function tests the `chunk_utils` module's ability to keep functions atomic when chunking text. It creates a Python file with two functions, each containing a loop. The function then parses this file using a parser for Python code and uses a tokenizer to determine the length of the source code. It sets up a mock response cache and calls the `_summarize_module_chunked` function from the `docgenerator` module, passing in the parsed module, tokenizer, and budget constraints. The test asserts that two chunks are created, each containing one of the functions' source code.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_docgenerator.py:test_structured_chunker_splits_large_class_by_method:f95b53ab5e53fd33d0d6f89c5757e2460094ac4a9664560c530c8ce74bd35ea7:f95b53ab5e53fd33d0d6f89c5757e2460094ac4a9664560c530c8ce74bd35ea7": "This function tests the `test_structured_chunker_splits_large_class_by_method` function, which is designed to split a large Python class into smaller chunks based on its methods. It uses various modules and utilities from the project to achieve this:\n\n1. **Imports**: The function imports necessary classes and functions from modules such as `cache`, `parser_python`, `chunk_utils`, `docgenerator`, and `llm_client`.\n\n2. **Test Setup**:\n\n3. **Tokenizer and Cache Initialization**:\n\n4. **Mocking and Testing**:",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_docgenerator.py:test_subclass_methods_are_summarized:1d85f79813bc8bd23b3bdd4d7654b3859c2c7d3e662a4c6cdf231b0feb995a13:1d85f79813bc8bd23b3bdd4d7654b3859c2c7d3e662a4c6cdf231b0feb995a13": "The function `test_subclass_methods_are_summarized` tests the summarization of methods within subclasses. It creates a temporary project directory with a Python file containing a class `A` that has a subclass `B` with a method `m`. The function then uses mock objects to simulate an LLM client and the summarization process, ensuring that the method `m` is included in the calls to `_summarize_chunked`. It asserts that the output directory contains the expected summary for the method.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_docgenerator.py:test_summarize_chunked_splits_long_text:abbbef3a95b896205d8cfd99f60a7f53bae9e83c6f294881fd8e054289a32e30:abbbef3a95b896205d8cfd99f60a7f53bae9e83c6f294881fd8e054289a32e30": "This function tests the `summarize_chunked` function from the `summarize_utils` module. It sets up a tokenizer, creates a cache object, and mocks the `_summarize` function to return \"summary\". The function is called with a long text string, a client object, a cache object, a key prefix, a prompt type, a maximum context tokens value, and a chunk token budget. The test asserts that the `_summarize` function was called more than once during the execution of `summarize_chunked`.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_docgenerator_subclasses.py:a9e56fb250c2146bacd150cd8d89d139b9ef4116bbde468ba21945e1b4b4b5b1:a9e56fb250c2146bacd150cd8d89d139b9ef4116bbde468ba21945e1b4b4b5b1": "The module defines a test function `test_subclass_docs_and_method_summary` that uses the `unittest.mock.patch` decorator to mock an `LLMClient`. It sets up a temporary project directory with a Python file containing a class hierarchy. The `main` function from the `docgenerator` module is called with this project directory and an output directory specified. The test asserts that the return value of `main` is 0, indicating success. It then checks that the generated HTML documentation contains summaries for the class \"B\" and its method \"m\", as well as a placeholder \"docstring summary\".",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_docgenerator_subclasses.py:test_subclass_docs_and_method_summary:4ca1bb0e22b1a06d0f076c5aed81ebb88551ca1b4158f6a1493e930ab3ad652b:4ca1bb0e22b1a06d0f076c5aed81ebb88551ca1b4158f6a1493e930ab3ad652b": "This function `test_subclass_docs_and_method_summary` tests the generation of documentation for a subclass and its method using the `docgenerator` module. It sets up a temporary project directory with a Python file containing a class `A` that has a nested class `B`, which in turn contains a method `m`. The function then calls the `main` function from the `docgenerator` module to generate documentation for this project, specifying an output directory.\n\nThe test uses a mock LLM client (`MockClient`) to simulate responses from the language model. It asserts that the `ping` method of the mock client returns `True`, indicating successful connection. The `summarize` method is mocked to return a summary string based on the provided text and project type.\n\nAfter running the main function, the test reads the generated HTML file from the output directory. It checks for the presence of specific strings related to the subclass `B` and its method `m`, ensuring that the documentation was correctly generated and includes summaries as expected.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:810610c86fdad6781acb74ecd58be99f6da6b185b3eb5ed893fd2d2a572e7ebe:merge0:c48b0bea0c82f162b7003d7371cf6455cfd317c0b7fb13f052d6a698d06f34ce": "The module provides functions for creating test fixtures, mocking an LLM client, and running tests related to text extraction, HTML rendering, and document processing. It includes tests for extracting text from Markdown, HTML, and DOCX files, rendering HTML with sections and evidence, creating user manuals in both HTML and PDF formats, handling missing dependencies gracefully, and inferring section content when information is missing. Additionally, the module contains test functions for a code documentation tool named `explaincode`, covering aspects such as categorizing code snippets, ranking code files, filling placeholders, skipping code scanning, fallback mechanisms based on flags, and handling large texts through chunking, merging, caching, and logging.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:810610c86fdad6781acb74ecd58be99f6da6b185b3eb5ed893fd2d2a572e7ebe:part0:5516db775b429103a40dd2a03a766cbe0e39e0bdb1b12007edef2db075c1950b": "The module defines functions for creating test fixtures, mocking an LLM client, and running tests related to text extraction, HTML rendering, and document processing. It includes tests for extracting text from Markdown, HTML, and DOCX files, rendering HTML with sections and evidence, creating user manuals in both HTML and PDF formats, handling missing dependencies gracefully, and inferring section content when information is missing.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:810610c86fdad6781acb74ecd58be99f6da6b185b3eb5ed893fd2d2a572e7ebe:part1:f6168ffd0c53de3b16c7a9eebf313f1905a2585db880dd3c97d8a20c97080ce6": "The module contains several test functions for a code documentation tool named `explaincode`. Each function tests different aspects of the tool's functionality:\n\n1. **test_scan_code_categorizes_snippets**: Tests the categorization of code snippets into \"Inputs\", \"Outputs\", and \"How to Run\" sections.\n2. **test_rank_code_files_supports_cpp_h_java**: Validates that the `rank_code_files` function correctly handles files with extensions like `.cpp`, `.h`, and `.java`.\n3. **test_llm_fill_placeholders_per_section_logging**: Ensures that placeholders in a manual are filled using code snippets, and logs the process.\n4. **test_full_docs_no_code_scan**: Checks if the tool skips code scanning when no code is needed.\n5. **test_missing_run_triggers_code_fallback_with_limits**: Tests fallback to code extraction when \"How to Run\" section is missing, with limits on file count and time budget.\n6. **test_no_code_flag_skips_code_fallback**: Verifies that the tool skips code fallback when `--no-code` flag is used.\n7. **test_force_code_flag_triggers_code_fallback**: Ensures that the tool triggers code extraction when `--force-code` flag is enabled.\n8.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:810610c86fdad6781acb74ecd58be99f6da6b185b3eb5ed893fd2d2a572e7ebe:part2:5dfbe796adcac882bd0d312874f74c28a44bac3c22859ff2d0e1b88a8ca6b599": "The module contains several test functions for a summarization process. It includes tests for chunking, merging, caching, and handling of large texts. Each function uses a dummy client to simulate the behavior of an LLM (Large Language Model) and asserts conditions based on the output and logs generated during the summarization process.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:Dummy:61ac41222822a56153507280d5d1da5dfb4003bb723c089f8915e25d3ec7d1e1:61ac41222822a56153507280d5d1da5dfb4003bb723c089f8915e25d3ec7d1e1": "The `Dummy` class in the project is designed for summarizing code by storing calls and generating responses based on those calls. It includes an initialization method that sets up a list to store call dictionaries and a summarize method that appends input parameters to this list, returning a formatted response string indicating the number of calls made.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:Dummy:83a8853b62a2b504629900b03a43e5c56a935d66e1982283bde7f3050b32c952:83a8853b62a2b504629900b03a43e5c56a935d66e1982283bde7f3050b32c952": "The `Dummy` class in the project provides a method `summarize` for processing input text based on a system prompt, which could be used for generating summaries or documentation snippets. It does not define any public variables.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:Dummy:9bf6639e04d74f63d2d87e3b9908762a7e4c0ed71fcd8e10ab3cc7cf2de6141a:9bf6639e04d74f63d2d87e3b9908762a7e4c0ed71fcd8e10ab3cc7cf2de6141a": "The `Dummy` class in the project is designed to summarize code by extracting specific sections from input text, replacing placeholders with a formatted string, and storing the processed text for further use or review. It includes an initialization method that sets up an empty list to store calls and a summary method that processes the input text using regular expressions to identify and replace placeholders based on predefined section types.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:Dummy:9c095e86320574dd35febf93d6a742fdd1abda8fa7099511ecf028840437776f:9c095e86320574dd35febf93d6a742fdd1abda8fa7099511ecf028840437776f": "The `Dummy` class defines a method `summarize` that takes `text`, `prompt_type`, and an optional `system_prompt`. It returns a formatted string with an overview section followed by \"NEEDS_RUN_INSTRUCTIONS\".",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:Dummy:__init__:db3b131b0ba0f8c19da82c36415f2aba4b713baca985cf65bbd5285ae3759683:db3b131b0ba0f8c19da82c36415f2aba4b713baca985cf65bbd5285ae3759683": "Initializes an instance with a list to store dictionary calls.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:Dummy:__init__:f73a3a572424de85bb41637ddb7e178958076e112fc4185ac0cea64dae24f819:f73a3a572424de85bb41637ddb7e178958076e112fc4185ac0cea64dae24f819": "Initializes an instance with a list to store string calls.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:Dummy:b869dbfeb504b6fb8e6902c49e34ddde3b0888076f8cf2d749be207e41042d1f:b869dbfeb504b6fb8e6902c49e34ddde3b0888076f8cf2d749be207e41042d1f": "The `Dummy` class in the project is designed to handle summarization tasks by storing calls made during its operations. It includes a method `summarize` that appends call details to an internal list and returns \"big\" or \"short\" based on the list's length, facilitating the tracking of function invocations for documentation purposes.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:Dummy:c1055cba34f6c91a568ad7f3afe63b50db63fca22f80a6f12097f80be0d801d7:c1055cba34f6c91a568ad7f3afe63b50db63fca22f80a6f12097f80be0d801d7": "The `Dummy` class in the project is designed for summarizing code by collecting calls and generating summaries based on input text and prompts. It includes an `__init__` method that initializes a list to store call information and a `summarize` method that processes input text and returns a summary or a specific string if certain conditions are met.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:Dummy:e211611d4685c25c1f49a7c5617078b16afbe712728ea1d21b772e4e3ed7806e:e211611d4685c25c1f49a7c5617078b16afbe712728ea1d21b772e4e3ed7806e": "The `Dummy` class in the project is designed for summarizing code by storing call details and appending them to a list. It includes an initialization method that sets up an empty list to hold dictionaries representing calls, and a `summarize` method that appends call information to this list before returning \"done\".",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:Dummy:f0203df66d7dae2e1d9e741d1d2ab4629d615936bca1b765886e4b7538b638e5:f0203df66d7dae2e1d9e741d1d2ab4629d615936bca1b765886e4b7538b638e5": "The `Dummy` class defines a method `summarize` that generates a formatted string summarizing various aspects of code, including its overview, purpose, problem-solving approach, running instructions, inputs, outputs, system requirements, and examples. This method is designed to provide comprehensive documentation for code snippets or modules.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:Dummy:summarize:04a59d6003fc253b7f2d197a32f616e7ff915453a9f3c57ff82078a51f5298ad:04a59d6003fc253b7f2d197a32f616e7ff915453a9f3c57ff82078a51f5298ad": "Function `summarize` processes a string input containing text, a prompt type, and an optional system prompt. It appends the input text to a list of calls. The function then uses regular expressions to extract \"Manual\" content and a section identifier from the input text. It retrieves a token associated with the section from a dictionary `SECTION_PLACEHOLDERS`. Finally, it replaces occurrences of this token in the extracted manual text with a formatted string indicating that the section has been filled.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:Dummy:summarize:1c3485ae9fe25b29483150d67603501ed1568172205d21f4e8e3ad17380a22ba:1c3485ae9fe25b29483150d67603501ed1568172205d21f4e8e3ad17380a22ba": "The function `summarize` takes three parameters: `text`, `prompt_type`, and an optional `system_prompt`. It returns a string containing a template overview, purpose, problem-solving approach, running instructions, input requirements, output expectations, system requirements, and examples. The function is marked with a pragma to exclude it from coverage reports due to being a simple stub.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:Dummy:summarize:217d7857c10f60dee6126555c95ee6d774f7a1b5efbbbdd871b2a614670d17b5:217d7857c10f60dee6126555c95ee6d774f7a1b5efbbbdd871b2a614670d17b5": "A function named `summarize` that takes three parameters: `text`, `prompt_type`, and an optional `system_prompt`. It returns a string formatted as \"Overview: x\\nHow to Run: [[NEEDS_RUN_INSTRUCTIONS]]\".",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:Dummy:summarize:627a4b48b32e053af1c9d6db437401aed7de4fd5255c5f50926bd373bb5437df:627a4b48b32e053af1c9d6db437401aed7de4fd5255c5f50926bd373bb5437df": "The function `summarize` takes three parameters: a string `text`, a string `prompt_type`, and an optional string `system_prompt` with a default value of an empty string. It appends a dictionary containing the input parameters to an attribute called `calls`. The function then returns a string formatted as \"resp\" followed by the length of the `calls` list.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:Dummy:summarize:78ccf80460220118714ea1885eb918e683c83a410b4d03b70aba859a0dca3596:78ccf80460220118714ea1885eb918e683c83a410b4d03b70aba859a0dca3596": "The function `summarize` processes a given `text` string based on the type of `prompt_type` and content in `system_prompt`. If `system_prompt` contains \"How to Run\", it returns \"[[NEEDS_RUN_INSTRUCTIONS]]\". If `system_prompt` includes \"enhancing a user manual\", it extracts the text between \"Manual:\" and \"Section:\" from `text`, replacing any occurrences of \"[[NEEDS_RUN_INSTRUCTIONS]]\" with \"use it\". Otherwise, it returns \"x\".",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:Dummy:summarize:ab3f0d9d1c4bec0b699e9e6bebc3161c380bb9121133d634c1d756b9c006db22:ab3f0d9d1c4bec0b699e9e6bebc3161c380bb9121133d634c1d756b9c006db22": "The function `summarize` takes three parameters: `text`, `prompt_type`, and an optional `system_prompt`. It appends a dictionary containing these parameters to the `calls` list of the object it belongs to. The function then returns the string \"done\".",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:Dummy:summarize:ae1d725d03a5a0cb10695a524606bf4c5e3d8c46e6bdd9c322aaf858f0a24d53:ae1d725d03a5a0cb10695a524606bf4c5e3d8c46e6bdd9c322aaf858f0a24d53": "The function `summarize` takes three parameters: a string `text`, a string `prompt_type`, and an optional string `system_prompt` with a default value of an empty string. It appends a dictionary containing the input parameters to a list called `calls`. If the `system_prompt` matches a specific constant (`explaincode.MERGE_SYSTEM_PROMPT`), it returns the string \"final\". Otherwise, it returns the first word of the `text` parameter.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:Dummy:summarize:cf774a300e22d141c142741d0a158680f066f47fffaea7025f0b4ff13e3ff041:cf774a300e22d141c142741d0a158680f066f47fffaea7025f0b4ff13e3ff041": "Function `summarize` takes three parameters: `text`, `prompt_type`, and an optional `system_prompt`. It appends a dictionary containing these parameters to the `calls` list. If the length of `calls` is less than or equal to 2, it returns the value of `big`; otherwise, it returns the string `\"short\"`.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:SlowClient:b35ff725971a651c9761e83284742455c0e4d9206d78d0ed26fa5085c36af3c6:b35ff725971a651c9761e83284742455c0e4d9206d78d0ed26fa5085c36af3c6": "The `SlowClient` class in the project is designed to handle the summarization of code by introducing delays based on specific conditions. It includes a method `summarize` that processes input text with optional system prompts, applying delays when necessary, and returns a simple confirmation message.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:SlowClient:summarize:81215f77b5bdc963253a5febc2f86ef614ee2b32b6c5e3234bc2546fea2dcbc1:81215f77b5bdc963253a5febc2f86ef614ee2b32b6c5e3234bc2546fea2dcbc1": "Function `summarize` takes three parameters: a string `text`, a string `prompt_type`, and an optional string `system_prompt` with a default value of an empty string. If `system_prompt` matches the constant `explaincode.CHUNK_SYSTEM_PROMPT`, it sleeps for a specified duration (`delay`). Regardless of the condition, it returns the string \"ok\".",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:Stub:c16c6195767f45ed0547a22a5a601362c37d0145b0d2cc8535d01c0d6425cc0c:c16c6195767f45ed0547a22a5a601362c37d0145b0d2cc8535d01c0d6425cc0c": "The `Stub` class in the project provides a method `summarize` that takes a prompt, its type, and an optional system prompt as parameters. It returns a string with the value `\"guessed\"`. This class is part of a larger tool for generating static HTML documentation for Python, MATLAB, C++, and Java projects by analyzing source files with a local LLM.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:Stub:summarize:34289b97bd6fbcae70ecb22cbadd55985049de1c9d992c034e8b3c85990fb396:34289b97bd6fbcae70ecb22cbadd55985049de1c9d992c034e8b3c85990fb396": "The function `summarize` takes three parameters: `prompt`, `prompt_type`, and an optional `system_prompt` with a default value of an empty string. It returns the string \"guessed\".",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:__init__:1770c120bfd22809fa046a53982907c626f5cf23145cd489069fe4c66d4a1ed8:1770c120bfd22809fa046a53982907c626f5cf23145cd489069fe4c66d4a1ed8": "The `__init__` method initializes a new instance of the class, setting up an empty list named `calls`. This list is intended to store dictionaries, each representing a call or invocation within the context of the class.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:__init__:7859f1fee653832b8ccb5dcb55522c9645ebbcc3e41d874889ab023fdad60479:7859f1fee653832b8ccb5dcb55522c9645ebbcc3e41d874889ab023fdad60479": "The `__init__` method initializes a new instance of the class. It sets up an empty list named `calls` to store string elements.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:_create_fixture:80cb818546b67f07a624feb02b3ccca427007e37876967d88888ea654ae263cc:80cb818546b67f07a624feb02b3ccca427007e37876967d88888ea654ae263cc": "This function `_create_fixture` creates a temporary directory structure with nested subdirectories and files. It generates an HTML file within the nested directory and writes specific content to a README.md file and a sample JSON file in the root of the temporary path. The HTML file contains basic HTML structure with a heading, while the README.md file includes sections for overview, purpose, problem solving, how to run, inputs, outputs, system requirements, and examples. Additionally, it creates a sample JSON file with some input data.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:_mock_llm_client:ae25962f20f1237b96c658524375f5a68513c52b66278961d79773b7909e0e86:ae25962f20f1237b96c658524375f5a68513c52b66278961d79773b7909e0e86": "The `_mock_llm_client` function returns an instance of a `Dummy` class, which simulates the behavior of an LLM client. This mock object has a `summarize` method that takes three parameters: `text`, `prompt_type`, and `system_prompt`. The `summarize` method returns a predefined string formatted with a simple overview of a demo project, including its purpose, problem-solving approach, execution instructions, inputs, outputs, system requirements, examples, and disclaimer.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:fake_extract:369845306a27d79556ed7cb951b636f9494413df3dc522aa14bca07fa68583ee:369845306a27d79556ed7cb951b636f9494413df3dc522aa14bca07fa68583ee": "The function `fake_extract` processes a list of files and returns a dictionary mapping each file to the string \"run code\". It takes an iterable of `Path` objects representing the files, along with optional parameters `max_files`, `time_budget`, and `max_bytes`. The function updates a tracker dictionary with the number of extract operations performed, the keyword arguments used, and the list of scanned files. It then returns a dictionary where each file path is associated with the string \"run code\".",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:fake_extract:79ff3ff4bc7333818b58009892db6723d706cbf42abf0bb7d70298939c6b8ffa:79ff3ff4bc7333818b58009892db6723d706cbf42abf0bb7d70298939c6b8ffa": "The `fake_extract` function takes an iterable of file paths and optional parameters for maximum files, time budget, and maximum bytes. It returns a dictionary with keys as file paths and values as strings describing actions related to reading input from users, writing output, and running the tool.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:fake_extract:8b31f90356afbf2b6c4b203e78ac6653dc561d675cf9dc4ce525ad728784e987:8b31f90356afbf2b6c4b203e78ac6653dc561d675cf9dc4ce525ad728784e987": "The function `fake_extract` takes an iterable of file paths and optional parameters for maximum files, time budget, and maximum bytes. It increments a tracker entry for \"extract\" by one and returns an empty dictionary mapping file paths to strings.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:fake_extract:dcb52bfb56c57eaf1ef2541745b9faefc8e488d59986d4a4fe4ecfcb7938228c:dcb52bfb56c57eaf1ef2541745b9faefc8e488d59986d4a4fe4ecfcb7938228c": "The `fake_extract` function takes an iterable of file paths and extracts code from them. It returns a dictionary where each key is a file path and the corresponding value is the extracted code. The function uses a tracker to increment the count of extract operations.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:fake_rank:26ef74152efd9e20ab1c664cc9e02e8a8775675bcfcd45344a79726ed28bd5f8:26ef74152efd9e20ab1c664cc9e02e8a8775675bcfcd45344a79726ed28bd5f8": "The function `fake_rank` takes a `root` directory path and a list of file name patterns as input. It increments a global variable `tracker[\"rank\"]` by one and returns a list of file paths that match the given patterns.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:fake_rank:2949b3ca543d43374c9ed03dcbc72301eec5774d157296810b1b9c5a04de7c61:2949b3ca543d43374c9ed03dcbc72301eec5774d157296810b1b9c5a04de7c61": "The function `fake_rank` takes a directory path (`root`) and a list of file patterns as arguments. It increments a global counter `tracker[\"rank\"]` by one and returns a list containing the path to a temporary script file named \"script.py\" located in a subdirectory named after the current rank value, which is derived from the incremented tracker count.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:fake_rank:62820412715bb1546a87cb1f312c9a185b0fb04be401a7c59923be59af19e70a:62820412715bb1546a87cb1f312c9a185b0fb04be401a7c59923be59af19e70a": "The function `fake_rank` takes a `root` directory path and a list of `patterns` as input. It increments a global variable `tracker[\"rank\"]` by 1 and returns an empty list of paths.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:fake_rank:fe178d35f9157ee5d55d11e7ff493cfd5db7b432bb7de7eba3c8572e30bfac76:fe178d35f9157ee5d55d11e7ff493cfd5db7b432bb7de7eba3c8572e30bfac76": "This function `fake_rank` takes a directory path (`root`) and a list of file patterns as input. It increments a global variable `tracker[\"rank\"]` by one and returns a list containing the path to a temporary file named \"a.py\" located in the specified directory.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:fake_summarize:dd8b871a20c79705095bcb95b9a3ddeb9c026ddbf5931a51106b7b6ad0d33aa5:dd8b871a20c79705095bcb95b9a3ddeb9c026ddbf5931a51106b7b6ad0d33aa5": "",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:hook:59cb856658f5dbd96d66870f9952a1c66aaa259e454c63b3fd11e8b79346cd75:59cb856658f5dbd96d66870f9952a1c66aaa259e454c63b3fd11e8b79346cd75": "The `hook` function takes a list of strings (`chunks`) as input and returns a new list where each string is converted to uppercase.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:summarize:071dc06888d7fc97fdf972106e02b4c79d4025644b6f0cbf743da06191beb0c9:071dc06888d7fc97fdf972106e02b4c79d4025644b6f0cbf743da06191beb0c9": "The `summarize` method is part of the `Stub` class. It takes three parameters: `prompt`, `prompt_type`, and an optional `system_prompt`. The method returns a string with the value `\"guessed\"`.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:summarize:0bfb8fe47d4aa86d1568ff78eeef8e11f52efcdd911ac9a87ba8b3845fe838de:0bfb8fe47d4aa86d1568ff78eeef8e11f52efcdd911ac9a87ba8b3845fe838de": "This function `summarize` is part of the class `Dummy`. It takes three parameters: a string `text`, a string `prompt_type`, and an optional string `system_prompt` with a default value of an empty string. The function returns a formatted string that includes sections for overview, purpose and problem solving, how to run, inputs, outputs, system requirements, and examples.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:summarize:1f84cea9ce90c11e076f0af4356960c1653c2e54430fdf1f900e4b432489261d:1f84cea9ce90c11e076f0af4356960c1653c2e54430fdf1f900e4b432489261d": "This function `summarize` is part of the class `Dummy`. It takes three parameters: `text`, `prompt_type`, and an optional `system_prompt` with a default value of an empty string. The function returns a formatted string that includes an overview section followed by instructions on how to run something, which currently states \"NEEDS_RUN_INSTRUCTIONS\".",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:summarize:3e65dee8a19454cbae5f362dbf96926ec13e7218ec48770362ba68cbfc823ecd:3e65dee8a19454cbae5f362dbf96926ec13e7218ec48770362ba68cbfc823ecd": "This function `summarize` is a method of the class `Dummy`. It takes three parameters: `text`, `prompt_type`, and an optional `system_prompt` with a default value of an empty string. The function appends a dictionary containing the provided text, prompt type, and system prompt to the `calls` list of the instance. If the length of the `calls` list is less than or equal to 2, it returns the string \"big\". Otherwise, it returns the string \"short\".",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:summarize:4e0279c55400092b2e767454565e049d37d30231a2063fd34df36c8acc6012bb:4e0279c55400092b2e767454565e049d37d30231a2063fd34df36c8acc6012bb": "This function `summarize` is a method of the class `Dummy`. It takes three parameters: `text`, `prompt_type`, and an optional `system_prompt` with a default value of an empty string. The function processes the input text based on the content of the `system_prompt`.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:summarize:528b2385097d95b5183a3d2b021079903484fb6c9f330e55140b859bd75ab8e8:528b2385097d95b5183a3d2b021079903484fb6c9f330e55140b859bd75ab8e8": "This function `summarize` is part of the class `Dummy`. It takes three parameters: `text`, `prompt_type`, and an optional `system_prompt` with a default value of an empty string. The function appends a dictionary containing these parameters to the `calls` list of the instance. It then returns the string \"done\".",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:summarize:625a72c5b82d677663ddcd5b19bf7502faa2f8cee9c9f45f28be20e7f0f60d9b:625a72c5b82d677663ddcd5b19bf7502faa2f8cee9c9f45f28be20e7f0f60d9b": "The `summarize` method is part of the `SlowClient` class. It takes three parameters: `text`, `prompt_type`, and an optional `system_prompt`. If the `system_prompt` matches a specific value (`explaincode.CHUNK_SYSTEM_PROMPT`), it introduces a delay using `time.sleep(delay)`. Regardless of the prompt type, the method returns the string \"ok\".",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:summarize:926f8dea02c47a1f3df8f7bba9e99f53417e283f65f66964641e9951cba8c9cf:926f8dea02c47a1f3df8f7bba9e99f53417e283f65f66964641e9951cba8c9cf": "The function `summarize` is part of the class `Dummy`. It takes three parameters: `text`, `prompt_type`, and an optional `system_prompt` with a default value of an empty string. The function appends a dictionary containing the input parameters to a list called `calls`. If the `system_prompt` matches `explaincode.MERGE_SYSTEM_PROMPT`, it returns the string \"final\". Otherwise, it returns the first word of the `text`.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:summarize:9e23eb810665ba6e1b04e213bd7bb83c5cfaee8f64e097abc3b734cd5d69f7c7:9e23eb810665ba6e1b04e213bd7bb83c5cfaee8f64e097abc3b734cd5d69f7c7": "This function `summarize` is part of the class `Dummy`. It takes three parameters: `text`, `prompt_type`, and an optional `system_prompt` with a default value of an empty string. The function appends a dictionary containing the input parameters to a list called `calls`. It then returns a string formatted as \"resp\" followed by the length of the `calls` list, indicating the response number.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:summarize:e3c3b4ebefdebea887d4a690afc50b4c1e1f49bac5c42791a91e2d5671d4392e:e3c3b4ebefdebea887d4a690afc50b4c1e1f49bac5c42791a91e2d5671d4392e": "This function `summarize` is part of the class `Dummy`. It takes three parameters: `text`, `prompt_type`, and an optional `system_prompt`. The function appends the input `text` to a list called `calls`. It then uses regular expressions to extract two parts from the `text`: `manual_text` and `section`. These are obtained by searching for patterns that match \"Manual:\" followed by any text until \"Section:\", and \"Section:\" followed by any text until a newline. The function retrieves a token from a dictionary called `explaincode.SECTION_PLACEHOLDERS` using the extracted `section`. Finally, it returns `manual_text` with all occurrences of the retrieved token replaced by the string \"filled {section}\".",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:test_cached_chunks_reused:3f0a50a2ef2bbb2ed72b2f8331eb2176e269b3202d690d83c000a21980c0fc80:3f0a50a2ef2bbb2ed72b2f8331eb2176e269b3202d690d83c000a21980c0fc80": "The function `test_cached_chunks_reused` tests the caching mechanism for response chunks in a manual summarization process. It creates a dummy client and cache, simulates two calls to summarize the same text with chunking set to \"auto\" and source as \"src\". The first call results in three summary responses being made, while the second call, using the same cache, retrieves the cached responses without making additional calls. The function asserts that the second call returns the same response as the first and that no new calls were made on the second client, demonstrating that the caching mechanism is working correctly.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:test_chunk_edit_hook_applied:ae198e3705e08e01453eaadc3d8e0740e31c3a9cd04cdea268d7aceb79990169:ae198e3705e08e01453eaadc3d8e0740e31c3a9cd04cdea268d7aceb79990169": "The function `test_chunk_edit_hook_applied` tests the application of a chunk editing hook during the summarization process. It creates a dummy class `Dummy` with a `summarize` method that records calls and modifies text based on the system prompt. The `hook` function converts each chunk to uppercase. The test uses a temporary path for caching, initializes a `Dummy` client, and applies the `_summarize_manual` function with the `post_chunk_hook` set to the `hook`. It asserts that the final result is \"final\" and that the last call to `summarize` has its text converted to uppercase.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:test_chunking_none_no_llm_calls:2ca13f1f4485dbb57768f40a445218fe21b1e9b460b032a0c207097dc83d4040:2ca13f1f4485dbb57768f40a445218fe21b1e9b460b032a0c207097dc83d4040": "The function `test_chunking_none_no_llm_calls` is a test case designed to verify the behavior of the code summarization process when chunking is disabled and no LLM calls are expected. It uses a temporary directory (`tmp_path`) and a mock object (`Dummy`) to simulate the environment during testing.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:test_chunking_triggers_multiple_calls_and_logs:c389cfbecb9d391533f5ddc5b51d7d8295774e5601c1eee59c26fcd979c53dd4:c389cfbecb9d391533f5ddc5b51d7d8295774e5601c1eee59c26fcd979c53dd4": "The function `test_chunking_triggers_multiple_calls_and_logs` tests the behavior of a summarization process that involves chunking and merging text. It uses a dummy client to simulate the summarization calls, a temporary path for caching, and a capture fixture to capture output.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:test_collect_docs_filters:3c69bad0205980a51974637e401750ae33b072f3505a3ed29e12e0155070aaae:3c69bad0205980a51974637e401750ae33b072f3505a3ed29e12e0155070aaae": "The function `test_collect_docs_filters` tests the `collect_docs` function from the `explaincode.py` module. It creates a temporary directory with various files, including Markdown and text files. The `collect_docs` function is expected to filter out non-Markdown files (like `.txt`) and return only Markdown files in the specified directory. The test asserts that \"keep.md\" is included in the returned files and that \"skip.txt\" is excluded.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:test_custom_output_directory:01f5042847647771598ad5987d820eda0ebbf52baa416410914783e9e2edfd97:01f5042847647771598ad5987d820eda0ebbf52baa416410914783e9e2edfd97": "The function `test_custom_output_directory` is a unit test for the code summarization tool. It creates a fixture using `_create_fixture`, sets up a mock LLM client with `_mock_llm_client`, and then runs the main function of the `explaincode` module with custom output directory specified by `--output`. The test asserts that two files, \"user_manual.html\" and \"user_manual_evidence.json\", are created in the specified output directory.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:test_custom_title_and_filename:873920f74123e919d5ef0626cb6085efd8fd69b7a23f5de18c5c54e9db95c334:873920f74123e919d5ef0626cb6085efd8fd69b7a23f5de18c5c54e9db95c334": "The function `test_custom_title_and_filename` is designed to test the functionality of generating a custom title and filename for HTML documentation. It uses a temporary path (`tmp_path`) and a mock LLM client (`_mock_llm_client`) provided by `monkeypatch`. The function calls the `main` function with specified arguments, including the path to the temporary directory and a custom title \"Fancy Guide\". After executing the main function, it checks for the existence of an output HTML file and an evidence JSON file in the temporary directory. It also verifies that the generated HTML file contains the expected `<h1>` tag with the text \"Fancy Guide\".",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:test_detect_placeholders:7f0f8451a9bf80779cb17622104102c6a42fe01c627dadb3d4b23ff7d5807421:7f0f8451a9bf80779cb17622104102c6a42fe01c627dadb3d4b23ff7d5807421": "The function `test_detect_placeholders` tests the `detect_placeholders` method from the `explaincode.py` module. It provides a string containing placeholders for an overview and outputs, and asserts that the detected missing placeholders are \"Overview\" and \"Outputs\".",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:test_docs_index_default_and_injection:720fd0de76363dea6533cdddf70e3967c365ef20bb8de7cf82df902c044418cf:720fd0de76363dea6533cdddf70e3967c365ef20bb8de7cf82df902c044418cf": "This function `test_docs_index_default_and_injection` tests the functionality of inserting a user manual into an index file. It uses a temporary path for testing, creates a mock LLM client, and invokes the main function with specific arguments to generate documentation. The test checks if the user manual and evidence files are created, and verifies that the navigation menu in the index file correctly links to the user manual.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:test_extract_snippets_skips_large_file:5ca29e500fdafa2ed96bcd4a9988d9801ea262522b4ed0d0b828c94a065d2371:5ca29e500fdafa2ed96bcd4a9988d9801ea262522b4ed0d0b828c94a065d2371": "This function tests the `extract_snippets` method from the `explaincode.py` module. It creates a large file (`big.py`) with 210,000 bytes of data and attempts to extract snippets using the `extract_snippets` function with specified parameters: `max_files=1`, `time_budget=5`, and `max_bytes=200,000`. The test asserts that the large file is not included in the returned snippets list. Additionally, it checks if a log message indicating that the file size exceeds the limit is present in the captured logs.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:test_extract_text_docx_preserves_headings:77beb02dbd432ef1abfe4276d0eaa9471e1488346fd942958399987c1c70862f:77beb02dbd432ef1abfe4276d0eaa9471e1488346fd942958399987c1c70862f": "The function `test_extract_text_docx_preserves_headings` is a unit test for the `extract_text` function from the `explaincode` module. It checks that headings are preserved when extracting text from a DOCX file. The test creates a temporary DOCX file with a heading and a paragraph, saves it to a specified path, and then uses the `extract_text` function to read the content. The extracted text is split into lines, and the first line (which should be the heading) is compared to the expected Markdown format (`# Title`). Additionally, the test verifies that the paragraph text (\"Text\") is present in the extracted content.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:test_extract_text_html_preserves_headings_and_code:f6fa21a84e552c4f95e051b0535e04a0bef4e9e8b4bd62e34cbd80dfe2e51183:f6fa21a84e552c4f95e051b0535e04a0bef4e9e8b4bd62e34cbd80dfe2e51183": "This function `test_extract_text_html_preserves_headings_and_code` is designed to test the ability of the `extract_text` function from the `explaincode.py` module to preserve headings and code blocks when extracting text from HTML files. It creates a temporary HTML file with headings (`<h1>`, `<h2>`) and a code block (`<pre><code>`). The function then reads this HTML file, extracts the text using `extract_text`, and asserts that the extracted text contains the preserved headings and code block.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:test_extract_text_markdown_preserves_headings_and_code:eea57cf648af1371717def58b895a4caff5141dc2a821f0e0b7d8d3481d1fcb8:eea57cf648af1371717def58b895a4caff5141dc2a821f0e0b7d8d3481d1fcb8": "The function `test_extract_text_markdown_preserves_headings_and_code` tests the ability of the `extract_text` function from the `explaincode.py` module to correctly extract and preserve headings and code blocks from a Markdown file. It creates a temporary Markdown file with a title, some text, and a Python code block, then asserts that these elements are present in the extracted text.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:test_force_code_flag_triggers_code_fallback:8f4693bda87f75cc0615b7b4c99b86ae7b9bdeebac706031d8dd05cccb77a12f:8f4693bda87f75cc0615b7b4c99b86ae7b9bdeebac706031d8dd05cccb77a12f": "This function `test_force_code_flag_triggers_code_fallback` is a unit test for the functionality that triggers code fallback when the `--force-code` flag is used. It uses fixtures and monkeypatching to mock certain behaviors of the `explaincode` module, specifically the `LLMClient`, `rank_code_files`, and `extract_snippets` functions. The test asserts that these functions are called exactly once each and checks if the appropriate log messages are generated when the `--force-code` flag is enabled.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:test_full_docs_no_code_scan:a5235f63b153b99cfd4c2403a8afa94d967e221fdb8ec51d3eb888159d5f3ed5:a5235f63b153b99cfd4c2403a8afa94d967e221fdb8ec51d3eb888159d5f3ed5": "The function `test_full_docs_no_code_scan` is a pytest test case designed to verify the behavior of a code documentation generation process when no code scanning is required. It sets up a temporary directory, mocks certain functions from the `explaincode` module to control their behavior during the test, and then runs the main function with specific command-line arguments.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:test_graceful_missing_docx:cfb9dcd923277f454ea3a82b02b572cf7f44d9694ad16f8c5667267bf7b048e8:cfb9dcd923277f454ea3a82b02b572cf7f44d9694ad16f8c5667267bf7b048e8": "This function `test_graceful_missing_docx` is a test case designed to verify the behavior of the code summarization tool when the `python-docx` library, which is used for creating and manipulating Word documents, is missing. The function uses `monkeypatch` to simulate the absence of the `Document` class from the `docx` module and sets up a mock LLM client using `_mock_llm_client`. It then runs the main function with a specified path and asserts that the output files (`user_manual.html` and `user_manual_evidence.json`) are created successfully in the temporary directory.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:test_hierarchical_merge_logged:333bf5b79e5c322035a59a1aad3268273c22afff1fd97a9f7c88234503e3a565:333bf5b79e5c322035a59a1aad3268273c22afff1fd97a9f7c88234503e3a565": "The function `test_hierarchical_merge_logged` is a unit test for the `_summarize_manual` function from the `manual_utils.py` module. It tests the behavior of the summarization process when using a hierarchical merge strategy.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:test_html_summary_creation:e645fe433e4a673ccf28abb1d3a461c611d03b3c84d1805357384639ff81f7ec:e645fe433e4a673ccf28abb1d3a461c611d03b3c84d1805357384639ff81f7ec": "This function `test_html_summary_creation` tests the creation of HTML summaries for a project. It uses a temporary path to create fixtures, mocks an LLM client, runs the main function with specified arguments, and then checks the existence of generated files. The function asserts that a user manual and evidence file are created in the temporary path. It also verifies that the evidence file contains data under the \"Overview\" key with associated evidence. Additionally, it reads the HTML content from the user manual, ensures that no placeholder text is present, and uses BeautifulSoup to check for the presence of a navigation section with an anchor linking to the overview.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:test_infer_sections_infers_entries:7437ad34d33b191977fc2cdb8a85acc29cc6fe138390542674f78cea43cc6574:7437ad34d33b191977fc2cdb8a85acc29cc6fe138390542674f78cea43cc6574": "The function `test_infer_sections_infers_entries` tests the `infer_sections` function from the `explaincode` module. It asserts that the returned dictionary contains an \"Overview\" key with the value \"Some context\". For all other keys defined in `REQUIRED_SECTIONS`, it checks that their values end with \"(inferred)\". Finally, it ensures that the string \"No information provided.\" is not present in any of the section values combined.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:test_infer_sections_no_context_defaults:901e8bf5d5d46ca8f480ce5354079eb3249469f6511b12f217f1497f76992812:901e8bf5d5d46ca8f480ce5354079eb3249469f6511b12f217f1497f76992812": "The function `test_infer_sections_no_context_defaults` is a unit test that checks the behavior of the `infer_sections` function from the `explaincode.py` module when no context is provided. The test asserts that if an empty string is passed to `infer_sections`, it returns a dictionary where all values are set to \"No information provided.\"",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:test_insert_into_index:c412b5315b794332a2a768173eb7050236316679420814be45c450a742ae2af7:c412b5315b794332a2a768173eb7050236316679420814be45c450a742ae2af7": "This function, `test_insert_into_index`, is designed to test the functionality of inserting a link into an HTML index file. It performs the following steps:\n\n1. Creates a temporary directory and sets up a fixture using `_create_fixture`.\n2. Creates an output directory within the temporary directory.\n3. Initializes an `index.html` file in the output directory with basic HTML structure containing an unordered list (`<ul>`).\n4. Uses `monkeypatch` to replace the `LLMClient` attribute of the `explaincode` module with `_mock_llm_client`.\n5. Calls the `main` function with specific command-line arguments to simulate running a code summarization tool, directing it to insert links into the index file.\n6. Reads the updated `index.html` file and asserts that a link to \"user_manual.html\" is present in the HTML content.\n\nThis test ensures that the code insertion functionality works as expected when generating documentation for Python projects using the DocGen-LM tool.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:test_insert_into_root_index:8e86e0be22f5528c31ac2d5ad9936e260723b5f501346563d75d08608a061e50:8e86e0be22f5528c31ac2d5ad9936e260723b5f501346563d75d08608a061e50": "This function `test_insert_into_root_index` is a test case designed to verify the functionality of inserting a user manual into an HTML index file. It uses the `pytest` framework for testing and leverages `monkeypatch` to mock the `LLMClient` from the `explaincode` module with `_mock_llm_client`. The function performs the following steps:\n\n1. Creates a temporary directory using `tmp_path`.\n2. Writes an initial HTML structure to `index.html` in the temporary directory.\n3. Mocks the `LLMClient` to simulate its behavior during the test.\n4. Calls the `main` function with specific arguments to insert a user manual into the index file.\n5. Verifies that the user manual and evidence files are created in the `docs` subdirectory of the temporary path.\n6. Parses the modified `index.html` using `BeautifulSoup`.\n7. Asserts that the `<nav>` element exists within the HTML structure.\n8. Checks that the first link (`<a>`) inside the `<nav>` element has an `href` attribute pointing to the user manual file.\n\nThis test ensures that the process of inserting a user manual into the index file works as expected, including creating necessary files and updating the navigation structure",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:test_llm_fill_placeholders_per_section_logging:31a79ee26d0586b1f80538629d1890de6924200d8fae65049ff3d2e4b9c8f880:31a79ee26d0586b1f80538629d1890de6924200d8fae65049ff3d2e4b9c8f880": "The function `test_llm_fill_placeholders_per_section_logging` tests the `llm_fill_placeholders` function from the `explaincode` module. It sets up a mock client that simulates an LLM response, replaces placeholders in a manual with code snippets from evidence, and logs the process. The test checks if the placeholders are correctly replaced and if the logging captures the correct information about which sections were filled using which files.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:test_llm_generate_manual_sanitizes_and_caches:f0c4d640740370f03346d8dbb2e285b7b7c74f6a7c9dfe2884569f7e4977190a:f0c4d640740370f03346d8dbb2e285b7b7c74f6a7c9dfe2884569f7e4977190a": "",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:test_map_evidence_overview_priority_and_filters:e4606cc9bd5c78ee1ac3804b78e4223109dc5129c9b3264c366a6b47534dff84:e4606cc9bd5c78ee1ac3804b78e4223109dc5129c9b3264c366a6b47534dff84": "The function `test_map_evidence_overview_priority_and_filters` tests the `map_evidence_to_sections` function from the `explaincode.py` module. It creates a dictionary of documentation files with their paths and content, including some that should be ignored. The function maps these documents to sections based on their content. The test asserts that certain files are not included in the \"Overview\" section, while others are correctly prioritized and ordered.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:test_map_evidence_snippet_limits:10f1ed135a3afbe53743d103f934e0e93b759335e7216ea6547525fd95950319:10f1ed135a3afbe53743d103f934e0e93b759335e7216ea6547525fd95950319": "The function `test_map_evidence_snippet_limits` tests the functionality of mapping evidence to sections, specifically focusing on snippet limits. It creates a dictionary of document paths and their contents, simulating long and short documents. The function then maps evidence to sections using `explaincode.map_evidence_to_sections`. It asserts that lines beyond the maximum allowed snippet length are not included in the snippets for the long document, while lines within the limit are included. Additionally, it checks that the short document's snippet is correctly identified as only containing the \"# Inputs\" header.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:test_missing_run_triggers_code_fallback_with_limits:f93c57a215aece7840d616fd01525016f6d0afcd4cd38067162f00cf083c1e24:f93c57a215aece7840d616fd01525016f6d0afcd4cd38067162f00cf083c1e24": "This function, `test_missing_run_triggers_code_fallback_with_limits`, is a test case designed to verify the behavior of a code summarization system when it encounters missing run instructions in a user manual. The test sets up a temporary directory with a README file and three Python files, simulates the behavior of an LLM client that provides summaries based on system prompts, and mocks functions related to ranking and extracting code snippets.\n\nThe function uses `monkeypatch` to replace the actual LLMClient class with a dummy implementation that returns specific responses based on the content of the system prompt. It also replaces the `rank_code_files` and `extract_snippets` functions with fake versions that track their calls and return predefined results.\n\nWhen the test is run, it invokes the main function with various command-line arguments to simulate scanning code files and generating a user manual. The test asserts that the generated HTML does not contain the placeholder text \"[[NEEDS_RUN_INSTRUCTIONS]]\", indicating that the missing instructions have been filled using code from the scanned files.\n\nThe test also checks that the fake functions were called as expected, with the correct arguments, and verifies that the log output contains specific messages indicating the progress of the summarization process.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:test_no_code_flag_skips_code_fallback:41b3bb0fd37a1d56f9a6908f65f609a0bb81b9516d1fd356777c106bafaba9e6:41b3bb0fd37a1d56f9a6908f65f609a0bb81b9516d1fd356777c106bafaba9e6": "This function, `test_no_code_flag_skips_code_fallback`, is a test case for the behavior of a code summarization tool when the `--no-code` flag is used. It sets up a temporary directory with a README file containing only an overview text. The function then mocks several components of the code summarization process, including the LLMClient, rank_code_files, and extract_snippets functions. These are replaced with dummy implementations that track calls and return predefined values.\n\nThe test case asserts that when the `--no-code` flag is specified during a call to the main function, the code scanning processes (rank_code_files and extract_snippets) are not called, as indicated by the tracker dictionary. It also checks that an informational log message is generated indicating that the code scan was skipped due to the `--no-code` flag being specified.\n\nThe test further verifies that the expected output (\"How to Run\") is present in the log, suggesting that the summary generation process still proceeds without attempting to analyze the code, and instead uses a fallback mechanism based on the existing README content.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:test_parallel_chunk_summarization:8b28da9dfaa114138c370da0a7af150b8d8c1f45a57a80ba192049dfdb727cdd:8b28da9dfaa114138c370da0a7af150b8d8c1f45a57a80ba192049dfdb727cdd": "The function `test_parallel_chunk_summarization` tests the parallel chunk summarization functionality using a mock client and a response cache. It creates a large text by repeating a paragraph multiple times, simulates a slow client that delays responses based on system prompts, and measures the time taken to summarize the text using manual utilities. The test asserts that the total duration is less than 1.5 times the delay, indicating that the summarization process is efficient despite the simulated slowness of the client.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:test_parse_manual_infers_missing_sections:ddbb8d07cf327e3b0520b86fb38a20b4c88e48002227279ac23c91595c118614:ddbb8d07cf327e3b0520b86fb38a20b4c88e48002227279ac23c91595c118614": "The function `test_parse_manual_infers_missing_sections` tests the `parse_manual` function from the `explaincode` module. It uses a stub class to simulate the behavior of an LLM client, which returns a guessed summary when called. The test asserts that the \"Overview\" section is correctly parsed and that the \"Inputs\" section, which was not provided in the input, is inferred and marked as such.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:test_pdf_summary_creation:fc021f7eb99ecf2e4f3d95009c113ff69b1426054f4c9638ca0d534afda2be4a:fc021f7eb99ecf2e4f3d95009c113ff69b1426054f4c9638ca0d534afda2be4a": "This function `test_pdf_summary_creation` is a test case designed to verify the creation of a PDF summary for a project. It uses the `pytest` framework and requires the `reportlab` library to be installed, which is used for generating PDF files.\n\nThe function performs the following steps:\n1. Checks if the `reportlab` library is installed using `importlib.util.find_spec`. If it's not installed, the test case skips execution.\n2. Calls `_create_fixture(tmp_path)` to set up a temporary directory with necessary files and configurations.\n3. Uses `monkeypatch.setattr` to replace the `LLMClient` class in the `explaincode` module with a mock client (`_mock_llm_client`). This is likely used for testing purposes, such as mocking API responses or behavior.\n4. Calls the `main` function with command-line arguments specifying the path to the temporary directory and the output format as \"pdf\".\n5. Asserts that two files are created in the temporary directory: `user_manual.pdf` and `user_manual_evidence.json`. The presence of these files confirms that the PDF summary creation process was successful.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:test_rank_code_files_supports_cpp_h_java:37625cb2ccdbe00d38c3f92662d3fa7af437334e32341a3ca868aa544a979ae8:37625cb2ccdbe00d38c3f92662d3fa7af437334e32341a3ca868aa544a979ae8": "The function `test_rank_code_files_supports_cpp_h_java` tests the functionality of ranking code files using the `explaincode.rank_code_files` method. It creates a temporary directory with various file types, including Python, C++, and Java source files, as well as an ignored text file. The function then ranks these files and asserts that only the relevant programming files (Python, C++, and Java) are included in the ranking, while the ignored text file is excluded.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:test_render_html_includes_toc_and_sources_block:0794f5e3867b1ab2f46d33280e63297fb8a1c435ff12f4a574a1880808e0f568:0794f5e3867b1ab2f46d33280e63297fb8a1c435ff12f4a574a1880808e0f568": "The function `test_render_html_includes_toc_and_sources_block` is designed to test the HTML rendering process used by the `explaincode` module. It checks if the rendered HTML includes a table of contents (TOC) and a sources block.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:test_render_html_renders_markdown_headings_and_code:d35e85c9c94461991ae4462f670854f4d2f2b8401c331117adcb84c85cc5f90c:d35e85c9c94461991ae4462f670854f4d2f2b8401c331117adcb84c85cc5f90c": "The function `test_render_html_renders_markdown_headings_and_code` tests the rendering of HTML from Markdown headings and code blocks. It creates a dictionary with a section titled \"Intro\" containing a Markdown heading and a Python code block. The function then uses the `explaincode.render_html` method to generate HTML from this dictionary, specifying \"Manual\" as the document title. Using BeautifulSoup, it asserts that an `<h1>` element with the text \"Title\" is present in the rendered HTML. Additionally, it checks that a `<pre>` tag containing a `<code>` block with the text \"print('hi')\" exists within the HTML.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:test_scan_code_categorizes_snippets:0381fc9ce5633da3038e0f23308059fdec3388a790b529c679724b4ebbcf9e54:0381fc9ce5633da3038e0f23308059fdec3388a790b529c679724b4ebbcf9e54": "This function tests the `scan_code` method in the `explaincode` module. It sets up temporary files and uses monkeypatching to mock the `collect_docs`, `rank_code_files`, and `extract_snippets` functions. The test asserts that the extracted snippets are categorized correctly into \"Inputs\", \"Outputs\", and \"How to Run\".",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:test_scan_code_skips_non_source_dirs:99452847dc3612d3f4d7adea5ebbea3521103c0f3fede4bebbe50ff0f7173028:99452847dc3612d3f4d7adea5ebbea3521103c0f3fede4bebbe50ff0f7173028": "The function `test_scan_code_skips_non_source_dirs` tests the behavior of the `scan_code` function from the `explaincode` module when it encounters non-source directories. It sets up a temporary directory structure with source, test, and example directories, each containing a Python file. The `collect_docs` method is monkeypatched to return an empty list for any base directory, simulating that no documentation is collected. The function then scans the temporary path for \"How to Run\" with specified parameters. It asserts that only the `src/main.py` file is included in the result under the \"How to Run\" key.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:test_validate_manual_references_flags_missing:c7eca0099f05a82c93cb09aeebf0191fa7d3d43acc40dd696fa33276893252f9:c7eca0099f05a82c93cb09aeebf0191fa7d3d43acc40dd696fa33276893252f9": "The function `test_validate_manual_references_flags_missing` tests the validation of manual references within documentation sections. It creates a temporary directory, writes a Python file named \"exists.py\" with content \"pass\", and sets up a dictionary `sections` containing an overview section that references both \"exists.py\" and another non-existent file \"missing.py\". The function calls `explaincode.validate_manual_references` to validate the references in the sections. After validation, it asserts that \"exists.py\" remains unchanged in the overview section, while \"missing.py [missing]\" is added to indicate a missing reference. It also checks that the evidence dictionary contains a list of missing references [\"missing.py\"] under the overview section.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_html_writer.py:ed039a0da27df295cd81a8ab2de805295849fc310d9e7141db11366b1d14bd1b:ed039a0da27df295cd81a8ab2de805295849fc310d9e7141db11366b1d14bd1b": "The module defines functions to generate HTML documentation for Python modules and packages. It includes tests to ensure the generated HTML is correct, including proper rendering of classes, methods, variables, and subfunctions. The `_highlight` function is used to syntax-highlight code snippets in C++ and Java.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_html_writer.py:test_cpp_java_highlighting:f236e81d99b720e92afbf02a6f63cb30613d41f5437668c350e99329c6d1af50:f236e81d99b720e92afbf02a6f63cb30613d41f5437668c350e99329c6d1af50": "The function `test_cpp_java_highlighting` tests the highlighting functionality for C++ and Java code. It calls a private function `_highlight` with sample C++ and Java code snippets, specifying the language as \"cpp\" and \"java\", respectively. The function asserts that the returned HTML strings contain `<span>` tags, indicating that syntax highlighting has been applied to the code.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_html_writer.py:test_subclass_rendering:c2e3703c02070a13b9350737baa25f0c947f82cfe5a9d5f1673070b8fcd5ed78:c2e3703c02070a13b9350737baa25f0c947f82cfe5a9d5f1673070b8fcd5ed78": "The function `test_subclass_rendering` tests the rendering of subclass information in HTML documentation. It creates a mock module data structure representing a Python module with a class and its subclass, including methods. The function then writes this module data to an HTML file using the `write_module_page` function (not shown in the provided code). After writing, it reads the generated HTML file and asserts that several key elements are present:\n\n1. `<details>` tags indicating expandable sections.\n2. A class named \"B\" is included.\n3. The summary of subclass \"B\" is displayed.\n4. The method `m` within subclass \"B\" is listed.\n5. Only one `<pre><code>` tag is present, suggesting that the code snippet for method `m` is correctly formatted and included.\n\nThis test ensures that subclasses and their methods are properly rendered in the HTML documentation generated by the system.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_html_writer.py:test_subfunction_rendering:c11a4038304949cb7c0d2564071b7f436dac38f7a7f86ece6fb9d637d833ca9b:c11a4038304949cb7c0d2564071b7f436dac38f7a7f86ece6fb9d637d833ca9b": "The function `test_subfunction_rendering` tests the rendering of subfunctions in HTML documentation. It creates a mock module data structure with an outer function containing an inner subfunction. The function then writes this module data to an HTML file using the `write_module_page` function and reads the generated HTML content. It asserts that the HTML contains details tags, references to the inner subfunction, its summary, and both the source code of the outer and inner functions are highlighted with `<pre><code>` tags.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_html_writer.py:test_write_index:18de590de8bda3d573c86452610e9f1b20284b39b9f87e9bc3c6a6abd5e561eb:18de590de8bda3d573c86452610e9f1b20284b39b9f87e9bc3c6a6abd5e561eb": "The function `test_write_index` is designed to test the `write_index` function, which generates an HTML index file for a project documentation structure. It takes parameters such as a temporary path (`tmp_path`), a project summary, a directory tree (`tree`), and summaries for individual modules (`summaries`). The function writes the index file and then reads it back to verify that it contains the correct elements and formatting.\n\nThe test checks if:",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_html_writer.py:test_write_module_page:b19fca912f560f004d1018426f7fdbeb1d80f06ff41a90fe0e7fc1c50134c8ca:b19fca912f560f004d1018426f7fdbeb1d80f06ff41a90fe0e7fc1c50134c8ca": "The function `test_write_module_page` is designed to test the generation of an HTML page for a Python module using the `write_module_page` function. It sets up a temporary directory, defines module data including classes, functions, and variables, and then calls `write_module_page` with this data. The function asserts that the generated HTML file contains specific elements such as project overview links, module summaries, class details, method signatures, variable declarations, and code snippets.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_integration.py:7610cd2fce0cd37892fc17f69cefa5dc0c0897e6aab60df5a0bd194234f19d04:7610cd2fce0cd37892fc17f69cefa5dc0c0897e6aab60df5a0bd194234f19d04": "The module defines two test functions for a documentation generator. The first function, `test_docgenerator_generates_html`, tests the generation of HTML documentation from various file types (Python, MATLAB, C++, Java) using a mock LLMClient. It asserts that the output directory contains HTML files for each input file and that the summary text is present in these files.\n\nThe second function, `test_static_copied_from_any_cwd`, tests the copying of static assets (like `style.css`) to the output directory regardless of the current working directory. It uses a mock LLMClient and asserts that the static asset is copied successfully to the output directory.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_integration.py:test_docgenerator_generates_html:45adf625e7838c61fe4177b6b5237885e244241ce2f2922ef97816f0204b623f:45adf625e7838c61fe4177b6b5237885e244241ce2f2922ef97816f0204b623f": "The function `test_docgenerator_generates_html` is a unit test for the `docgenerator.py` module. It creates a temporary project directory with files in Python, MATLAB, C++, and Java formats. The function then calls the `main` function from `docgenerator.py`, mocking an LLM client to return a predefined summary. After running the main function, it verifies that HTML files are generated for each file type in the project directory and that the summaries are included in these HTML files.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_integration.py:test_static_copied_from_any_cwd:ab46f8e483e576144f495109695fec38ae844b8349e3661b4c5d8f65fcf50969:ab46f8e483e576144f495109695fec38ae844b8349e3661b4c5d8f65fcf50969": "The function `test_static_copied_from_any_cwd` is a test function designed to verify the behavior of a code documentation tool when generating static HTML documentation for a Python project. It uses temporary directories and monkeypatching to simulate the environment in which the documentation tool operates.\n\nHere's what the function does:\n\n\n2. **Output Directory**: Specifies an output directory `output_dir` where the generated documentation will be stored.\n\n3. **Mocking LLMClient**: Uses `monkeypatch` to mock the `LLMClient` class from the `docgenerator` module. This mock client is configured to return a predefined summary when its `summarize` method is called and to always respond with `True` when its `ping` method is called.\n\n4. **Change Directory**: Changes the current working directory (`cwd`) to `tmp_path`.\n\n5. **Call Main Function**: Calls the `main` function from the `docgenerator` module, passing it the project directory path and specifying the",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_llm_client.py:82628573795fc440ac97b2cf7aa97bb506079f91432da86bdb370078b9e5cc90:82628573795fc440ac97b2cf7aa97bb506079f91432da86bdb370078b9e5cc90": "The code defines a test suite for an `LLMClient` class, which interacts with a language model. The tests cover the following functionalities:\n\n1. **Ping Method**: Tests that the `ping` method successfully checks connectivity to the language model server.\n2. **Summarize Method**:\n3. **Sanitize Summary Function**: Tests that the `sanitize_summary` function filters out unwanted phrases, FIM tokens, and prompt lines from the input text.\n\nThe tests use mocking to simulate HTTP responses and verify that the methods behave as expected under different conditions.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_llm_client.py:test_ping_failure:58dd6f99c6d2eb810bee94403d3f623f4c1ba3aa56b49c90fd32bd3981c22ba6:58dd6f99c6d2eb810bee94403d3f623f4c1ba3aa56b49c90fd32bd3981c22ba6": "This function tests the `ping` method of an `LLMClient` class when a connection failure occurs. It uses the `patch` decorator from the `unittest.mock` module to simulate a request exception, raising a `ConnectionError` as expected.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_llm_client.py:test_ping_success:d64edcb65e30a6920438cd8c103ba311d9086e3f4e9c88001932e7998c8c77de:d64edcb65e30a6920438cd8c103ba311d9086e3f4e9c88001932e7998c8c77de": "The function `test_ping_success` tests the `ping` method of an `LLMClient` class by mocking its HTTP GET request and verifying that it returns `True`. It asserts that the `raise_for_status` method of the mock response is called once. The test ensures that the client can successfully ping a fake URL without raising any exceptions.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_llm_client.py:test_prompt_varies_by_type:143be10fe6500d80fb566d2185f608b94b770160c86181dcb4e08ed8847e204e:143be10fe6500d80fb566d2185f608b94b770160c86181dcb4e08ed8847e204e": "The function `test_prompt_varies_by_type` tests the behavior of the `summarize` method in the `LLMClient` class. It uses a mock response to simulate an API call and checks that the prompts for summarizing a class and a function are different. The test asserts that the prompts are formatted using the appropriate template from `PROMPT_TEMPLATES`.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_llm_client.py:test_readme_prompt_template_used:f367d8f2bb096be02f775d8e52aa07250b4bd317ea5aac33b811da6427d13341:f367d8f2bb096be02f775d8e52aa07250b4bd317ea5aac33b811da6427d13341": "The function `test_readme_prompt_template_used` tests whether the `LLMClient` class correctly uses a predefined prompt template for generating summaries of README files. It creates a mock response from an LLM client, patches the HTTP POST request to return this mock response, and then calls the `summarize` method with \"foo\" as the text and \"readme\" as the type. The function asserts that the content of the second message in the prompt matches the expected template for README summaries, formatted with the input text \"foo\".",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_llm_client.py:test_sanitize_summary_filters_ai_language_model:a702f07830aa1187354ef5b134398e68aaa2c46d49db6d94f7560d66238b5423:a702f07830aa1187354ef5b134398e68aaa2c46d49db6d94f7560d66238b5423": "The function `test_sanitize_summary_filters_ai_language_model` is a unit test for the `sanitize_summary` function. It asserts that when the input text contains a phrase indicating it is an AI language model, the output will have this phrase removed. The expected result is \"It prints output.\"",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_llm_client.py:test_sanitize_summary_filters_altered_prompt_line:e78df893209a45c85e2a36ed787ffe0ed6018e62ed6e40d621a9a33c3a37cd2e:e78df893209a45c85e2a36ed787ffe0ed6018e62ed6e40d621a9a33c3a37cd2e": "",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_llm_client.py:test_sanitize_summary_filters_phrases:a68fe4bc6d6c030cb47516525a89cdd381d8a3a4d314e9bfcc1263843b191d3f:a68fe4bc6d6c030cb47516525a89cdd381d8a3a4d314e9bfcc1263843b191d3f": "",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_llm_client.py:test_sanitize_summary_filters_truncated_prompt_line:2dc04026e222679d67ed5445fb33984619802af6fad50ac464171eb89ddbf36e:2dc04026e222679d67ed5445fb33984619802af6fad50ac464171eb89ddbf36e": "The function `test_sanitize_summary_filters_truncated_prompt_line` tests the `sanitize_summary` function to ensure it filters out truncated prompt lines from the input text. It asserts that when the input text includes a line starting with \"Do not say what is or isn't included in the code\" followed by another line defining a class, the output of `sanitize_summary` should only be the second line: \"Defines a class.\"",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_llm_client.py:test_sanitize_summary_removes_fim_tokens:a2a632bef9d82f288d305b2bae9cc8ac43eb2d6ea3b8a56c298d153c5c5bd1a8:a2a632bef9d82f288d305b2bae9cc8ac43eb2d6ea3b8a56c298d153c5c5bd1a8": "This function `test_sanitize_summary_removes_fim_tokens` is designed to test the functionality of removing FIM (Found In Module) reserved tokens from a given text. The purpose is to ensure that these tokens are stripped out to prevent errors in tokenization processes. The provided code snippet demonstrates how the function should behave when it encounters FIM reserved tokens, expecting them to be removed from the output.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_llm_client.py:test_sanitize_summary_removes_prompt_lines:6c4d79c8b3694d310312b522460c99d87cef40627d494048407146277a992633:6c4d79c8b3694d310312b522460c99d87cef40627d494048407146277a992633": "The function `test_sanitize_summary_removes_prompt_lines` tests the `sanitize_summary` function to ensure it removes prompt lines from the input text. It asserts that after sanitization, only the content relevant to defining a class remains.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_llm_client.py:test_summarize_does_not_stream_on_http_error:9d73707b773dae1a7564c5b812de70b058807acf93c9cc3e150c66fb2b8ea78d:9d73707b773dae1a7564c5b812de70b058807acf93c9cc3e150c66fb2b8ea78d": "The function `test_summarize_does_not_stream_on_http_error` tests the behavior of the `summarize` method in the `LLMClient` class when an HTTP error occurs. It verifies that streaming is not attempted under such conditions.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_llm_client.py:test_summarize_raises_runtime_error_with_message:0c3ce5ec924ea3a434d648f2b5be7b11316f87a8077496618e8ce209b10d07e9:0c3ce5ec924ea3a434d648f2b5be7b11316f87a8077496618e8ce209b10d07e9": "The function `test_summarize_raises_runtime_error_with_message` tests the behavior of the `summarize` method in the `LLMClient` class when it encounters an error. It uses mocking to simulate a scenario where the HTTP request made by the client raises an `HTTPError` and subsequently a `ValueError`. The function asserts that calling `client.summarize(\"text\", \"module\")` raises a `RuntimeError` with the message \"server exploded\".",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_llm_client.py:test_summarize_retries_and_returns_summary:e077e2de3df778d85ab4de572b6985e86e538b17f9aab1e134e27c341315c56a:e077e2de3df778d85ab4de572b6985e86e538b17f9aab1e134e27c341315c56a": "The function `test_summarize_retries_and_returns_summary` tests the `summarize` method of the `LLMClient` class. It sets up a mock response that simulates an initial request failure followed by a successful response. The test asserts that the method retries on failure, waits for 1 second between attempts, and returns the expected summary content.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_manual_utils.py:_count:6bcc78de8a2666cbcd96f79983fb17c2de82a51e784b79bb6b643fadbb851d16:6bcc78de8a2666cbcd96f79983fb17c2de82a51e784b79bb6b643fadbb851d16": "The function `_count` takes a string `text` as input and returns the number of tokens in the text. It uses the `TOKENIZER` from the `manual_utils` module to encode the text into tokens and then calculates the length of this tokenized list, which represents the count of tokens.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_manual_utils.py:b152f93e4ae2356d36a0553ec3d878edb1db688524cfd71c19fb6ea54af90bc5:b152f93e4ae2356d36a0553ec3d878edb1db688524cfd71c19fb6ea54af90bc5": "The module defines two functions: `_count` and `test_chunk_docs_respects_token_limit`, `test_find_placeholders`. The `_count` function calculates the number of tokens in a given text using a tokenizer from the `manual_utils` module. The `test_chunk_docs_respects_token_limit` function tests the `chunk_docs` function from `manual_utils` to ensure it chunks documents without exceeding a specified token limit. The `test_find_placeholders` function checks if the `find_placeholders` function correctly identifies placeholders in a given text.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_manual_utils.py:test_chunk_docs_respects_token_limit:5ea27a71e0a679c56f4bd7c277c8061978cb79590481f7ceab0bb293bb2ca608:5ea27a71e0a679c56f4bd7c277c8061978cb79590481f7ceab0bb293bb2ca608": "This function tests the `chunk_docs` utility from the `manual_utils.py` module to ensure it respects a specified token limit. It creates a list of three strings, each containing 1000 characters repeated 'a', 'b', and 'c' respectively. The function then calls `chunk_docs` with these strings and a token limit of 2000. It asserts that the resulting chunks list contains exactly three elements and that the length of each chunk does not exceed the token limit.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_manual_utils.py:test_find_placeholders:c62870efe01b6232f934ee25e400b69a2f16d052536daa61c629c03ef28a8a0b:c62870efe01b6232f934ee25e400b69a2f16d052536daa61c629c03ef28a8a0b": "The function `test_find_placeholders` is a unit test that checks the functionality of the `find_placeholders` method from the `manual_utils.py` module. It asserts that the method correctly identifies and returns a set of placeholder tokens found in a given text string. The test case provided demonstrates the method's ability to extract placeholders like `[[NEEDS_OVERVIEW]]` and `[[FOO]]` from a sample input text.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_parser_cpp.py:7bf655540a7446dfdc4c0a3d20712a34c8c0cefe70fdce7aa5e2197a6cc58f87:7bf655540a7446dfdc4c0a3d20712a34c8c0cefe70fdce7aa5e2197a6cc58f87": "The module defines a test function `test_parse_cpp` that uses the `parse_cpp_file` function from the `parser_cpp` module to parse a C++ source file. The test checks if the parsed result contains the expected documentation strings, namespace, functions, and classes. It verifies the correctness of the parsed data by comparing it with predefined assertions.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_parser_cpp.py:test_parse_cpp:562fcc258fe6c04e614d77700a483258c12a720919beb53f50f796b9f1319ba7:562fcc258fe6c04e614d77700a483258c12a720919beb53f50f796b9f1319ba7": "The function `test_parse_cpp` tests the parsing of a C++ source file. It creates a temporary file with a sample C++ code snippet containing a module comment, a namespace, functions, and a class. The function then calls `parse_cpp_file` to parse this file and asserts that the parsed results match the expected values for the module docstring, namespace, functions, and classes. Specifically, it checks that the module docstring is \"Module comment\", the namespace is \"demo\", there is one function named \"add\" with a docstring of \"Adds numbers\", and one class named \"Greeter\" with a docstring of \"Greeter class\". It also verifies the presence of fields and methods within the class, including their names, docstrings, and source code snippets.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_parser_java.py:81c91b4467b1272b3aee2c23a686157de0d00112a71e34af42e7260d11e289fb:81c91b4467b1272b3aee2c23a686157de0d00112a71e34af42e7260d11e289fb": "The module defines a test function `test_parse_java` that uses the `parse_java_file` function from the `parser_java` module to parse a Java source file. The test checks if the parsed result contains the correct package, class, field, and method information extracted from the Java code.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_parser_java.py:test_parse_java:8045b34b69a1c0e356c6dbe42a05f3a969983a81cc35fbffe244db71cbf5b105:8045b34b69a1c0e356c6dbe42a05f3a969983a81cc35fbffe244db71cbf5b105": "This function `test_parse_java` is designed to test the parsing of a Java source file using a hypothetical `parse_java_file` function. It creates a temporary Java file with a package declaration, a class named `Util`, and two members: a public field `count` and a method `work`. The function then calls `parse_java_file` with the path to this temporary file and asserts that the parsed result contains the expected documentation strings, package name, and member details. Specifically, it checks for the presence of the module docstring, package, class name, class docstring, field name, field docstring, field type, method name, method docstring, and source code snippets for both the field and the method.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_parser_matlab.py:d371df41f01bfadecc63c5f1bddb7b77eb2309a17405bffe247ca4a3e17973bd:d371df41f01bfadecc63c5f1bddb7b77eb2309a17405bffe247ca4a3e17973bd": "The module provides unit tests for a MATLAB file parser. It includes two test functions: `test_parse_simple_matlab` and `test_parse_multiple_functions`. Each function creates a temporary MATLAB file with specific content, parses it using the `parse_matlab_file` function from the `parser_matlab` module, and asserts that the parsed result matches expected values. The tests check for correct parsing of function names, arguments, and headers in MATLAB files.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_parser_matlab.py:test_parse_multiple_functions:5ea2313bd49f220aa44aefdb8983a5939a99afecc01f53263abbd9cb0b0ef7ce:5ea2313bd49f220aa44aefdb8983a5939a99afecc01f53263abbd9cb0b0ef7ce": "This function `test_parse_multiple_functions` tests the parsing of multiple MATLAB functions from a source file. It creates a temporary file with two MATLAB functions, `compute` and `square`, and then parses this file using the `parse_matlab_file` function. The test checks that the parsed result contains:\nThe function asserts these conditions to ensure the parser correctly identifies and extracts information from multiple MATLAB functions in a single file.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_parser_matlab.py:test_parse_simple_matlab:cc88ebea461932d5f904fcd526cf299f0a242bb5cab472aaa3d00dc4e6bbbbc2:cc88ebea461932d5f904fcd526cf299f0a242bb5cab472aaa3d00dc4e6bbbbc2": "This function `test_parse_simple_matlab` tests the parsing of a simple MATLAB file. It creates a temporary MATLAB file with a header and a function definition, then parses it using the `parse_matlab_file` function. The test checks that the parsed result contains the correct header and function details, including the function name and arguments.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_parser_python.py:0656a74b22ae45e63880587901e7b10ae787467de6bd22083f6803af85bd3957:0656a74b22ae45e63880587901e7b10ae787467de6bd22083f6803af85bd3957": "This module contains tests for parsing Python files using the `parse_python_file` function from the `parser_python` module. It includes several test cases to verify the correctness of the parser, covering various scenarios such as simple modules, complex function signatures, nested structures, deeply nested classes, and class definitions inside methods. Each test case creates a temporary Python file with specific content, parses it using `parse_python_file`, and asserts that the parsed results match the expected structure and attributes of the code.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_parser_python.py:test_class_inside_method:a665951735583c1125f0a1554c5ec0eaea324b0952796d6795e54f9a4a62ad75:a665951735583c1125f0a1554c5ec0eaea324b0952796d6795e54f9a4a62ad75": "The function `test_class_inside_method` tests the parsing of a Python file containing a class defined inside another method. It creates a temporary Python file with the specified content, parses it using a hypothetical `parse_python_file` function, and then asserts that:\n1. The parsed result contains one top-level class named \"A\".\n2. Class \"A\" has one subclass named \"B\".\n3. Subclass \"B\" has one method named \"m\".",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_parser_python.py:test_deeply_nested_classes:d0bd7b778395e2be64dea12ee584a700514ff3807df976703985154d5f33a321:d0bd7b778395e2be64dea12ee584a700514ff3807df976703985154d5f33a321": "This function `test_deeply_nested_classes` tests the parsing of deeply nested classes in Python code. It creates a temporary file with nested class definitions and uses a hypothetical `parse_python_file` function to parse the file. The test then checks that the nested classes are correctly identified and that the methods within them are properly extracted.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_parser_python.py:test_parse_complex_signature:57b73d77c54bf23193b04391805aeea766579b87b341d01b8b1c65b1e0579663:57b73d77c54bf23193b04391805aeea766579b87b341d01b8b1c65b1e0579663": "This function `test_parse_complex_signature` tests the parsing of a Python file containing a complex function signature. It creates a temporary Python file with a docstring and a function named `complex` that has positional-only parameters, keyword-only parameters, and default values. The function then parses this file using `parse_python_file`, extracts the signature and docstring of the first function in the result, and asserts that they match the expected values.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_parser_python.py:test_parse_nested_structures:da5b5f3f01389fca6e96bac4ba896358432aacec56a5d28695fe3b0ad3ab5f62:da5b5f3f01389fca6e96bac4ba896358432aacec56a5d28695fe3b0ad3ab5f62": "This function `test_parse_nested_structures` is designed to test the parsing of nested structures in Python code. It creates a temporary file with nested functions and classes, then uses a hypothetical `parse_python_file` function to parse this file. The test asserts that the parsed result contains the correct information about the outer function, its inner function, and the class with its subclass and method.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_parser_python.py:test_parse_simple_module:c2c19e7b03bed71ece6d6a5b25b135f1517b0a737d8163a440eb47198ea1ed28:c2c19e7b03bed71ece6d6a5b25b135f1517b0a737d8163a440eb47198ea1ed28": "This function `test_parse_simple_module` tests the parsing of a simple Python module. It creates a temporary file with a sample Python script containing a class and a function, then uses the `parse_python_file` function to parse this file. The test checks if the parsed results match the expected values for the module docstring, classes, methods, and functions.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_resume_progress.py:3378cf564c2528ac12231265bea97bb649e9510221272bb4eb3d44bdd0ec5d5d:3378cf564c2528ac12231265bea97bb649e9510221272bb4eb3d44bdd0ec5d5d": "The module defines a test function `test_resume_progress` that uses the `pytest` framework to verify the behavior of the `docgenerator.main` function. It sets up a temporary project directory with two Python modules, mocks several functions from the `docgenerator` and `cache` modules to simulate their behavior during testing, and tests the main function's ability to resume progress after encountering an error. The test asserts that the function correctly handles errors, resumes processing, and generates documentation for modules as expected.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_resume_progress.py:crashing_set_progress:deb9a66230ae483c1e8669304059b6f4ddedd8a746c56831546b31a9b8f3d840:deb9a66230ae483c1e8669304059b6f4ddedd8a746c56831546b31a9b8f3d840": "This function `crashing_set_progress` is a method that extends the functionality of an existing `set_progress` method. It takes two parameters: `path` and `module_data`. The function first calls the original `set_progress` method using `original_set_progress(self, path, module_data)`. Then, it increments a global variable `calls[\"count\"]` by 1. If this is the first call to the function (i.e., `calls[\"count\"] == 1`), it raises a `RuntimeError` with the message \"boom\".",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_resume_progress.py:fake_rewrite_docstring:70a2ab226a263e653295aafb31465786f690db2bff32c065aee70401a2361327:70a2ab226a263e653295aafb31465786f690db2bff32c065aee70401a2361327": "The `fake_rewrite_docstring` function is defined to accept any number of positional (`*args`) and keyword (`**kwargs`) arguments. It returns `None`.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_resume_progress.py:fake_summarize_chunked:a86b19cbfcfe8219d2df16469465f5ac16944451cd45d6a176426ad6a0375b28:a86b19cbfcfe8219d2df16469465f5ac16944451cd45d6a176426ad6a0375b28": "The function `fake_summarize_chunked` is designed to generate a summary for a given piece of text by interacting with an LLM client. It takes several parameters including the client object, cache mechanism, key for caching, text to be summarized, type of prompt, maximum context tokens allowed, and a budget for chunking tokens. The function returns a hardcoded string \"summary\" as its output.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_resume_progress.py:fake_summarize_module:b09ed8de6e80e4cafe4808364bf124bf84bd23ef32b5901b24e187ad2a70cbb6:b09ed8de6e80e4cafe4808364bf124bf84bd23ef32b5901b24e187ad2a70cbb6": "The function `fake_summarize_module` takes several parameters including a client, cache, key prefix, module text, module object, tokenizer, maximum context tokens, and chunk token budget. It extracts the path from the key prefix, appends it to a list named `module_calls`, and returns the string \"summary\".",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_resume_progress.py:test_resume_progress:241e8747fb40bc3d21e09bb2b46b991b148e620195f4a105767f697d3816501a:241e8747fb40bc3d21e09bb2b46b991b148e620195f4a105767f697d3816501a": "The `test_resume_progress` function tests the resumption of progress in code documentation generation. It sets up a temporary project directory with two Python modules, simulates the summarization process using fake functions, and then attempts to resume the documentation generation after an interruption. The test ensures that only the unprocessed module is summarized when resuming, and that the cache reflects the correct progress state.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_reviewer.py:83233473a3bb44ee0c5e26502caa85ad29205c84af0e40280e3fd12a3f730505:83233473a3bb44ee0c5e26502caa85ad29205c84af0e40280e3fd12a3f730505": "This module defines a set of tests to detect and handle specific issues in Python modules. It includes functions to create temporary module files, run a main function with these files, and check for the presence of certain phrases indicating issues like assistant phrasing, contradictions, or hallucinations. The module also contains a test function that demonstrates how to use these features to automatically fix detected issues by removing specific phrases from the HTML output.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_reviewer.py:_make_module:ddbdcb6e81cefd89d8f95f8953cfc5ebc9c90d935ceecb4fe0aae3b7cc45ff2d:ddbdcb6e81cefd89d8f95f8953cfc5ebc9c90d935ceecb4fe0aae3b7cc45ff2d": "The function `_make_module` generates a module documentation page. It takes three parameters: `tmp_path`, which is the temporary path where the module will be created; `summary`, which is a summary of the module; and `methods`, which is an optional list of methods to include in the module's class. The function creates a dictionary `data` with keys for the module's name, summary, classes, and functions. If `methods` is provided, it adds a class named \"Foo\" with an empty docstring, summary, and the specified methods to the `classes` list in `data`. It then writes the module page using the `write_module_page` function and returns the path to the generated HTML file for the module.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_reviewer.py:test_assistant_phrasing_detected:065413ac10dd97571c60be8d294ec0696985cc4cf5ad72472fdf5e6993ea8eef:065413ac10dd97571c60be8d294ec0696985cc4cf5ad72472fdf5e6993ea8eef": "This function `test_assistant_phrasing_detected` is designed to test the detection of assistant phrasing in generated documentation. It creates a temporary module with specific content, runs the main function with the path to this module, and captures the output. The function then checks if the output contains the string \"[ASSISTANT]\" and \"mod.html\", indicating that the assistant phrasing was detected and that the HTML file was successfully generated.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_reviewer.py:test_autofix_removes_phrasing:3b8fd6ac15fd1fe0cf3b3872c7cfdd7de96d21e124f56294d59909f03264dbb1:3b8fd6ac15fd1fe0cf3b3872c7cfdd7de96d21e124f56294d59909f03264dbb1": "The function `test_autofix_removes_phrasing` is a unit test that verifies the functionality of an autofix feature. It creates a temporary module with a specific phrase, runs the autofix command on it using the `main` function, and then checks if the phrase has been removed from the HTML output.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_reviewer.py:test_contradiction_detected:6db2b5137d5e4616cd48c50ad7822b00006aa5ab2bc3327a976e369e2dc3fce3:6db2b5137d5e4616cd48c50ad7822b00006aa5ab2bc3327a976e369e2dc3fce3": "This function `test_contradiction_detected` tests if a contradiction is detected during the documentation generation process. It creates a temporary module with no methods defined and runs the main function of the project, capturing the output. The test asserts that the string \"[CONTRADICTION]\" is present in the output, indicating that a contradiction was detected.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_reviewer.py:test_hallucination_detected:2f8eee5822ae172922d99e350938bfdfd149c723bb467fa6bc38efdf61099691:2f8eee5822ae172922d99e350938bfdfd149c723bb467fa6bc38efdf61099691": "The function `test_hallucination_detected` is designed to test for the detection of hallucinations during code documentation generation. It creates a temporary module with specified features, runs the main function with the path to this module, and captures the output. The assertion checks if the string \"[HALLUCINATION]\" is present in the captured output, indicating that the test has successfully detected a hallucination.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_sanitize_docs.py:daf0cc4cb1542634a8ecb3a034b33efb1836feaeeec74e75b676987d2f6b2104:daf0cc4cb1542634a8ecb3a034b33efb1836feaeeec74e75b676987d2f6b2104": "This module contains tests for a utility named `sanitize_docs`. It includes two test functions:\n\n1. **test_sanitize_directory_removes_ai_disclaimer**: This function tests the removal of an AI disclaimer from HTML content within a directory. It creates a temporary file with HTML content containing an AI disclaimer and another paragraph. After running the `main` function, it checks that the AI disclaimer has been removed, while other content remains unchanged.\n\n2. **test_sanitize_directory_handles_headings_and_list_items**: This function tests handling of headings and list items in HTML content within a directory. It creates a temporary file with HTML content containing an AI disclaimer in a heading and another paragraph in a list item. After running the `main` function, it checks that both the AI disclaimer and the text \"You can run this\" have been removed, while other content remains unchanged.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_sanitize_docs.py:test_sanitize_directory_handles_headings_and_list_items:cb4474c1c774bc0068e7f6e7f53b079e6cc5d81ce91789be150dd7186aede89c:cb4474c1c774bc0068e7f6e7f53b079e6cc5d81ce91789be150dd7186aede89c": "The function `test_sanitize_directory_handles_headings_and_list_items` tests the sanitization of HTML files within a directory. It creates an HTML file with headings and list items containing unwanted text. The function then calls the `main` function with the path to the temporary directory, which is expected to sanitize the HTML content. After sanitization, the function asserts that specific phrases are removed from the HTML output while preserving other parts of the content.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_sanitize_docs.py:test_sanitize_directory_removes_ai_disclaimer:d2a688bca7447c89cdf6348bb2b21636e437e95699032f2643f05d3cc988bbaa:d2a688bca7447c89cdf6348bb2b21636e437e95699032f2643f05d3cc988bbaa": "The function `test_sanitize_directory_removes_ai_disclaimer` is a unit test for the sanitization of HTML files. It creates a temporary directory with an HTML file containing text that includes an AI disclaimer. The function then calls the `main` function, which is presumably responsible for sanitizing the HTML files in the specified directory. After sanitization, the function reads the contents of the HTML file again and asserts that the AI disclaimer has been removed while the other content remains intact.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_scanner.py:9fb66b0d67a215b5195a4a239c0f088601d37be9f219b4e6b10e9a18e33b8b13:9fb66b0d67a215b5195a4a239c0f088601d37be9f219b4e6b10e9a18e33b8b13": "The module defines a function `scan_directory` from the `scanner` module and tests for its functionality using `pytest`. It includes tests to verify that directories can be ignored, mixed file types are included, `.git` folder is skipped, and various programming languages' files (Python, Objective-C, Java, C++, C) are correctly identified.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_scanner.py:create_files:32538af1794ee70ae2782656be40d230ba45375524b287dacd59f5a139b1df0a:32538af1794ee70ae2782656be40d230ba45375524b287dacd59f5a139b1df0a": "The `create_files` function takes a base directory and a list of file paths relative to the base directory. It iterates over each file path, creates any necessary parent directories (if they do not already exist), and writes an empty string to each file.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_scanner.py:test_scan_directory_ignore_folder:7b1c10e4fb648dadeddc801b38e7afc262189a89db75f8170a5599932b470c2b:7b1c10e4fb648dadeddc801b38e7afc262189a89db75f8170a5599932b470c2b": "The function `test_scan_directory_ignore_folder` is a unit test for the `scan_directory` function. It creates a temporary directory with various files and subdirectories, including an ignored folder named \"ignore_me\". The function then scans the directory, excluding the \"ignore_me\" folder, and returns a set of file paths that were found. The test asserts that the result matches the expected set of file paths, ensuring that the ignored folder is not included in the scan results.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_scanner.py:test_scan_directory_mixed_file_types:72ceaca82f2413855026e88d9b75a4934dbd9ad4e9a448fceb523595539c7d2e:72ceaca82f2413855026e88d9b75a4934dbd9ad4e9a448fceb523595539c7d2e": "The function `test_scan_directory_mixed_file_types` is a test case designed to verify the functionality of scanning a directory for files with mixed file types. It uses a temporary path provided by `tmp_path` and creates several files within this path, including Python (.py), MATLAB (.m), and text (.txt) files, as well as nested files in a subdirectory.\n\nThe function then calls `scan_directory` with the path of the temporary directory and an empty list. The result of this function call is compared to an expected set of file paths, which includes all the Python and MATLAB files created, excluding the text file and the Markdown (.md) file in the nested directory. The assertion checks if the set of returned file paths matches the expected set.\n\nThis test ensures that the `scan_directory` function correctly identifies and returns only the relevant file types specified for scanning.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_scanner.py:test_scan_directory_skips_git_folder:6237a474a24771e5fbd24ec361f1569539be0d7efc08b2dd3b02b6a97675d1b0:6237a474a24771e5fbd24ec361f1569539be0d7efc08b2dd3b02b6a97675d1b0": "The function `test_scan_directory_skips_git_folder` tests the behavior of a hypothetical `scan_directory` function when scanning a directory. It creates a temporary directory with files, including one inside a `.git` subdirectory that should be ignored. The function scans the directory and asserts that only non-`.git` files are included in the result.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_scanner.py:test_scan_directory_supports_cpp_h_java:5d282e068b83842143e9f426deb8ca1074da1d5d232cccb80981b26f70d09cab:5d282e068b83842143e9f426deb8ca1074da1d5d232cccb80981b26f70d09cab": "The function `test_scan_directory_supports_cpp_h_java` tests the functionality of scanning a directory for supported file types, specifically C++, C header, and Java files. It creates a temporary directory with various files, including nested subdirectories, and then uses the `scan_directory` function to scan this directory. The expected result is a set of paths to all supported files found in the directory and its subdirectories. The test asserts that the actual result matches the expected set of file paths.",
  "PROJECT:856cf51fa88d37ebc251dde0aad348c9dc184caa3f6a310695d729559adb7a29:856cf51fa88d37ebc251dde0aad348c9dc184caa3f6a310695d729559adb7a29": "The project consists of multiple modules for various functionalities related to code documentation and summarization. The `cache.py` module provides a caching mechanism for responses. The `chunk_utils.py` module includes utilities for chunking text into manageable parts. The `docgenerator.py` module handles the generation of summaries for Python code, including class and function summaries. The `explaincode.py` module is responsible for collecting documentation, parsing code files, and generating user manuals using an LLM (Language Model). The `gui_wrapper.py` module provides a graphical user interface for interacting with the code summarization tools. The `html_writer.py` module generates HTML content from parsed code. The `llm_client.py` module interfaces with an LLM to generate summaries and sanitize them. The `manual_utils.py` module includes utilities for handling manual documents, such as chunking and finding placeholders. Various parser modules (`parser_cpp.py`, `parser_java.py`, etc.) are responsible for parsing different programming languages. The `retrofit_sidebar.py` module modifies a sidebar with documentation information. The `reviewer.py` module reviews generated documentation for quality issues. The `sanitize_docs.py` module sanitizes HTML files to remove AI-generated disclaimers and other unwanted content. The `scanner.py",
  "README:b0f4974ab84c7cc769a8bde4129f733f7dc545dcd5a7fd31c76ee876a2b1c447:b0f4974ab84c7cc769a8bde4129f733f7dc545dcd5a7fd31c76ee876a2b1c447": "DocGen-LM generates static HTML documentation for Python, MATLAB, C++, and Java projects by analyzing source files with a local LLM. It supports nested functions and subclasses, rendering complex structures as expandable sections in the output. The tool includes CLI and GUI options for customization, progress saving, and language support. Additionally, it provides utilities for sanitizing existing documentation, retrofitting sidebars, and generating project summaries.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\cache.py:ResponseCache:6e8c2e42633f49496cea58dcadcff0afbb62d6b1782009c6150f015775dc1c55:9b5a313b238d9e9df6d7f1f8612c9fb584df39f70a688b080a30b119baa79c33": "The `ResponseCache` class provides a mechanism for persisting and retrieving mappings from stable keys to language model responses. It uses JSON files to store the data on disk, ensuring that the cache can be reused across sessions. The class includes methods for setting and getting cached values, as well as managing progress information associated with processed module paths.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\cache.py:__init__:dff941704f16aa5c9d2b8c79026ee557090898c6ececdf2d8a23011bbedf55d0:2424befb9f0b8342f81f3473aa3d1d6b67bce31275d9805a653510f572a6b0c2": "The `__init__` method initializes a new instance of the `ResponseCache` class. It takes a file path as an argument and attempts to load existing cache data from that file. If the file exists, it reads the contents and parses them as JSON into a dictionary stored in `_data`. If the file does not exist or contains invalid JSON, it initializes `_data` as an empty dictionary. The method also ensures that a progress map is present in the cache data by using `setdefault`, which adds an empty dictionary under the key `\"__progress__\"` if it doesn't already exist.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\cache.py:_save:6ade64a9dd197eec910e0ccce44bf1a35bdab686f61a52cc27e306db97d05c34:49a544ce0966ace8b1c7870a928434b6c18bd8296522441a777288685a03e194": "This function `_save` is a method of the `ResponseCache` class. It saves the current state of the cache to a file. The function writes the contents of `self._data`, which is assumed to be a dictionary or other serializable data structure, to a file specified by `self.file`. The data is serialized using `json.dumps` with an indentation of 2 spaces and sorted keys for readability. The encoding used for writing the file is \"utf-8\".",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\cache.py:clear_progress:3566fb9c20a2270817f543d76eb28f0bde39ccea8ba7da21aa7563b517f94c72:0db070891b4c679ea0a4c1785f5a1b1eb6f114c2266146a768618a328e553476": "The `clear_progress` method in the `ResponseCache` class removes all saved progress information from the cache. It updates the `_data` dictionary by setting the value associated with the key `\"__progress__\"` to an empty dictionary and then calls the `_save` method to persist this change to disk.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\cache.py:get:2efe187f031002ffa82ae2254d57571f5bb6758c77d4f8c7c890400eb2caa625:e6d4f51e34c1d90373e4190b4e8685a0ba0a3b7fa559a7cf2e72d9757ce82417": "This function is part of the `ResponseCache` class. It defines a method `get` that retrieves the cached value associated with a given key from an internal data structure `_data`. If the key exists in the cache, it returns the corresponding value; otherwise, it returns `None`.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\cache.py:get_progress:fb32fe25288e01b98c5c3adbcc168058b5ae151cc19806446d8f33655e742802:aa90f948a147f96da99a33d0b8811b82d065c5258b6a9394d1c5b67d3d125d0a": "The `get_progress` method in the `ResponseCache` class returns a shallow copy of the progress map, which contains mappings of processed module paths to their data. This allows external access to the current state of progress without allowing modifications to the internal cache data structure.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\cache.py:make_key:f290ecfa4f436580fbdcf0cd23018f43e4eaaf96ef489045dcf9e38a26e44852:cf1068570f0fa9fce3d363b9f5d4be77c02f195366b174803950bb5f0a9c1ff5": "This function `make_key` generates a unique key for caching purposes based on the file path and content of a code file. It uses the SHA-256 hash algorithm to create a deterministic digest from the content, ensuring that any changes in the content will result in a different key. The key is formatted as `{file_path}:{digest}`, combining the file path with the hash digest to provide a unique identifier for each cached entry.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\cache.py:set:0a1a5f3e2394cb67eecffc6e236a42ad5e7577fa0ee00d6a1d09d38a14f48819:ad7e40f1276f42508c6cbd8282ca859a728d97df6a41f45c13e6c12db73f7f39": "This function `set` in the `ResponseCache` class is used to store a value associated with a key in the cache and then persists this change to disk. It takes two parameters: `key`, which is a string representing the unique identifier for the cache entry, and `value`, which is also a string representing the data to be stored. The function updates the internal `_data` dictionary with the provided key-value pair and then calls the `_save` method to ensure that the updated cache state is written to disk.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\cache.py:set_progress_entry:4552b8d430b063b817c5d0ce1cfd4534c288404ccae787bc724f936f3526b6ad:0575ab2db3484418bef8fdd36e1056d72486db4595d94679722ab4c6146ee7ee": "The `set_progress_entry` method records data for a specific path in the progress map of the `ResponseCache` class. It takes two parameters: `path`, which is a string representing the file or directory path, and `module_data`, which is a dictionary containing data related to the module at that path. The method updates the `_data` attribute of the instance by setting the value for the key `\"__progress__\"` to a dictionary if it does not already exist. It then assigns the `module_data` dictionary to the key corresponding to the provided `path`. Finally, it calls the `_save` method to save the updated cache state to disk.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\chunk_utils.py:_split_blocks:c9f46e13c38f666d168c0f9fdce0886e8055fc31a6304a24d6eac6248a0b5293:e10ee3688728cbf950eeb0c4fb6c590496fa42bddbdc6ecc84cea6314784ff0d": "",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\chunk_utils.py:_split_long_block:accd90124bc88f47b996842437a902871001983b325d1e57b360c0c74b70b246:5faeee8fdfafab78a7dd2dbd1d3116108749ee3dbb9a779ae99708faa8b9e745": "This function `_split_long_block` takes a string `block`, a tokenizer, and an integer `chunk_size_tokens`. It encodes the block into tokens using the provided tokenizer. If the number of tokens is less than or equal to `chunk_size_tokens`, it returns the original block as a single chunk. Otherwise, it calculates an average character length per token and determines the maximum number of characters for each chunk based on this average and `chunk_size_tokens`. It then splits the block into chunks of up to `max_chars` characters and returns these chunks as a list.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\chunk_utils.py:chunk_text:18a8d73b7c61b710dd351533813a1cb3bf430e693b1ab475965563247371fee4:aae8d2596c0690cc1b3e498828c252bd6850dc29ec0e434893c4b75fd7aafac8": "The `chunk_text` function splits a given text into chunks of approximately specified token size. It honors natural break points like blank lines, Markdown headings, and fenced code blocks. If a single block exceeds the token limit, it splits that block by character length. The function uses a tokenizer to count tokens accurately.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\chunk_utils.py:decode:e1a7fbe3dfc78825fd065629c671f12226deb573ddde5c00dd6920a248e4565e:38cb6bcd6933d8a308757fa1bde8450422c8495d2d073a666d3ca047d597c73f": "The `decode` method in the `_Simple` class takes a list of tokens as input and returns a single string by joining all the tokens with spaces.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\chunk_utils.py:encode:fea1b5a02caace79e418a8583dbb7c09b8e93a65efeb59b0edd34abafc8f51e1:9a19bce39d4ef35c6f73ca8483dbceca31e89f4a8dacc793b0502a3790cda2f0": "The `encode` method of the `_Simple` class removes FIM tokens from a given string and splits it into a list of words.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\chunk_utils.py:get_tokenizer:400302d4c4f4b3c907a5e19bd6af65be883a4637fd2da2ed18062768909cdd44:252099efcefb2bdd13b9af01b036c26a92c4f6cd8dc2a0b1733e0bccdb09b479": "The function `get_tokenizer` returns a tokenizer object used for estimating token counts. If the `tiktoken` library is available and can be loaded without errors, it attempts to use the `cl100k_base` encoding. If that fails or if `tiktoken` is not installed, it falls back to using the `gpt-3.5-turbo` model's encoding. If both fail, it prints a warning and returns a simple tokenizer that splits text into words for token counting.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\chunk_utils.py:strip_fim_tokens:2852adb616b7fce3c78896b251d0f2399bc0685e96352b3f0287eabec478a432:b6002f9ad8bc5856406a4f468773d932628efeb07bb5b88fdb60b8ff26099b7b": "The function `strip_fim_tokens` removes any FIM special tokens from a given string `text`. It uses the regular expression defined in `FIM_RE` to identify and remove these tokens.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\docgenerator.py:_build_function_prompt:c535221f54f65effba8f46312177565683bde6aed956e98e50211d9f189505e8:5d55327afc8e8d938bdad0afd3b133535d142332da56ec01baf975b51ddb67aa": "This function `_build_function_prompt` constructs a prompt for summarizing a Python function's source code. It takes four parameters: `source` (the function's source code), `class_name` (optional, the name of the class containing the function), `class_summary` (optional, a summary of the class), and `project_summary` (optional, a summary of the project). The function returns a string that includes these parameters as context and appends the function's source code.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\docgenerator.py:_chunk_module_by_structure:36e38cc3f78e886094736a1179a0238e386c553c39f20f1a75e81dec9cdc3dec:3efe396b5851381dc0cef1bfd9d4662c1a7630c273356c856129925c26b89e6c": "This function `_chunk_module_by_structure` processes a parsed Python module and splits its content into text chunks based on the specified token size. It first extracts the module's docstring, then iterates through classes, methods, variables, and functions to collect their source code. The collected blocks are then chunked using a tokenizer, ensuring no single block exceeds the given token limit. Chunks are separated by double newlines for clarity.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\docgenerator.py:_rewrite_docstring:1086b25abdfa5286432a31a48dc5cf3d737348a722a75b3769d54a30259749a7:aad406573763aadd41f04af30655d132e152aba79e42582c25f15da649e0ea12": "The function `_rewrite_docstring` rewrites the docstring of a code item using optional context. It takes an `LLMClient`, a `ResponseCache`, a file path, and an item dictionary as input. The function checks if there is source code or a docstring in the item; if not, it prints a warning and returns. If there is no docstring but source code exists, it returns without modifying anything.\n\nThe function constructs a prompt based on whether class name, class summary, or project summary are provided. It then generates a key content string by concatenating the source code, class name, class summary, and project summary (if applicable). A cache key is created using `ResponseCache.make_key`.\n\nThe function calls `_summarize_chunked` to generate a new docstring using the constructed prompt. The result is sanitized with `sanitize_summary`, and if it's empty, \"No summary available.\" is assigned to the item's docstring.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\docgenerator.py:_summarize_class_recursive:b3f224803e2359f633264fb159630483e37cc411fd4a801809d8a5d765724668:878f0b9558c1bcfd9a93d799c87b33db9b4a4dfa6fd0063878829245956641c4": "The function `_summarize_class_recursive` is designed to recursively summarize a class and its members in a Python codebase. It takes several parameters including `class_data`, `path`, `project_summary`, `tokenizer`, `client`, `cache`, `max_context_tokens`, and `chunk_token_budget`. The function performs the following tasks:\n\n1. Calls `_summarize_members_recursive` to summarize methods, variables, and subclasses within the class.\n2. Constructs a prompt for summarizing the class using predefined text (`CLASS_PROMPT`) that includes the class name, project summary, method summaries, and variable summaries.\n3. Generates a key for caching the class summary based on the path and class name.\n4. Summarizes the class using `_summarize_chunked`, which handles chunking the input if necessary.\n5. Sanitizes the generated summary to remove unwanted content.\n6. Updates the `class_data` dictionary with the new summary, replacing the original docstring if it exists.\n7. Recursively calls itself for each subclass of the current class.\n\nThe function also includes calls to `_rewrite_docstring` for methods and variables within the class, passing along relevant context such as the class name, class summary, and project summary.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\docgenerator.py:_summarize_function_recursive:cd224e2c8eaaa36368c6aee2e140f89492b056d9ff023e2eefbc1946323ae5e8:eef049e609a3c46a5467570ace9a50bad3351783f6eb6ce7f3e395ce0c3b4766": "This function, `_summarize_function_recursive`, is designed to recursively summarize a given function and its associated subfunctions and subclasses. It takes several parameters including the function details (`func`), path information (`path`), an LLM client (`client`), a response cache (`cache`), a tokenizer, and various token budget settings.\n\nThe function first constructs a prompt using `_build_function_prompt`, which incorporates the source code, class name, class summary, and project summary. It then generates a unique key for caching purposes using `ResponseCache.make_key`. The actual summarization is performed by `_summarize_chunked`, which handles chunking of the text to fit within token limits.\n\nIf the function's summary needs rewriting (controlled by the `rewrite` parameter), it calls `_rewrite_docstring` to refine the generated summary. After updating the function with its new summary, the function recursively processes each subfunction and subclass using `_summarize_function_recursive` and `_summarize_class_recursive`, respectively, passing along relevant context such as class name, summaries, and token budgets.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\docgenerator.py:_summarize_members_recursive:4c65ae288cfb5569df4e0fd42632b3f02293ca79363f9411ba8818ca99a5e228:cbed4a3cb8c45058ffeaac575fb1ecef0b81d83c5b17195485fe28ed284a4a22": "This function recursively summarizes the members (methods and variables) of a given class and its subclasses. It uses an LLMClient to generate summaries for each member, caches these summaries using ResponseCache, and updates the class data with the generated summaries. The function also calls itself recursively to handle subclasses.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\docgenerator.py:_summarize_module_chunked:53fbd405de1926086e54bc2b6f7551ac7b70a880519590be4b1a1a428b8abc51:569d525efd3a2b269d06ba1fc012fd35309db90c0849236507ffbf0308055c4d": "The function `_summarize_module_chunked` is designed to summarize a Python module using structure-aware chunking. It takes several parameters including an LLM client, response cache, key prefix, module text, module dictionary, tokenizer, maximum context tokens, and chunk token budget.\n\n1. **Template and Overhead Tokens Calculation**: The function calculates the overhead tokens for the system prompt and template.\n2. **Module Text Length Check**: If the length of the module text is less than or equal to the available tokens, it directly summarizes the module using the `_summarize` function.\n3. **Chunking by Structure**: If the module text is too long, it attempts to chunk the module by structure using `_chunk_module_by_structure`.\n4. **Summarizing Chunks**: Each chunk is summarized individually and stored in a list of partial summaries.\n5. **Merging Summaries**: The function combines the partial summaries into a single technical paragraph using a recursive merging approach. It ensures that the combined summary fits within the available tokens by breaking it down further if necessary.\n6. **Sanitization**: Finally, the function sanitizes the merged summary to remove any unwanted content and returns the sanitized summary.\n\nThe function handles exceptions during chunking and summarization processes,",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:Config:0b3ed3eff1c79c43fbe5d931fef9fce219dad2ae4a03975c80a50074ce4a92d9:594733ac4138c0c5ad11ce6e6840136f00c85e7c41a44ed0802b36201d93f5ba": "The `Config` class represents configuration settings parsed from command-line interface (CLI) arguments. It includes attributes for specifying paths, output formats, and various boolean flags to control behavior such as inserting into an index, chunking, scanning code, and setting limits on file size and number.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:_edit_chunks_in_editor:a24b1d5b1c9a52b2baba1d8cb38b531bd7cafd21cc29f964d15dd433fbf1bb5a:be5b68768f9b9778c86b837e1ccc0c49900f88f9ee628de064a064d02e157af0": "The `_edit_chunks_in_editor` function takes a list of code chunks as input, joins them into a single string with separators, and opens this string in the user's default editor. After editing, it reads the modified content back, splits it by the separator, and returns a list of non-empty chunks.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:collect_docs:930e37687ccb9646a9218c50460904fc61dfef20fb9693e37ed85c64b8ec52e8:2a886c87a23d399bff59a9bc7d4849728f618d198ba3429716d2c73f90f34009": "The `collect_docs` function returns a list of documentation files located under the specified base directory. It includes files from specific patterns in the project root and within a \"docs\" subdirectory. The function ensures that only unique files are returned by using a set to track seen files.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:collect_files:f49bda99309727239ddeb7a267ea356190b67425e6c1c68c0dbc26951e678c45:c8a2ce253854d9ece7e518ee3bb431551ea241c2d474e40c3e34226999afd1df": "The `collect_files` function returns a list of file paths relevant for summarization from a specified base directory. It starts with a default set of patterns to include files like README.md, text files, HTML files, and various document formats (docx, csv, json). If additional patterns are provided through the `extra_patterns` parameter, these are also included in the search.\n\nThe function uses `rglob` to recursively find all matching files in the base directory and its subdirectories. It then filters out duplicate files by using a set to track seen paths, ensuring that only unique file paths are returned. The result is a list of unique file paths that match the specified patterns.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:detect_placeholders:fd99a5a17faf27c80a0c961e7d5afc7f83bdee0dbbd1a5cae326d2848e75024a:8eb95fc0a1c02dfbb6d726abcc89aaf5258e4a30265ad21e7d748624affdfffd": "The `detect_placeholders` function identifies and returns the names of sections that are still marked with placeholder tokens. It takes a string `text` as input, finds all placeholders using the `find_placeholders` function, and then filters these to return only those whose corresponding tokens match those defined in the `SECTION_PLACEHOLDERS` dictionary.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:extract_snippets:7311dfb5ca43aafeec0ac42d427ae396abcca02eac783b066aa0992435075889:b962e207250625a6ec74ec9be8e11c987fe15db00e7222bee638efe23e861b42": "The `extract_snippets` function processes a list of Python files to extract relevant code snippets. It reads each file, checks its size and modification time, and parses it using the Abstract Syntax Tree (AST) for Python. The function identifies module docstrings, class and function docstrings, I/O signatures based on argument names, CLI parser definitions, and the `__main__` block. If a file meets the specified size or time constraints, it is skipped. The extracted snippets are stored in a dictionary with file paths as keys and concatenated text as values.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:extract_text:32e44aa62997230f880fe7989f5d47be36e94b8ab385a525b83b8c6ebf29e94f:7d9b846d5d317aba9ec60db5c23057c9d1b350de6c05815894ee8ad9485c495f": "The `extract_text` function reads and processes the content of a file located at the given `path`. It determines the file type based on its suffix (extension) and applies specific processing to extract plain text. Here's how it handles different file types:\n\n1. **HTML Files**: The function reads the HTML content, uses BeautifulSoup to parse it, and then modifies headings (`h1` to `h6`) by replacing them with markdown-style headers. It also converts `<pre>` tags containing code into fenced code blocks. Finally, it strips leading and trailing whitespace from each line and joins them back into a single string.\n\n2. **Markdown Files**: The function simply reads the content of the Markdown file as plain text.\n\n3. **Word Documents (`.docx`)**: If the `Document` class is available (indicating that the `python-docx` library is installed), the function reads the document, processes each paragraph, and converts headings into markdown-style headers based on their style names. It strips leading and trailing whitespace from each line and joins them back into a single string.\n\n4. **Other File Types**: For any other file type not explicitly handled (e.g., plain text files), the function simply reads the content as plain text.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:infer_sections:01a470f628fccc3bb7b87812222c85cb8e4f9001f76b500c326134fc2074f2c5:f71c459bc0710b67cf1d0f410c2ee478d90b53a045ae00f86db65b017d4eecec": "The `infer_sections` function takes a string of text as input and returns a dictionary representing manual sections. If the input text is non-empty, it places the text in an \"Overview\" section and generates placeholder content for other required sections labeled \"(inferred)\". If the input text is empty, it initializes all required sections with a default message indicating no information exists. The function ensures that all specified sections are present in the output dictionary.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:inject_user_manual:f64e52f14af888b044cca2d989184b3bfdffa371926e4b3caa82c06785b2a0fe:4129f6632ed802108dc5bce130559ba569e27ce894dcee73c5d1982eaa04245d": "Inserts a top-level link to a user manual into an HTML file specified by `index_path`. The link is added before the first `<nav>` or `<ul>` element if present. If neither is found, it is inserted at the start of the first `<body>` element or the document root.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:insert_into_index:be942870049acdec3bce633f284c52477b1b38a19446fdaaf21cdf9cac1e729e:af6d1533eb9d02e388a3161d531f5caac2d2f8fd3bfd2d3329e2749f1f64da77": "This function `insert_into_index` appends a navigation entry linking to a specified file into an HTML index file. It takes three parameters: the path to the index file (`index_path`), the title of the new entry (`title`), and the filename to link (`filename`). The function reads the existing content of the index file, parses it using BeautifulSoup, and finds either a `<ul>` or `<nav>` container element. If such an element is found, it checks if an anchor tag with the specified `href` attribute already exists. If not, it creates a new anchor tag with the given title and appends it to the container. If the container is a `<ul>`, it wraps the anchor in a list item (`<li>`). Finally, the modified HTML content is written back to the index file.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:llm_fill_placeholders:eed9c10b193f8d8cee6e2f07eb0d348bdb435d4b7fa239944297f6b5fb470282:b68c38d5d50d94fbc61d5cc418e109558a51201fc6925ba2ba6832d0538a4eea": "This function `llm_fill_placeholders` fills placeholder tokens in a manual text using provided code snippets. It iterates over each section in the `code_snippets` dictionary, concatenating the code snippets into a single string and encoding it to check token usage against a maximum context limit (`max_context_tokens`). If the combined token usage exceeds the limit, it summarizes the snippet using another function `summarize_chunked`. Then, it constructs a prompt by combining the manual text, section name, and code snippets. This prompt is used to update the manual by replacing placeholders with relevant information from the code snippets. The updated manual text is returned after processing all sections.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:llm_generate_manual:b5fec768c0bfea53b4a8c8cb4db30266fd8f152d4c2a2046351f8bc6705bc913:413789d1396ac9034cac8252b60b97895a90042275951a2f560f9cbfdf954477": "The function `llm_generate_manual` generates a user manual from provided documentation snippets. It maps these snippets to manual sections, performs LLM calls per section, and assembles the final manual text. The function returns the manual text, a mapping of source files to the sections they contributed, and an evidence map capturing the snippets used for each section.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:map_evidence_to_sections:046fa49a346742d605af1d569180cc1a801c4fdca0bbdab847e8004b489779a4:4f9906a81fb0139e98bd8bf69d66ec85ede4f0be14ec2e1bf727d27874715c2c": "The `map_evidence_to_sections` function processes a dictionary of documentation snippets and maps them to manual sections. It returns a tuple containing two dictionaries: `section_map` and `file_map`.\n\n\nThe function skips directories listed in `skip_dirs`. It iterates through each line of the documentation text, checking for section keywords. If a keyword is found, it extracts up to 10 lines of code following the keyword as a snippet. The snippets are then sorted based on their length and added to the appropriate section in `section_map`, limiting each section to 10 entries. The `Overview` section has additional sorting criteria based on file path characteristics.\n\nThe function ensures that only non-empty, non-commented, and non-header lines are included in snippets.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:parse_manual:072ce2af6a6006a20db118ac87daf6ed2b5e924d13af53ab0127f4d26393cf1e:db022d270e94e87d4be6169cfb19bcc232d61a3573d8e31443bf78bc1938b7f7": "The `parse_manual` function processes text from a language model to extract structured sections. It splits the input on lines containing a colon (`Section: content`) and organizes them into a dictionary. If required sections are missing and `infer_missing` is set to `True`, it uses an LLM client to infer these sections, marking them as `(inferred)`.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:rank_code_files:b5fc811be9c3432b037551fc19bee8cb8f171c1d2d5836a294bac7099de9f680:5110464215378846e79b03694eef1104b56d36d31452b0f6ab0f88284a23c3ca": "The `rank_code_files` function ranks Python code files under a given root directory based on simple heuristics. It supports various file extensions including `.py`, `.m`, `.ipynb`, `.cpp`, `.h`, and `.java`. The function skips certain directories like `venv`, `.git`, and `tests`. It assigns scores to files based on keywords in their paths and patterns provided by the user. Files with higher scores are considered more important and are returned first in the sorted list.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:render_html:f852df08cb1c14c4f4c53449b0657e6449bdc52cbdd466890c1988e692362000:938d4a878ca5b0c2fd6f8a119a175d92ed6b47ed90e708db6ad1b3c51b0cde4d": "The `render_html` function generates HTML content from a dictionary of sections, a title, and an optional evidence map. It processes each section to create an anchor link for navigation and renders the content either directly or using evidence snippets if no information is available. The function includes styling for the HTML document and handles Markdown rendering if the `markdown` module is available.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:scan_code:8a64bc5eb70636de799452714e6cf1ed4b9c085dad37c8c23ef2e4a141970102:4ccc31f40a18072c566325c3981a7ca8d67d229a2827b50290823637c7e17a3b": "The `scan_code` function collects source code snippets from a specified directory (`base`) and groups them by manual sections. It searches files for keywords associated with the provided sections (defaulting to all known sections) and returns a dictionary mapping section names to another dictionary of relative file paths and their corresponding snippet texts.\n\nHere's a breakdown of its functionality:\n\n1. **Pattern Extraction**: The function collects documentation files from the `base` directory using `collect_docs(base)` and extracts text from these files using `extract_text(doc)`. It then uses regular expressions to find patterns in the text, appending them to a list if they contain slashes or end with \".py\".\n\n2. **File Ranking**: It ranks code files based on the extracted patterns using `rank_code_files(base, patterns)`.\n\n3. **Snippet Extraction**: The function extracts snippets from the ranked files using `extract_snippets`, limiting the number of files processed (`max_files`), time budget (`time_budget`), and maximum bytes per file (`max_bytes_per_file`).\n\n4. **Section Categorization**: It categorizes the extracted snippets by section. If specific sections are provided, it uses those; otherwise, it uses all known sections. For each snippet, it checks if any of its keywords match",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:slugify:a0ac43a414bb690efbd481cd903c46903bc713a5df6455829d1f5fa7afcfc73b:f4ff94c25e8d13bc17d260547062a03a56bc937e40ccae66b0b0f888055fc270": "Converts a given string into a filesystem-friendly slug. It removes all non-alphanumeric characters and converts the string to lowercase, replacing spaces with underscores. If the resulting slug is empty, it defaults to \"user_manual\".",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:validate_manual_references:ef9fdd545e37a8d5d2f51608b060bdbbac9d29d3388693271f0eef34b730b26f:66ebf3e12eaf276c6767972e70bb56a8f82576dd93b9212c6e1d20f3bbe2bf79": "The `validate_manual_references` function checks for references to files or modules in a set of documentation sections and flags any that do not correspond to existing files in the project. It uses regular expressions to identify file path-like substrings within the text of each section. If a reference is found but does not match an existing file or module, it appends \"[missing]\" to the reference in the section text. Additionally, if an `evidence_map` dictionary is provided, it records any missing references under the corresponding section's key. The function modifies the input `sections` dictionary in place.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:write_pdf:ae45aac2be914e92859db11dbdb33134e5604219000006fe0603158cb12c28f9:50d247b1d65d35d403ce8eef36afb76c7611a48017e9e2b4a32bf311bd407f69": "The `write_pdf` function takes an HTML string and a file path as input. It checks if the `canvas` module is available; if not, it returns `False`. The function then parses the HTML to extract text, creates a PDF using the `canvas` module, and writes the text to the PDF at specified coordinates. Finally, it saves the PDF to the given path and returns `True` on success.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:__init__:26a024792a8fc1a9c5e5cbcc6cc5c9430a1e8b42f059e866125fc8a259d12781:db9baec640e35b4c6aa4901d43d7aeeaf23b230c2e07d0923e6bcb9996304080": "The `__init__` method initializes a new instance of the `CollapsibleBox` class. It sets up a toggle button with optional text and makes it checkable. The button's appearance is customized with a stylesheet, and its style is set to display text beside an icon with a right arrow. When the button is clicked, it triggers the `on_toggled` method. Below the toggle button, a content widget is added, which is initially hidden. The layout of the box is managed using a vertical box layout that contains both the toggle button and the content widget.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:__init__:89383d3b2d1639b53a7149688db28b09953396cece7f353d5cc12b5a1eeaed7b:5cf16fc616ae77cb9fb3d8625cf2bb3294bc108ef6e750ed371c634c0ee5556b": "The `__init__` method initializes the `MainWindow` class, setting up the graphical user interface for configuring and executing code documentation generation tasks. It includes components for selecting project and output directories, configuring options such as languages and private functions, and running commands to generate summaries or user manuals using an LLM. The interface features a header with a logo and title, input fields for project and output directories, checkboxes for language selection, options for output format and data inclusion, a log area for displaying output, and buttons for initiating different tasks like running DocGen, ExplainCode, or both.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:__init__:9a5480757caf696c9e432a82bf90c516f870a0f40309fab8ec26a7524e4bb33a:bd952a09df32136b91cd220afd2765aad55553df02d34b258a5b14793d195a2f": "The `__init__` method initializes a new instance of the `PathLineEdit` class. It calls the constructor of its superclass and sets the widget to accept drag-and-drop events for URLs.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:__init__:cacc0a8a0bf43c14b82db12490d4d57a91b036f0e71ddae4f8f076ba7af7885d:fe6e14daead42efbfffcb9aaab3f6845c3d77ddcb5c479b76279b982634dd059": "The `__init__` method initializes a new instance of the `CommandRunner` class. It takes a list of commands (`cmds`) as an argument and assigns it to the instance variable `self.cmds`. This method is typically used to set up any necessary attributes or configurations when creating an object of this class.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:_reader:198fc72aac55b1a40a14d102009ea79f87e87af1d950b5630f27a9f4eb02d097:1fe3f5d2b86e60f5d10e1ee2d1b52d9c491ded9bb2f17a8a5cbf24aa811f9ab8": "The `_reader` method reads a stream character by character, emitting chunks of text to an output signal. It handles carriage returns and newlines to update the GUI progress bar appropriately. When the stream ends, any remaining buffered text is flushed.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:append_log:72e6df59c18ac3c0c9224f85026920db7776e4b9528ee56021a58d01a455d6af:9a19fe4e0c8dde63c6c5bceb5441d3c8315c85a9ef39c273f9931c578aaeed7f": "The `append_log` method in the `MainWindow` class appends text to a log area. It uses a regular expression to split the input text into parts, handling carriage return characters (`\\r`) by moving the cursor to the start of the line and removing any existing text before inserting new text. After appending all parts, it scrolls the log area to the bottom to ensure the latest text is visible.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:build_docgen_cmd:a9eec50fa687bba201d919ed4cce0520d5ec17732a7c8a67b24b5a3fcece68f5:d5112ed6a5757e27e249598d2969a7e199c2b8854b60179eba999477d7968b25": "The `build_docgen_cmd` method constructs a command to run the `docgenerator.py` script for generating code documentation. It takes a boolean parameter `resume` indicating whether to resume a previous task. The method gathers project and output directory paths from GUI elements (`project_edit` and `output_edit`). If the `resume` flag is set, it appends the `--resume` argument to the command. Additionally, if a checkbox for including private functions is checked, it adds the `--include-private` argument. The constructed command includes the Python interpreter (`pythonw`) followed by the script path and the gathered directory paths.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:build_explain_cmd:386e21fe42ade81a2ad97ce2a668aaa1d1cea1e1c0aab06ab5dcad5ed4239e84:82b76bdeb33e2f9d23c4c9b70688ba99ae9ed0f76049a12d318c0dd166c4be0c": "The `build_explain_cmd` method constructs a command to run the `explaincode.py` script with specified parameters. It sets up the command list with the interpreter (`pythonw`) and the script name (`explaincode.py`). The method then appends arguments for project path, output directory, and output format based on user input from GUI elements (`project_edit`, `output_edit`, `format_combo`). If a data file is specified and included in the configuration, it adds the `--data` flag followed by the path to the data file. The constructed command list is then returned for execution.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:dark_style:7000d0bd657b145f33bcbc80a9997e2fdb3f742f39262f302e29a418337e8d1e:7d9cbf10cc6098a83c0772ec6b2a632c423fd8956a59b6e0ca2e15f2d9569467": "The `dark_style` method in the `MainWindow` class returns a string containing CSS styles for various widgets in the graphical user interface. The styles define the appearance of `QWidget`, `QLineEdit`, `QPlainTextEdit`, `QComboBox`, and `QPushButton`. The background colors, border styles, padding, and font properties are customized to provide a dark theme with a monochrome color palette.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:dragEnterEvent:e8b8cb2db998cc8367bb56a53e9f7f268f87d75a5b1985d1cd72061f999fac68:af3339ed78e5803856823f4b7d3d9a7bfe4f4bb42d122fff60a4608cef522cb0": "The `dragEnterEvent` method in the `PathLineEdit` class handles the event when a drag-and-drop operation enters the widget. It checks if the MIME data contains URLs and accepts the proposed action if it does, allowing the drop of file paths onto the widget.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:dropEvent:811a4832582e711594ca0559a5999180589dd2acf247e837a05001315a5d4b56:20577a0bae035529e5b4580f4090c36a0e075ba3e4fa79cb25eb0eed6c77f7e7": "The `dropEvent` method is an overridden function in the `PathLineEdit` class. It handles the drag-and-drop event when URLs are dropped onto the widget. The method retrieves the list of URLs from the event's MIME data and sets the text of the widget to the local file path of the first URL in the list, effectively allowing the user to input a file path through drag-and-drop functionality.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:on_finished:d700433cfe9448f23f8e603267b917290a73ad125745de2dff176fbc48ea7f8f:f8a71aa82e2af8d333f0482c65082ee9d7df9e7ba9108614bdbbf8824a69714b": "The `on_finished` method in the `MainWindow` class handles the completion of a process. It appends a log entry indicating the exit code of the process and sets the running state to false, indicating that the process has finished executing.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:on_toggled:9ba255a99f4df79eba45b7b16b9bb6a648874fde9590c9991c5abc282a254397:496023278ab8d4ab77f961a9dc5337e0307162abb802cd1d83fd75ba3c54a698": "This function `on_toggled` is part of the `CollapsibleBox` class. It handles the toggling of content visibility in response to a button click. When the toggle button's state changes, it checks whether the button is currently checked or not. Based on this state, it sets the arrow icon of the toggle button to either a down arrow (if checked) or a right arrow (if unchecked). Additionally, it updates the visibility of the content area within the box to be visible when the button is checked and hidden otherwise.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:run:063ca43f36c661151a80a4bd343f8ead8d0dcea362f04077b1d6303b20d67701:8f33a0ad492e5e1feabd5a749240e3eaea05a8431ab6cb02acbd9e4946a25a9e": "The `run` method of the `CommandRunner` class manages the execution of a list of commands asynchronously. It iterates through each command, emitting its start message to an output signal. For each command, it creates two threads to read from the standard output and error streams separately using the `_reader` method. These threads are started and then joined to ensure that all output is captured before moving on to the next command or handling any errors. If a command returns a non-zero exit code or an exception occurs during execution, the loop breaks, and the final exit code is emitted through the `finished` signal.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:run_both:3b6831cb8e05c8129afc371a713e7cb9ef5609be1254d42756397d15d8c949a5:32e1945720879efd92f306e99e6e1a904bd6d6bdc1c5a524408fd95c62aeb0a7": "The `run_both` method in the `MainWindow` class clears the log area and then runs two commands: one for generating summaries using the `docgen.py` module and another for generating user manuals using the `explaincode.py` module.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:run_commands:1f9ae5147c31620fd5ae9a2d587c785695bc980533e9e96f51736dafa89ce526:8c2234b09c50bb447a868d3ae933f9a161e59c324c7c065355345bb5226deb8a": "The `run_commands` method in the `MainWindow` class is designed to execute a list of commands for generating code documentation. It first checks if both project and output directories are set by verifying non-empty text in `self.project_edit` and `self.output_edit`. If either is empty, it appends an error message to the log area and returns without executing any commands.\n\nIf both directories are set, the method sets its running state to True and initializes a `CommandRunner` object with the provided list of commands. It connects the `output` signal of the `CommandRunner` to the `append_log` method, which updates the log area with command output in real-time. The `finished` signal is connected to the `on_finished` method, which will be called when all commands have completed execution.\n\nFinally, the method starts running the commands by calling the `start` method on the `CommandRunner` object. This setup ensures that the GUI remains responsive while commands are executed and provides feedback through the log area as each command completes.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:run_docgen:afc770f3db8b0e0e1cdbde2c50a8e8db0f70fb5a33aebae8696ae278cb22b4da:941651abf93f3ad9b735399eeb95e0c212055ae64fe3be88fb5bfe6e877ca311": "The `run_docgen` method in the `MainWindow` class clears the log area and then runs a command to generate documentation. It uses the `build_docgen_cmd` method to create the command and passes it to the `run_commands` method for execution.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:run_docgen_resume:5d77fe40bb601cf3b53d59dbbbb44cd627ad607e7b870b90c7ffe332ee6f2ea0:cbd8f89c2402862998eb56fb4b95c6f4ecd8562e48b4dec38d5ab5ab2bf156f9": "The `run_docgen_resume` method in the `MainWindow` class clears the log area and runs a command to generate documentation summaries using an LLM. It constructs the command with the `resume=True` parameter, which indicates that the documentation generation should be resumed from where it left off.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:run_explain:73ecfc78c33236d3bc7529d893c02b285c656a65e3305d5bcf9c4e85bb9f717b:81825a4f971ecfb538e6f914ce2598c3e234e8f8418df8e405031f43cc62d546": "The `run_explain` method in the `MainWindow` class clears the log area and runs a command to generate user manuals using an LLM. It builds the command for generating explanations by calling `build_explain_cmd()` and then executes it with `run_commands()`.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:select_dir:8b4e01ee23791cc647ffe311a1810408e0a5c07fd7d042271c6831d6eda2c96a:707452d64108e7a3f5006e0a80ec76ca7242b9de350a87384765aedfbc797e14": "The `select_dir` method in the `MainWindow` class is designed to open a file dialog for selecting an existing directory. When called, it prompts the user to choose a directory and updates the specified `QLineEdit` widget with the selected directory path if one is chosen.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:select_file:ac8d02a20efde64406d1b4e7a9c6789f30acc9bb02829bbbb9d62f0f4f296781:50dc0691a24401d7743dda0bbf92106c702358666e2bb8061d87ef43eb1c7715": "The `select_file` method in the `MainWindow` class is designed to open a file dialog allowing the user to select a data file (JSON, CSV, or TXT) and set the selected file path in a specified `QLineEdit` widget.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:setContentLayout:d4402c4acea1ba46d6ceb2f2f0c0e3cac361955ac43e666909073e1ce3deba24:fa6a4d8048d17badc55fde513eb904c7739ca4b28ecf7f495acef15fefa5ce9c": "The `setContentLayout` method sets the layout for the content area within a collapsible box. It takes a `layout` parameter and assigns it to the `content` attribute of the `CollapsibleBox` instance. This allows for customizing the appearance and arrangement of elements within the expandable section of the box.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:set_running:72f70d97dc9caaa56847b71835482d2cc1a56bdca796beb4393a8f184b57312a:4d1f789bbb280cdb5d8bc811427556f545748314896547efbe6871652dbf242d": "The `set_running` method in the `MainWindow` class sets the enabled state of four buttons (`docgen_btn`, `resume_btn`, `explain_btn`, and `both_btn`) based on a boolean parameter `running`. If `running` is `True`, all buttons are disabled. If `running` is `False`, all buttons are enabled. This method is used to manage the state of these buttons when a documentation generation process is running or paused.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\html_writer.py:_highlight:eccdb9832189769c9b80b8fde8bb2fee8b68b61a59db226da65166180676760c:d199f9925f17bd0e78943acf5311b4683682594378654b1e3ae7e763703aab7e": "The function `_highlight` takes a string `code` and a string `language`, and returns the code highlighted in HTML using Pygments. It selects an appropriate lexer based on the language (Matlab, Python, C++, Java) or defaults to `TextLexer` if the language is not recognized. The highlighted code is then wrapped in `<pre><code>` tags for display.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\html_writer.py:_render_class:8f593b48718c93eb0f1ed737f80756fea2a588dbc19a681e2efada59b96e5de5:eee7b9789e76c32ac8a47d103e51972954c20778b4c22776d222b57abf191629": "This function `_render_class` generates HTML parts for a class and its subclasses. It takes a dictionary representing the class, a programming language string, and an optional level parameter (default is 2). The function returns a list of strings containing HTML code.\n\nThe function starts by creating an HTML heading tag (`<h1>` to `<h6>`) based on the provided level for the class name. It then checks if there's a docstring or summary for the class and appends it as a paragraph.\n\nNext, it processes any variables associated with the class, creating headings for each variable and appending their names and summaries (if available) as paragraphs. If source code is present for a variable, it calls `_highlight` to syntax-highlight the code.\n\nThe function then iterates over methods in the class, calling `_render_function` for each method to generate HTML parts.\n\nFinally, it processes subclasses of the current class. For each subclass, it creates a `<details>` element with a summary and recursively calls `_render_class` to render the subclass's HTML parts.\n\nThe generated HTML parts are collected in a list and returned.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\html_writer.py:_render_function:fbba168f7e5a1c34256028e184dad3890a0774cbe1384c7fa5b319237db3b074:0bd8276f85cea708295cb05dbbc89b208fdd7138242f45d763e19103fd8a24cc": "This function `_render_function` takes a dictionary representing a function (`func`), a programming `language`, an optional `level` for HTML heading tags (default is 3), and an optional `prefix`. It returns a list of HTML strings that represent the function and any nested subfunctions.\n\nThe function constructs HTML parts by:\n1. Creating an HTML heading tag based on the `level` parameter.\n2. Escaping and appending the function's signature or name as the heading content.\n3. Adding a paragraph containing the function's summary or docstring, if available.\n4. Highlighting and appending the function's source code, if present.\n5. Iterating over any nested subfunctions, creating a `<details>` element for each subfunction, and recursively calling `_render_function` to generate HTML parts for the subfunction.\n\nThe resulting list of HTML strings can be used to render the function and its subfunctions in an HTML document, with expandable sections for subfunctions.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\html_writer.py:_render_nav_tree:d2e01739499be8e5b4584a11213ce9d173d32dcd5dc87bc8e53e3b0d14176e15:a9c2b14efafa5a5d856c9d510088b776cd94c3fd02769ff9db619deb084c0b85": "This function `_render_nav_tree` generates HTML for a nested navigation tree based on the provided dictionary `tree`. It includes an optional \"Home\" link if specified. The function uses a recursive helper function `_render` to traverse the tree and construct the HTML structure. Each node in the tree can contain files and subdirectories, which are rendered as list items with links or expandable details sections.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\html_writer.py:write_index:fa1a6e520a8e58815ea308c615c67586599d3121f3999610328550818af3767a:692863def5651c9c2c20e667c786021cee760180289210ea322d120cef49fef4": "The function `write_index` generates the content for an `index.html` file. It takes three parameters: `output_dir`, `project_summary`, and `nav_tree`. Optionally, it can also take a dictionary `module_summaries`.\n\n1. **Parameters**:\n\n2. **Process**:",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\html_writer.py:write_module_page:f5d740efc2d39d437fb3a7f17aeab54f3a20da2cd1e74ee5d2ddce2f2c4564a7:d6ca1682ee0bcd054c531dab74c7815bfefe6666fe9c19a79bdf16c4bbecd0fe": "This function `write_module_page` generates an HTML documentation page for a module. It takes three parameters: `output_dir`, `module_data`, and `nav_tree`. The function creates a directory structure under `output_dir` if it doesn't exist. It then constructs the body of the HTML page by rendering a summary, classes, variables, and functions from the `module_data`. Each class and function is rendered using helper functions `_render_class` and `_render_function`, respectively. Variables are listed with their summaries and source code (if available). The navigation tree is included at the top of the page. Finally, the HTML content is written to a file named after the module in the `output_dir`.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\llm_client.py:LLMClient:9086fe6d0aa4aad556d06744f699ce311e195429fe4c45bc9bd606ed6044b040:b119b81ce87856ab8f9a73d218c0a23edea1037962ac564ed23e34440ccc5293": "The `LLMClient` class provides a thin wrapper around the LMStudio HTTP API, allowing users to interact with language models. It includes methods for checking connectivity (`ping`) and generating summaries of text using specified prompts and parameters. The `summarize` method constructs a prompt based on a template, sends it to the model, and handles retries in case of failures.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\llm_client.py:__init__:9ce7b4e6a365a5ae1d2e3409d8ec990b693962a1f3c00f6f8c71aaffba602d13:f307a88ed1be7abd68a3873347107007cafe0f1ec12908ffdc4882df64760777": "The `__init__` method initializes an instance of the `LLMClient` class. It sets up the client with a base URL and specifies the language model to be used for generating summaries. The base URL is stripped of any trailing slashes, and the endpoint for making requests to the LLM is constructed by appending `/v1/chat/completions`.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\llm_client.py:ping:3f77f23cdf97a1c39765985cbc45279e5237ffe19bfe6fa8fc733c225ffeb195:5f7fbf660c5abaff4d42627af0a116ad33206cde0a86b0d03e1eea29c72d0013": "The `ping` method in the `LLMClient` class checks if the API is reachable by sending a GET request to the server's base URL. It accepts an optional `timeout` parameter with a default value of 2.0 seconds. If the server responds successfully, it returns `True`. If there is any issue during the connection or response handling, it raises a `ConnectionError` with a message indicating that the server cannot be contacted at the specified base URL.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\llm_client.py:sanitize_summary:89a8416e96d9902d7124c50ee13718d7837d88f99e030520e03254a71e85885c:15e0f08951869cf68da74b4d3167b4ecf4839b6727108957fb94dffca06af955": "The function `sanitize_summary` takes a string `text` as input and returns the text with meta commentary removed. It performs several operations to filter out unwanted phrases and lines:\n\n1. If the input text is exactly \"project summary\", it returns \"It prints.\"\n\n2. It removes FIM special tokens using the `strip_fim_tokens` function.\n\n3. It defines two lists: `BAD_START_PHRASES` containing phrases that should not start a line, and `BAD_CONTAINS` containing phrases that should be avoided in the text.\n\n4. The function splits the input text into lines and filters each line based on the following conditions:\n\n5. It joins the filtered lines back into a single string and returns it after stripping any leading or trailing whitespace.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\llm_client.py:summarize:bb0cbfe2f832ed998a74ffa6bf1063d8d8ec32c3c8951af943ed898279df67b8:3b778e1541e2d289e1090d5ea2b0e6bbc5195b172d81361d825f7e3ed0e61599": "The `summarize` method in the `LLMClient` class is designed to generate a summary for a given text using a specified prompt template. It handles various parameters such as the text to be summarized, the type of prompt, an optional system prompt, and limits on token usage. The method uses a tokenizer to calculate the size of the prompt and logs this information. If the prompt exceeds a specified token budget, it logs a warning.\n\nThe method constructs a payload for an API request, which includes details about the model, temperature, maximum tokens, and messages (system and user prompts). It attempts to send this payload to an endpoint using the `requests` library in a loop up to three times. If successful, it processes the response by decoding the content bytes, parsing JSON data, and extracting the summary text. The summary is then sanitized before being returned.\n\nIf any errors occur during the request or response processing, such as HTTP errors or request exceptions, the method logs the error and retries the request after a short delay. If all attempts fail, it raises a `RuntimeError` with an appropriate error message.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\manual_utils.py:_count_tokens:e9554d8a4798151d48ccb26976347d04f224f89b26fcb9b6b4999a9ed0fc7aae:f05a692d308dbe59f5cd69eb834deee967656b153ff7b04ee229e4a3ecc6582d": "This function `_count_tokens` takes a string `text` as input and returns an integer representing the approximate number of tokens in the text. It uses a tokenizer to encode the text, which converts it into a sequence of tokens, and then calculates the length of this sequence to determine the token count.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\manual_utils.py:_split_text:7061a58b3742c540c3912ff637f7905647defc9ef68f5be76e5fb2d356c46147:7833d99b3c4b8d74dfaeb28ea288be2d1f3f4d4a80fcaa13e2b6bc442b9aadee": "Splits a given text into manageable chunks based on specified maximum token and character limits. It first splits the text into paragraphs, then further divides each paragraph into smaller pieces if it exceeds the token or character limit. The function ensures that each chunk is separated by at least two newline characters to maintain readability.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\manual_utils.py:_summarize_manual:dd684a10469cb10f18dcf3885071f8cb256c89fdeb1fae088c9eb15b94dda181:d5947c0222571c34bd65d6ec14bcce85c52d1d5237396073aecf610c4f75f4e9": "This function `_summarize_manual` generates a manual summary for a given text using an LLM (Language Model) through the `LLMClient`. It handles different chunking strategies and caching mechanisms to ensure efficient summarization. The function supports automatic, manual, and no chunking options based on the input parameters. It uses lazy imports to avoid circular dependencies and includes error handling for network failures and other exceptions. The output is sanitized to remove unwanted content before being returned.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\manual_utils.py:chunk_docs:f444800e40f2a3b3f408e82d3897a6a1d72479387b4e27d17368ccf16aa81f4b:abac3a85c857f4736e9a289d686a7899a1258a9c0f29be55a5183cb416531f5e": "This function `chunk_docs` takes a list of strings (`docs`) and an integer (`token_limit`) as input. It joins the non-empty strings in `docs`, separated by double newlines, into a single string. If the resulting string is empty, it returns an empty list. Otherwise, it splits this text into chunks using the `_split_text` function with a maximum of `token_limit` tokens and up to three times that many characters per chunk. The purpose is to break down large blocks of documentation into smaller, more manageable pieces based on token limits.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\manual_utils.py:find_placeholders:a4619d01f5ead6f749f5cc07dfd5fb4b2fe0303a816516790869a7cb3d98befc:ac03fb7c4ced1cc2a0dd33a814cb0b62a0557c0fcb7b28ffdebaa961257c9995": "The function `find_placeholders` takes a string `text` as input and returns a set of placeholder tokens found within the text. The placeholders are identified using a regular expression defined by `PLACEHOLDER_RE`, which matches tokens enclosed in double backticks followed by two square brackets, such as ``[[TOKEN]]``.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\parser_cpp.py:_extract_block:97d3f200fbacde11bfcb27aa6fc6cba62cacadd1a0426062da7bd1f40247a8f1:7fab4fad4a948f6f343d5776f96d72910be9ff03cb480122abc22e6835dcfbc0": "The function `_extract_block` takes a list of strings `lines` and an integer `start`. It returns a tuple containing the text of a block starting at the given index and the ending index of that block. The block is determined by counting the number of opening and closing curly braces `{}` within the lines, ensuring they balance before the function exits.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\parser_cpp.py:_get_preceding_comment:46c72e355fc985edc860e983299d5b8853496e0f24fc1ded2d94aee9471c4021:0b53ee1b41e16e2462f0f8a08976545d7ddeb91da7698ddf47969cc677ef5532": "Collects contiguous comment lines appearing before a specified index in a list of code lines.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\parser_cpp.py:_parse_class_body:4ca4681c43e24c69d9f7b3020889c191f02c3b6c472ca335f42a6d0631bac556:298176184be9c1a67cd03c14d3e1ab70b7d5ba3207d12d3556df24a76b0b6b64": "This function `_parse_class_body` parses the body of a class from a list of source code lines. It identifies and extracts public methods and variables within the specified range (`start` to `end`). The function returns two lists: one for methods and another for variables.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\parser_cpp.py:parse_cpp_file:ef1389b0984460694fab78c5ccc264d15c8f61ea0aaffc007205cb0d6946f789:f025c120cc6069c6e15ffe3ea770d364281e3a6c276ff9d00a82284470f414df": "The `parse_cpp_file` function reads a C++ source file and extracts structured information about its contents. It processes the file line by line to identify module-level comments, namespaces, classes, and functions. For each class and function, it captures their names, signatures, docstrings, and source code blocks. The function returns a dictionary containing these parsed elements, including any namespace information if present.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\parser_matlab.py:parse_matlab_file:138828a115a11d367615d6b5f59b40a599d787f6202a8cc23139099032d077c6:3b663fe94e185ddfb4a37507623ba5d1831e24425e819bac8e0315d2cce9fc0d": "The function `parse_matlab_file` parses a MATLAB `.m` file and extracts its basic structure. It reads the file content, identifies leading comment lines as the file header, and searches for function declarations to extract their names and arguments. The result is returned as a dictionary containing the file header and a list of functions, each with its name and argument list.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\parser_python.py:_format_arg:9e7e53d74e60117425af0c8092ef3b690be341077ada770c20f34e05fe9aeb5f:616829b8d441118422484f3131f73a16fc08e4e1e6ee9b8772fe4c3094b0ba5a": "This function formats an argument from an AST (Abstract Syntax Tree) node. It takes an `arg` object of type `ast.arg`, which represents a function argument, and returns a string that includes the argument name. If the argument has an annotation, it appends the annotation in a formatted manner to the argument name. The function uses `ast.unparse` to convert the annotation back into a string representation.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\parser_python.py:_format_arguments:62a72c7699fd818374f5fda60a3a6496068d7e0ccbe978f255fcd7ccc767dba1:a3e722842d20ddc25aaa4e0234c5a93cc90388112edb0201d9209f2ebf2fabca": "This function `_format_arguments` takes an `ast.arguments` object as input and returns a string representation of the arguments. It processes positional-only, regular, variable-positional, keyword-only, and variable-keyword arguments, formatting them with their default values if provided. The function uses helper functions `_format_arg` and `ast.unparse` to convert argument nodes into strings.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\parser_python.py:_format_signature:c1a78b36941f2e378465c433e60a2323fd88e6c3f6e5ae671b9dc7bdb494f1af:4647761b3c61666dbf5cb900769ab8948e9dfbc7a2989604752ec4344fcdfeef": "This function `_format_signature` takes an `ast.FunctionDef` or `ast.AsyncFunctionDef` object as input and returns a string representing the signature of the function. It formats the function name, parameters, and return type (if present) into a readable string. The parameters are formatted using another helper function `_format_arguments`.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\parser_python.py:_parse_classes:0c4af95ea967a624e0486a1a26da04563c1335baaea2de6fb13441f9b984510d:be79acca09f413dad4643407f102fc7f7968c1267e74b592d2979b06b4764bb9": "This function recursively parses all `ClassDef` nodes within a given list of AST nodes. It iterates through each node in the provided list and checks if it is an instance of `ast.ClassDef`. If so, it appends the result of calling `parse_class` with the current item and source code to the `classes` list. If the node is an instance of either `ast.FunctionDef` or `ast.AsyncFunctionDef`, it recursively calls `_parse_classes` on the body of the function and extends the `classes` list with the results. Finally, it returns the list of parsed classes.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\parser_python.py:parse_class:3d6c6aab73ca3381a75661199d67babe86823d1a34e6e94067242d74732bd492:1896976d4b637d72faacc3237d9d9d1a012023c704205dc71dd549f646604fe4": "This function `parse_class` takes an AST node representing a class and the source code as input. It returns a dictionary containing information about the class, including its name, docstring, methods, subclasses, and source code. The function iterates through the body of the class to identify nested functions (methods) and recursively parses any nested classes.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\parser_python.py:parse_classes:62b690b5ab459c11977ef4c75199ddc03771a7db54491c02a4c6b6a3f66fc865:6042838bf6f5a3f6ec5162734589d90aafef1e1a8889d309e03a6e1c73e8fde9": "This function `parse_classes` serves as a public wrapper for the internal `_parse_classes` function. It takes two parameters: `node`, which is an abstract syntax tree (AST) node, and `source`, which is a string containing the source code. The function retrieves the body of the AST node using `getattr(node, \"body\", [])` to handle cases where the node might not have a body attribute. It then calls `_parse_classes` with the retrieved body and the source code as arguments.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\parser_python.py:parse_function:0f12d357cff17237fb710c7a8df7e2342e83b133f4b983b60807d8e75872b1ac:64e1621a42bb79d013386d235621cc0b5f74d7a4c098f331fcba744116944c51": "The function `parse_function` takes an AST node representing a function or async function and the source code as input. It returns a dictionary containing information about the function, including its name, signature, return type, docstring, source code segment, subfunctions, and subclasses.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\parser_python.py:parse_python_file:4749ec18d237bd352506acabb29072ecae8c723d8c84f3242ae1476f569d7172:0a18b234f784169fbe2f9c368551ec551edbe3a15b7712ee2a1da9a0f63e82aa": "The `parse_python_file` function reads a Python source file and extracts structured information. It takes the file path as input and returns a dictionary containing the module docstring, classes, and functions. The function uses the `ast` module to parse the source code and iterates through the nodes to identify class definitions and function definitions. Each identified class and function is parsed further using helper functions (`parse_class` and `parse_function`).",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\retrofit_sidebar.py:_paths_to_tree:39e8af9b8c61246f45ddb2c93292c6f046e5f20fc1689103b18a953f94dfb34c:26375594e84c89e562e72e0b2662457b7674f193a84c36de73d8bbe64eab0d8c": "Converts a list of file paths into a nested dictionary tree. Each path is split into parts, and the function constructs a dictionary where each key represents a directory or file in the path, with nested dictionaries representing subdirectories. The final part of each path becomes a key with a value of `None`.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\retrofit_sidebar.py:_tree_to_ul:dbb9b813c16cac1d71db3a9f26f0eb3e35fbc46c636a3744ab1f7618d8398073:6b1a7b3733a2ec870d4489e8363678f1cd76bbf185dd5594e8dec6854d3683ad": "The function `_tree_to_ul` recursively constructs an unordered list (`<ul>`) from a nested dictionary (`tree`). It iterates over the keys of the dictionary in sorted order, creating a new list item (`<li>`) for each key. If the value associated with a key is another dictionary and not empty, it calls itself recursively to build a nested `<ul>` element. The resulting `<ul>` structure is returned.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\retrofit_sidebar.py:retrofit_sidebar:d55a131c6d757ccebeb649a8e083e6aa0755ab6c5c0af6b9851e76fdd30f9ebd:de510187fda02dd2f0254fb1bd5fd1afb2857a7d6b2cb9095837cc538f79b0e2": "The `retrofit_sidebar` function replaces documentation sidebars with a hierarchical module list. It takes two parameters: `source_root`, which is the root directory of the source code, and `docs_dir`, which is the directory containing the HTML documentation files.\n\n1. The function resolves the absolute path of the `source_root`.\n2. It scans the directory for Python modules using the `scanner.scan_directory` function.\n3. It converts the list of module paths to a relative path list with respect to the `source_root`.\n4. It constructs a hierarchical tree structure from the relative paths using the `_paths_to_tree` function.\n5. It creates an HTML unordered list (`<ul>`) representation of the tree structure using the `_tree_to_ul` function.\n6. It reads each HTML file in the `docs_dir`, finds the sidebar div with the class \"sidebar\", and replaces it with the new sidebar markup.\n7. Finally, it writes the modified HTML content back to the original files.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\reviewer.py:_is_generated_html:2126c18d8506d25d53abbe31a46bac7e4766dfe82c424420aaa171b27d0122c5:a4544b4407820d7954654c77febb1e28054ed953d287ef74d60d55564624745e": "Function `_is_generated_html` checks if a given string `text` appears to be output from DocGen-LM, a tool for generating static HTML documentation. It returns `True` if the text contains specific markers indicating it was produced by DocGen-LM, such as \"Generated by DocGen-LM\", an `<h1>` heading with the title \"Project Documentation\", headings for classes and methods (e.g., `<h2>Class:` and `<h3>Method:`), or any other patterns that match typical output from the tool.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\reviewer.py:check_assistant_phrasing:49ff1729c18d7a37fbd15649127aef5146ad5bb50338567d69aa44bbbd2022ac:cd9c7dcd28070558c6f41acec412aa78b3e739fb6c34a37be07fedec09cac867": "The function `check_assistant_phrasing` takes an HTML string as input and returns a list of phrases that appear to be assistant-like. It extracts paragraphs from the HTML, strips out any HTML tags, converts the text to lowercase, and checks if any predefined assistant phrases are present. If a match is found, it appends the phrase along with its line number in the original HTML to the findings list.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\reviewer.py:check_contradictions:5d6d0422b5f3d1246bb4972afbddc87e44583bef1c2bdfa17319d0656890ea5e:5c0ff3fad6e4312918d61688eb73d60b86866c44781959aeb6bdd133498feb03": "The `check_contradictions` function analyzes HTML content to identify contradictions between the text and the structure of the document. It extracts paragraphs, methods, functions, and classes from the HTML. If the summary states there are no methods but actual method headers are found, it adds a contradiction description to the list. Similarly, if the summary claims there are no functions or classes but these elements are present in the HTML, corresponding contradictions are also identified and added to the findings list. The function returns a list of contradiction descriptions.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\reviewer.py:check_hallucinations:990344f6931012457c7fe172edd248f08a3d3f4b3d6e8a6d005a2387440fad4d:cbb513d54bf725b3378b7368212e1ea100dfeaa772a4797ac5a11ff106de525b": "Function `check_hallucinations` takes an HTML string as input and returns a list of hallucination phrases detected within the HTML. It extracts paragraph tags (`<p>`) from the HTML, strips any HTML tags from the extracted text, converts it to lowercase, and then checks if any predefined hallucination terms are present in the text. If a term is found, it is added to the list of findings, which is returned at the end of the function.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\scanner.py:_is_subpath:5f233f370ff26c2df0406491e45176143d3df28391cdcfa7a15f56870ae0e83b:cd4abce83e2437bd2cff4b3e6a5bb751f788e423ebfdd771e2b8745e51654866": "This function checks if one directory (`path`) is a subdirectory of another directory (`parent`). It returns `True` if `path` is either equal to or inside `parent`, and `False` otherwise. The check is performed using the `relative_to` method, which raises a `ValueError` if `path` is not a subdirectory of `parent`.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\scanner.py:scan_directory:61bc50e2ed2d40218b12296dd9f9cd2843d890ab2ba9760d065e237c5ac18745:15a3652a23dcce3da26e749b314d15a7e1a0d88a5619afef5f3dd6fada53bb85": "The `scan_directory` function recursively discovers source files with extensions `.py`, `.m`, `.cpp`, `.h`, and `.java` under a specified base directory. It skips directories and files listed in the ignore list. If progress is enabled, it displays a progress bar during the scan. The function returns a sorted list of absolute paths to the discovered source files.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\summarize_utils.py:summarize_chunked:69af92fffd1fe0e8f423172c82f2646a961cc18dabd5e8fa79e25bd3da0c18a3:b7e6e2d53844ad6971eb9cc9932a7466eb404bf329902ff93e31328cd17ec920": "The function `summarize_chunked` is designed to summarize a given text by chunking it if necessary. It uses an LLM client, a response cache, and various parameters such as key prefix, text, prompt type, system prompt, maximum context tokens, and chunk token budget.\n\n1. **Initialization**: The function initializes a tokenizer and sets the maximum context tokens and chunk token budget to their minimum values between the provided limits and a predefined `MAX_CHUNK_TOKENS`.\n\n2. **Template Selection**: It selects a template based on the prompt type or defaults to \"module\" if the prompt type is not found.\n\n3. **Overhead Tokens Calculation**: The function calculates the overhead tokens required for the system prompt and the template, ensuring that there are enough available tokens for processing.\n\n4. **Text Chunking**: If the text length exceeds the available tokens, it attempts to chunk the text into manageable parts using the `chunk_text` function. If chunking fails, it logs a warning and proceeds with summarizing the entire text.\n\n5. **Partial Summaries**: For each chunk, the function generates a partial summary using the `_summarize` function and stores these summaries in a list.\n\n6. **Combining Summaries**: The function combines the partial",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:__init__:0affefc769bcac347cad8308b90145fb99dd5b3f7caecb46578af67ed40e1fd8:8787c344575c5f8392011ea01e7d673f397965e4cd17c3569f45e91c655f0576": "The `__init__` method initializes a new instance of the `Dummy` class. It sets up an empty list named `calls`, which is intended to store dictionaries representing function calls made through instances of this class. Each dictionary in the list could contain parameters and other relevant information about each call, facilitating later summarization or analysis.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:__init__:801753a318f948d2c0c5a129350d34e805f370071107561176046d8267f2e317:1b8c71f556c37ef6a666615a872d6c28779c0ff3a2897afb029d3d539e2688dc": "The `__init__` method initializes a new instance of the `Dummy` class. It sets up an empty list named `calls`, which is intended to store dictionaries representing function calls made during operations of this instance. This list facilitates tracking and summarization of these calls for documentation purposes.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:__init__:a9a47428ccb632dd365aa1414bdbc163f9a040577743ec0473539eae3eee38ef:f9e800644dc2063012c153b16256e58d4d4d45936d431414abc7df0166b5e842": "The `__init__` method initializes a new instance of the `Dummy` class. It sets up an empty list named `calls`, which is intended to store dictionaries representing call details. This list will be used to accumulate information about function calls made during the execution of code that utilizes instances of this class.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:__init__:d196f216ababb3be5854614cba967290d2a40aed2f1b65a1d0fd9f15e49868ad:9a1edd56e9f3e37d38cc278bc8fff18875c5bbf3ebf6415885fbbdfcc0a9290a": "The `__init__` method initializes an instance of the `Dummy` class. It sets up an empty list named `calls` to store strings representing function calls or other relevant data as the class processes code.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:__init__:efec72a4cbaa08c8a89f611f3bbb4e16d206a3ce517f5f2764a7533fa02b0151:045aca0284b74ae8f738ae2ca3574850575acd8bdc3dc26206503e29306954eb": "The `__init__` method initializes a new instance of the `Dummy` class. It sets up an empty list named `calls` to store dictionaries, where each dictionary represents a call with relevant information. This list will be used to collect and manage calls made during the object's lifecycle, facilitating potential summarization or analysis based on these collected calls.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:summarize:05cbb27eea63f4ad0aaca3c8aec8597c812253bc8abc9bcf9976501445dcb0c2:5a2e5a0b4247241536bee81dc41c7f7b3aaf0e65ba066afff82e74e0dce600e8": "The `summarize` method in the `Stub` class takes a prompt, its type, and an optional system prompt as parameters. It returns the string `\"guessed\"`. This method is part of a larger tool for generating static HTML documentation for Python, MATLAB, C++, and Java projects by analyzing source files with a local LLM.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:summarize:11438b60a0cf95df3863a9a685f7485621ea96868e01d719d9c50b29cedf7aa6:78598614f3de17d4597e9a5f3f7992e53f584b012fce034088463f064e4c3c1f": "The `summarize` method in the `Dummy` class processes input text based on a system prompt. It checks if the system prompt contains specific phrases and returns modified text accordingly:\n\n1. If the system prompt includes \"How to Run,\" it returns \"[[NEEDS_RUN_INSTRUCTIONS]]\".\n2. If the system prompt mentions \"enhancing a user manual,\" it searches for the section labeled \"Manual\" in the input text, extracts its content, and replaces any occurrences of \"[[NEEDS_RUN_INSTRUCTIONS]]\" with \"use it\". If no such section is found, it returns \"x\".",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:summarize:145e18e41740cdf5c92e49b1e0f526bbf4a434966c7ca91c5faf0f19813532e9:7b843a0be9e9e196a6cef00853d8f00d144abaa7f133ca77ecbedaf7f3923a5c": "The `summarize` method in the `SlowClient` class processes input text with an optional system prompt. If the provided system prompt matches a specific value (`explaincode.CHUNK_SYSTEM_PROMPT`), it introduces a delay using `time.sleep(delay)`. Regardless of the prompt, the method returns a simple confirmation message \"ok\".",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:summarize:2e70dee6adbc0c3019b1c1348161481c99c04500421f3444496f7fc046d356ce:8ac536d9420758b6cdc299b49d3a531761800748509f909507e97022184a867f": "The `summarize` method in the `Dummy` class processes input text to extract and replace placeholders based on predefined section types. It appends the input text to a list of calls, searches for sections within the text using regular expressions, retrieves the corresponding placeholder token from a dictionary, and replaces the token with a formatted string indicating that the section has been filled.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:summarize:38e47e7fbb3ac872cb3c1c079e94e45eff0f498d50ca692e643ed16ca8bbf31e:aca02929deddc3d368ca0ed4faeb88b25bc060e10575a45424374c30895df559": "The `summarize` method in the `Dummy` class is designed to store call details. It takes three parameters: `text`, `prompt_type`, and an optional `system_prompt`. The method appends a dictionary containing these parameters to a list named `calls` and returns the string \"done\".",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:summarize:59c9f7bffb059a872984183a2b91c23c7b579836a5955e938b8f9a7537473431:b862398f48e8f432345993f574535b8c25f9efa11e2c7bb2ca2a8f5583f43b26": "The `summarize` method in the `Dummy` class takes three parameters: `text`, `prompt_type`, and an optional `system_prompt`. It returns a formatted string with an overview section followed by \"NEEDS_RUN_INSTRUCTIONS\".",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:summarize:7801d8def9aa28ffc09d2e18b0b0dd0c496c7b9ec6b5201f2e0e69c42d577ad7:7b8bad3ae0c6129cef03f40dc3c6b2e01d34c65d5908d787760485f0fda614a4": "The `summarize` method in the `Dummy` class is designed to process input text and generate a summary or a specific string based on the provided prompt type and system prompt. It appends call information, including the text, prompt type, and system prompt, to a list called `calls`. If the system prompt matches `explaincode.MERGE_SYSTEM_PROMPT`, it returns the string \"final\". Otherwise, it returns the first word of the input text.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:summarize:a2dafcb3a235dfe71d462983c542465b094721cfec1a8ecec1170bd569d9361f:fcec7b49bd487fec342e3420fadc532dc409ae6420afa8d9b3d5ea0f73f8afe8": "The `summarize` method in the `Dummy` class generates a formatted string summarizing various aspects of code, including its overview, purpose, problem-solving approach, running instructions, inputs, outputs, system requirements, and examples. The method takes three parameters: `text`, `prompt_type`, and an optional `system_prompt`. It returns a string with predefined sections for documentation purposes.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:summarize:b42094bafeb9974fb1ccdb0d6ca8874ddfa36db085d2b1345691d4fda969eb2c:00907af939995db884ccc52507643bd148a2c6aebda811a5a1fda4eac046c8ad": "The `summarize` method in the `Dummy` class is designed to append call details to an internal list and return either \"big\" or \"short\" based on the length of the list. It takes three parameters: `text`, `prompt_type`, and an optional `system_prompt`. The method appends a dictionary containing these parameters to the `calls` list. If the length of `calls` is less than or equal to 2, it returns \"big\"; otherwise, it returns \"short\".",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:summarize:e70936b7b342c7571e98f63d26664a213db77bd18fe1eaa6a465a24075b34e18:5275fc2e85fb17b241277dd09ef5fcdf487f154605d0d2aedf78b51dd5193334": "The `summarize` method in the `Dummy` class is designed to store a dictionary of call details and return a response string. It takes three parameters: `text`, `prompt_type`, and an optional `system_prompt`. The method appends a dictionary containing these parameters to a list named `calls`. It then returns a formatted string that includes the word \"resp\" followed by the number of calls currently stored in the `calls` list.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_llm_client.py:test_sanitize_summary_removes_fim_tokens:335d6be21fd4fa76b665f548e33039c48204bd8cbd236a520a7b1a63d5bcd837:a2a632bef9d82f288d305b2bae9cc8ac43eb2d6ea3b8a56c298d153c5c5bd1a8": "A function that sanitizes a summary by removing FIM reserved tokens.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_llm_client.py:test_summarize_does_not_stream_on_http_error:87844c17a018e25f91f3b13f5f9ea3535f1b47eed81102a160155e3a59c98ebd:9d73707b773dae1a7564c5b812de70b058807acf93c9cc3e150c66fb2b8ea78d": "The function `test_summarize_does_not_stream_on_http_error` tests the behavior of the `summarize` method in the `LLMClient` class when an HTTP error occurs. It sets up a mock `requests.post` response that raises an `HTTPError` and does not return any content. The function asserts that streaming should not be attempted, as indicated by the absence of calls to `mock_response.iter_content`.",
  "__progress__": {}
}