{
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\cache.py:2e37ab4b52e9489ed2b2dc8e686dc29df25416d04f5b423c47ba2cc9aecf698c:2e37ab4b52e9489ed2b2dc8e686dc29df25416d04f5b423c47ba2cc9aecf698c": "A simple on-disk cache for LLM responses. Implements methods to initialize the cache from a file, generate deterministic keys based on file paths and content, retrieve cached values by key, store new values with associated keys, and persist the cache to disk in JSON format.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\cache.py:ResponseCache:__init__:919483e1ff4b05cae685fcac27aa9458bc309d42dd717af59b0942962ccdf4e4:919483e1ff4b05cae685fcac27aa9458bc309d42dd717af59b0942962ccdf4e4": "Initializes an object with a file path. If the file exists, reads and parses it as JSON; if not, initializes an empty dictionary.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\cache.py:ResponseCache:_save:d6c96e0258c810e9fec48856af580533cfc0aa8f13ea666bb1d396aa4abe5e41:d6c96e0258c810e9fec48856af580533cfc0aa8f13ea666bb1d396aa4abe5e41": "Saves data to a file using JSON format with indentation and sorted keys.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\cache.py:ResponseCache:aa00a774dc08193e02f365ac53be6fd337b9ddd5da163e180e2c5720c8aeb190:aa00a774dc08193e02f365ac53be6fd337b9ddd5da163e180e2c5720c8aeb190": "The `ResponseCache` class manages a cache for storing and retrieving parsed documentation data from source files using JSON format. It provides methods for initializing the cache, generating unique keys based on file content, retrieving cached data, setting new data with persistence, and saving the cache to disk. This class is integral to a larger system that generates static HTML documentation for various programming languages by analyzing source files with an LLM client.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\cache.py:ResponseCache:get:eeb84b4591575a8ed2767f4abac56f1f2dd0697e81322599734b8b31e94ddcce:eeb84b4591575a8ed2767f4abac56f1f2dd0697e81322599734b8b31e94ddcce": "Returns the cached value associated with a given key if it exists in the cache. If the key is not found, returns None.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\cache.py:ResponseCache:make_key:4f63c9f618b20a79035ed49cae07b9b800a46f352498e23dc8700f47c38fe96d:4f63c9f618b20a79035ed49cae07b9b800a46f352498e23dc8700f47c38fe96d": "Function `make_key` takes two parameters: `file_path` (a string representing the path to a file) and `content` (a string representing the content of the file). It returns a deterministic key by hashing the content using SHA-256 and appending the file path to the hash digest.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\cache.py:ResponseCache:set:0bc8af7637662ae14e3eca8604a4d7155ff442d423955a243d6b586ffee8d8ba:0bc8af7637662ae14e3eca8604a4d7155ff442d423955a243d6b586ffee8d8ba": "The function `set` takes a string `key` and a string `value` as arguments. It stores the `value` associated with the `key` in an internal data structure `_data`. After storing the value, it calls another method `_save()` to persist the changes to disk.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\chunk_utils.py:6c5fb52965b9c830534a1a0e867741ffe867c9e43e8bfc85e5073585b38f3c88:6c5fb52965b9c830534a1a0e867741ffe867c9e43e8bfc85e5073585b38f3c88": "This module provides utility functions for tokenization and text chunking. The `chunk_text` function splits text into chunks roughly of a specified size in tokens, preferring natural break points like blank lines, Markdown headings, and fenced code blocks. If a single block exceeds the token limit, it falls back to splitting by approximate character length. The `get_tokenizer` function returns a tokenizer object for estimating token counts, using `tiktoken` if available or falling back to a simple word-based tokenizer.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\chunk_utils.py:_split_blocks:cf5246df1cecd53cc656d80bc1d3f9c3626b33c4bda14e54fe4ff2d3d4ed5774:cf5246df1cecd53cc656d80bc1d3f9c3626b33c4bda14e54fe4ff2d3d4ed5774": "The function `_split_blocks` takes a string of Markdown text as input and returns a list of paragraphs, headings, and code blocks. It processes the text line by line, identifying and separating these elements based on specific markers: paragraph breaks (empty lines), heading indicators (`#` at the beginning of a line), and code block delimiters (triple backticks ````). The function handles opening and closing of code blocks, ensuring that they are not split into multiple blocks. It also strips leading and trailing whitespace from each block before returning them as a list.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\chunk_utils.py:_split_long_block:f5bfa16b7fe7f98d6217a523e276d6afccd462670098dd97a0691b1614108ee0:f5bfa16b7fe7f98d6217a523e276d6afccd462670098dd97a0691b1614108ee0": "This function `_split_long_block` takes a string `block`, a tokenizer, and an integer `chunk_size_tokens`. It encodes the block into tokens using the provided tokenizer. If the number of tokens is less than or equal to `chunk_size_tokens`, it returns the original block as a single element list. Otherwise, it calculates an average character length per token and determines a maximum number of characters for each chunk based on this average and `chunk_size_tokens`. The function then splits the block into chunks of approximately `max_chars` characters and returns these chunks as a list.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\chunk_utils.py:chunk_text:aa8145842163e4f6d0c78cc08169030ab095583e475e0f17825143e62330be9b:aa8145842163e4f6d0c78cc08169030ab095583e475e0f17825143e62330be9b": "The `chunk_text` function splits a given text into chunks of approximately `chunk_size_tokens` each. It uses a tokenizer to determine the number of tokens in each block, ensuring that natural break points like blank lines and Markdown headings are respected. If a single block exceeds the token limit, it is split by character length. The function returns a list of these chunks.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\chunk_utils.py:get_tokenizer:6ab83396f03abcfa943a43532d1f002a2f80f86fa6e6661a68244410d655f66f:6ab83396f03abcfa943a43532d1f002a2f80f86fa6e6661a68244410d655f66f": "The `get_tokenizer` function returns a tokenizer object used for estimating token counts. It first attempts to import and use the `tiktoken` library with the \"cl100k_base\" encoding. If this fails, it tries to use the \"gpt-3.5-turbo\" model instead. If both fail, it prints a warning message and returns a simple tokenizer class that splits text into tokens by whitespace and joins them back together.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\docgenerator.py:5e2744d1f2ac7a61423513824837db56e681496c72ef7a51e176af794aa86bb5:merge0:a255bb02b329b8b3bda18686186f8cdaab3f23e2f4543e4cc02558b1151d8fcf": "This module provides a command-line interface for generating HTML documentation using DocGen-LM. It scans a source tree for Python, MATLAB, C++, and Java files, parses them, requests summaries from a running LLM, and writes the documentation. The module includes functions for cleaning output directories, summarizing text with caching, chunking modules by structure, summarizing modules in a structured manner, building context-enriched prompts, rewriting docstrings, and recursively summarizing members of classes and their subclasses. It defines a Python script that processes directories, ignores specified paths, handles file encoding errors, and uses command-line arguments for configuration, such as the source directory, output directory, ignored paths, LLM URL, model name, and token budget. The script reads files, parses them into structured data, generates summaries using the LLM, and writes HTML documentation pages.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\docgenerator.py:5e2744d1f2ac7a61423513824837db56e681496c72ef7a51e176af794aa86bb5:part0:1c64143af786e8eb7be2acf707b8ef199e58dfcecb6905425f9691140ba88e1e": "This module provides a command-line interface for generating HTML documentation using DocGen-LM. It scans a source tree for Python, MATLAB, C++, and Java files, parses them, requests summaries from a running LLM, and writes the documentation.\n\nThe module includes functions for:\n- Cleaning output directories to remove previously generated HTML files.\n- Summarizing text using an LLM client with caching.\n- Chunking modules by structure to handle large codebases.\n- Summarizing modules in a structured manner.\n- Building context-enriched prompts for summarization.\n- Rewriting docstrings using optional contextual information.\n- Recursively summarizing members of classes and their subclasses.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\docgenerator.py:5e2744d1f2ac7a61423513824837db56e681496c72ef7a51e176af794aa86bb5:part1:284b2291cfd40a154724990d41794b767883b7609fbc43b076b0d336f6843137": "The code defines a Python script that generates HTML documentation using a local language model (LLM). It includes functions to recursively summarize classes and methods, rewrite docstrings, and handle different programming languages like Python, C++, Java, and MATLAB. The script also processes directories, ignores specified paths, and handles file encoding errors. It uses command-line arguments for configuration, such as the source directory, output directory, ignored paths, LLM URL, model name, and token budget. The script reads files, parses them into structured data, generates summaries using the LLM, and writes HTML documentation pages.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\docgenerator.py:_build_function_prompt:0ffd0a4d7f7aac54fe4e6fa49e81d66f1b7c71fa4ee7b12010a22713561a8b82:0ffd0a4d7f7aac54fe4e6fa49e81d66f1b7c71fa4ee7b12010a22713561a8b82": "The function `_build_function_prompt` constructs a prompt for summarizing Python source code. It takes four parameters: `source`, `class_name`, `class_summary`, and `project_summary`. The function returns a string that includes the provided context (class name, class summary, project summary) along with instructions on how to summarize the function based on its source code.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\docgenerator.py:_chunk_module_by_structure:a510bec1cf237f142b1a9158ad57e13c68e98e68e26bd6652d5b87c0164b9ade:a510bec1cf237f142b1a9158ad57e13c68e98e68e26bd6652d5b87c0164b9ade": "This function `_chunk_module_by_structure` takes a dictionary representing a module, a tokenizer object, and an integer `chunk_size_tokens`. It processes the module's structure to create text chunks that do not exceed the specified token size. The function first extracts the module documentation if available. Then, it iterates through classes, methods, variables, and functions within the module, adding their source code to blocks. If a block exceeds the token limit, it is further chunked using another function `chunk_text`. Finally, it combines these blocks into chunks that fit within the token size limit, ensuring that each chunk is separated by two newline characters for readability.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\docgenerator.py:_rewrite_docstring:f6c786829cc583b3f253f88d0522d655be9dd7148dfbd820f60b276375381fd6:f6c786829cc583b3f253f88d0522d655be9dd7148dfbd820f60b276375381fd6": "This function `_rewrite_docstring` is designed to rewrite the docstring of a code item using an LLM client. It takes several parameters including an LLM client, a cache for responses, the file path, and details about the item such as its source code and name. The function checks if there is source code or a docstring available; if not, it prints a warning and returns. If a docstring exists, it constructs a prompt based on the provided context (class name, class summary, project summary) or uses a default prompt format. It then generates a key for caching purposes and calls `_summarize_chunked` to generate a new docstring using the LLM client. The resulting summary is sanitized and stored back in the item dictionary under the \"docstring\" key. If no summary can be generated, it defaults to \"No summary available.\"",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\docgenerator.py:_summarize:bbbb1e0cb1cb5744ec4033744098c4f390d3b3513f0a8e0f8752ef7971ed8a57:bbbb1e0cb1cb5744ec4033744098c4f390d3b3513f0a8e0f8752ef7971ed8a57": "The `_summarize` function takes an `LLMClient`, a `ResponseCache`, a `key`, a `text`, and a `prompt_type`. It first checks if the summary for the given key is already cached. If it is, it returns the cached summary. Otherwise, it uses the LLM client to generate a summary of the provided text based on the prompt type. The generated summary is then stored in the cache under the specified key and returned.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\docgenerator.py:_summarize_class_recursive:ab2ae4e790286e5cf76ff0fe7fa65f0c3f8c23cf3709962ba386ee7d63c58e51:ab2ae4e790286e5cf76ff0fe7fa65f0c3f8c23cf3709962ba386ee7d63c58e51": "This function `_summarize_class_recursive` recursively summarizes a class and its members by generating summaries for methods, variables, and subclasses. It uses an LLM client to interact with a language model for text generation, caches responses to improve performance, and sanitizes the generated summaries. The function updates the original class data with new summaries and rewrites docstrings where necessary.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\docgenerator.py:_summarize_members_recursive:a546eceda68419375e86bbac85a638f868fc1072a0f35d0acb18d442c1fea139:a546eceda68419375e86bbac85a638f868fc1072a0f35d0acb18d442c1fea139": "The function `_summarize_members_recursive` is designed to recursively summarize the methods and variables of a class, as well as any subclasses. It takes several parameters including `class_data`, which contains information about the class and its members; `path`, which represents the path to the source file; `client`, an LLM client for text generation; `cache`, a caching mechanism to store summaries; `tokenizer`, likely used for tokenization; and `max_context_tokens` and `chunk_token_budget` for managing text length.\n\nThe function iterates over methods and variables in `class_data`, summarizing each using the `_summarize_chunked` function. It then assigns these summaries back to the respective method or variable objects within `class_data`. For subclasses, it recursively calls itself to ensure all members of the subclass hierarchy are summarized. This approach ensures that the documentation is comprehensive and covers all levels of nested classes and methods.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\docgenerator.py:_summarize_module_chunked:34bfe851eb79dc11aa53648b3a306fd0e59471d232192b3e7bcfbe65b9a76546:34bfe851eb79dc11aa53648b3a306fd0e59471d232192b3e7bcfbe65b9a76546": "This function `_summarize_module_chunked` is designed to summarize a Python module using structure-aware chunking. It takes several parameters including an LLM client, response cache, key prefix, module text, module dictionary, tokenizer, maximum context tokens, and chunk token budget.\n\nThe function first calculates the available tokens for summarization after accounting for overhead from system prompt and template encoding. If the module text can fit within these available tokens, it proceeds to summarize directly using another internal function `_summarize`.\n\nIf the module text is too large, the function attempts to structure-awarely chunk the module into smaller parts based on its structure. Each part is then summarized individually. If structure-based chunking fails, it falls back to summarizing the entire module text.\n\nAfter obtaining summaries for all chunks, the function combines these summaries into a single technical paragraph using another internal function `_merge_recursive`. This recursive merging ensures that the combined summary does not exceed the available tokens by breaking down larger parts if necessary. If merging fails, it returns a sanitized version of the partial summaries.\n\nThe final result is a summarized technical paragraph representing the module, which is then sanitized before being returned.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\docgenerator.py:clean_output_dir:2516c2ddd9b028326fe47549a22233ca301c7615f4edac89fd64e0282210ce39:2516c2ddd9b028326fe47549a22233ca301c7615f4edac89fd64e0282210ce39": "The function `clean_output_dir` takes a directory path (`output_dir`) as input and iterates through all files in that directory. If a file is an HTML file (ends with \".html\"), it reads the first line of the file. If the first line contains \"Generated by DocGen-LM\", the file is deleted. Any exceptions during file operations are caught, and a warning message is printed indicating which file could not be checked or removed.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\docgenerator.py:main:288c1a1c4e2964a84c80ce07e61c0b7d3c2ff5a31ae6a24b0819977168ec1bc4:288c1a1c4e2964a84c80ce07e61c0b7d3c2ff5a31ae6a24b0819977168ec1bc4": "The `main` function serves as the entry point for generating HTML documentation from source files. It parses command-line arguments to configure settings such as the source directory, output directory, ignored paths, and LLM client details. The function initializes an LLM client, sets up a tokenizer, and creates necessary directories for the output.\n\nIt then scans the source directory for relevant files (Python, C++, Java, MATLAB) and parses them into structured data using language-specific parsing functions. For each file, it generates summaries of modules, classes, and functions by interacting with an LLM client. The summaries are cached to improve performance.\n\nAfter processing all files, the function constructs a project outline and gathers markdown documentation from README and docs directories. It then summarizes the project structure and any additional markdown content using the LLM client.\n\nFinally, the function generates index and module pages for the documentation, incorporating the generated summaries and linking them appropriately. The function returns 0 to indicate successful execution.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:2316bec472994532a63a4ffe1b79089830475b1615c7f13efb5582fbb3629a2f:merge0:0cb24f2edda104c0e61bf0a24b998408791c9f8c12b4a266ca87f3c7c767a939": "This module provides comprehensive functionality for generating project summaries from existing documentation and sample files. It includes classes, functions, and utilities for parsing configuration from CLI arguments, collecting documentation and code files based on specified patterns, generating slugs for filenames, inserting navigation entries into an index file, extracting plain text from various file types, detecting placeholders in text, mapping documentation snippets to manual sections, and ranking code files by heuristics. The module defines functions to extract relevant code snippets from files, categorize them by sections, and generate a manual using an LLM client. It includes:\n\n1. `extract_snippets`: Extracts code snippets from given files based on file size, time budget, and specific conditions.\n2. `scan_code`: Collects source code snippets from a base directory grouped by manual sections.\n3. `llm_generate_manual`: Generates a manual from documentation snippets using an LLM client, mapping snippets to manual sections and assembling the final text.\n4. `llm_fill_placeholders`: Fills placeholder tokens in a manual text using provided code snippets.\n5. `_edit_chunks_in_editor`: Opens chunks of text in the user's editor for optional modification.\n\nThese functions facilitate automated documentation generation and manual creation from source code, leveraging LLMs for content synthesis. The module also provides utilities to render HTML from structured sections of a manual, parse plain text into structured sections, validate references within sections, infer missing sections, and write HTML content as a PDF. It includes utilities for slugifying text, escaping HTML, and handling Markdown conversion. The module manages evidence snippets and missing references, ensuring that the rendered HTML reflects extracted documentation accurately.\n\nThe module defines a `main` function that sets up command-line arguments to configure project documentation summarization. It uses the `argparse` library to parse these arguments and create a `Config` object with the provided settings. The main function collects documentation files, reads their contents, and initializes logging based on the chunking mode. It creates an instance of an `LLMClient` for language model-based summarization and a `ResponseCache` for caching responses.\n\nThe main process involves two passes: the first to generate an initial manual summary using the language model, and the second to fill in any missing sections with code snippets if specified. The function handles exceptions during the LLM summarization process, falling back to manual section inference if necessary. Finally, it renders the HTML or PDF output based on the selected format, injects a link to the generated manual into an index file if requested, and saves evidence data for later reference.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:2316bec472994532a63a4ffe1b79089830475b1615c7f13efb5582fbb3629a2f:part0:cad03170c79ae4f0d1d2f36c57f3909c62a26464f20a175abadc08436cee8417": "This module provides functionality to generate a project summary from existing documentation and sample files. It includes classes, functions, and utilities for:\n\n- Parsing configuration from CLI arguments.\n- Collecting documentation and code files based on specified patterns.\n- Generating slugs for filenames.\n- Inserting navigation entries into an index file.\n- Extracting plain text from various file types.\n- Detecting placeholders in text.\n- Mapping documentation snippets to manual sections.\n- Ranking code files by heuristics.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:2316bec472994532a63a4ffe1b79089830475b1615c7f13efb5582fbb3629a2f:part1:a43cf959c49329fc55010ef118243e83a7285b55bcb50895e6ee163ece28ad9f": "The module defines functions to extract relevant code snippets from files, categorize them by sections, and generate a manual using an LLM client. It includes:\n\n1. `extract_snippets`: Extracts code snippets from given files based on file size, time budget, and specific conditions.\n2. `scan_code`: Collects source code snippets from a base directory grouped by manual sections.\n3. `llm_generate_manual`: Generates a manual from documentation snippets using an LLM client, mapping snippets to manual sections and assembling the final text.\n4. `llm_fill_placeholders`: Fills placeholder tokens in a manual text using provided code snippets.\n5. `_edit_chunks_in_editor`: Opens chunks of text in the user's editor for optional modification.\n\nThese functions facilitate automated documentation generation and manual creation from source code, leveraging LLMs for content synthesis.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:2316bec472994532a63a4ffe1b79089830475b1615c7f13efb5582fbb3629a2f:part2:728ef003d9b9cf619f2797bd3f130e29e504e38c3a5e8a9633d300640b8df8a4": "The module provides functions to render HTML from structured sections of a manual, parse plain text into structured sections, validate references within sections, infer missing sections, and write HTML content as a PDF. It includes utilities for slugifying text, escaping HTML, and handling Markdown conversion. The module also manages evidence snippets and missing references, ensuring that the rendered HTML reflects extracted documentation accurately.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:2316bec472994532a63a4ffe1b79089830475b1615c7f13efb5582fbb3629a2f:part3:a9277aadc6312b031707b1eddb8a882d73e638ba5c39005838093b1f6829288b": "The module defines a `main` function that sets up command-line arguments to configure project documentation summarization. It uses the `argparse` library to parse these arguments and create a `Config` object with the provided settings.\n\nThe function then collects documentation files, reads their contents, and initializes logging based on the chunking mode. It creates an instance of an `LLMClient` for language model-based summarization and a `ResponseCache` for caching responses.\n\nThe main process involves two passes: the first to generate an initial manual summary using the language model, and the second to fill in any missing sections with code snippets if specified. The function handles exceptions during the LLM summarization process, falling back to manual section inference if necessary.\n\nFinally, it renders the HTML or PDF output based on the selected format, injects a link to the generated manual into an index file if requested, and saves evidence data for later reference.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:Config:379108716b1445bc77fb98976ce16de349018c3a870b5d856dc3f9b1298d1e26:379108716b1445bc77fb98976ce16de349018c3a870b5d856dc3f9b1298d1e26": "The `Config` class in the DocGen-LM project is designed to handle configuration settings for generating static HTML documentation from source files in Python, MATLAB, C++, and Java. It facilitates the parsing of different file types, summarization of code and documentation, and interaction with an LLM client for text generation, ultimately providing a detailed and organized overview of complex project structures.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:_edit_chunks_in_editor:8106ad44c916b12bcbd165fb479b70683bc30895bdf50f63a6e6deae4e98b96d:8106ad44c916b12bcbd165fb479b70683bc30895bdf50f63a6e6deae4e98b96d": "The function `_edit_chunks_in_editor` takes a list of code chunks as input, joins them with a separator, writes the result to a temporary file, opens the file in the user's default editor, and then reads back the edited content. It discards any empty chunks after editing and returns the modified chunks.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:collect_docs:774bded624fe48a765a342e47c13de5667d2bbf3566001770679d37d5d7d6ee5:774bded624fe48a765a342e47c13de5667d2bbf3566001770679d37d5d7d6ee5": "The `collect_docs` function takes a directory path (`base`) as input and returns a list of paths to documentation files found within that directory. It includes both project root files and those located in a subdirectory named \"docs\". The function filters for specific file extensions such as `.md`, `.txt`, `.html`, and `.docx`. It also ensures that only unique files are returned by using a set to track seen files.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:collect_files:54b5df3ca2191b5aaebb39341ea7e09be7ac91d8041dd7525d5e244b5f5c0da9:54b5df3ca2191b5aaebb39341ea7e09be7ac91d8041dd7525d5e244b5f5c0da9": "This function `collect_files` takes a base directory path (`base`) and an optional iterable of additional file patterns (`extra_patterns`). It returns an iterable of paths to files relevant for summarization. The function starts with a list of default file patterns, searches the base directory recursively using these patterns, and then adds any extra patterns provided. It ensures that only unique files are returned by maintaining a set of seen files and filtering out duplicates.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:detect_placeholders:1cc20660f5c4a6417a390bb8598fecb1b0c480dad86b6a95c088c6959f6b148e:1cc20660f5c4a6417a390bb8598fecb1b0c480dad86b6a95c088c6959f6b148e": "The function `detect_placeholders` takes a string `text` as input and returns a list of section names that are still marked by placeholder tokens. It uses the helper function `find_placeholders` to identify all placeholder tokens in the text, then filters this list to include only those tokens associated with section names defined in the `SECTION_PLACEHOLDERS` dictionary.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:extract_snippets:30aae82db5a0024b0613f60e8b1c92ba48eec7a772a241180011dbf05dba994e:30aae82db5a0024b0613f60e8b1c92ba48eec7a772a241180011dbf05dba994e": "The function `extract_snippets` is designed to extract relevant code snippets from a list of files. It processes each file based on its type and extracts documentation strings for classes, functions, and methods, as well as CLI parser definitions and the main execution block if present. The function includes checks to limit the number of files processed, time spent processing, and file size. It logs information about each file it considers or skips during processing.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:extract_text:3c0771bfc6bebb1ff55558b11b955281b3cd62a71d4af0143b6c558b5d285e06:3c0771bfc6bebb1ff55558b11b955281b3cd62a71d4af0143b6c558b5d285e06": "The function `extract_text` reads the content of a file located at the given `path` and extracts plain text based on the file's extension. It handles different file types such as HTML, Markdown, and DOCX. For HTML files, it removes headings and preformatted code blocks, converting them into markdown syntax. For Markdown files, it simply returns the content as is. For DOCX files, if the `Document` class from the `python-docx` library is available, it extracts text, converting heading styles into markdown headers. If any exceptions occur during processing, an empty string is returned.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:infer_sections:924b1cdb815ca67acc9c432c51086d612c482c610f86eb85ee0482a16a6a70ed:924b1cdb815ca67acc9c432c51086d612c482c610f86eb85ee0482a16a6a70ed": "The function `infer_sections` takes a string `text` as input and returns a dictionary of code documentation sections. If the input text is non-empty, it places the entire text under an \"Overview\" section and generates placeholder content for other required sections labeled \"(inferred)\". If the input text is empty, it initializes all required sections with a default message indicating no information is available. The function uses a set `REQUIRED_SECTIONS` to define which sections are included in the output dictionary.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:inject_user_manual:985f1f50921ed95ee4e595d8ef22775df054ffcc65ee038443e3055079df29e9:985f1f50921ed95ee4e595d8ef22775df054ffcc65ee038443e3055079df29e9": "The function `inject_user_manual` inserts a top-level link to a user manual into an HTML file specified by `index_path`. It uses the BeautifulSoup library to parse the HTML content. The link is added to the first navigation element (`<nav>`) or `<ul>` if present; otherwise, it is inserted at the start of the first element in `<body>` or directly into the document root.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:insert_into_index:f769af8452d0dcef7f797693dcdada9a93a900605d6346ecade5201d65341fd0:f769af8452d0dcef7f797693dcdada9a93a900605d6346ecade5201d65341fd0": "This function `insert_into_index` appends a navigation entry linking to a specified file into an HTML index file. It takes three parameters: the path to the index file (`index_path`), the title of the navigation entry (`title`), and the filename being linked (`filename`). The function reads the existing content of the index file, parses it using BeautifulSoup, and finds either an unordered list (`ul`) or a navigation element (`nav`). If such an element is found, it checks if the link already exists. If not, it creates a new anchor tag with the specified title and filename, wraps it in a list item if necessary, and appends it to the container. Finally, it writes the updated HTML content back to the index file.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:llm_fill_placeholders:ead2c291e37b71ef3b3611e729c28cc2d436ac5bf5268e7734bbf02d6b0c893c:ead2c291e37b71ef3b3611e729c28cc2d436ac5bf5268e7734bbf02d6b0c893c": "The function `llm_fill_placeholders` processes a manual text by filling placeholder tokens with relevant information extracted from code snippets. It uses an LLM client and a caching mechanism to handle long snippets efficiently. The process involves summarizing large code snippets if necessary, constructing prompts, and updating the manual text incrementally for each section.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:llm_generate_manual:383255020c40087d641b0fc40505325eb3c12db20ffbb38a42758376f4d7d66f:383255020c40087d641b0fc40505325eb3c12db20ffbb38a42758376f4d7d66f": "The function `llm_generate_manual` processes documentation snippets from source files to generate a user manual. It uses an LLM client to summarize the documentation and constructs the final manual text by mapping sections to their corresponding content. The function returns the generated manual text, a mapping of source files to the sections they contributed, and an evidence map capturing the snippets used for each section.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:main:d3a73b9327c2cc521c6114c7676262e93680d0ffb391b3c951083b4818d4c874:d3a73b9327c2cc521c6114c7676262e93680d0ffb391b3c951083b4818d4c874": "The `main` function serves as the entry point for the DocGen-LM tool. It parses command-line arguments to configure the documentation generation process, including the target project directory, output format, and various options for code scanning and manual generation. The function then sets up logging, initializes an LLM client, and proceeds through two passes of manual generation: the first pass using available documentation, followed by a second pass that may include code scanning if necessary to resolve placeholders. Finally, it renders the HTML or PDF output and optionally inserts a link to the generated manual into an index file. The function handles exceptions gracefully, falling back to manual inference if LLM summarization fails.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:map_evidence_to_sections:023eced64a67ec183d9893e1044c67238b6556c13f3f348e358e753932d6990b:023eced64a67ec183d9893e1044c67238b6556c13f3f348e358e753932d6990b": "The function `map_evidence_to_sections` processes a dictionary of documentation snippets indexed by file paths. It categorizes these snippets into sections based on predefined keywords and organizes them into two maps: one for each section and another linking files to the sections they contribute to. The function filters out snippets from excluded directories, ensures that only top 10 snippets per section are kept, and provides a priority sorting mechanism for \"Overview\" sections.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:parse_manual:e82440b0f7c248384827b9cc23fb1e6a8da9da44acabe7b4ffa508fdd6854bbf:e82440b0f7c248384827b9cc23fb1e6a8da9da44acabe7b4ffa508fdd6854bbf": "The function `parse_manual` parses text from a language model into structured sections. It splits the input on lines containing a colon (`Section: content`) and keeps the sections in order. If `infer_missing` is true, it infers absent required sections using an LLM client and marks them as `(inferred)`.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:rank_code_files:72af100be10aee123801a6fa70591926193bcaf673f58fea03ac1ec0876db121:72af100be10aee123801a6fa70591926193bcaf673f58fea03ac1ec0876db121": "The `rank_code_files` function ranks Python code files under a specified root directory based on certain heuristics. It supports file extensions for Python, MATLAB, Jupyter notebooks, C++, C++ headers, and Java. The ranking is determined by searching for specific keywords in the file paths and matching them against user-defined patterns. Higher scores are given to paths containing keywords like \"run\", \"main\", or \"cli\" and those that match user-provided patterns. The function skips certain directories typically found in version control systems or build environments. The result is a list of code files sorted by their rank, with higher-ranked files appearing first.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:render_html:a94b0522037852978ee91583649172970eb205c60c7c1d4fc8cc42fa450fec53:a94b0522037852978ee91583649172970eb205c60c7c1d4fc8cc42fa450fec53": "The `render_html` function generates HTML content for a documentation page based on provided sections, title, and an optional evidence map. It processes each section to create an anchor link in the navigation menu and renders the section's content as HTML. If the content is empty or lacks information, it uses snippets from the evidence map to populate the section. The function also includes styling for the HTML document and handles Markdown rendering if available.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:scan_code:bfaa48d7d5a5dd107b9449bb4cb1040e21d7e4c02ca0afe4a374573d2b2bf8b9:bfaa48d7d5a5dd107b9449bb4cb1040e21d7e4c02ca0afe4a374573d2b2bf8b9": "The `scan_code` function collects source code snippets from a specified directory (`base`) grouped by manual sections. It uses a list of patterns to identify relevant files and extracts snippets based on time budget and file size limits. The function categorizes these snippets according to predefined section keywords and returns a dictionary mapping each section to its corresponding snippets.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:slugify:eeba86f9b360c54e09cd3f341df2a6c7e4a8116b146d17fb28ac5c72ec5b8b22:eeba86f9b360c54e09cd3f341df2a6c7e4a8116b146d17fb28ac5c72ec5b8b22": "The `slugify` function converts a given string into a filesystem-friendly slug. It removes all non-alphanumeric characters, converts the string to lowercase, and replaces spaces with underscores. If the resulting slug is empty after these operations, it defaults to \"user_manual\".",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:validate_manual_references:8743bee6c1f6369779f721f4642e164de7b7c8365bfe42a9c38a8a180e053494:8743bee6c1f6369779f721f4642e164de7b7c8365bfe42a9c38a8a180e053494": "The `validate_manual_references` function checks for the existence of file references within a set of documentation sections. It scans each section's text for substrings that resemble file paths or module names using a regular expression pattern. If a referenced file is not found under the specified project root, it annotates the reference with `[missing]` in the section text. Additionally, if an `evidence_map` is provided, missing references are recorded under the corresponding section in a `missing_references` list. The function modifies the `sections` dictionary in place to update the text of each section accordingly.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:write_pdf:490b91d015c9582c3ea88c7213e26b7387a84772634e4f32ab2446233a5cabff:490b91d015c9582c3ea88c7213e26b7387a84772634e4f32ab2446233a5cabff": "This function `write_pdf` takes an HTML string and a file path as input. It attempts to write the HTML content as a PDF file at the specified path. The function first checks if a canvas object is available; if not, it returns `False`. If the canvas is present, it extracts text from the HTML using BeautifulSoup, initializes a PDF canvas with the given path and page size, writes each line of text to the PDF, and saves the document before returning `True` on success.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:39ce94027bfc6ce0cad3c1969ec59b2e9fae55e8264b967e099883832496302f:39ce94027bfc6ce0cad3c1969ec59b2e9fae55e8264b967e099883832496302f": "A PyQt5 application for running DocGen-LM documentation tool and ExplainCode. Features include:\n\n- A dark-themed GUI with a header, project/output directory selectors, options for DocGen and ExplainCode, and a log area.\n- Custom widgets like `PathLineEdit` for file/directory selection and `CollapsibleBox` for organizing options.\n- Multi-threaded command execution using `CommandRunner`, which handles output streaming and error handling.\n- Buttons to run DocGen, ExplainCode, or both, with logging of the process.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:CollapsibleBox:__init__:3872795cd50f67882abd634cee89722f78baef841dae8e915249543f655adece:3872795cd50f67882abd634cee89722f78baef841dae8e915249543f655adece": "A class constructor that initializes a widget with a toggle button and a content area. The toggle button is styled to have no border, a light gray color, and bold font weight. It displays the title provided during initialization and has an arrow pointing right. When clicked, it triggers the `on_toggled` method. The content area starts hidden and is added below the toggle button in a vertical layout with no margins.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:CollapsibleBox:b0e660435885bad34863d1706fd7abadfde4311c704e6086623dbb7737cb1d8e:b0e660435885bad34863d1706fd7abadfde4311c704e6086623dbb7737cb1d8e": "The `CollapsibleBox` class implements an expandable section widget with a toggle button for showing or hiding content. It initializes with a styled toggle button and a hidden content area, toggling visibility based on user interaction. This class is part of a comprehensive code documentation tool that supports multiple programming languages by providing a GUI interface and caching mechanisms for efficient text generation and rendering.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:CollapsibleBox:on_toggled:f90ec87aaa91989724254207a4e933efac34041b0616a24b2d270248eb906904:f90ec87aaa91989724254207a4e933efac34041b0616a24b2d270248eb906904": "Toggles the visibility of content based on the state of a toggle button. When the toggle button is checked, it displays an arrow pointing down; when unchecked, it shows an arrow pointing right. The content's visibility matches the toggle button's state.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:CollapsibleBox:setContentLayout:ac9bfe1723225a787e6fed8f56df1803aac7bf21a8460cdab57bb446c2364b27:ac9bfe1723225a787e6fed8f56df1803aac7bf21a8460cdab57bb446c2364b27": "Sets the content layout of an object.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:CommandRunner:33d9db2729b5a9708c208846c51dd1034b0287454a8b017bf02622a53ae86d23:33d9db2729b5a9708c208846c51dd1034b0287454a8b017bf02622a53ae86d23": "The `CommandRunner` class is designed to execute a list of commands sequentially, capturing their output and handling errors. It includes a method `_reader` for reading characters from a stream and emitting chunks of text, which is useful for updating progress bars in a GUI. The `run` method executes each command, captures standard output and error streams using separate threads, and handles exceptions by setting the return code to -1 if any command fails.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:CommandRunner:__init__:e101f462c35c5d2aea35db85e4ee5dd50b4513aa99b522541dc82c8e27a017f4:e101f462c35c5d2aea35db85e4ee5dd50b4513aa99b522541dc82c8e27a017f4": "Initializes an object with a list of commands.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:CommandRunner:_reader:8cbfd3ce114ed1c88228963326a3e4e5c43e87fbd062a6965099f60e48b826d6:8cbfd3ce114ed1c88228963326a3e4e5c43e87fbd062a6965099f60e48b826d6": "The function `_reader` reads characters from a stream one by one and emits chunks of text. It handles carriage returns to update progress bars in the GUI, flushes any buffered text when the stream ends, and ensures that new lines are properly emitted with their preceding text.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:CommandRunner:run:c94857cc54e41729c04041a0a02b8ef637ddeb94d917c5048d30a4c9036c500a:c94857cc54e41729c04041a0a02b8ef637ddeb94d917c5048d30a4c9036c500a": "The function `run` executes a list of commands sequentially. It emits each command before execution and captures the standard output and error streams using separate threads. If any command returns a non-zero exit code, the loop breaks. Any exceptions during command execution are caught and emitted as errors, setting the return code to -1. Finally, it emits a completion signal with the final return code.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:MainWindow:2fd06ed489b74a1b2c7fdb2dc882a4a1b8263b3edd97f1765e8e9d429bfe3e94:2fd06ed489b74a1b2c7fdb2dc882a4a1b8263b3edd97f1765e8e9d429bfe3e94": "The `MainWindow` class implements a graphical user interface for generating documentation using DocGen-LM. It provides functionality to select project and output directories, choose languages to document, set output formats, and run commands for document generation and explanation. The class includes methods for UI interaction, logging messages, and executing commands through an LLM client.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:MainWindow:__init__:a80b0d28b1f21493df62eb0b88f81a94c02125321fa3d1ec29f46b28cd23ebe1:a80b0d28b1f21493df62eb0b88f81a94c02125321fa3d1ec29f46b28cd23ebe1": "This code defines a class with an `__init__` method that sets up the user interface for a documentation tool. The UI includes:\n\n- A header with a logo and title.\n- Fields to select project and output directories, each with a browse button.\n- Checkboxes for selecting languages to document (Python, MATLAB, C++, Java) and an option to include private functions.\n- Options for output format (HTML or PDF), including the ability to include input data analysis with its own file selection field.\n- A log area for displaying messages.\n- Buttons to run DocGen, ExplainCode, or both.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:MainWindow:append_log:479035b003afdc113e4797fee7c099619ef8d0c73b903f780a2ffa361feaaf55:479035b003afdc113e4797fee7c099619ef8d0c73b903f780a2ffa361feaaf55": "The function `append_log` appends text to a log widget. It moves the cursor to the end of the log, splits the input text by carriage return characters, and processes each part. If a part is a carriage return, it moves the cursor to the start of the line and removes any existing text on that line. Otherwise, it inserts the text at the current cursor position. Finally, it sets the cursor back in the log widget and scrolls the view to the bottom.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:MainWindow:build_docgen_cmd:6fa0775116713b62dd6629e8c1004ce85ebf3d3733c83a88ff84ed7cd8476068:6fa0775116713b62dd6629e8c1004ce85ebf3d3733c83a88ff84ed7cd8476068": "This function constructs a command list for running a document generator. It includes the Python interpreter (`pythonw`), the script `docgenerator.py`, and arguments from two text fields: `project_edit` and `output_edit`. If a checkbox `docgen_private_cb` is checked, it appends `--include-private` to the command. The function returns the constructed command list.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:MainWindow:build_explain_cmd:7b8696f7337008622c6bc5488b4fc92413596481c1750330bdc72564631f2cb5:7b8696f7337008622c6bc5488b4fc92413596481c1750330bdc72564631f2cb5": "Constructs a command to run `explaincode.py` with specified parameters, including project path, output file, format, and optional data.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:MainWindow:dark_style:024d23387b641216e7d149e6c045b026f1a451318d781be0d3d84d51867f51ef:024d23387b641216e7d149e6c045b026f1a451318d781be0d3d84d51867f51ef": "Returns a string containing CSS styles for dark theme.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:MainWindow:on_finished:c98dd27bd106b89d8d5059a01d5a7c208db9c09ee3836ee9d932c0f5bdb99f8b:c98dd27bd106b89d8d5059a01d5a7c208db9c09ee3836ee9d932c0f5bdb99f8b": "The function `on_finished` logs the exit code of a process and sets the running status to False.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:MainWindow:run_both:123251ea533aa28d4fb511b62f853998d3769fcced0962a00cdc1cb16c3cfef0:123251ea533aa28d4fb511b62f853998d3769fcced0962a00cdc1cb16c3cfef0": "Clears the log and runs both document generation and explanation commands.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:MainWindow:run_commands:259d9e78ac20ac9cd282474591a8079c54a2e042ef9670b77335a47dad9adaff:259d9e78ac20ac9cd282474591a8079c54a2e042ef9670b77335a47dad9adaff": "The function `run_commands` takes a list of commands as input. It checks if project and output directories are set; if not, it logs an error message and returns. If the directories are set, it sets the running state to true, initializes a `CommandRunner` with the provided commands, connects the runner's output signal to a method that appends log messages, connects the finished signal to a method handling completion, and starts the command execution.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:MainWindow:run_docgen:0249c14aca7d5d21ff6d3b7929c59f2dbc05b970b05e9329f97566991188ecf6:0249c14aca7d5d21ff6d3b7929c59f2dbc05b970b05e9329f97566991188ecf6": "Clears the log and runs a command to generate documentation.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:MainWindow:run_explain:aaae3953f6dfd026db21ab5cd9b5c637f7a8e0fee01ae706e4db035bf9a67663:aaae3953f6dfd026db21ab5cd9b5c637f7a8e0fee01ae706e4db035bf9a67663": "Clears the log and runs a command to generate an explanation.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:MainWindow:select_dir:2a0195f8b02fa1d0340ed30e33775539f64b5ddf0498a2fae1d7426f16c229f5:2a0195f8b02fa1d0340ed30e33775539f64b5ddf0498a2fae1d7426f16c229f5": "The function `select_dir` opens a dialog to select an existing directory. If a directory is selected, it sets the text of a provided `QLineEdit` widget to the path of the selected directory.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:MainWindow:select_file:eefcbb0d572a55989ebf1a954aae8e90553ec7f2c5c165ee8e6029c3df4770d3:eefcbb0d572a55989ebf1a954aae8e90553ec7f2c5c165ee8e6029c3df4770d3": "The function `select_file` opens a file dialog to select a data file (JSON, CSV, or TXT) and sets the selected file path in a provided `QLineEdit` widget.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:MainWindow:set_running:d3acbd2de6100d567839296867ec1053032418777abacda408081e46f5c8e826:d3acbd2de6100d567839296867ec1053032418777abacda408081e46f5c8e826": "Disables buttons based on running state.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:PathLineEdit:26182c7f300f9a6e9006dd3f323586fcfffb47a785804e6da1698a9b9cbd937b:26182c7f300f9a6e9006dd3f323586fcfffb47a785804e6da1698a9b9cbd937b": "The `PathLineEdit` class is designed for handling drag-and-drop events in a user interface component, specifically for accepting URLs that represent file paths. It initializes with an optional parent object and processes dragEnterEvent and dropEvent to accept and handle URLs, updating the object's text to reflect the local file path of the first URL encountered.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:PathLineEdit:__init__:c9e8a7be9ec3c7638ba891fb56438f32b028d50d553e3cf05183fab3aa0b6309:c9e8a7be9ec3c7638ba891fb56438f32b028d50d553e3cf05183fab3aa0b6309": "Initializes an object with optional parent. Accepts drag-and-drop events.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:PathLineEdit:dragEnterEvent:362f23d15259d38f2384b97d4fe0df74d022e537eb20da5aa442f957d48d0d35:362f23d15259d38f2384b97d4fe0df74d022e537eb20da5aa442f957d48d0d35": "Handles the `dragEnterEvent` by accepting the proposed action if the event contains URLs.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:PathLineEdit:dropEvent:2bae52494ea3b00064a9fc268f5338cc663c0b954be820963c807172bd13b7cf:2bae52494ea3b00064a9fc268f5338cc663c0b954be820963c807172bd13b7cf": "The function `dropEvent` processes a drag-and-drop event. It retrieves URLs from the event's MIME data and sets the text of the object to the local file path of the first URL if any URLs are present.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\html_writer.py:_highlight:44a9b099baff0f8dabd0897a65359cbeb00263fe5a28b66e8020f49e254f8f5f:44a9b099baff0f8dabd0897a65359cbeb00263fe5a28b66e8020f49e254f8f5f": "The function `_highlight` takes a string `code` and a string `language` as input. It uses the Pygments library to highlight the code based on the specified language. The function supports Python, MATLAB, C++, and Java languages. If an unsupported language is provided, it defaults to using the `TextLexer`. The highlighted code is returned within HTML `<pre>` and `<code>` tags for proper formatting in web pages.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\html_writer.py:_render_class:32c425a8df7ea61eaafadf10cf721197faf896e0d61f2da2429c17edca2b872b:32c425a8df7ea61eaafadf10cf721197faf896e0d61f2da2429c17edca2b872b": "This function `_render_class` generates HTML parts for a class and its subclasses. It takes a dictionary representing the class, a programming language string, and an optional level parameter (default is 2). The function returns a list of HTML strings.\n\nThe function starts by creating an HTML heading tag (`<hX>`) for the class name, where `X` is determined by the minimum of the provided level and 6. It then adds a paragraph with the class's docstring or summary if available.\n\nNext, it processes any variables associated with the class, adding headings and descriptions as needed. For each variable, it includes its source code highlighted in the specified language using another function `_highlight`.\n\nThe function also iterates over methods within the class, rendering them using a helper function `_render_function`, which adds a prefix indicating that the item is a method.\n\nFinally, for each subclass of the current class, it creates an expandable section (`<details>`) containing the subclass's name and rendered HTML parts. This recursive structure allows for nested classes to be displayed as expandable sections within their parent class.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\html_writer.py:_render_function:f03a36bbe64e904df757b4ba90938b2e47c9f71e7e389a6e3791efd97cfce405:f03a36bbe64e904df757b4ba90938b2e47c9f71e7e389a6e3791efd97cfce405": "This function `_render_function` is designed to generate HTML parts for a given function and its nested subfunctions. It takes three parameters: `func`, which is a dictionary containing information about the function; `language`, specifying the programming language of the code; and an optional `level` parameter, defaulting to 3, which controls the depth of the HTML headings used for rendering. The function returns a list of strings representing the HTML parts.\n\nThe function starts by creating an HTML heading tag based on the `level` parameter and appends it to the `parts` list along with the function's signature or name, escaped to prevent HTML injection. It then checks if there is a summary or docstring for the function and appends it as a paragraph if available.\n\nIf the function has source code, it calls another function `_highlight` (not shown in the provided code) to highlight the source code according to the specified `language` and adds the highlighted code to the `parts` list.\n\nThe function then iterates over any nested subfunctions of the current function. For each subfunction, it creates a `<details>` HTML tag, which allows for collapsible sections. Inside this tag, it appends a summary of the subfunction and recursively calls `_render_function` to generate HTML parts for the subfunction itself, increasing the `level` by 1 to create nested headings.\n\nFinally, the function returns the list of HTML parts generated for the function and its subfunctions.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\html_writer.py:_render_html:5b19d8c4dd22f5d9408eb1fded1d81e1f2fa8a81bc615534c84c0c807919e7ad:5b19d8c4dd22f5d9408eb1fded1d81e1f2fa8a81bc615534c84c0c807919e7ad": "The function `_render_html` takes four parameters: `title`, `header`, `body`, and `nav_html`. It reads a template from a specified path, formats it with the provided parameters, and returns the formatted HTML string. The template includes placeholders for the title, header, body, navigation, and static path, which are replaced by the actual values passed to the function.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\html_writer.py:cb7d2be80220e642e35c48dec36335863a7e75a6e55f27602ef20acab3ba0b36:cb7d2be80220e642e35c48dec36335863a7e75a6e55f27602ef20acab3ba0b36": "This module provides HTML rendering utilities for DocGen-LM. It includes functions to highlight code snippets in various programming languages and to render documentation pages using simple template substitution. The module defines templates for index and module pages, which are populated with project summaries, page links, function descriptions, class definitions, and variable details. It uses Pygments for syntax highlighting and HTML for rendering the final output.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\html_writer.py:write_index:27386c7f2693ef4098ce8d3f46e145cdc1c8a1a2e822c189eac7308376a1c986:27386c7f2693ef4098ce8d3f46e145cdc1c8a1a2e822c189eac7308376a1c986": "The `write_index` function generates the content for an `index.html` file in a specified output directory. It takes three parameters: `output_dir`, `project_summary`, and `page_links`. Optionally, it can also take `module_summaries`.\n\n- `output_dir`: The directory where the `index.html` file will be written.\n- `project_summary`: A summary of the project that will be displayed on the page.\n- `page_links`: An iterable of tuples containing text and link pairs for navigation.\n- `module_summaries`: An optional dictionary mapping module names to summaries.\n\nThe function creates a directory if it doesn't exist, constructs HTML content for the project summary and navigation links, and optionally includes summaries for modules. It then uses `_render_html` to generate the final HTML output and writes it to `index.html` in the specified output directory.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\html_writer.py:write_module_page:24821cf50d2c82f63f62b31f83e3a68144643a2cc81da169f138e653bb4f8d5a:24821cf50d2c82f63f62b31f83e3a68144643a2cc81da169f138e653bb4f8d5a": "This function `write_module_page` generates an HTML documentation page for a Python module. It takes three parameters: `output_dir`, which is the directory where the output HTML file will be saved; `module_data`, a dictionary containing information about the module such as its name, summary, variables, and functions; and `page_links`, an iterable of tuples representing links to other pages in the documentation.\n\nThe function first constructs the destination directory for the output file. It then extracts the module's name and language from `module_data`. A navigation bar is created with a link to the project overview and any additional links provided in `page_links`.\n\nThe body of the HTML page is built by concatenating various parts, including the module summary, class documentation (if any), variable documentation, and function documentation. Each part is generated using helper functions `_render_class`, `_render_function`, and `_highlight`. The final HTML content is rendered using `_render_html` and written to a file in the specified output directory with the filename corresponding to the module's name.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\llm_client.py:8a7e034326ab8436a77c127885417c779154a56476b599c11324d27f342ab6d3:8a7e034326ab8436a77c127885417c779154a56476b599c11324d27f342ab6d3": "This module provides an interface to a local language model (LLM) backend using the LMStudio HTTP API. It includes:\n\n- A `sanitize_summary` function that removes unwanted phrases from a summary text.\n- An `LLMClient` class that:\n- Initializes with a base URL and model name.\n- Includes a `ping` method to check if the LLM server is reachable.\n- Implements a `summarize` method that sends a request to the LLM API using a specified prompt template, handles retries on failures, and sanitizes the response before returning it.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\llm_client.py:LLMClient:5b627271ed622a3f8ff6c3c730f5d777df5e695100d9a253dca34971ece81bdc:5b627271ed622a3f8ff6c3c730f5d777df5e695100d9a253dca34971ece81bdc": "The `LLMClient` class in the DocGen-LM project initializes with a base URL and model, provides functionality to check API reachability through the `ping` method, and generates summaries of code using prompts and an LLM endpoint via the `summarize` method.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\llm_client.py:LLMClient:__init__:700c23b8c0716a1aaf00c10fbc2e056bef4f6e1dca9c72b739185f920ef55cf8:700c23b8c0716a1aaf00c10fbc2e056bef4f6e1dca9c72b739185f920ef55cf8": "Initializes an object with a base URL and model. Strips trailing slashes from the base URL and constructs an endpoint for chat completions. Sets the model attribute to the provided value or \"local\" if not specified.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\llm_client.py:LLMClient:ping:3fe5655e89accd067c6ddc9c1cc323c9dd9eac2dea9be6646ea4d470b3e0a436:3fe5655e89accd067c6ddc9c1cc323c9dd9eac2dea9be6646ea4d470b3e0a436": "Function `ping` checks if the API is reachable by sending a GET request to the server. It returns `True` if successful, otherwise raises a `ConnectionError`.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\llm_client.py:LLMClient:summarize:52bc385d2540bdc7232f1e87dafe84d928a26648f0179a1f497d043c53316d44:52bc385d2540bdc7232f1e87dafe84d928a26648f0179a1f497d043c53316d44": "The function `summarize` takes a string `text`, a prompt type, and an optional system prompt. It uses the specified prompt template to generate a summary of the text. The function sends this prompt along with a system message to a language model endpoint using HTTP POST. It handles potential errors by retrying up to three times before raising a runtime error if all attempts fail.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\llm_client.py:sanitize_summary:be74c6875c644f40bf4cf23d28161546be79fa470af7cec3445f7584c562573a:be74c6875c644f40bf4cf23d28161546be79fa470af7cec3445f7584c562573a": "The function `sanitize_summary` takes a string `text` as input and returns a sanitized version of the text by removing lines that start with certain phrases considered meta commentary or redundant. It also filters out lines containing specific keywords related to summaries, outputs, responses, and descriptions. The function uses regular expressions to match patterns indicating the start of certain types of lines and removes them from the final output.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\manual_utils.py:_count_tokens:ce6a92c6278cd9b9586514b81ba46ad856bcac4a079db2cbb90b78880af7caa8:ce6a92c6278cd9b9586514b81ba46ad856bcac4a079db2cbb90b78880af7caa8": "Counts the number of tokens in a given text using a tokenizer.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\manual_utils.py:_split_text:bcd50290b39ae82460ff3d4bfea9122f93dcc1b167ab95006d98dc09d118a35b:bcd50290b39ae82460ff3d4bfea9122f93dcc1b167ab95006d98dc09d118a35b": "The function `_split_text` splits a given text into chunks while respecting specified maximum token and character limits. It first splits the text into paragraphs, then iterates through each paragraph to determine if it fits within the token and character constraints. If a paragraph exceeds these limits, it is further split using another function `chunk_text`. The resulting chunks are collected in a list and returned.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\manual_utils.py:_summarize_manual:ba727135f4ac6129bb1cb963895ebcf93ef4403ddf95a4c5f0b1062fbdb0715a:ba727135f4ac6129bb1cb963895ebcf93ef4403ddf95a4c5f0b1062fbdb0715a": "The function `_summarize_manual` generates a manual summary for the provided text using an LLM client and a caching mechanism. It supports different chunking strategies: \"auto,\" \"manual,\" and \"none.\" The function handles text splitting, caching, and merging to ensure that summaries are within token and character limits. If chunking is enabled, it processes the text in chunks, summarizes each part, and then merges them into a final summary. The function also includes error handling for network failures and provides debug logging for various stages of processing.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\manual_utils.py:ca45f47ddbb3006a8bf59dd1857385df96e5bfaf41681af7c2da178cba05f5ca:ca45f47ddbb3006a8bf59dd1857385df96e5bfaf41681af7c2da178cba05f5ca": "This module provides functions for splitting text into manageable chunks and generating summaries using a language model. It includes:\n\n1. `_count_tokens`: Counts the number of tokens in a given text.\n2. `_split_text`: Splits text into chunks based on token and character limits.\n3. `chunk_docs`: Splits a list of documents into chunks.\n4. `find_placeholders`: Identifies placeholder tokens in text.\n5. `_summarize_manual`: Generates a summary for text using a specified chunking strategy, utilizing an LLMClient for summarization tasks.\n\nThe module uses caching to store and retrieve previously generated summaries to improve efficiency. It handles different chunking strategies (\"auto\", \"manual\", \"none\") and includes error handling for network failures and other exceptions during the summarization process.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\manual_utils.py:chunk_docs:92414b7d919ee88ae2d360607ac9838f29ed9825c25b491e04574f9199a94ac5:92414b7d919ee88ae2d360607ac9838f29ed9825c25b491e04574f9199a94ac5": "This function `chunk_docs` takes a list of strings (`docs`) and an integer (`token_limit`) as input. It joins the non-empty strings in the list with double newline characters for separation, then splits the resulting text into chunks where each chunk is roughly equal to the specified `token_limit`. The function returns a list of these chunks.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\manual_utils.py:find_placeholders:e35a27e18d9620b24f47e57246e3f07e51a731cd19bca4e818dcb9da925aaea3:e35a27e18d9620b24f47e57246e3f07e51a731cd19bca4e818dcb9da925aaea3": "The function `find_placeholders` searches for placeholder tokens enclosed in double backticks followed by two square brackets, such as ``[[TOKEN]]``, within a given text string. It returns a set of these placeholder tokens found in the text.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\parser_cpp.py:20fbb103bacaa4a0b0e1faa76ad26882965689f182fed8716afa4e58a1cc1689:20fbb103bacaa4a0b0e1faa76ad26882965689f182fed8716afa4e58a1cc1689": "This Python module provides a simple parser for C++ files used by DocGen-LM. It extracts namespaces, classes, functions, and public variables from the source code. The parser returns a structured dictionary containing `module_docstring`, `classes`, and `functions`. Each class and function includes their respective documentation comments, source snippets, and any leading comments. The module uses line-based parsing to identify and extract these elements, making it compatible with Python's `parse_python_file` structure.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\parser_cpp.py:_extract_block:558af3a5161ee8d4106ce8f69c665fe7f4bfe9acdf0aa08f63a08a50e213b6b4:558af3a5161ee8d4106ce8f69c665fe7f4bfe9acdf0aa08f63a08a50e213b6b4": "This function extracts a block of code from a list of lines, starting from a given index. It returns the text of the block and the ending index. The block is defined by matching braces `{` and `}`. The function iterates through the lines, adding each line to the block until all opening braces are matched with closing ones.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\parser_cpp.py:_get_preceding_comment:bd97e6d892fe5785c36c3320d06734c3cc4656441853fa5433f9b2ddb993ad44:bd97e6d892fe5785c36c3320d06734c3cc4656441853fa5433f9b2ddb993ad44": "Collects contiguous comment lines appearing before a specified index in a list of source code lines.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\parser_cpp.py:_parse_class_body:dd0db24808ac2b72b9cb7add27dcc75604d5faf75dcb608b7bfbe210854a4cbe:dd0db24808ac2b72b9cb7add27dcc75604d5faf75dcb608b7bfbe210854a4cbe": "The function `_parse_class_body` parses the body of a class in source code and extracts public methods and variables. It takes three parameters: `lines`, which is a list of strings representing the lines of source code; `start`, which is an integer indicating the starting index of the class body within `lines`; and `end`, which is an integer indicating the ending index of the class body.\n\nThe function returns two lists:\n1. A list of dictionaries, where each dictionary represents a public method with keys for the method's name, signature, docstring, and source code.\n2. A list of dictionaries, where each dictionary represents a public variable with keys for the variable's name, type, docstring, and source line.\n\nThe function iterates through the lines from `start` to `end`, identifying access modifiers (`public:`, `protected:`, `private:`) and extracting method signatures and variable declarations based on their syntax. It also retrieves preceding comments as docstrings for methods and variables. The extracted information is then stored in the respective lists and returned at the end of the function.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\parser_cpp.py:parse_cpp_file:3a5d7a34eebdd3724052a64ff6f501fa5211ed3e36f0904a49c1cd1028f657fd:3a5d7a34eebdd3724052a64ff6f501fa5211ed3e36f0904a49c1cd1028f657fd": "The function `parse_cpp_file` reads a C++ source file from the specified path and returns structured information about its contents. It processes the file line by line to identify module-level comments, namespaces, classes, structs, and functions. For each class or struct, it extracts methods and variables. Functions are identified based on their signature. The function collects all this information into a dictionary, which includes the module docstring, namespace (if present), classes, and functions. Each class and function is represented as a dictionary containing details such as name, documentation string, source code block, and relevant members for classes.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\parser_java.py:729faf96c4d338772a690be0eaf2138a3bbdae3288180abc6c0056faa4919469:729faf96c4d338772a690be0eaf2138a3bbdae3288180abc6c0056faa4919469": "A simple parser for Java files used by DocGen-LM. Extracts package, classes, public methods, and variables using naive line-based parsing. The output mirrors `parse_python_file` with keys `module_docstring`, `classes`, and `functions`. Each entry includes its source code and leading documentation comments (Javadoc or `//`).",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\parser_java.py:_extract_block:5efb4cbd3855f801c5455849c983bc11510ddec09b28c0fd997982b095fc6609:5efb4cbd3855f801c5455849c983bc11510ddec09b28c0fd997982b095fc6609": "The function `_extract_block` takes a list of strings `lines` and an integer `start` as input. It extracts a block of text starting from the line at index `start`, which is expected to contain an opening brace `{`. The function iterates through subsequent lines, appending them to `text_lines`, until it encounters a closing brace `}` that matches the opening brace in the starting line. It returns the extracted block as a single string and the index of the last line included in the block.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\parser_java.py:_get_preceding_comment:90b8dde6633eebdd63119d0722a2b85a197113835044c30f20ce3eb229d5acd2:90b8dde6633eebdd63119d0722a2b85a197113835044c30f20ce3eb229d5acd2": "The function `_get_preceding_comment` extracts the preceding comment(s) from a list of lines at a specified index. It handles both single-line comments (starting with `//`) and multi-line comments enclosed in `/* */`. The function iterates backward through the lines, collecting comments until it encounters a non-comment line or reaches the beginning of the file. It returns the collected comments as a single string, preserving their order and formatting.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\parser_java.py:_parse_class_body:587891d90b6fe509203884b46fdd17a9474c8fc06e7d299a98df3519fe69746a:587891d90b6fe509203884b46fdd17a9474c8fc06e7d299a98df3519fe69746a": "This function `_parse_class_body` extracts methods and variables from a block of code within a class. It takes three parameters: `lines`, which is a list of strings representing the lines of code; `start`, which is the starting index of the block to parse; and `end`, which is the ending index of the block to parse.\n\nThe function initializes two lists, `methods` and `variables`, to store dictionaries containing information about each method and variable found within the specified block. It then iterates through the lines from the start index to the end index.\n\nFor each line, it checks if the line starts with \"public \". If the line contains a method signature (indicated by parentheses), it extracts the method's name, signature, docstring, and source code. If the line declares a variable (indicated by a semicolon and not containing parentheses), it extracts the variable's name, type, docstring, and source code.\n\nThe function uses helper functions `_extract_block`, `_get_preceding_comment` to extract additional information about methods and variables. It returns two lists: one with method details and another with variable details.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\parser_java.py:parse_java_file:e57f4df8427db76aaf4b92f132562a6a237e9bdee6d71a2f043a79c80cbc01c5:e57f4df8427db76aaf4b92f132562a6a237e9bdee6d71a2f043a79c80cbc01c5": "The function `parse_java_file` reads a Java source file from the specified path and extracts relevant information such as the module docstring, package name, classes, and methods. It processes each line of the file to identify class declarations and extract their names, documentation strings, method definitions, and variable declarations. The extracted data is returned in a dictionary format, providing a structured representation of the Java code for further processing or documentation generation.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\parser_matlab.py:15cf90e58e5b33528fe0fc6fa2e48fa77e43bd0fed902a29ea22b67a2f78ff68:15cf90e58e5b33528fe0fc6fa2e48fa77e43bd0fed902a29ea22b67a2f78ff68": "This module provides a function to parse MATLAB `.m` files and extract basic structure. It reads the file content, identifies leading comment lines as the file header, and extracts `function` declarations along with their arguments. The parsed data is returned in a dictionary containing the file header comments and a list of functions, each represented by its name and arguments.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\parser_matlab.py:parse_matlab_file:b6b2638e71ed632a41331842ee35a833523b8d6ccdf59ab9592ffc46c9c28a16:b6b2638e71ed632a41331842ee35a833523b8d6ccdf59ab9592ffc46c9c28a16": "The `parse_matlab_file` function reads and parses a MATLAB `.m` file to extract its basic structure. It returns a dictionary containing the file's header comments and any function declarations found within the file. Each function entry includes the function name and a list of arguments. The function uses regular expressions to identify and parse function declarations from the file content.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\parser_python.py:9b7a83be6356666450a5a1a457ffe2e114b6726c1c43053f6e27962b7ce8f0aa:9b7a83be6356666450a5a1a457ffe2e114b6726c1c43053f6e27962b7ce8f0aa": "This module provides a parser for Python files using the `ast` module to extract structured information according to the Software Requirements Specification (SRS). It includes functions to format arguments and signatures of functions, parse classes and functions within a Python file, and retrieve structured information about the parsed content. The main entry point is `parse_python_file`, which takes a file path as input and returns a dictionary containing the module docstring, classes, and functions.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\parser_python.py:_format_arg:f4c63ed1cee8821eac567d6ce49a376fb7043f96eee263c192fdaaac8efa3b5b:f4c63ed1cee8821eac567d6ce49a376fb7043f96eee263c192fdaaac8efa3b5b": "Formats an argument by appending its type annotation, if available.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\parser_python.py:_format_arguments:ed6cc08dadbd69c3e8f457e71345bb9915aea25a4d063a89368111741b62d57a:ed6cc08dadbd69c3e8f457e71345bb9915aea25a4d063a89368111741b62d57a": "This function `_format_arguments` takes an `ast.arguments` object as input and returns a string representation of the arguments. It processes positional-only, regular, variable-positional, keyword-only, and variable-keyword arguments, including their default values if provided. The function uses helper functions to format individual arguments and constructs the final string by joining all parts with commas.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\parser_python.py:_format_signature:39fccbe4b2b84954ad26ea4c7bdd3c524df479ec189d8a057d41f6ef815f0d0d:39fccbe4b2b84954ad26ea4c7bdd3c524df479ec189d8a057d41f6ef815f0d0d": "The `_format_signature` function takes a Python `ast.FunctionDef` or `ast.AsyncFunctionDef` object as input and returns a formatted string representing the function's signature. It extracts the function name, arguments, and return type (if present) to construct a complete signature string.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\parser_python.py:_parse_classes:0b162b40ee3a8de96c9934cd385b0c7ff078dd3bc2a095177c72d790bfa9fec2:0b162b40ee3a8de96c9934cd385b0c7ff078dd3bc2a095177c72d790bfa9fec2": "The function `_parse_classes` recursively parses all `ClassDef` nodes within a list of AST nodes. It iterates through each node, checking if it is an instance of `ast.ClassDef`. If so, it calls the `parse_class` function to process and store the class information. If the node is an instance of `ast.FunctionDef` or `ast.AsyncFunctionDef`, it recursively calls `_parse_classes` on the body of the function to search for nested classes. The function returns a list of dictionaries containing parsed class information.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\parser_python.py:parse_class:56ea9035ec6a35f66e71bd82f2d87de69e0dfb1f3d35e20722fd65cc008c0322:56ea9035ec6a35f66e71bd82f2d87de69e0dfb1f3d35e20722fd65cc008c0322": "The `parse_class` function takes an AST node representing a class and the source code as input. It returns a dictionary containing information about the class, including its name, docstring, methods, subclasses, and source code segment.\n\n- The function initializes a dictionary `cls_info` with keys for the class's name, docstring, methods, subclasses, and source code.\n- It sets the class's name and docstring from the AST node using `ast.get_docstring`.\n- It iterates through the body of the class to find method nodes (`FunctionDef` or `AsyncFunctionDef`) and appends their information to the `methods` list by calling `parse_function`.\n- The function calls `_parse_classes` to recursively parse any nested classes within the current class and updates the `subclasses` list.\n- Finally, it returns the populated `cls_info` dictionary.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\parser_python.py:parse_classes:dc2026c8fdf16a839e3ec7adc88fc398e4757b12c4fd51670b69914364e343db:dc2026c8fdf16a839e3ec7adc88fc398e4757b12c4fd51670b69914364e343db": "This function is a public wrapper for parsing classes in Python code. It takes an abstract syntax tree (AST) node and the source code as input. The function extracts the body of the AST node using `getattr` and passes it along with the source code to the private `_parse_classes` function, which is responsible for the actual parsing of classes.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\parser_python.py:parse_function:deb0069c2cf8222045b18f9458de29a01e16bf14a6e67017fe5c0361b495a70b:deb0069c2cf8222045b18f9458de29a01e16bf14a6e67017fe5c0361b495a70b": "This function `parse_function` takes an AST node representing a function or asynchronous function definition and the source code as input. It returns a dictionary containing information about the function, including its name, signature, return type, docstring, source code segment, nested functions, and subclasses.\n\nThe function initializes a dictionary with keys for each piece of information to be extracted. It then iterates through the body of the node, checking for nested function definitions (both synchronous and asynchronous) and appending their parsed information to the `subfunctions` list. Additionally, it calls another helper function `_parse_classes` to extract any subclasses within the function's body and adds them to the `subclasses` list.\n\nThe function uses various utility functions from Python's `ast` module to retrieve and format information such as the function signature, return type, docstring, and source code segment.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\parser_python.py:parse_python_file:faadb7912206070377a142b64afeff368c6d692bedc1e949e7a1b0a9c4897a13:faadb7912206070377a142b64afeff368c6d692bedc1e949e7a1b0a9c4897a13": "This function `parse_python_file` takes a file path as input and returns a dictionary containing structured information about the Python module. It reads the source code from the specified file, parses it using the `ast` module, and extracts the module docstring, classes, and functions. Each class and function is parsed further using helper functions (`parse_class` and `parse_function`). The resulting dictionary includes nested structures for classes and functions, providing a detailed representation of the Python source code.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\reviewer.py:4f9d422499a1acff78c67b05122179a409cbacd25a4c242442e0aef707dbeb81:4f9d422499a1acff78c67b05122179a409cbacd25a4c242442e0aef707dbeb81": "This module provides a tool to review HTML documentation generated by DocGen-LM. It checks for assistant-like phrases, contradictions, and hallucinations in the HTML content. The tool can also automatically fix some issues by sanitizing paragraphs using a `sanitize_summary` function from the `llm_client` library.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\reviewer.py:_extract_tags:cd8e0b8d3aa01bac99d698b29c01e7240043eb220aeee39f40be0a12c73c214b:cd8e0b8d3aa01bac99d698b29c01e7240043eb220aeee39f40be0a12c73c214b": "The function `_extract_tags` is designed to extract all occurrences of a specified HTML tag and its content from a given HTML string. It uses the `re.findall` method with a regular expression pattern that matches the opening and closing tags along with their contents. The pattern is case-insensitive and allows for any characters (including newlines) within the tags, as indicated by the `re.DOTALL` flag. The function returns a list of strings, each representing the content inside an instance of the specified tag.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\reviewer.py:_find_line_number:b0db2654ccb0ecb7441d65c5be1fe903ece0333c37309053d574b9e51b735158:b0db2654ccb0ecb7441d65c5be1fe903ece0333c37309053d574b9e51b735158": "The function `_find_line_number` searches for a specific phrase within an HTML string and returns the line number where the phrase is found. If the phrase is not found, it returns -1. The search is case-insensitive.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\reviewer.py:_is_generated_html:840c5b3683161f0f86ae8807d4926a2abe9e90682855beec2ce792b7dd4ee90b:840c5b3683161f0f86ae8807d4926a2abe9e90682855beec2ce792b7dd4ee90b": "The function `_is_generated_html` checks whether a given string `text` appears to be output from DocGen-LM, a tool for generating static HTML documentation. It returns `True` if the text contains specific markers indicating it was generated by DocGen-LM: the phrase \"Generated by DocGen-LM\", an `<h1>` heading with the title \"Project Documentation\", and headings for classes and methods prefixed with `<h2>` and `<h3>`, respectively.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\reviewer.py:_review_file:0a8f8b6f78b8a8604884f7326afaf2754e788a01aa456975ddacc93ac70f4a38:0a8f8b6f78b8a8604884f7326afaf2754e788a01aa456975ddacc93ac70f4a38": "The function `_review_file` reads a file at the given `path`, checks for assistant phrasing, contradictions, and hallucinations in its HTML content, and optionally fixes any issues found. It returns a list of messages indicating any problems detected or actions taken. If `autofix` is enabled and issues are found, it sanitizes the HTML paragraphs and writes the changes back to the file.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\reviewer.py:_sanitize_paragraphs:cf14248fe788dc57fa382461d13846e9e5985fe439aaa7383d68f6adfe21bb1a:cf14248fe788dc57fa382461d13846e9e5985fe439aaa7383d68f6adfe21bb1a": "The function `_sanitize_paragraphs` processes HTML content to sanitize and standardize paragraph tags. It uses a regular expression to identify paragraphs within the HTML string. For each matched paragraph, it removes any unwanted characters or formatting from the content using the `sanitize_summary` function and then wraps the cleaned content back into a `<p>` tag. This ensures that all paragraphs in the HTML are properly formatted and free of extraneous elements.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\reviewer.py:_strip_html:d2d5d4f4166ed154463f95c9e84c99f0a1dfc9531c242ff458638f24fc9e9ae8:d2d5d4f4166ed154463f95c9e84c99f0a1dfc9531c242ff458638f24fc9e9ae8": "The function `_strip_html` takes a string `text` as input and returns a new string with all HTML tags removed. It uses the `re.sub` function from the `re` module to substitute any sequence of characters that match the regular expression `<[^>]+>` (which represents an HTML tag) with an empty string, effectively removing them from the input text.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\reviewer.py:check_assistant_phrasing:ccea89692af93d3a75da22e3ab5e8d32e5b2a26b471fc9b98ae6f599af5092af:ccea89692af93d3a75da22e3ab5e8d32e5b2a26b471fc9b98ae6f599af5092af": "The function `check_assistant_phrasing` analyzes an HTML string to identify and list occurrences of assistant-like phrases. It extracts paragraph tags from the HTML using `_extract_tags`, strips HTML from the text, converts it to lowercase for case-insensitive comparison, and checks if any predefined assistant phrases are present. If a phrase is found, it appends a formatted string with the phrase and its line number in the original HTML to a list of findings. The function returns this list of findings.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\reviewer.py:check_contradictions:dee3640729263cfc222494acdd8e490606147ea4355970ae827f0cd650b8d77d:dee3640729263cfc222494acdd8e490606147ea4355970ae827f0cd650b8d77d": "The `check_contradictions` function analyzes HTML documentation to identify contradictions between the text and the structure of the document. It returns a list of contradiction descriptions.\n\n1. **Input**: The function takes a single argument, `html`, which is a string containing HTML content.\n2. **Output**: It returns a list of strings, where each string describes a contradiction found in the HTML.\n3. **Process**:\n- Extracts all paragraph (`<p>`) tags from the HTML and converts their text to lowercase.\n- Joins the first two paragraphs into a summary text.\n- Extracts headers (`<h3>`) that start with \"Method:\" and those that do not, categorizing them as methods and functions, respectively.\n- Extracts headers (`<h2>`) that start with \"Class:\", categorizing them as classes.\n- Checks for contradictions:\n- If the summary text states \"no methods\" but methods are found, it adds a contradiction description to the list.\n- If the summary text states \"no functions\" but functions are found, it adds a contradiction description to the list.\n- If the summary text states \"no classes\" but classes are found, it adds a contradiction description to the list.\n- Returns the list of contradictions.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\reviewer.py:check_hallucinations:cee159f01934d51c06f496107c0212548bfa02846593114d03108588acae1a4a:cee159f01934d51c06f496107c0212548bfa02846593114d03108588acae1a4a": "The function `check_hallucinations` analyzes an HTML string to detect the presence of hallucination phrases. It extracts all paragraph (`<p>`) tags from the HTML, strips out any HTML formatting, converts the text to lowercase, and checks for the presence of predefined hallucination terms. If a term is found, it is added to a list of findings, which is then returned.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\reviewer.py:main:3134f8fe143ffacc8d0f196549c75c773069abae6c82921544d2e501deeb9d92:3134f8fe143ffacc8d0f196549c75c773069abae6c82921544d2e501deeb9d92": "The `main` function serves as the entry point for a script designed to review and optionally fix issues in generated HTML documentation. It accepts command-line arguments through `argv`, which defaults to `None`. The function uses Python's `argparse` module to parse two arguments: `directory`, which specifies the path to the HTML output directory, and `--autofix`, a boolean flag indicating whether to automatically rewrite files to fix identified issues.\n\nUpon parsing the arguments, the function calls another function named `review_directory` with the provided directory path and the autofix option. Finally, it returns an integer value of 0, typically used to indicate successful execution in command-line scripts.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\reviewer.py:review_directory:7575865be334ef8bf20e5ceae07631715ba7558e715e8a6c9f73ec2551188378:7575865be334ef8bf20e5ceae07631715ba7558e715e8a6c9f73ec2551188378": "The function `review_directory` traverses a directory and its subdirectories, searching for files with the `.html` extension. For each HTML file found, it calls another function `_review_file` to analyze and process the content. If `autofix` is set to `True`, the function attempts to automatically fix any issues identified during the review. The results of the review are printed line by line. If an error occurs while reading a file, it prints an error message and continues with the next file.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\scanner.py:_is_subpath:639d1aff101c8029085ae16a26a4c6f4b5d4b253840d6c1ac45d3ea613edc3ec:639d1aff101c8029085ae16a26a4c6f4b5d4b253840d6c1ac45d3ea613edc3ec": "This function checks if a given `path` is either equal to or located within another `parent` path. It uses the `relative_to()` method from Python's `Path` class to determine if the `path` can be expressed as a relative path to the `parent`. If successful, it returns `True`, indicating that `path` is a subpath of `parent`; otherwise, it catches the `ValueError` and returns `False`.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\scanner.py:a6d2f1f5582a4ecc843b89dfb8f7747af779e8c3bbcef06f98d1c3bb16723167:a6d2f1f5582a4ecc843b89dfb8f7747af779e8c3bbcef06f98d1c3bb16723167": "This module defines a function `scan_directory` that recursively discovers source files of specific types (`.py`, `.m`, `.cpp`, `.h`, `.java`) within a given directory, while ignoring specified paths. It uses optional progress bar display if enabled and handles an optional dependency on the `tqdm` library for progress tracking. The function returns a sorted list of absolute paths to the discovered files.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\scanner.py:scan_directory:136f3d72aeb0ff04d190963415e8307c5171f4812ff210eadcd71da4b3a0cfca:136f3d72aeb0ff04d190963415e8307c5171f4812ff210eadcd71da4b3a0cfca": "The function `scan_directory` recursively discovers source files of specified types (Python, MATLAB, C++, C++ header, Java) within a given directory. It skips directories and files listed in the `ignore` parameter. If `show_progress` is set to True, it displays a progress bar during the scan. The function returns a sorted list of absolute paths to the discovered source files.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\setup.py:501f48f7d373462af3d41b0caf7d7e23e2a79c5fe2886cf307b86c01a8b8d82f:501f48f7d373462af3d41b0caf7d7e23e2a79c5fe2886cf307b86c01a8b8d82f": "This module sets up a Python package using `setuptools`. It defines the entry point for running the script, which executes the `setup` function from `setuptools`. The `setup` function is called with parameters specifying that three Python modules (`explaincode`, `parser_cpp`, and `parser_java`) should be included in the package.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\summarize_utils.py:_summarize:240d1b45f8668081b53d7e62d7f51eeee533e572dd95b1049153d04511c7a4c3:240d1b45f8668081b53d7e62d7f51eeee533e572dd95b1049153d04511c7a4c3": "The `_summarize` function takes an LLMClient, a ResponseCache, a key, text, and a prompt type as input. It attempts to retrieve a cached summary using the provided key. If a cached summary exists, it returns that; otherwise, it generates a new summary using the client's `summarize` method with the given text, prompt type, and system prompt. The generated summary is then stored in the cache under the specified key before being returned.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\summarize_utils.py:dfc94899d582f733d44e86f9d4150162786fe35452be561882e6039626bba1de:dfc94899d582f733d44e86f9d4150162786fe35452be561882e6039626bba1de": "This module provides functions for summarizing text using a language model client and caching responses. It includes:\n\n1. `_summarize`: A helper function to summarize text directly or retrieve from cache.\n2. `summarize_chunked`: A main function that summarizes large texts by chunking them if necessary, ensuring the context fits within token limits. It handles exceptions during chunking and summarization, using a recursive merging approach to combine summaries into a single paragraph.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\summarize_utils.py:summarize_chunked:0db483955970deb91660c991badc17710d5ef5944daac9dcad9d33a9fc6592d2:0db483955970deb91660c991badc17710d5ef5944daac9dcad9d33a9fc6592d2": "This function `summarize_chunked` is designed to summarize text by chunking if necessary. It takes an LLM client, a response cache, a key prefix, the text to be summarized, and various parameters such as prompt type, system prompt, maximum context tokens, and chunk token budget.\n\nThe function first calculates the available tokens based on the system prompt and template. If the text can fit within these available tokens, it proceeds to summarize using the `_summarize` function. If not, it chunks the text into smaller parts that fit within the available tokens. Each part is then summarized individually. After summarizing all parts, the function combines them into a single technical paragraph using another recursive function `_merge_recursive`. This process ensures that the summary remains within the token budget and avoids network failures by handling exceptions gracefully.\n\nThe final summary is sanitized before being returned.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_cache.py:97b2ae8f04e70da29a7fb5d7cb91652ea871818ccc183154b3320347b5835642:97b2ae8f04e70da29a7fb5d7cb91652ea871818ccc183154b3320347b5835642": "This module defines two functions for testing a response cache implementation. The `test_cache_round_trip` function tests setting and retrieving a value from the cache, ensuring that the value persists across cache instances. The `test_cache_get_missing` function tests attempting to retrieve a non-existent key from the cache, expecting a `None` result.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_cache.py:test_cache_get_missing:5d5b5762e5e6567244fa9c610d7a0e6e4ee5ed2d172164cec433cecd1e29168e:5d5b5762e5e6567244fa9c610d7a0e6e4ee5ed2d172164cec433cecd1e29168e": "The function `test_cache_get_missing` tests the behavior of a response cache when attempting to retrieve an item that does not exist. It creates a temporary directory, initializes a `ResponseCache` object with a path to a JSON file within that directory, and then asserts that calling `get` on the cache with a non-existent key returns `None`.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_cache.py:test_cache_round_trip:6b5bcd28a908372e0d8f8d73a55504bc1b2a07992fb156abafcd85dc711b402b:6b5bcd28a908372e0d8f8d73a55504bc1b2a07992fb156abafcd85dc711b402b": "The function `test_cache_round_trip` tests the caching mechanism by writing a summary to a cache file and then reading it back. It uses a temporary path provided by `tmp_path`, creates a `ResponseCache` object with a JSON file as the backend, stores a key-value pair in the cache, and verifies that the value can be retrieved correctly from the same cache instance after reloading.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_chunk_utils.py:d2a16b3c3609200d2d6d0ef21f64bf5274294b26300f2f0821797948f0587063:d2a16b3c3609200d2d6d0ef21f64bf5274294b26300f2f0821797948f0587063": "The module defines several test functions to verify the functionality of `get_tokenizer` and `chunk_text`. It includes tests for:\n\n1. Ensuring that `get_tokenizer` returns a tokenizer object.\n2. Verifying that encoding and decoding text using the tokenizer preserves the original string.\n3. Confirming that `chunk_text` can split a long text into chunks without reconstructing the content.\n4. Checking that `chunk_text` splits markdown headings correctly when chunk size is limited.\n5. Ensuring that `chunk_text` handles code blocks within the text appropriately, maintaining their integrity across chunks.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_chunk_utils.py:test_chunk_text_preserves_code_blocks:e8aba1441efa47e91edf459cebd3b0e5d15de0b3c2117edc6d352ba9639c49ce:e8aba1441efa47e91edf459cebd3b0e5d15de0b3c2117edc6d352ba9639c49ce": "This function tests the `chunk_text` method to ensure it preserves code blocks when splitting text into chunks. It uses a tokenizer and specifies a maximum chunk size of 4. The test checks that at least one chunk contains the original code block and that each chunk has either zero or two backticks (indicating the start or end of a code block).",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_chunk_utils.py:test_chunk_text_reconstructs_content:612d2656d0d7193b29817a9706cb46e3ab301e790d46b7f0e207896bdda83ac1:612d2656d0d7193b29817a9706cb46e3ab301e790d46b7f0e207896bdda83ac1": "This function tests the `chunk_text` function to ensure it correctly reconstructs the original text after chunking. It uses a tokenizer obtained from `get_tokenizer()`, splits a long string of repeated words into chunks with a maximum length of 10, and then joins these chunks back together. The test asserts that the reconstructed text matches the original text (ignoring leading/trailing whitespace) and that the number of chunks is greater than one, indicating successful chunking.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_chunk_utils.py:test_chunk_text_splits_markdown_headings:9ebcba60722bd697f48b4b3d1aa2e1db9bcc9bfbf4db722f44a5722b8ac9cb90:9ebcba60722bd697f48b4b3d1aa2e1db9bcc9bfbf4db722f44a5722b8ac9cb90": "The function `test_chunk_text_splits_markdown_headings` tests the functionality of splitting text into chunks based on Markdown headings. It uses a tokenizer to process the input text, which contains two Markdown headings (`# H1` and `# H2`). The function then asserts that the text is split into exactly two chunks and that each chunk starts with the respective heading.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_chunk_utils.py:test_get_tokenizer_roundtrip:f5d67a24c31744d6f2523d2c3caea52d32b089434355d37afd1dc8b615f18a4e:f5d67a24c31744d6f2523d2c3caea52d32b089434355d37afd1dc8b615f18a4e": "This function tests the round-trip encoding and decoding functionality of a tokenizer. It retrieves a tokenizer instance, encodes a text string into tokens, asserts that the result is a list, decodes the tokens back to text, and verifies that the decoded text matches the original input after stripping any leading or trailing whitespace.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_docgenerator.py:bd93d1343982129d654c006ec965a99e35d08b1cc647b7560f7fcc9a9e98b43b:bd93d1343982129d654c006ec965a99e35d08b1cc647b7560f7fcc9a9e98b43b": "The module contains several test functions for a documentation generator. It uses the `unittest.mock` library to patch dependencies and simulate behavior of an LLMClient during testing. The tests cover various scenarios such as skipping invalid Python files, generating summaries for classes and functions, handling non-UTF8 files, sanitizing project summaries, using README content, cleaning output directories, chunking long text, and processing different types of source code files (Python, C++, Java).",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_docgenerator.py:test_chunking_accounts_for_prompt_overhead:b4621e28f40ee3c955f6033f2e33f7a6b4d724330e5e3844b57e2979a4107bb7:b4621e28f40ee3c955f6033f2e33f7a6b4d724330e5e3844b57e2979a4107bb7": "This function tests the `summarize_chunked` function from the `summarize_utils` module by mocking its behavior. It sets up a temporary cache, defines a tokenizer, and calculates prompt overhead based on system and template prompts. The test asserts that the mock `_summarize` function is called more than once during the execution of `summarize_chunked`, indicating that the text was chunked and summarized multiple times to fit within the maximum context token limit.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_docgenerator.py:test_clean_output_dir:79b638d8c069833a596f79011f2f96da1d0b8e48769d40c687335fd1e72f5564:79b638d8c069833a596f79011f2f96da1d0b8e48769d40c687335fd1e72f5564": "The function `test_clean_output_dir` is a unit test for the `clean_output_dir` function in the `docgenerator` module. It uses a temporary directory provided by `tmp_path` to simulate an output directory for documentation files.\n\n1. The function creates a subdirectory named \"docs\" within the temporary path.\n2. Inside the \"docs\" directory, it creates three files: \"old.html\", \"custom.html\", and \"style.css\".\n3. It then calls the `clean_output_dir` function with the path to the \"docs\" directory as an argument.\n4. The test asserts that \"old.html\" has been deleted (it should not exist after cleaning), while \"custom.html\" and \"style.css\" still exist.\n\nThis test ensures that the `clean_output_dir` function correctly identifies and removes files that are considered generated by the documentation tool, leaving only custom and asset files intact.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_docgenerator.py:test_generates_class_and_function_summaries:51fce11fc2170dbe81ae582cc4c72eeb8f2f5b452bd4a215e449f5a27707f6fc:51fce11fc2170dbe81ae582cc4c72eeb8f2f5b452bd4a215e449f5a27707f6fc": "This function, `test_generates_class_and_function_summaries`, is a unit test for a code documentation tool. It checks if the tool correctly generates summaries for classes and functions within a Python project.\n\nThe test creates a temporary project directory with a single Python module (`mod.py`) containing a class `Foo` and a function `bar`. It then sets up a mock LLM client to simulate responses for summarizing different parts of the code, including the module, project, class, improved class documentation, function, and improved function documentation.\n\nThe test calls the main function with the path to the project directory and specifies an output directory. It asserts that the return value of the main function is 0, indicating success.\n\nAfter running the main function, the test reads the generated HTML files (`mod.html` and `index.html`) from the output directory and checks if they contain the expected summaries for the class and function, as well as the module.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_docgenerator.py:test_handles_class_without_docstring:6159abfc2a7591dd8b929a7b47c3585c768177c02e9b500fc2149d3091f0544a:6159abfc2a7591dd8b929a7b47c3585c768177c02e9b500fc2149d3091f0544a": "This function tests the handling of a Python class without a docstring. It creates a temporary project directory with a single module containing an empty class named `Foo`. The function then calls the `main` function with this project directory and specifies an output directory for the documentation. A mock LLM client is used to simulate responses during the summarization process, including summaries for the module, project, and class. After running the main function, it asserts that the return code is 0 (indicating success) and checks that the generated HTML file contains the expected summary for the class.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_docgenerator.py:test_merge_recurses_when_prompt_too_long:3453a74460c2ecb33b9279b858ad824eaff62c418932deb7dcd20466e572437c:3453a74460c2ecb33b9279b858ad824eaff62c418932deb7dcd20466e572437c": "This function tests the behavior of merging recursive calls when a prompt is too long. It sets up a fake summarization function to simulate responses from an LLM client, ensuring that the text length does not exceed the available context tokens. The test asserts that there are multiple merge calls specifically for docstring prompts, indicating that the system handles long prompts by breaking them down into manageable chunks and merging the results.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_docgenerator.py:test_processes_cpp_file:02009f6042553583ecf42acfa754cf6972d8064a5f19d7609bc33b749b2dc8a4:02009f6042553583ecf42acfa754cf6972d8064a5f19d7609bc33b749b2dc8a4": "This function, `test_processes_cpp_file`, is a unit test designed to verify the functionality of processing a C++ file within the DocGen-LM project. It uses Python's `unittest.mock` module to mock external dependencies such as a C++ parser and an LLM client.\n\nThe test sets up a temporary directory structure with a single C++ file named \"mod.cpp\" containing a simple function `add`. It then creates an output directory where the documentation will be generated.\n\nThe function calls the main entry point of the DocGen-LM project, passing the path to the project directory and specifying the output directory. It asserts that the return value of the main function is 0, indicating success.\n\nAdditionally, it verifies that the C++ parser was called exactly once with the expected arguments, ensuring that the file was correctly parsed.\n\nFinally, the test checks that an HTML file named \"mod.html\" has been created in the output directory, confirming that the documentation generation process completed successfully.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_docgenerator.py:test_processes_java_file:a2443948678f5876f1021f0eaeb2c2b4f750f1cfb20994b3ff26f5700ca170bb:a2443948678f5876f1021f0eaeb2c2b4f750f1cfb20994b3ff26f5700ca170bb": "The function `test_processes_java_file` is a unit test for processing Java files in the DocGen-LM project. It sets up a temporary directory, creates a sample Java file named `Mod.java`, and specifies an output directory for documentation. The function then mocks the `parse_java_file` function to return predefined parsed data and configures an LLM client mock to simulate successful ping and summary generation. When calling the `main` function with the project directory and output path, it asserts that the return value is 0 (indicating success) and that the `parse_java_file` function was called once. Finally, it checks that a generated HTML file exists in the output directory.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_docgenerator.py:test_project_summary_is_sanitized:a4fa5de4d07718e4aeaaf384c4e3dcfb290ca10b2e515d839254f9a0c82c6ac7:a4fa5de4d07718e4aeaaf384c4e3dcfb290ca10b2e515d839254f9a0c82c6ac7": "This function `test_project_summary_is_sanitized` is designed to test the functionality of a code documentation tool, specifically focusing on sanitization and summarization processes. It uses a temporary directory to create a mock project structure with a Python module containing a simple function. The function then invokes the main documentation generation process using a mocked LLM client that simulates responses for different types of summaries. After running the main function, it checks if the output HTML file does not contain certain unwanted text (\"You can run this\") and contains expected content (\"It prints.\"). It also verifies that the LLM client was called with the correct arguments to generate project summaries.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_docgenerator.py:test_readme_summary_used:fa87feed8319855a96898a1f9ebcf88d26dfe2529d7bf32d1febe694a96fd18f:fa87feed8319855a96898a1f9ebcf88d26dfe2529d7bf32d1febe694a96fd18f": "The function `test_readme_summary_used` is a unit test for the `main` function of the DocGen-LM project. It sets up a temporary directory structure with a Python module and a README file, then calls the `main` function with the path to this directory and an output directory specified. The test uses a mock LLM client to simulate responses from the client during the summarization process. After running the main function, it checks that the return value is 0 (indicating success), that the HTML output contains the summary of the README file, and that the LLM client was called with \"readme\" as one of its arguments.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_docgenerator.py:test_single_long_partial_is_recursively_chunked:52dc98efb442c50394358c6a3ae975ff5bb158c01d3c472bbaa357dc782bdfad:52dc98efb442c50394358c6a3ae975ff5bb158c01d3c472bbaa357dc782bdfad": "This function `test_single_long_partial_is_recursively_chunked` tests the functionality of recursively chunking and summarizing text using a mock LLM client. It sets up a temporary cache, defines a tokenizer, and configures prompt templates. The function then simulates responses from an LLM client to ensure that long texts are correctly split into chunks based on token budget constraints. Finally, it asserts that the number of calls made to summarize docstrings exceeds one, indicating successful chunking and summarization.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_docgenerator.py:test_skips_invalid_python_file:087f8dcd1d4deed37cdfe737ce361871fc7d4381fa21bef10fc7f854b53a76e3:087f8dcd1d4deed37cdfe737ce361871fc7d4381fa21bef10fc7f854b53a76e3": "This function, `test_skips_invalid_python_file`, is designed to test the behavior of a code documentation tool when encountering an invalid Python file. It uses a temporary directory to create a project structure with a single Python file that contains invalid syntax (leading zero in an integer). The function then simulates the interaction with an LLM client using a mock object, which returns a predefined summary for valid files and skips processing of invalid files. After running the main documentation generation function, it asserts that only the index page is generated, while no HTML file is created for the invalid Python file.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_docgenerator.py:test_skips_non_utf8_file:4beda7a52ef5fdcfaf4f56890adc296d6dc04ef894bff184ca386dbe8fd20348:4beda7a52ef5fdcfaf4f56890adc296d6dc04ef894bff184ca386dbe8fd20348": "The function `test_skips_non_utf8_file` is a unit test for the `main` function in the `docgenerator` module. It checks that non-UTF-8 encoded files are skipped during documentation generation.\n\nHere's what the function does:\n\n1. Creates a temporary project directory with a non-UTF-8 file named `bad.py`.\n2. Sets up a mock LLM client to simulate successful ping and summary responses.\n3. Calls the `main` function with the path to the project directory and an output directory for documentation.\n4. Asserts that the return value of `main` is 0, indicating success.\n5. Verifies that the index HTML file exists in the output directory.\n6. Ensures that a non-UTF-8 HTML file does not exist in the output directory.\n\nThis test ensures that the `main` function correctly handles and skips non-UTF-8 encoded files during documentation generation.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_docgenerator.py:test_structured_chunker_keeps_functions_atomic:58ff55370f6b6c17da660d1695337b104bf548f168c4d413dd637794e6652d61:58ff55370f6b6c17da660d1695337b104bf548f168c4d413dd637794e6652d61": "The function `test_structured_chunker_keeps_functions_atomic` tests the `_summarize_module_chunked` function to ensure it correctly handles Python functions as atomic chunks. It creates a temporary Python file with two functions, parses it using `parse_python_file`, and then uses a mock for `_summarize` to simulate text generation. The test checks that the function is called twice, once for each function in the module, and that the chunked sources match the original function sources.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_docgenerator.py:test_structured_chunker_splits_large_class_by_method:311d4cc82096b6f80e2f0c22a513d37a2c3625d29d5ddd75de03e7fcb0edacc2:311d4cc82096b6f80e2f0c22a513d37a2c3625d29d5ddd75de03e7fcb0edacc2": "This function tests the `test_structured_chunker_splits_large_class_by_method` function, which is designed to split a large Python class into smaller chunks based on its methods. It uses a temporary file to store the source code of a class with two methods (`a` and `b`). The function then parses this file using the `parse_python_file` function from the `parser_python` module.\n\nThe test sets up a tokenizer, cache, and mock for the `_summarize` function. It calculates the budget for tokenization based on the length of the class source code and additional overhead for system prompts and prompt templates. The `_summarize_module_chunked` function is called with these parameters to split the class into chunks.\n\nThe test asserts that the number of chunks generated matches the number of methods in the class and that each chunk corresponds to a method's source code.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_docgenerator.py:test_subclass_methods_are_summarized:afdb631b3f4ff9bc9037e1f3e792db1648b30a5a30e55f1dcc8c0f6eadcd6781:afdb631b3f4ff9bc9037e1f3e792db1648b30a5a30e55f1dcc8c0f6eadcd6781": "This function `test_subclass_methods_are_summarized` is designed to test the functionality of a code documentation tool, specifically its ability to summarize methods within subclasses. It uses Python's `unittest.mock.patch` to simulate interactions with an LLM client and internal summarization functions.\n\nThe function sets up a temporary project directory containing a Python file with a nested class structure (`class A` containing `class B`, which contains method `m`). It then calls the `main` function of the documentation tool, passing the path to this project directory and specifying an output directory for the generated documentation.\n\nDuring the execution, it mocks the LLM client's ping method to return `True` and patches two summarization functions (`_summarize` and `_summarize_chunked`) to return a predefined summary string. The function asserts that the method `m` within subclass `B` is being passed to the chunked summarization function, indicating that it has been detected and processed by the documentation tool.\n\nThe test concludes by asserting that the return value of the `main` function is `0`, suggesting successful execution.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_docgenerator.py:test_summarize_chunked_splits_long_text:486cbe7605729ff424a8570b54ac7a7f08af0ac20c07c3d78bb79c9fcbb09b69:486cbe7605729ff424a8570b54ac7a7f08af0ac20c07c3d78bb79c9fcbb09b69": "This function, `test_summarize_chunked_splits_long_text`, tests the functionality of summarizing long texts by splitting them into chunks. It uses a temporary path for caching results and patches the `_summarize` method to return a predefined summary. The test ensures that the text is split into multiple chunks and summarized individually, with the total number of calls to `_summarize` being greater than one.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_docgenerator_subclasses.py:77a42c49a04297507d96ac281add639b0c5692b2d65f55a79c7ca6a88ffafbb8:77a42c49a04297507d96ac281add639b0c5692b2d65f55a79c7ca6a88ffafbb8": "This module defines a test function `test_subclass_docs_and_method_summary` that uses the `unittest.mock.patch` decorator to mock an `LLMClient`. The function creates a temporary project directory with a Python file containing a subclass and a method. It then calls the `main` function from the `docgenerator` module, passing in the path to the project directory and specifying an output directory for documentation. The test asserts that the return value of the `main` function is 0, indicating success. It also checks that the generated HTML documentation contains summaries for the class and method, as expected.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_docgenerator_subclasses.py:test_subclass_docs_and_method_summary:8a28b697aad62542e4496c002f365789ab985057d3045ff888a5f0b781136354:8a28b697aad62542e4496c002f365789ab985057d3045ff888a5f0b781136354": "This function `test_subclass_docs_and_method_summary` tests the generation of documentation for subclasses and methods within a Python project. It creates a temporary project directory with a nested class structure, invokes the main documentation generation process using a mock LLM client to simulate text summarization, and verifies that the generated HTML output contains summaries for the subclass and its method.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:_create_fixture:073fff36c471c89c06de6b290d45fc02fdb715fd292db77e7973ff2708a74d8c:073fff36c471c89c06de6b290d45fc02fdb715fd292db77e7973ff2708a74d8c": "This function `_create_fixture` creates a temporary directory structure and files for testing purposes. It generates a nested directory with an HTML file and populates it with various types of content, including a README.md file formatted in Markdown and a sample JSON file. The function uses the `tmp_path` parameter to specify the root directory for creating these files, ensuring that they are stored in a temporary location suitable for testing environments.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:_mock_llm_client:aba6e4be6ddad83fdc6d0376e69008888147c887a65a520e768c950544aeb346:aba6e4be6ddad83fdc6d0376e69008888147c887a65a520e768c950544aeb346": "The `_mock_llm_client` function returns an object that simulates an LLM client. This mock client has a `summarize` method, which takes three parameters: `text`, `prompt_type`, and an optional `system_prompt`. The method returns a predefined summary string formatted using `textwrap.dedent`.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:b255f1cfcf5befe8f902b371186dba71f3dfbd8c11c42e932622e99a953d6bf9:merge0:75cb71a73ad49268e3e8c807910f32bc14a8d969f4b63ededaa17d5a03585442": "The module provides a comprehensive suite of functions and tests for creating documentation summaries, extracting text from files, rendering HTML content, and handling various file formats. It includes a mock LLM client for summarization purposes and tests for scenarios such as Markdown, HTML, and DOCX files, as well as generating user manuals in both HTML and PDF formats. The module also contains functions for collecting documentation files, mapping evidence to sections, detecting placeholders, parsing manual content, validating references, inferring sections from context, and extracting snippets from code files. Additionally, it features test functions for a code documentation tool, covering functionalities like categorizing code snippets, ranking code files, filling placeholders in user manuals, handling different file types (e.g., Python, C++, Java), skipping or forcing code scans based on flags, and inserting generated documentation into existing index files. The tests use mock objects and assertions to ensure the correctness of implemented functions. Furthermore, it includes test functions for a summarization process that verify aspects such as chunking, caching, and logging. These tests utilize a mock client to simulate API calls and confirm that the summarization process operates correctly, with checks on output accuracy and appropriate system prompts. Some tests also validate caching functionality by re-running the summarization with identical input to ensure no new API calls are made.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:b255f1cfcf5befe8f902b371186dba71f3dfbd8c11c42e932622e99a953d6bf9:part0:5516db775b429103a40dd2a03a766cbe0e39e0bdb1b12007edef2db075c1950b": "The module defines several functions and tests for creating documentation summaries, extracting text from files, rendering HTML content, and handling different file formats. It includes a mock LLM client for summarization purposes and tests for various scenarios such as handling Markdown, HTML, and DOCX files, as well as generating user manuals in both HTML and PDF formats. The module also contains functions for collecting documentation files, mapping evidence to sections, detecting placeholders, parsing manual content, validating references, inferring sections from context, and extracting snippets from code files.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:b255f1cfcf5befe8f902b371186dba71f3dfbd8c11c42e932622e99a953d6bf9:part1:f6168ffd0c53de3b16c7a9eebf313f1905a2585db880dd3c97d8a20c97080ce6": "The module contains several test functions for a code documentation tool. It tests functionalities such as categorizing code snippets, ranking code files, filling placeholders in user manuals, handling different file types (e.g., Python, C++, Java), skipping or forcing code scans based on flags, and inserting generated documentation into existing index files. The tests use mock objects and assertions to verify the correctness of the implemented functions.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:b255f1cfcf5befe8f902b371186dba71f3dfbd8c11c42e932622e99a953d6bf9:part2:6bbe7d26a85f376316a924b9f7e5d33cb08b1ccb650e5cc867902d439ce763e3": "The module contains several test functions for a summarization process. Each function tests different aspects of the summarization logic, including chunking, caching, and logging. The tests use a mock client to simulate API calls and verify that the summarization process behaves as expected. They also check if the output is correct and if the system prompts are used appropriately. Additionally, some tests ensure that caching works correctly by re-running the summarization with the same input and verifying that no new API calls are made.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:test_cached_chunks_reused:0108c9b0500081f18d581caf7d98f55b1fb2a207f4ab73b9e44aeed7f8bf14e4:0108c9b0500081f18d581caf7d98f55b1fb2a207f4ab73b9e44aeed7f8bf14e4": "This function `test_cached_chunks_reused` tests the caching mechanism in a code documentation tool. It creates a dummy client and cache file to simulate interactions with an LLM client. The function generates a large text by repeating a paragraph, then uses this text to call a manual summarization function twice. The first call populates the cache, and subsequent calls reuse the cached results, demonstrating that the caching mechanism is working as expected.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:test_chunk_edit_hook_applied:dbdaaffb8cfd251279cce35c4003c53301f3c6ff7eba4dd7eaffb4295aad277b:dbdaaffb8cfd251279cce35c4003c53301f3c6ff7eba4dd7eaffb4295aad277b": "This function tests the application of a chunk editing hook during code summarization. It creates a large text input with two paragraphs, simulates a client that records calls and modifies text based on prompts, defines a hook to convert chunks to uppercase, and uses a response cache. The function asserts that after processing, the final result is \"final\" and that the last call to the client's `summarize` method has its text converted to uppercase.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:test_chunking_none_no_llm_calls:f397f0a279596b8533776a3a8475e607e87c2399f877bf1ea1e16464a62c0009:f397f0a279596b8533776a3a8475e607e87c2399f877bf1ea1e16464a62c0009": "This function tests the behavior of a code documentation tool when chunking is disabled and no LLM calls are expected. It creates a large text file named \"README.md\" with a specific structure, initializes a dummy class to simulate LLM client interactions, and then runs the main function with specified arguments. The test asserts that the dummy class's `summarize` method was called five times and checks if the system prompt contains the word \"Overview\".",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:test_chunking_triggers_multiple_calls_and_logs:a1ea69eb9dd224617865271d9486a6500f7d554307aa57ea44c5891a38718452:a1ea69eb9dd224617865271d9486a6500f7d554307aa57ea44c5891a38718452": "This function tests the chunking and merging functionality of a code summarization system. It creates a mock client that records calls to its `summarize` method, simulating interactions with an LLM. The test provides a large text input split into two paragraphs. The `manual_utils._summarize_manual` function is called with this text, using the \"auto\" chunking strategy and a source identifier of \"src\". The function should make multiple calls to the client's `summarize` method, each time processing a chunk of the text, followed by a final merge call. The test asserts that the result from the final merge is \"final\", that three calls were made (two chunks plus one merge), and that all chunk calls use the `CHUNK_SYSTEM_PROMPT`, while the merge call uses the `MERGE_SYSTEM_PROMPT`. Additionally, it checks that the output captured by `capsys` includes messages indicating the start of each chunk and the length of the merged LLM response.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:test_collect_docs_filters:89ea9cb0ce3a573abb2b4b41e971d138590feafd5bf753db183d4af15912d735:89ea9cb0ce3a573abb2b4b41e971d138590feafd5bf753db183d4af15912d735": "This function `test_collect_docs_filters` is designed to test the functionality of collecting documentation files from a specified directory while applying filters. It uses a temporary path provided by `tmp_path` to create a structured directory with various file types, including Markdown (`md`) and text (`txt`). The function then calls `explaincode.collect_docs(tmp_path)` to collect the documentation files. After collecting, it checks if the expected files are present in the result and ensures that filtered out files are not included. Specifically, it verifies that \"keep.md\" is collected while \"skip.txt\" is excluded from the results.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:test_custom_output_directory:320724ce76ea6d8e5d4446da0b2c88ef20e28be19d67e102c9192de73799e461:320724ce76ea6d8e5d4446da0b2c88ef20e28be19d67e102c9192de73799e461": "This function tests the functionality of generating documentation in a custom output directory. It creates a temporary path, sets up a mock LLM client using `monkeypatch`, and then runs the main function with specified input and output paths. The test asserts that the expected HTML and evidence JSON files are generated in the custom output directory.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:test_custom_title_and_filename:8d0f82238e1b3f811a13fe4a51b7beebbd311c41fad2726ee13f09e8fc483f36:8d0f82238e1b3f811a13fe4a51b7beebbd311c41fad2726ee13f09e8fc483f36": "This function tests the generation of HTML documentation with a custom title and filename. It creates a test fixture, mocks an LLM client, runs the main function with specified path and title, and verifies that the output file exists, contains the correct title, and includes evidence data in JSON format.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:test_detect_placeholders:5c7248bf2fe861e781dfe152dec574b435a042ba71e776d1cb3ae1dc97366844:5c7248bf2fe861e781dfe152dec574b435a042ba71e776d1cb3ae1dc97366844": "The function `test_detect_placeholders` is designed to test the capability of a hypothetical module named `explaincode` to detect placeholders within a given text. The function takes a string `text` as input, which contains specific placeholder patterns such as `[[NEEDS_OVERVIEW]]` and `[[NEEDS_OUTPUTS]]`. It then calls the `detect_placeholders` method from the `explaincode` module with this text.\n\nThe purpose of `detect_placeholders` is to identify all occurrences of placeholder patterns in the input text. The function asserts that the set of detected placeholders matches a predefined set containing \"Overview\" and \"Outputs\". This test ensures that the `detect_placeholders` method correctly identifies and returns the expected placeholders from the provided text.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:test_docs_index_default_and_injection:a8278b33087dcf26dde266dc6e5c73d80b2cac3c9974120e16833c6d1a9caba1:a8278b33087dcf26dde266dc6e5c73d80b2cac3c9974120e16833c6d1a9caba1": "The function `test_docs_index_default_and_injection` tests the generation of documentation index and manual insertion. It creates a temporary directory, sets up an HTML file with a navigation section, mocks an LLM client, runs the main documentation generation process with specified options, and asserts the creation of user manual files and their presence in the navigation menu.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:test_extract_snippets_skips_large_file:9fd599027958d95218dc6edb2759c58b324bbe36ccf8f4a1f4907669748eee13:9fd599027958d95218dc6edb2759c58b324bbe36ccf8f4a1f4907669748eee13": "This function tests the `extract_snippets` function from the `explaincode` module. It creates a large Python file (`big.py`) with 210,000 bytes of content. The test sets up logging to capture INFO level messages and then calls `extract_snippets` with this large file, specifying a maximum number of files (1), time budget (5 seconds), and maximum byte size (200,000 bytes). The function is expected to skip processing the large file because its size exceeds the specified limit. The test asserts that the large file is not included in the returned snippets and checks that an INFO level log message indicating a file size limit exceeded is present.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:test_extract_text_docx_preserves_headings:3a6912f94c39c810eab5764239fdc658e49b3056d799df5ecf0f48d22b05e8bb:3a6912f94c39c810eab5764239fdc658e49b3056d799df5ecf0f48d22b05e8bb": "This function tests the `extract_text` function from the `explaincode` module to ensure it correctly extracts and formats text, including headings, from a DOCX file. It creates a temporary DOCX document with a heading and a paragraph, saves it, and then uses the `extract_text` function to read the content. The test asserts that the extracted text starts with the formatted heading (`# Title`) and contains the plain text (\"Text\").",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:test_extract_text_html_preserves_headings_and_code:00a6649227af46a2ee620b80ca178df5764cbb7dc44fbfc5f3d8c2d2d7e3e31e:00a6649227af46a2ee620b80ca178df5764cbb7dc44fbfc5f3d8c2d2d7e3e31e": "The function `test_extract_text_html_preserves_headings_and_code` is designed to test the functionality of extracting text from HTML files while preserving headings and code snippets. It creates a temporary HTML file with specific headings (`<h1>`, `<h2>`) and a code block (`<pre><code>`). The function then uses `explaincode.extract_text` to extract the text content from this HTML file and asserts that the extracted text contains the preserved headings and code snippet, formatted as markdown.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:test_extract_text_markdown_preserves_headings_and_code:48d73f5d44723fcfaa418df13d7843d84ac04f5ab7128b7729a9df114ab31977:48d73f5d44723fcfaa418df13d7843d84ac04f5ab7128b7729a9df114ab31977": "This function tests the `extract_text` method from the `explaincode` module to ensure it correctly extracts and preserves headings and code blocks from a Markdown file. It creates a temporary Markdown file with a title, some plain text, and a Python code block. The function then reads this file, extracts its content using `explaincode.extract_text`, and asserts that the extracted text contains the original heading and code block intact.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:test_force_code_flag_triggers_code_fallback:211b0314c802253e9d866b6a03427e7d6cef1d0448e72d761600a65916323a08:211b0314c802253e9d866b6a03427e7d6cef1d0448e72d761600a65916323a08": "This function tests the behavior of a code documentation tool when the `--force-code` flag is used. It sets up a temporary directory, mocks certain functions to simulate specific behaviors (ranking files and extracting snippets), and then runs the main function with the `--force-code` flag. The test checks that the mocked functions are called once, logs the expected messages indicating that the code scan was triggered and completed successfully without missing sections.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:test_full_docs_no_code_scan:342f814de60d8324a79001eafb33918cb3b1b5646234037a0b4c37891e45adf9:342f814de60d8324a79001eafb33918cb3b1b5646234037a0b4c37891e45adf9": "This function `test_full_docs_no_code_scan` is a test case for the DocGen-LM documentation generator. It verifies that the system correctly handles cases where code scanning is not needed, by mocking relevant functions and checking the output logs.\n\nThe test performs the following steps:\n1. Creates a temporary directory fixture using `_create_fixture`.\n2. Initializes a tracker dictionary to monitor function calls.\n3. Defines mock functions `fake_rank` and `fake_extract` that update the tracker and return predefined results.\n4. Uses `monkeypatch` to replace actual functions in the `explaincode` module with these mocks, including an LLM client mock.\n5. Sets up logging capture to monitor log messages.\n6. Calls the main function of DocGen-LM with a specified path and code scanning option.\n7. Asserts that the mocked functions were not called (i.e., `rank_code_files` and `extract_snippets`).\n8. Verifies that the expected log messages \"DOC PASS\" and \"Code scan skipped\" are present in the captured logs.\n\nThis test ensures that the system behaves correctly when code scanning is unnecessary, focusing on documentation generation without additional code analysis.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:test_graceful_missing_docx:6f2b994eee896089adfd7e1c93858f37d535e9ce6edd1186297fb1e1c788c1ec:6f2b994eee896089adfd7e1c93858f37d535e9ce6edd1186297fb1e1c788c1ec": "This function tests the graceful handling of missing `docx` library in a Python project. It creates a temporary directory, attempts to import and use the `Document` class from the `docx` module to create a simple document if the module is available. If the module is not available, it sets the `Document` variable to `None`. The function then uses `monkeypatch` to mock the `Document` and `LLMClient` classes in the `explaincode` module with `_mock_llm_client`. It runs the `main` function with a specified path to the temporary directory. Finally, it asserts that two files, \"user_manual.html\" and \"user_manual_evidence.json\", are created in the temporary directory, indicating successful documentation generation even without the `docx` library.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:test_hierarchical_merge_logged:a815a99e60544d270523a4309819a82c986e0f625694f0b663945273b04e7b9e:a815a99e60544d270523a4309819a82c986e0f625694f0b663945273b04e7b9e": "This function `test_hierarchical_merge_logged` is a unit test for the `_summarize_manual` function from the `manual_utils` module. It uses a mock client and response cache to simulate interactions with an LLM client. The test checks that the summary text is correctly truncated after three calls, logs the hierarchical merge pass, and captures the output using `capsys`.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:test_html_summary_creation:531f2a73e8c3d83e7a87d04ea243fcec9d7b4451103525ac0c71d97fb3642e74:531f2a73e8c3d83e7a87d04ea243fcec9d7b4451103525ac0c71d97fb3642e74": "This function `test_html_summary_creation` is designed to test the creation of HTML summaries for a project using the DocGen-LM tool. It performs the following steps:\n\n1. Creates a temporary directory and populates it with fixture data.\n2. Mocks the LLMClient class from the explaincode module to simulate interactions with a local language model.\n3. Runs the main function of the DocGen-LM tool, specifying the path to the temporary directory.\n4. Verifies that the `user_manual.html` and `user_manual_evidence.json` files are created in the temporary directory.\n5. Reads the JSON evidence file to check if it contains an \"Overview\" section with associated evidence.\n6. Reads the HTML summary file and ensures it does not contain the placeholder text \"No information provided.\"\n7. Uses BeautifulSoup to parse the HTML and checks for the presence of a navigation (`nav`) element containing a link to the \"Overview\" section.\n\nThe function asserts that all these conditions are met, indicating successful creation of the HTML summary with an expandable overview section.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:test_infer_sections_infers_entries:198aa2b21c9029dc555a2c8605e756d632319af4186c45ccb316ba0bbdebd732:198aa2b21c9029dc555a2c8605e756d632319af4186c45ccb316ba0bbdebd732": "The function `test_infer_sections_infers_entries` tests the `infer_sections` function from the `explaincode` module. It asserts that the returned dictionary contains an \"Overview\" key with a value equal to the input context and other keys (excluding \"Overview\") ending with \"(inferred)\". The test also ensures that the string \"No information provided.\" is not present in any of the section values combined.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:test_infer_sections_no_context_defaults:9027bd3f05cb22cc2a5b5a407dee54cc4488fa63f25c06b985235b5bda4bbd7e:9027bd3f05cb22cc2a5b5a407dee54cc4488fa63f25c06b985235b5bda4bbd7e": "The function `test_infer_sections_no_context_defaults` tests the behavior of the `infer_sections` function from the `explaincode` module when no context is provided. It asserts that if an empty string is passed to `infer_sections`, all values in the returned dictionary are equal to \"No information provided.\"",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:test_insert_into_index:e7807a66ea9108adfe56ddb17cafb260623e9519af998e91dd2c6a6d54373964:e7807a66ea9108adfe56ddb17cafb260623e9519af998e91dd2c6a6d54373964": "This function `test_insert_into_index` is a unit test for inserting links into an HTML index file. It uses the `pytest` framework and requires a temporary directory (`tmp_path`) and a monkeypatch object to mock external dependencies.\n\nThe function performs the following steps:\n1. Creates a fixture using `_create_fixture(tmp_path)`.\n2. Sets up an output directory within the temporary path.\n3. Initializes an HTML index file with basic structure in the output directory.\n4. Mocks the `LLMClient` from the `explaincode` module to use a custom mock client (`_mock_llm_client`).\n5. Calls the `main` function with specific command-line arguments to insert links into the index file.\n6. Reads the updated HTML content of the index file.\n7. Asserts that a link to \"User Manual\" is present in the HTML content, indicating successful insertion.\n\nThis test ensures that the functionality for inserting links into an HTML index file works as expected when invoked with specific command-line options.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:test_insert_into_root_index:60129d8cbc72918aaeb979a189f26dafe1d2eee2fd71396bd7d9ef1fae521bdd:60129d8cbc72918aaeb979a189f26dafe1d2eee2fd71396bd7d9ef1fae521bdd": "This function tests the insertion of a user manual into an HTML index file. It creates a temporary directory, sets up a mock LLM client, runs the main function with specified arguments to insert the manual, and then verifies that the manual and evidence files exist in the correct location. It also checks if the navigation element in the index.html file contains a link to the user manual.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:test_llm_fill_placeholders_per_section_logging:d3cfd91b90b3fd4da1d7b11a83cabe7b6180e868b28bf7fc582f19b6f9bda91d:d3cfd91b90b3fd4da1d7b11a83cabe7b6180e868b28bf7fc582f19b6f9bda91d": "This function, `test_llm_fill_placeholders_per_section_logging`, is a unit test for the `llm_fill_placeholders` function within the `explaincode` module. It uses a dummy client to simulate interactions with an LLM and a cache to store responses. The test ensures that placeholders in the manual are correctly filled based on evidence from input and output files, and that logging captures the process of filling these placeholders.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:test_map_evidence_overview_priority_and_filters:305f1d6dae42b0be78d7736d2d26c72bf03037c2d001fb0f4c92719c3376e7f1:305f1d6dae42b0be78d7736d2d26c72bf03037c2d001fb0f4c92719c3376e7f1": "The function `test_map_evidence_overview_priority_and_filters` is designed to test the functionality of mapping evidence (documentation files) to sections based on their content and priority. It uses a dictionary `docs` where keys are file paths and values are the contents of those files. The function then calls `explaincode.map_evidence_to_sections` with this dictionary, which presumably processes the documentation files and returns a section map.\n\nThe test asserts that certain files (those under \"tests\", \"examples\", and \"fixtures\" directories) should not be included in the \"Overview\" section. It also checks that the first two files in the \"Overview\" section are \"README.md\" and \"docs/guide.md\", and that the third file is \"src/other.md\". This ensures that the mapping prioritizes certain types of documentation files while excluding others based on their paths.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:test_map_evidence_snippet_limits:c7ef4d401902eba9db03d6ead7a79c99149dbc604d34b666fb39fb4f513d7794:c7ef4d401902eba9db03d6ead7a79c99149dbc604d34b666fb39fb4f513d7794": "This function `test_map_evidence_snippet_limits` tests the functionality of mapping evidence to sections within a document, specifically focusing on snippet limits. It creates two files with varying amounts of content and uses the `explaincode.map_evidence_to_sections` function to map evidence to sections. The test asserts that lines exceeding the maximum allowed snippet length are not included in the mapped snippets for the long file, while the last line within the limit is present. Additionally, it checks that the short file's snippet contains only the section header \"# Inputs\".",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:test_missing_run_triggers_code_fallback_with_limits:89f9aab8cd6bbeb0a37390d9aac391b85f00ab066f375890548031bf4614c8d3:89f9aab8cd6bbeb0a37390d9aac391b85f00ab066f375890548031bf4614c8d3": "This function tests the behavior of a documentation generation system when it encounters a README file without run instructions and needs to fallback to code snippets. It sets up a mock environment with dummy classes and functions to simulate the system's interactions with an LLM client, ranking files, and extracting code snippets. The test asserts that the system correctly identifies missing run instructions, uses code from a specified file to fill in the gap, and logs the process.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:test_no_code_flag_skips_code_fallback:81e69e16b77b9913dd6d630d493a3af6f174f6e449b174ea11e78af49f5975fe:81e69e16b77b9913dd6d630d493a3af6f174f6e449b174ea11e78af49f5975fe": "The function `test_no_code_flag_skips_code_fallback` is a unit test for a code documentation tool. It verifies that when the `--no-code` flag is used, the tool skips the code scanning and generation process. The test sets up a temporary directory with a README file, mocks the LLMClient to return a predefined summary, and uses monkeypatch to replace functions responsible for ranking and extracting code snippets with dummy implementations that do not perform any actions. It then calls the `main` function with specific arguments and checks that the `rank_code_files` and `extract_snippets` functions were not called, indicating that the code scanning was skipped as expected. The test also asserts that a log message confirming the skip of code scanning is present in the output.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:test_parallel_chunk_summarization:eed3c779e25cf05b274f5d8cf1e551a0f0f04d7e3e4872b030f995ecf1f4c108:eed3c779e25cf05b274f5d8cf1e551a0f0f04d7e3e4872b030f995ecf1f4c108": "The function `test_parallel_chunk_summarization` is designed to test the performance of parallel chunk summarization using a mock LLM client and a response cache. It creates a large text input by repeating a paragraph multiple times, simulates a slow LLM client that introduces a delay when processing specific system prompts, and measures the time taken to summarize the text using manual utilities. The test asserts that the total duration of the summarization process is less than twice the delay introduced by the mock client, ensuring that the caching mechanism effectively reduces the number of calls to the LLM client.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:test_parse_manual_infers_missing_sections:fc70c5e7ecaac5b3a6d3b22cce8e43bf114b69b43cd26ade845f752061c32c45:fc70c5e7ecaac5b3a6d3b22cce8e43bf114b69b43cd26ade845f752061c32c45": "This function tests the `parse_manual` function from the `explaincode` module. It uses a stub client that returns a guessed summary for any prompt. The function is tested with an input string \"Overview: hi\" and a client instance. The test asserts that the output dictionary contains the expected \"Overview\" key with the value \"hi\". It also checks that the \"Inputs\" key ends with \"(inferred)\" and does not contain the string \"No information provided.\"",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:test_pdf_summary_creation:b5c9f98e9b8cd07ea109db9ecd3e31666ff9d2e655a514be4a7b9852065976eb:b5c9f98e9b8cd07ea109db9ecd3e31666ff9d2e655a514be4a7b9852065976eb": "This function tests the creation of a PDF summary for a project. It first checks if the `reportlab` library is installed, skipping the test if it's not. Then, it creates a fixture using `_create_fixture` and sets up a mock LLM client with `_mock_llm_client`. The `main` function is called with the specified path and output format set to \"pdf\". Finally, it asserts that both the PDF file (`user_manual.pdf`) and the evidence JSON file (`user_manual_evidence.json`) exist in the temporary path.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:test_rank_code_files_supports_cpp_h_java:e4c4ca93f6eb72d58933ddeab4710732986eab9af8f6fd79af91b136a9ced5a6:e4c4ca93f6eb72d58933ddeab4710732986eab9af8f6fd79af91b136a9ced5a6": "This function tests the `rank_code_files` function from the `explaincode` module to ensure it correctly identifies and ranks C++ header files (`*.h`) along with Python, Java, and C++ source files. It creates a temporary directory with various file types, including an ignored text file, writes empty content to each file, and then calls `rank_code_files`. The function asserts that the ranked list contains only the expected code files (Python, C++, Java, and C++ header files) and excludes the ignored text file.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:test_render_html_includes_toc_and_sources_block:81da325a43a0b76b315b67efc7e6fb7cb99d4215107e5a54c551575469db923a:81da325a43a0b76b315b67efc7e6fb7cb99d4215107e5a54c551575469db923a": "This function tests the rendering of HTML documentation to ensure it includes a table of contents (TOC) and blocks for source code snippets. It creates a mock dictionary of sections and evidence, then calls `explaincode.render_html` with these inputs along with a title \"Manual\". The rendered HTML is parsed using BeautifulSoup to check that:\n\n1. A `<nav>` element exists containing a link (`<a>`) to the \"Overview\" section.\n2. Multiple `<div>` elements with class \"sources\" are present, each containing text from either \"readme.md\" or \"run.py\".",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:test_render_html_renders_markdown_headings_and_code:e344e3128bbad892a250f726af6cf026fdea850ff588784f931b91ef8f5d9b28:e344e3128bbad892a250f726af6cf026fdea850ff588784f931b91ef8f5d9b28": "This function tests the `render_html` method from the `explaincode` module. It creates a dictionary of sections where each key-value pair represents a section title and its corresponding Markdown content, including Python code. The function then calls `render_html` with these sections and a document type \"Manual\". After rendering, it uses BeautifulSoup to parse the generated HTML. The test checks if an `<h1>` tag with the text \"Title\" exists in the HTML and if there is a `<code>` block containing the string \"print('hi')\".",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:test_scan_code_categorizes_snippets:f7c18b0bf9afc7efb82edbe314632464a82f5f89a84ca2dd8fa1bd7bdce7a439:f7c18b0bf9afc7efb82edbe314632464a82f5f89a84ca2dd8fa1bd7bdce7a439": "The function `test_scan_code_categorizes_snippets` is a test case designed to verify the functionality of the `scan_code` method from the `explaincode` module. It uses a temporary directory and monkeypatching to simulate the behavior of the `collect_docs`, `rank_code_files`, and `extract_snippets` functions.\n\nThe test sets up three Python files in a temporary directory, then mocks these functions to return predefined values:\n- `collect_docs` returns an empty list.\n- `rank_code_files` returns all paths in the temporary directory.\n- `extract_snippets` categorizes each file based on its content into \"Inputs\", \"Outputs\", and \"How to Run\".\n\nThe function then calls `scan_code` with specified categories, maximum files, time budget, and maximum bytes per file. The test asserts that the results match the expected categorized snippets for each file.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:test_scan_code_skips_non_source_dirs:f4d8d69ec97ce1609b9969e75484fccff0a0f411216789c5165917ecdd6784fc:f4d8d69ec97ce1609b9969e75484fccff0a0f411216789c5165917ecdd6784fc": "This function tests the `scan_code` method from the `explaincode` module. It creates a temporary directory structure with source files, test files, and example files. The `monkeypatch` is used to mock the `collect_docs` function so that it returns an empty list. The `scan_code` method is then called with the temporary path, a list containing \"How to Run\", and various parameters such as maximum files, time budget, and maximum bytes per file. The result of the scan is checked to ensure that only the source file (`src/main.py`) is included under the \"How to Run\" key.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_explaincode.py:test_validate_manual_references_flags_missing:9fe9512ad757fa2f9765500e6ee8f7c7123242214afc8a44636dc3c40d554908:9fe9512ad757fa2f9765500e6ee8f7c7123242214afc8a44636dc3c40d554908": "The function `test_validate_manual_references_flags_missing` is designed to test the functionality of validating manual references within a project. It creates a temporary directory, writes a Python file named \"exists.py\" with content \"pass\", and sets up a dictionary `sections` containing an overview section that mentions both \"exists.py\" and \"missing.py\". The function then calls `explaincode.validate_manual_references` with the sections, temporary path, and evidence dictionary. After validation, it asserts that \"exists.py\" is included in the overview, \"missing.py [missing]\" is added to indicate a missing reference, and that the evidence dictionary correctly lists \"missing.py\" as a missing reference.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_html_writer.py:0d328a8316d6c274a1a52fe5b14bcec61ffc9bd273ede38f7dc2f101ba757cc7:0d328a8316d6c274a1a52fe5b14bcec61ffc9bd273ede38f7dc2f101ba757cc7": "This module defines functions to generate HTML documentation for Python modules, including indices and individual module pages. It uses the `html_writer` module for HTML generation. The module includes tests to ensure that the generated HTML is correct, covering various aspects such as rendering of links, summaries, variables, classes, methods, and nested structures like subfunctions and subclasses. Additionally, it provides a function `_highlight` to syntax-highlight code snippets in C++ and Java.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_html_writer.py:test_cpp_java_highlighting:8e5f6a26d6082b37e83c5ef6774b7384a60b95ca087e10b81bad421357087ce8:8e5f6a26d6082b37e83c5ef6774b7384a60b95ca087e10b81bad421357087ce8": "The function `test_cpp_java_highlighting` is designed to test the code highlighting functionality for C++ and Java languages. It calls a private helper function `_highlight` with sample code snippets in C++ and Java, respectively, specifying the language as \"cpp\" and \"java\". The function then asserts that the output HTML contains `<span>` tags, which are typically used for syntax highlighting in HTML. This ensures that the syntax highlighting is working correctly for both languages.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_html_writer.py:test_subclass_rendering:5abaad33ff9a331ec47cc823b5004b41ea61d5bedbda7c784075edc33b258c96:5abaad33ff9a331ec47cc823b5004b41ea61d5bedbda7c784075edc33b258c96": "This function tests the rendering of subclasses in a module's documentation. It creates a mock module data structure with a nested subclass structure, writes this data to an HTML file using `write_module_page`, and then reads the generated HTML content. The test asserts that the HTML contains `<details>` tags for expandable sections, mentions \"Class: B\", includes the method signature \"def m(self)\", and has exactly one code block (`<pre><code>`) containing the method definition.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_html_writer.py:test_subfunction_rendering:51eea14727b5666063db446170182ce3e33b215a82eb0b354aa9b2d7a7d2fa61:51eea14727b5666063db446170182ce3e33b215a82eb0b354aa9b2d7a7d2fa61": "This function tests the rendering of subfunctions within a module's documentation. It creates a mock module data structure with an outer function containing an inner subfunction. The function then writes this module page to a temporary directory using the `write_module_page` function. After writing, it reads the generated HTML file and asserts that:\n1. The `<details>` tag is present, indicating expandable sections.\n2. The string \"Subfunction: def inner(y)\" is included in the HTML, showing the subfunction's name.\n3. Two instances of `<pre><code>` tags are found, corresponding to the source code of both the outer and inner functions, suggesting that their syntax is being highlighted.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_html_writer.py:test_write_index:31270c43f3e9f7003bf47b515e28a13e0bc1b87f0ab5b6cc961796f59b928cee:31270c43f3e9f7003bf47b515e28a13e0bc1b87f0ab5b6cc961796f59b928cee": "The function `test_write_index` is designed to test the functionality of writing an index file for a project documentation. It uses a temporary path provided by `tmp_path` to create and write to an HTML file named \"index.html\". The function takes several parameters:\n\n- `links`: A list of tuples where each tuple contains a module name and its corresponding HTML file name.\n- `summaries`: A dictionary containing summaries for each module.\n- The function writes the index content to \"index.html\" in the temporary path, including project summary, module links, and summaries.\n\nThe assertions check that:\n1. The generated HTML starts with a comment indicating it was generated by DocGen-LM.\n2. The project summary is correctly included in the HTML.\n3. The correct number of module links are present in the HTML.\n4. Module names and their summaries are accurately rendered in the HTML.\n5. Only one summary is rendered, even if multiple modules have summaries.\n6. The HTML contains a header for modules and an unordered list of modules.\n\nThis function ensures that the index file generated by DocGen-LM is correctly formatted and includes all necessary information about project modules and their summaries.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_html_writer.py:test_write_module_page:5085071797c7ebd2438e1a72e63ab1b14582a2ac92880de5836b7d193da009f2:5085071797c7ebd2438e1a72e63ab1b14582a2ac92880de5836b7d193da009f2": "This function tests the `write_module_page` function by creating a temporary directory, providing sample module data including classes, methods, variables, and functions, and writing the documentation page. It then reads the generated HTML file to verify that it contains expected elements such as links, summaries, class definitions, method signatures, variable declarations, and function definitions. The test checks for specific HTML tags, text content, and structure to ensure the documentation is correctly formatted and includes all necessary information.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_integration.py:7610cd2fce0cd37892fc17f69cefa5dc0c0897e6aab60df5a0bd194234f19d04:7610cd2fce0cd37892fc17f69cefa5dc0c0897e6aab60df5a0bd194234f19d04": "The module defines two test functions for a documentation generator. The first function, `test_docgenerator_generates_html`, tests the generation of HTML files from various types of source code files (Python, MATLAB, C++, Java) using a mock LLMClient. It asserts that the output directory contains the expected HTML files and that they contain the correct summary text.\n\nThe second function, `test_static_copied_from_any_cwd`, tests that static resources are copied to the output directory regardless of the current working directory. It asserts that the `style.css` file is present in the output directory's `static` folder.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_integration.py:test_docgenerator_generates_html:58db3307d7a3473ae20199a5242ce54936d872c6576fcd54b91e5118e76dbb91:58db3307d7a3473ae20199a5242ce54936d872c6576fcd54b91e5118e76dbb91": "The function `test_docgenerator_generates_html` is a unit test for the `main` function of the DocGen-LM project. It sets up a temporary directory with files representing different programming languages (Python, MATLAB, C++, Java) and then calls the `main` function to generate HTML documentation for these files using an LLM client mock. The test verifies that the expected HTML files are created in the output directory and that they contain the summary text returned by the LLM client.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_integration.py:test_static_copied_from_any_cwd:f54f7376c1a30881dd465dcaf8e944bec17724b935d7afd5e7e5316db1873b1b:f54f7376c1a30881dd465dcaf8e944bec17724b935d7afd5e7e5316db1873b1b": "This function tests the `main` function of a code documentation tool, specifically verifying that it correctly generates static HTML documentation for a Python project. It uses a temporary directory to create a mock project with a single Python module (`mod.py`). The test then simulates an LLM client interaction by mocking the `LLMClient` class and its methods. After changing the current working directory to the temporary path, the function calls the `main` function with the project directory and output directory as arguments. It asserts that the return value of `main` is 0, indicating successful execution. Finally, it checks that a CSS file (`style.css`) exists in the output directory's static folder, ensuring that the documentation generation process has created the necessary files.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_llm_client.py:ff8a0c5e5d3895b53e3efd3ac0badb2dca6ba723a90e55d61bc0a3a56cb89180:ff8a0c5e5d3895b53e3efd3ac0badb2dca6ba723a90e55d61bc0a3a56cb89180": "The module defines unit tests for an `LLMClient` class. It includes tests for the `ping` method, which checks if the client can successfully connect to a server, and the `summarize` method, which sends text to a language model for summarization. The `sanitize_summary` function filters out disclaimers from the summary text. Each test uses mock objects to simulate HTTP requests and responses, and assertions to verify that the methods behave as expected under different conditions.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_llm_client.py:test_ping_failure:7216b4d74decaf42a3fce0bf31264a51b8462784bcde26642b3a1994b35bd603:7216b4d74decaf42a3fce0bf31264a51b8462784bcde26642b3a1994b35bd603": "This function tests the `ping` method of an `LLMClient` class. It uses a mock to simulate a request failure when attempting to connect to \"http://fake\". The test asserts that a `ConnectionError` is raised as expected when the ping operation fails due to the simulated network error.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_llm_client.py:test_ping_success:3b5a9c021992f5a9f09319f84ef35e74683f596232f0a7883917fc59ebffa4e1:3b5a9c021992f5a9f09319f84ef35e74683f596232f0a7883917fc59ebffa4e1": "This function tests the `ping` method of an `LLMClient` class. It creates a mock response object that simulates a successful HTTP GET request without raising any exceptions. The function then asserts that calling `client.ping()` returns `True`, indicating a successful connection. It also verifies that the `requests.get` method was called once with the specified URL and timeout, and that the `raise_for_status` method of the mock response object was called to ensure there were no HTTP errors.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_llm_client.py:test_prompt_varies_by_type:641abc6660817ea4e168c2245e1daa71857c3aaa5841a9ea8628d3dc2de6726f:641abc6660817ea4e168c2245e1daa71857c3aaa5841a9ea8628d3dc2de6726f": "This function tests the `summarize` method of an `LLMClient` class, ensuring that it generates different prompts based on the type of code being summarized. It uses a mock HTTP client to simulate responses from a language model and compares the generated prompts for classes and functions. The test asserts that the prompts are correctly formatted using predefined templates and that they differ between class and function types.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_llm_client.py:test_readme_prompt_template_used:da28b75d051efdc51a86b54e129fd62fec1ffa0e1c16df31eb1441f8437a3eb8:da28b75d051efdc51a86b54e129fd62fec1ffa0e1c16df31eb1441f8437a3eb8": "This function tests whether the `LLMClient` uses the correct prompt template for summarizing README files. It creates a mock response from an LLM client, simulates a POST request to the client with a sample text, and checks if the generated prompt matches the expected format using the `PROMPT_TEMPLATES[\"readme\"]`.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_llm_client.py:test_sanitize_summary_filters_phrases:a916559db93e1b44cbcbb89c381e07986c6a517b7864fd326de641c7845f982f:a916559db93e1b44cbcbb89c381e07986c6a517b7864fd326de641c7845f982f": "",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_llm_client.py:test_summarize_raises_runtime_error_with_message:9308d2a694fdb9d2fe8d21e29de5f1cc47a87ad8d2e973225a304d285782bc44:9308d2a694fdb9d2fe8d21e29de5f1cc47a87ad8d2e973225a304d285782bc44": "This function tests that the `summarize` method of an `LLMClient` class raises a `RuntimeError` with a specific message when an HTTP error occurs during text generation. It uses mocking to simulate a failed HTTP request and a JSON parsing error, then asserts that the expected exception is raised with the correct message.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_llm_client.py:test_summarize_retries_and_returns_summary:4cbe474a8643b7e0b0ca3c4e0402526bb98c8c0879dfe33cce193f7df4ab8cbd:4cbe474a8643b7e0b0ca3c4e0402526bb98c8c0879dfe33cce193f7df4ab8cbd": "The function `test_summarize_retries_and_returns_summary` tests the `summarize` method of an `LLMClient` class. It sets up a mock LLM client and response to simulate a request failure followed by a successful response. The test asserts that the `summarize` method retries on failure, waits for 1 second between attempts, and returns the expected summary text.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_manual_utils.py:79194c18898c3be5fd9b77410afeef01c9f0a1405b52a64720962e71b081ca75:79194c18898c3be5fd9b77410afeef01c9f0a1405b52a64720962e71b081ca75": "The module defines two functions: `_count` and `test_chunk_docs_respects_token_limit`, `test_find_placeholders`. The `_count` function calculates the number of tokens in a given text using a tokenizer from the `manual_utils` module. The `test_chunk_docs_respects_token_limit` function tests the `chunk_docs` function from `manual_utils` to ensure it respects a token limit by splitting documents into chunks that do not exceed the limit. The `test_find_placeholders` function tests the `find_placeholders` function from `manual_utils` to verify its ability to identify and return placeholders in a given text.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_manual_utils.py:_count:651678b3db0bbc657cbbe11f4de755413829d6be4e40e6a727684f705562db22:651678b3db0bbc657cbbe11f4de755413829d6be4e40e6a727684f705562db22": "Counts the number of tokens in a given text using a tokenizer from `manual_utils`.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_manual_utils.py:test_chunk_docs_respects_token_limit:a4856a26540557886bed734aaa94b719a1053d7f46f9bd4642a281fdf926d184:a4856a26540557886bed734aaa94b719a1053d7f46f9bd4642a281fdf926d184": "This function tests the `chunk_docs` method from the `manual_utils` module to ensure it respects a specified token limit. It creates a list of three strings, each containing 1000 characters repeated 'a', 'b', and 'c' respectively. The function then chunks these documents using a token limit of 2000 tokens. The test asserts that the number of chunks is exactly two and that no chunk exceeds the token limit of 2000 tokens.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_manual_utils.py:test_find_placeholders:c604ea0165444da78a2b29dcd10ee7d2c9c072bfaa1b5c676d65d2072160128c:c604ea0165444da78a2b29dcd10ee7d2c9c072bfaa1b5c676d65d2072160128c": "The function `test_find_placeholders` is designed to test the functionality of a utility function named `find_placeholders`. This utility function appears to search for and extract placeholder tokens from a given text string. The placeholders are enclosed in double square brackets, such as `[[NEEDS_OVERVIEW]]` and `[[FOO]]`.\n\nIn this specific test case:\n- A sample text string is provided: `\"Intro [[NEEDS_OVERVIEW]] middle [[FOO]] end\"`.\n- The function `manual_utils.find_placeholders` is called with this text string.\n- The expected output, which is a set of placeholder tokens found in the text, is compared to the actual output using an assertion.\n\nThe test asserts that the set of placeholders extracted from the text matches the expected set: `{\"[[NEEDS_OVERVIEW]]\", \"[[FOO]]\"}`. If the function works correctly, this assertion will pass, indicating that the placeholder extraction functionality is functioning as intended.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_parser_cpp.py:7bf655540a7446dfdc4c0a3d20712a34c8c0cefe70fdce7aa5e2197a6cc58f87:7bf655540a7446dfdc4c0a3d20712a34c8c0cefe70fdce7aa5e2197a6cc58f87": "This module defines a test function `test_parse_cpp` that uses the `parse_cpp_file` function from `parser_cpp.py` to parse a C++ source file. The test checks if the parsed data includes the expected module comment, namespace, functions, and classes with their respective docstrings and source code snippets.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_parser_cpp.py:test_parse_cpp:2e9f2c285d2d51815f3ff3077d5c0caaee0f74f86e53611dc607746b86dd205d:2e9f2c285d2d51815f3ff3077d5c0caaee0f74f86e53611dc607746b86dd205d": "This function, `test_parse_cpp`, is designed to test the parsing of a C++ source file. It uses a temporary directory and a sample C++ code snippet with comments, a namespace, functions, and classes. The function writes this code to a file named \"sample.cpp\" in the temporary directory. It then calls `parse_cpp_file` with the path to this file as an argument.\n\nThe test asserts that the parsed result contains:\n- A module docstring matching \"Module comment\".\n- A namespace named \"demo\".\n- One function named \"add\" with a docstring \"Adds numbers\" and source code containing \"return a + b;\".\n- One class named \"Greeter\" with a docstring \"Greeter class\", one variable named \"name\" with a docstring \"name field\" and source code containing \"std::string name;\", and one method named \"greet\" with a docstring \"greet someone\" and source code starting with \"std::string greet\".",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_parser_java.py:81c91b4467b1272b3aee2c23a686157de0d00112a71e34af42e7260d11e289fb:81c91b4467b1272b3aee2c23a686157de0d00112a71e34af42e7260d11e289fb": "This module defines a test function `test_parse_java` that uses the `parse_java_file` function from the `parser_java` module to parse a Java source file. The test checks if the parsed result contains the expected package, class, field, and method information.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_parser_java.py:test_parse_java:74c08c0652e800c4de11f32c7a4de95bae344e00977eced3613e00a3bbb4797f:74c08c0652e800c4de11f32c7a4de95bae344e00977eced3613e00a3bbb4797f": "This function `test_parse_java` tests the parsing of a Java source file using a hypothetical `parse_java_file` function. It creates a temporary Java file with a package declaration, a class definition, and some fields and methods. The function then parses this file and asserts that the parsed result contains the correct documentation strings, package name, classes, fields, and methods. Specifically, it checks that the module docstring is \"Example package\", the package is \"demo\", there are no functions, one class named \"Util\" with a docstring of \"Utility class\", a field named \"count\" with a docstring of \"public field\" and type \"int\", and a method named \"work\" with a docstring of \"do work\".",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_parser_matlab.py:d371df41f01bfadecc63c5f1bddb7b77eb2309a17405bffe247ca4a3e17973bd:d371df41f01bfadecc63c5f1bddb7b77eb2309a17405bffe247ca4a3e17973bd": "This module defines two test functions to verify the functionality of a MATLAB file parser. The `test_parse_simple_matlab` function checks if the parser correctly handles a simple MATLAB file with a single function. It asserts that the header is parsed correctly and that the function details are accurately extracted.\n\nThe `test_parse_multiple_functions` function tests the parser's ability to handle multiple functions within a single MATLAB file. It verifies that both functions are correctly identified, their names and arguments are accurately captured, and that there are no issues with parsing files containing more than one function.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_parser_matlab.py:test_parse_multiple_functions:c79b8318db900d36010ab8445068987046ad448e5ed57f745d80606f42c65aec:c79b8318db900d36010ab8445068987046ad448e5ed57f745d80606f42c65aec": "This function, `test_parse_multiple_functions`, tests the parsing of multiple MATLAB functions from a source file. It creates a temporary file with two MATLAB functions: `compute` and `square`. The function then parses this file using `parse_matlab_file` and asserts that:\n1. The header is empty.\n2. There are exactly two functions parsed.\n3. The names of the parsed functions are \"compute\" and \"square\".\n4. The arguments for each function match the expected values: `compute` takes `a` and `b`, while `square` takes `x`.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_parser_matlab.py:test_parse_simple_matlab:32186d9885563c86c5032f62b6e799571eb85ccfd1eff46f03e5128cd1c46ba7:32186d9885563c86c5032f62b6e799571eb85ccfd1eff46f03e5128cd1c46ba7": "The function `test_parse_simple_matlab` is a unit test for parsing simple MATLAB files. It creates a temporary file with MATLAB code, then calls the `parse_matlab_file` function to parse the file. The test asserts that the parsed header matches the expected content and that there is one function defined in the file. It further checks that the function's name, arguments, and body are correctly extracted from the source code.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_parser_python.py:0656a74b22ae45e63880587901e7b10ae787467de6bd22083f6803af85bd3957:0656a74b22ae45e63880587901e7b10ae787467de6bd22083f6803af85bd3957": "The module defines several test functions to verify the functionality of a `parse_python_file` function. Each test function creates a Python source file with specific content, parses it using `parse_python_file`, and then asserts that the parsed data matches expected values.\n\n- `test_parse_simple_module`: Tests parsing a simple Python module with a docstring, class, and method.\n- `test_parse_complex_signature`: Tests parsing a function with complex signature parameters.\n- `test_parse_nested_structures`: Tests parsing nested functions and classes.\n- `test_deeply_nested_classes`: Tests parsing deeply nested classes.\n- `test_class_inside_method`: Tests parsing a class defined inside another class.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_parser_python.py:test_class_inside_method:7796198d2e1642332ab4780bdc36d4d2f5b9f8754a401a2cb884ef4550f68d77:7796198d2e1642332ab4780bdc36d4d2f5b9f8754a401a2cb884ef4550f68d77": "This function `test_class_inside_method` tests the parsing of a Python file containing a class inside another method. It uses a temporary directory to create a source file with nested classes and methods, then parses this file using a hypothetical `parse_python_file` function. The test asserts that:\n1. The outer class `A` has one subclass.\n2. The subclass is named `B`.\n3. Class `B` contains one method named `m`.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_parser_python.py:test_deeply_nested_classes:dd011aff0ce2c8f6ff32142fa06502337b791b60395b70a62bf210df314b2bdb:dd011aff0ce2c8f6ff32142fa06502337b791b60395b70a62bf210df314b2bdb": "This function, `test_deeply_nested_classes`, is designed to test the parsing of deeply nested classes in Python source files. It uses a temporary path provided by pytest's `tmp_path` fixture to create a Python file named \"deep.py\" with a nested class structure:\n\n- Class A contains class B.\n- Class B contains class C.\n- Class C has a method named `inner`.\n\nThe function then calls `parse_python_file` with the path of this temporary file as an argument. The result is expected to be a dictionary containing parsed information about the classes and methods in the file.\n\nThe test asserts that:\n1. The first class in the result is named \"A\".\n2. The first subclass of class A (i.e., class B) has been correctly identified.\n3. The first subclass of class B (i.e., class C) has been correctly identified, with its name being \"C\".\n4. Class C contains a method named `inner`.\n\nThis ensures that the parsing function can handle deeply nested class structures and extract both class names and method details accurately.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_parser_python.py:test_parse_complex_signature:d238ae0bc9ada8521a3619cedbcd2335227616d8c56843d41d9178488e176c5d:d238ae0bc9ada8521a3619cedbcd2335227616d8c56843d41d9178488e176c5d": "This function `test_parse_complex_signature` tests the parsing of a Python file containing a complex function signature. It uses a temporary directory to create a sample Python file with a docstring and a complex function definition. The function then calls `parse_python_file` to parse the file and extracts the function's signature and documentation. Finally, it asserts that the extracted signature matches the expected value and that the function's documentation is correctly captured from the source code.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_parser_python.py:test_parse_nested_structures:9fd829a94a62a22644099362948c4e59e3a2b1ace651e3b3ba965726a8599796:9fd829a94a62a22644099362948c4e59e3a2b1ace651e3b3ba965726a8599796": "This function tests the parsing of nested structures in Python files. It creates a temporary file with nested functions and a subclass, then uses `parse_python_file` to parse this file. The test checks that the parsed result contains the correct outer function, its inner function, and the class with its subclass and method.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_parser_python.py:test_parse_simple_module:31dbe0ea8dedb43f7f36d08e1d30956a22bf8b88fdc4ce0bbd9f720f2aad1256:31dbe0ea8dedb43f7f36d08e1d30956a22bf8b88fdc4ce0bbd9f720f2aad1256": "This function `test_parse_simple_module` tests the parsing of a Python module using a temporary file path provided by `tmp_path`. It creates a sample Python file with a docstring, a class named `Greeter`, and a method `greet`, as well as a standalone function `add`. The function then calls `parse_python_file` to parse this file. Assertions are used to verify that the parsed results match the expected values for the module's docstring, classes, methods, and functions. Specifically, it checks the names, signatures, docstrings, and source code of the parsed elements to ensure accuracy.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_reviewer.py:83233473a3bb44ee0c5e26502caa85ad29205c84af0e40280e3fd12a3f730505:83233473a3bb44ee0c5e26502caa85ad29205c84af0e40280e3fd12a3f730505": "This module defines several functions and tests for a code review tool. It includes:\n\n1. `_make_module`: Creates a temporary module with specified summary and methods, then writes an HTML page for it.\n2. `test_assistant_phrasing_detected`: Tests if the assistant phrasing is detected when \"You can use this class\" is in the module summary.\n3. `test_contradiction_detected`: Checks if a contradiction is detected when methods are defined but not described in the summary.\n4. `test_hallucination_detected`: Verifies that a hallucination is flagged when the module claims to implement features it doesn't.\n5. `test_autofix_removes_phrasing`: Tests if autofix removes phrasing like \"You can\" from the HTML output.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_reviewer.py:_make_module:057b2bf7441c04e20644b47f712ceba5574799f2d19f7674a909a33bd63d62be:057b2bf7441c04e20644b47f712ceba5574799f2d19f7674a909a33bd63d62be": "The function `_make_module` creates a temporary module page with the specified summary and optional methods. It constructs a dictionary `data` containing the module's name, summary, classes, and functions. If methods are provided, it includes a class named \"Foo\" with an empty docstring, summary, and the given methods. The function then writes this data to a module page using `write_module_page`, which takes the temporary path, data, and a list of tuples specifying file names and paths. Finally, it returns the path to the generated HTML file for the module.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_reviewer.py:test_assistant_phrasing_detected:293a5ed66b083cbc2a388f1f2fa85e97cef10be9447d1d88f8b569c5838a2656:293a5ed66b083cbc2a388f1f2fa85e97cef10be9447d1d88f8b569c5838a2656": "This function tests if assistant phrasing is detected and included in the generated documentation. It creates a module with specific content, runs the main function with the temporary path as an argument, captures the output, and asserts that both \"[ASSISTANT]\" and \"mod.html\" are present in the output.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_reviewer.py:test_autofix_removes_phrasing:c8f96570d6b6f3438933c90267aa4be80f03ee4b49991fd8d0b58533165fa723:c8f96570d6b6f3438933c90267aa4be80f03ee4b49991fd8d0b58533165fa723": "This function tests the `--autofix` option of the DocGen-LM tool. It creates a temporary module with phrasing that should be removed, runs the tool with the `--autofix` flag, and then checks that the phrasing has been successfully removed from the generated HTML file.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_reviewer.py:test_contradiction_detected:4257df108fac0fea913bb13d25774caab56f6480373715d151c7ee5db8373d45:4257df108fac0fea913bb13d25774caab56f6480373715d151c7ee5db8373d45": "The function `test_contradiction_detected` is designed to test the detection of contradictions within a Python project. It takes two parameters: `tmp_path`, which represents a temporary directory path, and `capsys`, which captures standard output.\n\nThe function performs the following steps:\n1. Defines a list of methods with a single method named \"bar\" that has an empty docstring and source code.\n2. Creates a module using the `_make_module` function, passing the temporary path, a description indicating no methods are defined, and the list of methods.\n3. Calls the `main` function with the string representation of the temporary path as an argument.\n4. Reads the captured standard output using `capsys.readouterr().out`.\n5. Asserts that the string \"[CONTRADICTION]\" is present in the captured output.\n\nThis test ensures that the system correctly identifies and reports contradictions within a project's documentation or code structure.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_reviewer.py:test_hallucination_detected:4c1de4b8ce3137ab0444cd3b213fd5fc104193a68d077de4f5720035d123cbe4:4c1de4b8ce3137ab0444cd3b213fd5fc104193a68d077de4f5720035d123cbe4": "This function tests for the detection of a hallucination during the documentation generation process. It creates a module with specified content, runs the main function with the temporary path containing the module, and captures the output. The test asserts that the string \"[HALLUCINATION]\" is present in the captured output, indicating that the system has detected an issue related to generated content.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_scanner.py:9fb66b0d67a215b5195a4a239c0f088601d37be9f219b4e6b10e9a18e33b8b13:9fb66b0d67a215b5195a4a239c0f088601d37be9f219b4e6b10e9a18e33b8b13": "This module defines several tests for a `scan_directory` function. It uses the `pytest` framework to validate that the function correctly identifies and returns files of specified types, excluding directories listed in an ignore list and skipping common version control directories like `.git`. The tests create temporary file structures using `pathlib`, call `scan_directory`, and assert the results match expected outputs.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_scanner.py:create_files:2a77bdb5f92789f35ef0ecac7c31a9265d06d3cf2ea8c28d88cabc76da5c6880:2a77bdb5f92789f35ef0ecac7c31a9265d06d3cf2ea8c28d88cabc76da5c6880": "The function `create_files` takes a directory path and a list of relative file paths as input. It iterates over the list of relative paths, constructs the full path by appending each relative path to the base directory, creates any necessary parent directories if they do not exist, and then writes an empty string to each file.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_scanner.py:test_scan_directory_ignore_folder:1340ee0a31716c94954ba5e535abe9f93f1b8518067b0a6457f4b8997f01f5b7:1340ee0a31716c94954ba5e535abe9f93f1b8518067b0a6457f4b8997f01f5b7": "The function `test_scan_directory_ignore_folder` is designed to test the functionality of scanning a directory while ignoring specified folders. It uses a temporary path provided by `tmp_path` and creates several files within it, including some in subdirectories and one in an \"ignore_me\" folder that should be excluded from the scan.\n\nThe function then calls `scan_directory` with the path of the temporary directory and a list containing the name of the folder to ignore (`[\"ignore_me\"]`). The result of this function call is compared to an expected set of file paths, which includes all files except those in the \"ignore_me\" folder. If the result matches the expected set, the test passes; otherwise, it fails with an assertion error.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_scanner.py:test_scan_directory_mixed_file_types:0e23627957181f1dfaeb838e124288f656f3faaf0538b73e1136141d79f8fa64:0e23627957181f1dfaeb838e124288f656f3faaf0538b73e1136141d79f8fa64": "The function `test_scan_directory_mixed_file_types` is a test case designed to verify the functionality of scanning a directory containing files of various types. It uses a temporary path provided by `tmp_path` and creates several files within it, including Python, MATLAB, text, and Markdown files, as well as nested files.\n\nThe function then calls `scan_directory` with the path of the temporary directory and an empty list of file extensions to scan for. The result is compared against an expected set of file paths, which includes only the Python and MATLAB files (excluding the text and Markdown files) and their nested counterparts.\n\nThe assertion checks if the set of returned file paths matches the expected set, ensuring that the `scan_directory` function correctly identifies and returns files of the specified types.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_scanner.py:test_scan_directory_skips_git_folder:da07138a26b152233844e64c5a219517ac3057f7799022ceea52b7f999e738cf:da07138a26b152233844e64c5a219517ac3057f7799022ceea52b7f999e738cf": "This function tests the `scan_directory` function to ensure it skips files and directories within a `.git` folder. It creates a temporary directory with specified files, including some within a `.git` subdirectory, then calls `scan_directory` on this path. The test asserts that the returned list of file paths includes only those outside the `.git` directory, confirming that the function correctly ignores `.git` contents during scanning.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_scanner.py:test_scan_directory_supports_cpp_h_java:8af1abaadc870b16fd2c1b1f8c8f4450208da213faba6d768bbabfd7c6f93571:8af1abaadc870b16fd2c1b1f8c8f4450208da213faba6d768bbabfd7c6f93571": "This function tests the `scan_directory` function to ensure it correctly identifies and includes C++, Java, and header files within a directory structure. It creates a temporary directory with various file types, including nested directories, and then uses `scan_directory` to scan this directory. The test asserts that all expected files are included in the result set, verifying that the function handles different file extensions and nested structures as intended.",
  "PROJECT:fb02e6e9708fb901818bbb6cf969808832bdff359161ee46cf8eaa6665d3802e:fb02e6e9708fb901818bbb6cf969808832bdff359161ee46cf8eaa6665d3802e": "This project appears to be a comprehensive code documentation tool that supports multiple programming languages. It includes modules for parsing different file types (Python, C++, Java, MATLAB), summarizing code and documentation, generating HTML and PDF summaries, and interacting with an LLM client for text generation. The system also features a GUI wrapper for user interaction and a caching mechanism to improve performance. Additionally, there are test modules to ensure the functionality works as expected across various scenarios.",
  "README:b3ecc1a4f38b030a9777cc9e1c4c8b667da9c029caacca4368a617a75a9f0141:b3ecc1a4f38b030a9777cc9e1c4c8b667da9c029caacca4368a617a75a9f0141": "DocGen-LM generates static HTML documentation for Python, MATLAB, C++, and Java projects by analyzing source files with a local LLM. It captures and renders nested functions and subclasses as expandable sections, providing a detailed and organized overview of complex project structures.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\cache.py:ResponseCache:4bf39f0ddf33468e133fc0de74e4b5ffcc04454990de01f6d9556f317e81e88f:bb8c5e04ff12539d13e7ca41ecbd56f704e29527621cb046143ffeb35745f4a7": "The `ResponseCache` class provides a mechanism for persisting and retrieving mappings from stable keys to language model (LLM) responses. It initializes by loading existing data from a specified file path, or creating an empty dictionary if the file does not exist. The class includes methods for generating deterministic keys based on file paths and content, retrieving cached values, setting new key-value pairs, and persisting the cache to disk in JSON format.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\cache.py:__init__:0a9e2dc65b52321591376be646e1fc94c33c040444e33581fb1244ce54669700:c9c3121354aeb2f711fd39ff265d78ab49b5f1f12d4239da1333d1527b91b2c9": "The `__init__` method initializes a new instance of the `ResponseCache` class. It takes a file path as an argument and sets it to the `file` attribute. If the file exists, it attempts to read its contents and parse them as JSON into the `_data` dictionary. If the file does not exist or contains invalid JSON, it initializes `_data` as an empty dictionary.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\cache.py:_save:cc6d27666bab0dbd222c2982b9a92f40a8da28fd77f465161a029f0d9ab7556b:070a71c8e53548d931fed3547f73f44ba0022eac2d2315b97de88d380a6aeeb4": "The `_save` method in the `ResponseCache` class writes the current cache data to a file. It uses the `write_text` method of the `file` attribute, which is assumed to be an instance of a file-like object. The method converts the `_data` dictionary into a JSON string using `json.dumps`, with an indentation of 2 spaces and sorted keys for better readability. The encoding used for writing the file is specified as \"utf-8\".",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\cache.py:get:6616ff4f4be4c799bb734a62f47772d374d3eed36cdb0b35cbc3419e79951324:82046480f2fb2b1f01966b04d299df5364f1f7327cb27341f6333da0caccaa3a": "The `get` method in the `ResponseCache` class retrieves the cached value associated with a given key. If the key exists in the cache, it returns the corresponding value; otherwise, it returns `None`. This method is used to access data stored in the cache without modifying its contents.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\cache.py:make_key:dc653fa33b85df8a7bddc97e822e442e3babd0e251b12f7c0d9a5d8012daae2f:ff7b5c095ca5f5786d6868f8f35792094a3d5aa42d354009577298947749e946": "The `make_key` function generates a unique key based on the file path and content. It uses SHA-256 hashing to create a deterministic hash of the content, ensuring that the same content produces the same key. The function concatenates the file path with the hashed content to form a composite key, which is then returned as a string. This key can be used to store and retrieve cached documentation data efficiently.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\cache.py:set:64cb535d67edac66c72a6a7033ccefcc0879b6cd123377aaca8c38776b639a25:33f0f3dd1e0b87b54df0d7219acb53df71e87ded8a52388a3ddb4b5c8119dd1e": "This function `set` in the `ResponseCache` class is designed to store a string value associated with a unique key in the cache. It updates an internal dictionary `_data` with the provided key and value, ensuring that any changes are persisted by calling another method `_save()`. This method facilitates both caching of data for quick retrieval and persistent storage across sessions.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\chunk_utils.py:_split_blocks:3894d910e294c90c138318a6bbaf9d2fcbda8cfe5dc2b600b10107b9fa053ce4:cf5246df1cecd53cc656d80bc1d3f9c3626b33c4bda14e54fe4ff2d3d4ed5774": "This function `_split_blocks` takes a string `text` containing Markdown formatted content and splits it into separate blocks based on paragraph, heading, and code fence delimiters. It returns a list of these blocks as strings. The function processes each line to determine whether it belongs to a paragraph, heading, or code block, and accumulates lines until the delimiter is encountered, at which point it adds the accumulated content as a block to the result list.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\chunk_utils.py:_split_long_block:af3e2238c6c0a29d614b7725edece635458e477758bd59f71d634cd708ee4bf4:f5bfa16b7fe7f98d6217a523e276d6afccd462670098dd97a0691b1614108ee0": "The function `_split_long_block` takes a string `block`, a tokenizer, and an integer `chunk_size_tokens`. It encodes the block into tokens using the provided tokenizer. If the number of tokens is less than or equal to `chunk_size_tokens`, it returns the original block as a single-element list. Otherwise, it calculates an average character length per token and determines a maximum character length for each chunk based on this average. The function then splits the block into chunks of characters up to `max_chars` and returns these chunks as a list.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\chunk_utils.py:chunk_text:3dae48e1d40c7de1857ca0c0fb2df58db455b6a85e971a7cd6eb609080559046:aa8145842163e4f6d0c78cc08169030ab095583e475e0f17825143e62330be9b": "Splits a given text into chunks of approximately `chunk_size_tokens` each. Natural break points such as blank lines, Markdown headings, and fenced code blocks are respected. If a single block exceeds `chunk_size_tokens`, it is split by approximate character length. The function returns a list of these chunks.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\chunk_utils.py:get_tokenizer:ff3f6cab59316a25b2c21e592e6fbd061775f2d9c0708e16ce643e778378bccf:6ab83396f03abcfa943a43532d1f002a2f80f86fa6e6661a68244410d655f66f": "The `get_tokenizer` function returns a tokenizer object used for estimating token counts. If the `tiktoken` library is available and can be loaded, it attempts to use the \"cl100k_base\" encoding. If that fails or if `tiktoken` is not installed, it falls back to using the \"gpt-3.5-turbo\" model. If both fail, it prints a warning and returns a simple tokenizer that splits text into tokens by whitespace and joins them back together.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\docgenerator.py:_build_function_prompt:8fa8372242f8af0a01e2a2b1a3e3ee14c076e2513348f89833a6a0021a5fd936:0ffd0a4d7f7aac54fe4e6fa49e81d66f1b7c71fa4ee7b12010a22713561a8b82": "This function `_build_function_prompt` constructs a prompt for summarizing a Python function. It takes four parameters: `source` (the function's source code), and optional parameters `class_name`, `class_summary`, and `project_summary`. The function returns a string that includes these parameters as context, followed by instructions on how to summarize the function based solely on its source code.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\docgenerator.py:_chunk_module_by_structure:057f3b41d4e8f6637f95f8d3d8522bdcc70fc839aa40eb30bb6b1ca12eb87642:a510bec1cf237f142b1a9158ad57e13c68e98e68e26bd6652d5b87c0164b9ade": "The function `_chunk_module_by_structure` processes a Python module's parsed structure to generate text chunks that fit within specified token limits. It starts by adding the module's docstring, followed by class definitions and their methods or variables if they exceed the token limit. Functions are also added as separate blocks. The function then iterates through these blocks, creating chunks that do not exceed the token size. If a block exceeds the limit, it is further split into smaller chunks. Chunks are separated by double newlines for readability.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\docgenerator.py:_rewrite_docstring:eb57ffa4cd25617fd0fe9bd9a49a608d7768685c9ab266270834f30c0ac0cb78:f6c786829cc583b3f253f88d0522d655be9dd7148dfbd820f60b276375381fd6": "The function `_rewrite_docstring` is designed to rewrite the docstring of a code item using an LLM client and a caching mechanism. It takes several parameters including the LLM client, cache, file path, item dictionary, optional class and project summaries, tokenizer, and token budgets for context and chunking. The function first checks if there is source or docstring data; if not, it prints a warning and returns. If a docstring exists, it constructs a prompt based on the provided context (class and project summaries) or uses a default prompt format. It then generates a cache key using the file path, item name, and content of the source and docstrings. The function calls `_summarize_chunked` to generate a summary using the constructed prompt and updates the item's docstring with the sanitized result or a default message if no summary is available.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\docgenerator.py:_summarize_class_recursive:ce2d9973d1ec509ae6910cf6a221860b75363a0413c4814536e09ad22334e0a1:ab2ae4e790286e5cf76ff0fe7fa65f0c3f8c23cf3709962ba386ee7d63c58e51": "This function, `_summarize_class_recursive`, is designed to recursively summarize a class and its members in a Python project. It takes several parameters including `class_data` (a dictionary containing the class information), `path` (the file path of the class), `project_summary` (a summary of the project), `tokenizer`, `client` (an LLM client for text generation), `cache` (a caching mechanism to improve performance), and `max_context_tokens` and `chunk_token_budget` (limits on token usage).\n\nThe function performs the following tasks:\n1. It recursively summarizes the members of the class using `_summarize_members_recursive`.\n2. It constructs a list of method summaries and variables summaries.\n3. It formats these summaries into a prompt string for summarization using an LLM client.\n4. It caches and retrieves the summarized docstring for the class.\n5. It updates the `class_data` dictionary with the new summary and docstring.\n6. It rewrites the docstrings of methods and variables within the class, incorporating the new class summary.\n7. It recursively calls itself to summarize any subclasses of the current class.\n\nThis function is part of a larger system for generating detailed documentation for Python projects by analyzing source files and interacting with an LLM client.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\docgenerator.py:_summarize_members_recursive:16de9702209075c01af550daf286016cf9abd72661b1deedcaf28bb2f0502f49:a546eceda68419375e86bbac85a638f868fc1072a0f35d0acb18d442c1fea139": "Summarizes methods and variables of a given class and its subclasses recursively. It uses an LLM client to generate summaries for each method and variable, caches the results using a response cache, and updates the class data with the generated summaries.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\docgenerator.py:_summarize_module_chunked:135f8ff271ea8302b8475b8e20f28fc6215876b51caac7f6c47e871bc9db6263:34bfe851eb79dc11aa53648b3a306fd0e59471d232192b3e7bcfbe65b9a76546": "This function `_summarize_module_chunked` is designed to summarize a Python module using structure-aware chunking. It takes several parameters including an LLM client, a cache for responses, a key prefix, the text of the module, a dictionary representing the module, a tokenizer, and maximum context tokens and chunk token budgets.\n\nThe function first calculates the available tokens based on the overhead from system prompts and template usage. If the entire module text fits within these available tokens, it summarizes the module directly using another internal function `_summarize`.\n\nIf the module text is too large to fit in one chunk, the function attempts to break it down into smaller chunks based on the structure of the module. This is done by calling `_chunk_module_by_structure`, which may raise an exception if structure-based chunking fails.\n\nFor each chunk, the function summarizes it and collects these partial summaries. It then combines these partial summaries into a single technical paragraph using a recursive merging process. The merging process ensures that the combined summary fits within the available tokens, breaking down further if necessary until all parts are merged successfully.\n\nFinally, the function sanitizes the final summary and returns it. If any steps fail (e.g., due to network issues), it handles exceptions by printing warnings and attempting to sanitize or return partial results.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:Config:0b3ed3eff1c79c43fbe5d931fef9fce219dad2ae4a03975c80a50074ce4a92d9:594733ac4138c0c5ad11ce6e6840136f00c85e7c41a44ed0802b36201d93f5ba": "The `Config` class defines a data structure to hold configuration settings parsed from command-line interface (CLI) arguments. It includes various attributes such as file paths, output formats, and boolean flags that control the behavior of a program based on user input.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:_edit_chunks_in_editor:f49dedaf83ad9cbc51630880d084a6d4d49953a01a567061b302c5a34de789a7:8106ad44c916b12bcbd165fb479b70683bc30895bdf50f63a6e6deae4e98b96d": "This function `_edit_chunks_in_editor` opens a list of code chunks in the user's default editor for optional modification. Each chunk is separated by lines containing `---`. After editing, it returns the modified chunks as a list, discarding any empty chunks. The function uses a temporary file to store the initial content and invokes the user's preferred editor (defaulting to \"vi\" if not set) to edit this file. Once the editor is closed, the function reads the edited content, splits it back into individual chunks based on the separator, and returns these chunks after stripping any leading or trailing whitespace.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:collect_docs:55a0ce83c6544a10bc87f5b43239545bdf9c562148a20867d2d07c680493c880:774bded624fe48a765a342e47c13de5667d2bbf3566001770679d37d5d7d6ee5": "The function `collect_docs` takes a directory path as input and returns a list of paths to documentation files found within that directory and its subdirectories. It includes specific patterns for Markdown, text, HTML, and DOCX files in the project root and under a \"docs\" subdirectory. The function ensures that each file is only added once to the result list by using a set to track seen files.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:collect_files:15f3ffd0aabd447bf596eeea33f47e4368ace716c48dbb394d476150371a6064:54b5df3ca2191b5aaebb39341ea7e09be7ac91d8041dd7525d5e244b5f5c0da9": "The `collect_files` function collects files from a specified base directory that are relevant for summarization. It starts with a list of default file patterns to include (`README.md`, `.txt`, `.html`, `.docx`, `.csv`, `.json`). It then extends this list with any additional patterns provided by the user. The function uses `rglob` to recursively search for files matching these patterns within the base directory and its subdirectories. To ensure uniqueness, it filters out duplicate files based on their path, returning a list of unique file paths that match any of the specified patterns.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:detect_placeholders:794ed7033d3a982b338beffe9db5096ba161449df347e00e00f342f2be0bf09a:1cc20660f5c4a6417a390bb8598fecb1b0c480dad86b6a95c088c6959f6b148e": "This function `detect_placeholders` takes a string `text` as input and returns a list of section names that are still marked by placeholder tokens. It uses the helper function `find_placeholders` to identify all placeholder tokens present in the text. Then, it filters these tokens against a dictionary `SECTION_PLACEHOLDERS`, which maps section names to their corresponding placeholder tokens. The function collects and returns the names of sections for which placeholders are still detected in the input text.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:extract_snippets:bb9682fd6dcf3c843ab26e4811171ffb811c503d533e935e3dbe819f907fefd8:30aae82db5a0024b0613f60e8b1c92ba48eec7a772a241180011dbf05dba994e": "The function `extract_snippets` processes a list of Python files to extract relevant code snippets. It iterates through the provided files, applying filters based on file size and elapsed time. For each file, it reads up to a specified number of bytes and attempts to parse the content as Python code using the `ast` module. If successful, it extracts docstrings from modules, classes, functions, and async functions. It also identifies potential I/O signatures by looking for function arguments related to paths, files, configurations, or I/O operations. Additionally, it searches for command-line interface (CLI) parser definitions and a main execution block. The extracted snippets are stored in a dictionary with the file path as the key and the collected information as the value.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:extract_text:1e11535fd0863561d74ebb46da03303a3db96518a1c354a502a20c1a3c7c03e5:3c0771bfc6bebb1ff55558b11b955281b3cd62a71d4af0143b6c558b5d285e06": "The function `extract_text` reads a file from the specified `path` and extracts plain text based on its file type. It handles HTML, Markdown, and DOCX files. For HTML files, it converts headings to markdown-style headers and code blocks to fenced code blocks. For Markdown files, it simply returns the content as is. For DOCX files, if the `Document` class from the `python-docx` library is available, it extracts text, converting heading styles to markdown headers. If any exceptions occur during processing, it returns an empty string.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:infer_sections:5717452a9bbc927afa604d6e3eebfa0eecbe355222aadc9fe402732abedd2d8b:924b1cdb815ca67acc9c432c51086d612c482c610f86eb85ee0482a16a6a70ed": "The function `infer_sections` takes a string `text` as input and returns a dictionary of code documentation sections. If the input text is non-empty, it creates an \"Overview\" section with the combined text and placeholder content for other required sections labeled \"(inferred)\". If the input text is empty, it initializes all required sections with a default message indicating no information is provided.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:inject_user_manual:720d169cc1b866d4ea935910f1ee6be2484c109d1667b9a2777339b64558c0f2:985f1f50921ed95ee4e595d8ef22775df054ffcc65ee038443e3055079df29e9": "This function `inject_user_manual` inserts a top-level link to a user manual into an HTML file specified by `index_path`. The link is added either before the first `<nav>` or `<ul>` element if present, or at the start of the first `<body>` element or the document root if neither are found.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:insert_into_index:59dda5b202b9b56819547737565da370c6c1cd9da702d7cba83bf89be3a0e684:f769af8452d0dcef7f797693dcdada9a93a900605d6346ecade5201d65341fd0": "The function `insert_into_index` appends a navigation entry linking to a specified file into an HTML index file. It uses the BeautifulSoup library to parse the HTML content of the index file, finds the appropriate container element (`ul` or `nav`), checks if the link already exists, and then adds it if not. Finally, it writes the updated HTML back to the index file.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:llm_fill_placeholders:28f59abca5c34e04760ecfad4d2f432ae1293147549b72f2bf7c5edc0655729e:ead2c291e37b71ef3b3611e729c28cc2d436ac5bf5268e7734bbf02d6b0c893c": "The function `llm_fill_placeholders` processes a manual text and integrates relevant code snippets into it. It uses an LLM client to fetch summaries of long code snippets and updates the manual incrementally for each section. The function handles token usage efficiently by summarizing large snippets before sending them to the model, ensuring that prompts stay within the model's context window. It logs information about which sections were updated with code from specific files.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:llm_generate_manual:bba9e4244895386c8a8209f31f63c7063fe33ecb3c64391945aee5febbadf31b:383255020c40087d641b0fc40505325eb3c12db20ffbb38a42758376f4d7d66f": "The function `llm_generate_manual` takes a dictionary of documentation snippets, an LLM client, a response cache, and an optional chunking strategy as input. It maps the documentation to sections, performs LLM calls for each section, and assembles the final manual text. The function returns the manual text, a mapping of source files to sections they contributed, and an evidence map capturing the snippets used for each section.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:map_evidence_to_sections:300c69659c5d0dd1a521ffec654f3ce0361c9dfaf7aa2e34260afe35b6c5ca58:023eced64a67ec183d9893e1044c67238b6556c13f3f348e358e753932d6990b": "The function `map_evidence_to_sections` takes a dictionary of source paths and their corresponding documentation texts as input. It processes these documents to map them into sections based on predefined keywords and returns two dictionaries: one mapping section names to the top 10 snippets (by length) from each file, and another mapping each file path to the set of sections it contributes to. The function filters out snippets from excluded directories and ensures that only the most relevant snippets are kept per section.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:parse_manual:ed6dc4b01778737c04e5483024f06f431b304d9187a4cd09e7c36cca34e32351:e82440b0f7c248384827b9cc23fb1e6a8da9da44acabe7b4ffa508fdd6854bbf": "The `parse_manual` function takes a string of text and an optional LLMClient object, along with a boolean flag to infer missing sections. It parses the input text into structured sections based on lines containing a colon. If required sections are missing and inference is enabled, it uses the provided LLMClient to generate summaries for those sections and marks them as inferred. The function returns a dictionary where keys are section names and values are their corresponding content.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:rank_code_files:a0159033b8ab81a291611895bb78c40541d66be354029fd7c19cc6adfc3d4d9a:72af100be10aee123801a6fa70591926193bcaf673f58fea03ac1ec0876db121": "The function `rank_code_files` ranks Python files under a specified root directory based on their relevance and structure. It supports various file extensions including `.py`, `.m`, `.ipynb`, `.cpp`, `.h`, and `.java`. The ranking is determined by heuristics that look for specific keywords in the file paths, such as \"run\", \"main\", \"cli\", etc., and by checking if they match any user-provided patterns. Files with higher scores are considered more relevant and are returned first in the sorted list.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:render_html:9c6e9ecb09dace8720910e5f7056c76a3e4fcfccc1d3adcc7775973f2f3e9aa8:a94b0522037852978ee91583649172970eb205c60c7c1d4fc8cc42fa450fec53": "The `render_html` function generates HTML documentation from a dictionary of sections, each containing code or documentation text. It includes an optional evidence map to provide supporting snippets when the section content is empty or lacks information. The function slugifies section titles for navigation links and renders the content in Markdown if available, escaping any HTML to prevent injection attacks. It constructs the HTML document with a title, table of contents, and body parts containing section headers and rendered content.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:scan_code:0c90a6949d750bf8df8fb81cdebb59a4a60b1e355af89650eb54ff656f0a07ce:bfaa48d7d5a5dd107b9449bb4cb1040e21d7e4c02ca0afe4a374573d2b2bf8b9": "The `scan_code` function collects source code snippets from a specified base directory (`base`) and groups them by manual sections. It uses regular expressions to identify relevant patterns in documentation files, ranks the identified files based on their relevance, and then extracts snippets from these files. The function allows for customization through parameters such as maximum number of files (`max_files`), time budget (`time_budget`), and maximum bytes per file (`max_bytes_per_file`). It categorizes the collected snippets according to predefined sections and returns a dictionary where each key is a section name and the value is another dictionary mapping relative file paths to their corresponding code snippets.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:slugify:ada6b588c74fd8e457f14e6d647c06e050bd7c37060280a076c45f31d490dac4:eeba86f9b360c54e09cd3f341df2a6c7e4a8116b146d17fb28ac5c72ec5b8b22": "The `slugify` function takes a string `text` as input and returns a filesystem-friendly slug. It first strips any leading or trailing whitespace, converts the text to lowercase, and replaces all non-alphanumeric characters with underscores. If the resulting slug is empty after removal of underscores, it defaults to \"user_manual\".",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:validate_manual_references:68654bc91b06ff90778475798572e65e4dbcba7577b320c72b41e052785c0ee7:8743bee6c1f6369779f721f4642e164de7b7c8365bfe42a9c38a8a180e053494": "The `validate_manual_references` function checks for the existence of file references within a dictionary of document sections. It uses regular expressions to identify potential file paths or module names in the text of each section. If a referenced file is not found under the specified project root, it appends \"[missing]\" to the reference in the text and records the missing references in an evidence map if provided. The function modifies the input dictionary in place.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\explaincode.py:write_pdf:f52bb526a3778c33851a7f6526e07d710645dbcb74004f6f8272c7cb7d2c7798:490b91d015c9582c3ea88c7213e26b7387a84772634e4f32ab2446233a5cabff": "The function `write_pdf` takes an HTML string and a file path as input. It checks if the `canvas` module is available; if not, it returns `False`. Otherwise, it extracts text from the HTML using BeautifulSoup, initializes a PDF canvas, writes the extracted text to the PDF, saves the PDF to the specified path, and returns `True` on success.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:__init__:24a5685c6e6c99459bfb24d832e2ed036e965f0ce28b720d677453bb9e024f93:f1e4eb5605dd2cc9151d1595942db6ecbea5807244451dc0e1cb5cca5db5a309": "The `__init__` method initializes a new instance of the `PathLineEdit` class. It accepts an optional `parent` object and calls the constructor of its superclass with this parent. The method then sets the drag-and-drop acceptance property of the line edit to `True`, allowing it to handle drag-and-drop events.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:__init__:3ed6b73a553a559e35aa2f0f8212190aa7e2a68c60fbb0cb96d6219b3635b6b5:d530293eae2c59418919a519901e399e3b7752c5154490f925ec61c18a1f0b90": "The `__init__` method initializes a new instance of the `CollapsibleBox` class. It sets up a toggle button with optional text and makes it checkable. The button is styled to have no border, a light gray color, and bold font weight. The arrow type is set to right, and a click event handler (`on_toggled`) is connected to the button's `clicked` signal.\n\nA content widget is created and initially hidden. A vertical layout is set up for the main widget, with no margins, and adds both the toggle button and the content widget to this layout.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:__init__:7bb44646a186dfac43852071ab78e36f21bc7e6fbaa9c6d75fd657f52bb74c16:5e85eaa24f4e91dd11ae8beadcf70086a90ec4f23030e770da6c7fdce50bea25": "The `__init__` method initializes a new instance of the `CommandRunner` class. It takes a list of commands (`cmds`) as an argument and stores it in the instance variable `self.cmds`. This setup is typical for classes that need to manage or execute external processes, allowing them to be configured with specific tasks upon creation.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:__init__:7ebb9fb15bd43d6a84b1fd411010f898ba3077fe014c2f3e2309dcaed6c24efc:04259cbc6c8f5ebfb91e8909ebfeb393f6fb623b79ac0c230d1886f01444c2fc": "The `__init__` method initializes the user interface for the `MainWindow` class. It sets up a window with a title and dark theme, including sections for selecting project and output directories, choosing languages to document, setting output formats, and running commands for document generation and explanation. The UI components include labels, text fields, checkboxes, combo boxes, buttons, and a log area. Each section is organized into collapsible boxes for better organization. The method also connects button clicks to corresponding methods for running DocGen and ExplainCode commands.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:_reader:bbcb7f85e976e16f9460fb56395ab9f8c4bfe0435f8c21e2da996047db183bee:22c4c1a70758a1a3d192df6ad1b603c71acd7ca69678fa046a324cc6cc701f4d": "The `_reader` method is part of the `CommandRunner` class and is responsible for reading characters from a stream, emitting chunks of text, and handling carriage returns. It captures any buffered text when the stream ends or when a newline character is encountered. Carriage return characters are emitted to allow for progress bar updates in a GUI.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:append_log:57de80604eb293fce59e447fd46a7b5d99aaae520d39b5e39f9f1449f27b3cc4:8b9976db1c5d25a4d00d58ed0fc37f96b9a7259d6fe70e95308e9dd166f94412": "The `append_log` method in the `MainWindow` class appends text to a log widget. It uses regular expressions to split the input text into parts, handling carriage return characters by moving the cursor to the start of the line and removing any existing text before inserting new parts. The method ensures that the log widget scrolls to the bottom after appending text.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:build_docgen_cmd:64301c0a4480ba38d6ed69d4149ad924000609606cb9080ed332c066ec21d74c:523d2e664809b6367e357ce60542ae38087b91556784ca563cb7390d7f3402c7": "The `build_docgen_cmd` method constructs a command list for running the `docgenerator.py` script with specified parameters. It includes the project directory path from a UI element (`self.project_edit.text()`) and the output directory path from another UI element (`self.output_edit.text()`). If a checkbox indicating private documentation is checked, it appends the `--include-private` flag to the command list. The method returns this constructed command list, which can be used to execute the document generation process through an LLM client.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:build_explain_cmd:c78c8ad7f3316c15dd840511dfa45f74289a58d0895a336569b7163a4d54d571:dc1f5069d1190145f566700e57ada5748e101c55ac0d03fb69f024e3a3b8ed7e": "The `build_explain_cmd` method constructs a command to run the `explaincode.py` script with parameters for project path, output directory, output format, and optional data. It retrieves values from UI elements such as text edits and combo boxes, and conditionally includes additional arguments based on user selections.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:dark_style:b98cf6a602f88fc70c5fe579cf1b77472ab9a707d772f38ed16f0dde5ce84377:2b4635fcce11f4dddd5a0fb9bdd7ec72e007039e10abc317b0b49ad248887e3b": "The `dark_style` method returns a string containing CSS code that defines the appearance of widgets in the `MainWindow` class. The style includes dark colors for backgrounds and text, with specific styles applied to `QWidget`, `QLineEdit`, `QPlainTextEdit`, `QComboBox`, and `QPushButton`. It also sets hover effects for buttons and normal font weights for labels.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:dragEnterEvent:056f486dfa0f63a33961e0276471afaa3bcfce08c9d4889f3d50657beaac2bdd:363ecba9f3d18483bffe33cd0ee719fd33fd81ea29cee672941a60c0c8dddf4c": "The `dragEnterEvent` method in the `PathLineEdit` class checks if the incoming drag-and-drop event contains URLs. If it does, the method accepts the proposed action to allow the drop operation. This ensures that the `PathLineEdit` component can handle file path data through drag-and-drop interactions.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:dropEvent:e3da1deeaf4668eb5a93cc8ff9f66af7160a0c77a6788c4c73db06a508ec67ab:2b5e7a2319b9aa4af70ab6bdd13dca5dfbf23414c2652ba7dea768748ec6af67": "The `dropEvent` method in the `PathLineEdit` class handles the drop event for URLs representing file paths. It extracts the first URL from the dropped data, converts it to a local file path using `toLocalFile()`, and sets this path as the text of the `PathLineEdit` object.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:on_finished:2df4c939b82029bb20107da8e593d4ae401d5698059594ddec8e60b80ec20496:24dabecf9709b9342785e9aad0c85aea497ca32a94e3041ebaad8eb57dbf6a4f": "The `on_finished` method in the `MainWindow` class handles the completion of a process. It appends a log message indicating the exit code of the process and sets the running state to False, signaling that the process has finished executing.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:on_toggled:639b8c1e7b0d723f40b544d9a6f05d5254619006855addd1754b79b23a468296:68256ce04f16d7d7043b6b2de861435968f932619c7fd9cc51bca70efa87aa3b": "The `on_toggled` method is a callback function for the toggle button in the `CollapsibleBox` class. It updates the state of the content area based on whether the toggle button is checked or unchecked. If the toggle button is checked, it sets the arrow type to `QtCore.Qt.DownArrow`, making the content visible. If the toggle button is unchecked, it sets the arrow type to `QtCore.Qt.RightArrow`, hiding the content.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:run:3c70a8187876affcd29dbf138204d151e8307bd3c4daa9250c69ea4080a1f5c0:90f3c5e7073d964e848b712d492c7ef3ab61694abafb209d6eb423a0dae60769": "The `run` method of the `CommandRunner` class executes a list of commands sequentially. It captures standard output and error streams using separate threads to handle real-time updates, such as updating progress bars in a GUI. The method emits each command being executed and handles exceptions by setting the return code to -1 if any command fails.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:run_both:fc5f499a7acfa075b08552b1f826f87cf07a537fb5e244ec66bb6c0bd8a20167:6d2526a4dccc4f8e4fc39eaaf9fdf5d5841047c7af1182e1bdbd5bdfddcacc82": "The `run_both` method in the `MainWindow` class clears the log and then runs two commands: one for generating documentation using DocGen-LM (`build_docgen_cmd`) and another for explaining the generated documentation (`build_explain_cmd`). This method orchestrates the execution of both document generation and explanation processes within the GUI application.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:run_commands:c185683c809fae68ca4f469057cd66def009783def382886dcdb88f1e1b5c88d:8e067cfe801c0aa35194753416441414af6864700812dfb4a2c2eedc2b5ccf56": "The `run_commands` method in the `MainWindow` class is designed to execute a list of commands for document generation and explanation. It first checks if both project and output directories are set by verifying non-empty text in `self.project_edit` and `self.output_edit`. If either directory is not set, it logs an error message and returns without executing any commands.\n\nIf the directories are valid, it sets the application to a running state using `self.set_running(True)`. It then initializes a `CommandRunner` object with the provided list of commands (`cmds`). The `CommandRunner` is configured to connect its output signal to the `append_log` method, which logs messages to the user interface. Additionally, it connects the `finished` signal of `CommandRunner` to the `on_finished` method, which likely handles post-command execution tasks such as updating the UI or notifying the user of completion.\n\nFinally, the method starts the command execution by calling `self.runner.start()`.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:run_docgen:516fccfd02717129c37d4e8d4675e52ac14778f849def11e16115a6fb222ac23:ec8729e9554844970451b174506de63c31e7bd8904368cd09ca830a684971904": "The `run_docgen` method in the `MainWindow` class clears the log and executes a command to generate documentation using DocGen-LM. It constructs the command using the `build_docgen_cmd` method and then runs it through an LLM client.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:run_explain:8469ec3ed2459cf0ad8cfbf75c0472dbad24dfb0382c4b4bbb3ae866b9c734c9:dadf610f1ec6bc8145cd80d312f388ebca0441e3b50f200c78567671c581f148": "The `run_explain` method in the `MainWindow` class clears the log and executes a command to generate explanations for the selected project using DocGen-LM.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:select_dir:8a4bb90b1196bdd3f58306205a81134e4ed74dce16bb4f4742f2b67bcba1c958:c99ef6cde24444e18edf6ac90d8755795ac18efbe06331c34e84467965444e45": "The `select_dir` method in the `MainWindow` class allows users to select an existing directory through a file dialog. When a user clicks on a button or performs an action that triggers this method, it opens a dialog prompting the user to choose a directory. If a valid directory is selected, the path of the chosen directory is displayed in the provided `QLineEdit` widget. This functionality facilitates setting project and output directories within the graphical user interface.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:select_file:a4d4c7081d8e4884a94eb6f8846c8685527fc04fd1058099ed4c65de66013a9b:844ec75a3afb07f70cf52aa546b3af40d8552c8ec30aff253d58bea8ba45dba6": "The `select_file` method in the `MainWindow` class allows users to select a data file (JSON, CSV, or TXT) using a file dialog. The selected file's path is then displayed in the provided `QLineEdit` widget.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:setContentLayout:f2ef0a1b38339c5b9a5f027989d5beedc841fc783c0727f762235b1fe1f304c1:2c00bc9ead4216cddc37b04ab15eac55f48c98712caf6531bdf70f3b59fed4c5": "The `setContentLayout` method sets the content area of the `CollapsibleBox` widget to a new layout. This allows for dynamic updating of the content displayed within the expandable section based on user interaction or other programmatic changes.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\gui_wrapper.py:set_running:1c763cb7da62db5dcda7ab89791b960e2e950ef3f6e4617eb18cb7d38c7fca19:86fdb7855f1690a95c545417a634f588883c707bc021b32c2fd760e7310c5baa": "This function `set_running` is a method of the `MainWindow` class. It takes a boolean parameter `running`. The function iterates over three buttons (`docgen_btn`, `explain_btn`, and `both_btn`) and sets their enabled state based on the value of `running`. If `running` is `True`, the buttons are disabled; if `False`, they are enabled. This likely controls the usability of these buttons in response to whether a document generation or explanation process is currently running.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\html_writer.py:_highlight:069c373c9e1aaf536f2f289be5ac983bd15e3d0e2d370f3f91597afcce13c705:44a9b099baff0f8dabd0897a65359cbeb00263fe5a28b66e8020f49e254f8f5f": "The function `_highlight` takes a string of code and a language identifier as input. It uses the `pygments` library to apply syntax highlighting to the code based on the specified language. The function supports Python, MATLAB, C++, Java, and generic text. It returns the highlighted code wrapped in HTML `<pre>` and `<code>` tags for proper rendering.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\html_writer.py:_render_class:6e4b208b383c4fad5d397409f6fcbcd37e3e37e901c5ed5f73ee7dccdd675295:32c425a8df7ea61eaafadf10cf721197faf896e0d61f2da2429c17edca2b872b": "This function `_render_class` generates HTML parts for a class and its subclasses. It takes a dictionary representing the class, a programming language, and an optional nesting level as input. The function constructs HTML tags based on the provided level to create expandable sections for classes and their members. It includes the class name, documentation, variables with summaries, methods, and subclasses. Each method is rendered using another function `_render_function`. Subclasses are wrapped in `<details>` tags for collapsible display.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\html_writer.py:_render_function:e3b7e4abfdf239604c632b69345c12104a6d67832f708e3e47026f4bcc300067:f03a36bbe64e904df757b4ba90938b2e47c9f71e7e389a6e3791efd97cfce405": "This function `_render_function` is designed to generate HTML parts for a given function and its nested subfunctions. It takes three parameters: `func`, which is a dictionary containing information about the function; `language`, indicating the programming language of the code; and an optional `level` parameter that controls the heading level, defaulting to 3. The function also accepts an optional `prefix` for additional text before the function signature.\n\nThe function constructs HTML parts by:\n1. Creating a header tag (`h1` to `h6`) based on the provided `level`, with the function's name and signature.\n2. Adding a paragraph containing the summary or docstring of the function, if available.\n3. Highlighting the source code of the function using `_highlight` function, passing the language as an argument.\n4. Iterating over any nested subfunctions, creating a `<details>` element for each subfunction with a `<summary>` tag displaying the subfunction's signature. It then recursively calls itself to render the subfunction details.\n\nThe resulting list of HTML parts is returned, which can be further combined to form the complete documentation for the function and its subfunctions.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\html_writer.py:write_index:48a08c2cd04a3deb78831cf14a6f949fd486fa90cd60435557825835fad1478b:27386c7f2693ef4098ce8d3f46e145cdc1c8a1a2e822c189eac7308376a1c986": "The function `write_index` generates the content for an `index.html` file in a specified output directory. It takes three required parameters: `output_dir`, `project_summary`, and `page_links`. The optional parameter `module_summaries` provides additional information about modules.\n\nThe function creates the destination directory if it doesn't exist. It constructs HTML navigation links from the `page_links` parameter, escaping any special characters to prevent XSS attacks. It also escapes the project summary for inclusion in the HTML body.\n\nFor each page link, the function checks if there is a corresponding module summary and includes it in the output. The module items are formatted as list items with optional summaries displayed below the links.\n\nThe function then combines all parts into an HTML document using `_render_html`, which presumably handles the actual rendering of the HTML structure. Finally, it writes the generated HTML to `index.html` in the destination directory.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\html_writer.py:write_module_page:bcc63064d79881631a0dee4c5b63e5d03975d17f0195378c25a9e9218acb809a:24821cf50d2c82f63f62b31f83e3a68144643a2cc81da169f138e653bb4f8d5a": "This function `write_module_page` generates an HTML documentation page for a Python module. It takes three parameters: `output_dir`, which is the directory where the output HTML file will be saved; `module_data`, a dictionary containing information about the module such as its name, summary, classes, variables, and functions; and `page_links`, an iterable of tuples representing navigation links.\n\nThe function first constructs the destination directory for the output file and ensures it exists. It then prepares the navigation items for the HTML page, including a link to the project overview and any additional links provided in `page_links`.\n\nNext, it builds the body content of the HTML page. This includes rendering summaries, classes, variables, and functions from the `module_data`. Each class is rendered using `_render_class`, each variable and function using `_render_function`, and source code snippets are highlighted using `_highlight`.\n\nFinally, the function combines all parts into a complete HTML string using `_render_html` and writes this string to an HTML file named after the module in the specified output directory.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\llm_client.py:LLMClient:0450ae63cabfa0ed173a17685aaed786fb03ea0116bb2780dc7d65aa134af656:f58e8b90a5ceb1fe8faffd827e3b347a5bd448329c6f4befec00c7f46a5e14d4": "The `LLMClient` class provides a thin wrapper around the LMStudio HTTP API, enabling interaction with language models. It includes methods for checking connectivity (`ping`) and generating summaries of text using specified prompts (`summarize`). The `summarize` method constructs a prompt based on a template, sends it to the API, and processes the response to return a summary.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\llm_client.py:__init__:33551ebb4c0562968b7feb1c77d0250b2062934652c15308e3a38419be39b51c:9751802da1b7a680cf4047605cba7a2b1e6f0586495865c6adb09d1add9c8160": "The `__init__` method initializes an instance of the `LLMClient` class. It accepts two parameters: `base_url`, which defaults to \"http://localhost:1234\", and `model`, which defaults to \"local\". The method sets the `base_url` attribute by removing any trailing slashes, constructs the `endpoint` attribute by appending \"/v1/chat/completions\" to the `base_url`, and assigns the provided `model` value to the `model` attribute.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\llm_client.py:ping:065d05d74e01c06152e3d55b6344fbc1774d1c1382054864623502b14671e432:b47b30293e91df88a60b3496e08566d606d89c7759a73effab8e361e1e41a22f": "The `ping` method in the `LLMClient` class checks if the API is reachable by sending a GET request to the base URL with an optional timeout. It returns `True` if the server responds successfully, otherwise it raises a `ConnectionError` indicating that the server cannot be contacted.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\llm_client.py:sanitize_summary:048ae164197efe6a097ba8f0d608e5a9603ba111588a6292a172a0edee086fe0:be74c6875c644f40bf4cf23d28161546be79fa470af7cec3445f7584c562573a": "The function `sanitize_summary` takes a string `text` as input and returns a sanitized version of the text by removing lines that start with certain phrases or contain specific keywords related to summaries, outputs, responses, and other meta-commentary. It also removes leading and trailing whitespace from each line before processing. The function uses a list of bad starting phrases and specific keywords to filter out unwanted content.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\llm_client.py:summarize:45caf7308e1460260513db86c58d68f9263517d6729ba547b094f3a0e24531cf:4a6149459bd9127c72ce06ece822a44fba270cd8c171478ee959207009028792": "The `summarize` method in the `LLMClient` class generates a summary for a given text using a specified prompt type and an LLM endpoint. It constructs a payload with the model, temperature, system prompt, and user prompt, then sends this payload to the LLM endpoint via a POST request. The method handles potential errors during the request, such as HTTP errors or request exceptions, by logging the error message and retrying up to three times before raising a `RuntimeError` if all attempts fail.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\manual_utils.py:_count_tokens:fe7952d3c31a6ced435d1419a878d6a93857bc2e92d6bc6a8281b7bf472a7b6c:ce6a92c6278cd9b9586514b81ba46ad856bcac4a079db2cbb90b78880af7caa8": "This function `_count_tokens` takes a string `text` as input and returns an integer representing the approximate number of tokens in the text. It uses a tokenizer to encode the text, which converts it into a sequence of tokens, and then calculates the length of this sequence to determine the token count.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\manual_utils.py:_split_text:bd630c61a62dfada718b9947960c5f5c18848bd688ae8a333af787c2b4c14a7b:bcd50290b39ae82460ff3d4bfea9122f93dcc1b167ab95006d98dc09d118a35b": "The `_split_text` function splits a given text into chunks while respecting specified maximum token and character limits. It first splits the input text into paragraphs, then iterates through each paragraph to determine if it can be added to the current chunk without exceeding the token or character limit. If adding a paragraph would exceed the limits, it starts a new chunk. If a single paragraph exceeds the limits, it is further split using another function (`chunk_text`) before being added to the chunks list. The function returns a list of text chunks that adhere to the specified size constraints.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\manual_utils.py:_summarize_manual:b6aab3dfcc5ecbf0f95ba4a91c0ca420c7e8867cbae5d702cd99a6b2275e22f9:ba727135f4ac6129bb1cb963895ebcf93ef4403ddf95a4c5f0b1062fbdb0715a": "This function `_summarize_manual` generates a manual summary for the provided text using an LLM client and a caching mechanism. It supports different chunking strategies: \"manual,\" \"auto,\" or \"none.\" The function handles text splitting, caching of responses, and hierarchical merging to ensure that the summary does not exceed token or character limits. If the text is too large, it chunks the text into smaller parts, summarizes each part, and then merges them back together. The function uses a post-chunk hook for additional processing if provided. It also handles exceptions gracefully, logging warnings for failures during chunking, summarization, and caching.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\manual_utils.py:chunk_docs:7e54dc60e0772e07b6fd6448ccc531a1c2c6904df5f067269291fe3b0b72bb1e:92414b7d919ee88ae2d360607ac9838f29ed9825c25b491e04574f9199a94ac5": "This function `chunk_docs` takes a list of strings (`docs`) and an integer (`token_limit`) as input. It joins the non-empty strings in `docs`, separated by double newlines, into a single string. If the resulting string is empty, it returns an empty list. Otherwise, it calls another function `_split_text` with the combined text, using both `max_tokens` and `max_chars` set to the value of `token_limit`. The purpose of this function is to split the documentation into chunks that do not exceed a specified token limit for processing or storage.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\manual_utils.py:find_placeholders:cbd38882a15150ef9d6cfdb75f56c5cec0aee30e4fbd4ff42f679ee4e38372e2:e35a27e18d9620b24f47e57246e3f07e51a731cd19bca4e818dcb9da925aaea3": "The function `find_placeholders` takes a string `text` as input and returns a set of placeholder tokens found within the text. Placeholder tokens are identified using a regular expression defined by `PLACEHOLDER_RE`, which matches strings in the form ``[[TOKEN]]``. The function extracts all such tokens from the input text and returns them as a set, ensuring uniqueness.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\parser_cpp.py:_extract_block:75c98180c1c16297a6950c9bbdacf1098df0a84c53583145ff26059a828f1d37:558af3a5161ee8d4106ce8f69c665fe7f4bfe9acdf0aa08f63a08a50e213b6b4": "The function `_extract_block` takes a list of strings `lines` and an integer `start` as input. It returns a tuple containing the text of a block starting at the given index and the ending index of that block.\n\nThe function initializes a list `text_lines` with the line at the start index. It then counts the number of opening and closing braces in the starting line to determine if it is part of a block. The function iterates through subsequent lines, appending each line to `text_lines` and adjusting the brace count until it reaches zero, indicating the end of the block. Finally, it returns the concatenated text of the block and the index of the last line included in the block.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\parser_cpp.py:_get_preceding_comment:5e6170eeec51669558241ee8b2bdbcea661914285ef9102eec1bd6641acefd66:bd97e6d892fe5785c36c3320d06734c3cc4656441853fa5433f9b2ddb993ad44": "The function `_get_preceding_comment` extracts contiguous comment lines from a list of source code lines that appear before a specified index. It handles both single-line (`//`) and multi-line (`/* ... */`) comments, collecting them in reverse order (from the current line to the first preceding comment) until it encounters a non-comment line or reaches the beginning of the file. The function returns a string containing all collected comments, joined by newlines.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\parser_cpp.py:_parse_class_body:da766cd316042c4641dcdd928790d61ef80acd43ed5634a839ee57001a93078b:dd0db24808ac2b72b9cb7add27dcc75604d5faf75dcb608b7bfbe210854a4cbe": "The function `_parse_class_body` processes a list of source code lines to extract and categorize public methods and variables within a class. It returns two lists: one for methods and another for variables, each containing dictionaries with details such as name, signature/type, docstring, and source code block. The function iterates through the lines, identifies access modifiers (public, protected, private), and extracts method signatures and variable declarations based on their syntax.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\parser_cpp.py:parse_cpp_file:00611cdfecbc8e897bae0db550e957dda0f28728f244cddf85db3a75e64845ca:3a5d7a34eebdd3724052a64ff6f501fa5211ed3e36f0904a49c1cd1028f657fd": "The `parse_cpp_file` function reads a C++ source file specified by the given path and returns structured information about its contents. It processes the file line-by-line to extract module-level comments, namespaces, classes, and functions. Each class and function is parsed to capture their names, signatures, docstrings, and source code blocks. The function also handles nested structures within classes and extracts methods and variables. The result is a dictionary containing the parsed information organized by module-level comments, classes, and functions, along with optional namespace details if present.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\parser_matlab.py:parse_matlab_file:a5b2a3c5077b8f5099c29e206899f87f0df696d5ae3735b22d710df2d64b177c:b6b2638e71ed632a41331842ee35a833523b8d6ccdf59ab9592ffc46c9c28a16": "The function `parse_matlab_file` reads and parses a MATLAB `.m` file to extract its structure. It returns a dictionary containing the file's header comments and any function declarations found within. Each function entry includes the function name and a list of arguments. The function uses regular expressions to identify and parse function declarations from the file content.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\parser_python.py:_format_arg:d6a1c9210ebe701755e14858a2df4adbd3a65f9f0980b58c50858caa13a554db:f4c63ed1cee8821eac567d6ce49a376fb7043f96eee263c192fdaaac8efa3b5b": "Formats a function argument by appending its type annotation, if available.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\parser_python.py:_format_arguments:b074d3b8969d1f89cea451426055c2439ae99bc930adf29c101b569fa98759c6:ed6cc08dadbd69c3e8f457e71345bb9915aea25a4d063a89368111741b62d57a": "This function `_format_arguments` takes an `ast.arguments` object as input and returns a string representation of the arguments it contains. It handles positional-only parameters, regular parameters with optional defaults, variable-length positional parameters, keyword-only parameters with optional defaults, and variable-length keyword parameters. The function formats each argument according to its type and whether it has a default value, then joins them into a single string separated by commas.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\parser_python.py:_format_signature:a1a6dcd3114accf60a40961901f888e5e5111fe17ee267724c0b215623207aac:39fccbe4b2b84954ad26ea4c7bdd3c524df479ec189d8a057d41f6ef815f0d0d": "This function `_format_signature` takes a Python `ast.FunctionDef` or `ast.AsyncFunctionDef` object as input and returns a string representing the signature of the function, including its name, parameters, and return type if specified. It uses another helper function `_format_arguments` to format the arguments of the function.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\parser_python.py:_parse_classes:da6e43147a4ddef9317a0efa3cd48e838e5e4472b02dd540dfcdf927d0736cd1:0b162b40ee3a8de96c9934cd385b0c7ff078dd3bc2a095177c72d790bfa9fec2": "This function `_parse_classes` recursively parses all `ClassDef` nodes within a given list of AST nodes. It iterates through each item in the input list and checks if it is an instance of `ast.ClassDef`. If so, it calls another function `parse_class` to process the class node and appends the result to the `classes` list. If the item is an instance of `ast.FunctionDef` or `ast.AsyncFunctionDef`, it recursively calls `_parse_classes` on the body of that function to search for nested classes. Finally, it returns the list of parsed classes.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\parser_python.py:parse_class:c1d902496578a84f8435678e8eae094cdcacea9dd733b52f7ae1c61c7ad4eb8c:56ea9035ec6a35f66e71bd82f2d87de69e0dfb1f3d35e20722fd65cc008c0322": "The function `parse_class` takes an AST node representing a class and the source code as input. It returns a dictionary containing information about the class, including its name, docstring, methods, subclasses, and source code segment. The function iterates through the body of the class to identify and parse any nested functions (methods) and subclasses, adding their details to the returned dictionary.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\parser_python.py:parse_classes:db4c5decb627ec9a5c2a40ccb138e938ca09c39358c8ce915e898f8bd183d369:dc2026c8fdf16a839e3ec7adc88fc398e4757b12c4fd51670b69914364e343db": "This function serves as a public interface for parsing classes within Python code. It accepts an abstract syntax tree (AST) node and the source code as input. The function then calls a private helper function `_parse_classes`, passing it the body of the AST node (or an empty list if `node.body` is not present) along with the source code. The result is a list of dictionaries, each representing a class found in the source code.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\parser_python.py:parse_function:b0cdece289ae24b42a28fd6b63872f3746e108cb0000c472ede355db671d55d5:deb0069c2cf8222045b18f9458de29a01e16bf14a6e67017fe5c0361b495a70b": "The `parse_function` function analyzes a Python function or asynchronous function node (`ast.FunctionDef` or `ast.AsyncFunctionDef`) and extracts detailed information about it. It returns a dictionary containing the function's name, signature, return type (if any), docstring, source code segment, and lists of nested functions and subclasses.\n\nThe function uses helper functions `_format_signature` to format the function signature and `_parse_classes` to extract subclass information from the node's body. It recursively processes each item in the function's body to identify and parse nested functions and subclasses, adding them to the `subfunctions` and `subclasses` lists respectively.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\parser_python.py:parse_python_file:74a210274cf2445444cdb8955b671f26586080dcd6b16fe97bff18c689234ab5:faadb7912206070377a142b64afeff368c6d692bedc1e949e7a1b0a9c4897a13": "The `parse_python_file` function reads a Python source file and extracts structured information. It takes the file path as input and returns a dictionary containing the module's docstring, classes, and functions.\n\n- The function reads the content of the specified Python file.\n- It uses the `ast.parse` method to parse the source code into an abstract syntax tree (AST).\n- A dictionary is initialized to store the parsed information, including the module's docstring and lists for classes and functions.\n- The function iterates through the nodes in the AST:\n- If a node is a class definition (`ast.ClassDef`), it calls `parse_class` to extract details about the class and adds it to the dictionary.\n- If a node is a function or asynchronous function definition (`ast.FunctionDef` or `ast.AsyncFunctionDef`), it calls `parse_function` to extract details about the function and adds it to the dictionary.\n- Finally, the function returns the dictionary containing the parsed information.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\reviewer.py:_is_generated_html:085934f44749c0c2bd856a0048ccd4d9c7b5cf5c39424d8fe25ddd6be01f15c1:840c5b3683161f0f86ae8807d4926a2abe9e90682855beec2ce792b7dd4ee90b": "Function `_is_generated_html` checks if a given `text` string appears to be output from DocGen-LM, a code documentation tool. It returns `True` if the text contains specific markers indicating it was generated by DocGen-LM: the phrase \"Generated by DocGen-LM\", an HTML heading for project documentation, and headings for classes and methods.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\reviewer.py:check_assistant_phrasing:0af4e244741b636bc426d7f3e0df4d9e42ffbb858ce4cc750475ccda9dd894be:ccea89692af93d3a75da22e3ab5e8d32e5b2a26b471fc9b98ae6f599af5092af": "The function `check_assistant_phrasing` analyzes an HTML string to identify and list occurrences of phrases that mimic assistant-like language. It extracts paragraph tags from the HTML, strips any HTML formatting, converts the text to lowercase for case-insensitive comparison, and checks if any predefined assistant phrases are present. If a match is found, it records the exact phrase along with its line number in the original HTML. The function returns a list of these findings.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\reviewer.py:check_contradictions:f5d6bf8feb23582f4662a5d6d1967cf819df9584aa8de76d1a5c847fc00141de:dee3640729263cfc222494acdd8e490606147ea4355970ae827f0cd650b8d77d": "The `check_contradictions` function analyzes HTML content to identify contradictions between the text and the structure of the code. It returns a list of contradiction descriptions.\n\n1. **Extract Paragraphs**: The function extracts all paragraph (`<p>`) tags from the HTML, strips any HTML tags, converts them to lowercase, and joins them into a single string `summary_text`.\n\n2. **Extract Headers**: It also extracts headers (`<h3>` and `<h2>`) that start with \"Method:\", \"Function:\", or \"Class:\".\n\n3. **Check Contradictions**:\n- If the summary text contains \"no methods\" but there are method headers, it appends a finding.\n- If the summary text contains \"no functions\" but there are function headers, it appends a finding.\n- If the summary text contains \"no classes\" but there are class headers, it appends a finding.\n\n4. **Return Findings**: The function returns a list of contradiction descriptions based on these checks.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\reviewer.py:check_hallucinations:fd19c6ff1bb265cd25ad375b127077c62764de70d084eaa3ff0213935a319b40:cee159f01934d51c06f496107c0212548bfa02846593114d03108588acae1a4a": "The function `check_hallucinations` analyzes HTML content to detect the presence of hallucination phrases. It extracts all paragraph (`<p>`) tags from the provided HTML string, strips any HTML tags from the extracted text, converts it to lowercase, and then checks if any predefined hallucination terms are present in the text. If a term is found, it is added to a list of findings, which is returned at the end of the function.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\scanner.py:_is_subpath:baff8412cbe9580202f9f7bd58a372a4fc8c1467c748d6b0d7a8f8f127fe92bd:639d1aff101c8029085ae16a26a4c6f4b5d4b253840d6c1ac45d3ea613edc3ec": "This function checks if one file path (`path`) is a subpath of another (`parent`). It returns `True` if `path` is the same as or within `parent`, and `False` otherwise. The check is performed using the `relative_to` method, which raises a `ValueError` if `path` is not a subpath of `parent`.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\scanner.py:scan_directory:d663da55f773b2b71160e8ce9ab6e6c73a38e9fbcbdec81e34844be5d335840e:136f3d72aeb0ff04d190963415e8307c5171f4812ff210eadcd71da4b3a0cfca": "The `scan_directory` function recursively discovers source files with extensions `.py`, `.m`, `.cpp`, `.h`, and `.java` within a specified directory. It ignores paths listed in the `ignore` parameter and optionally displays a progress bar during scanning. The function returns a sorted list of absolute paths to the discovered source files.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\summarize_utils.py:summarize_chunked:1b5792cad3cf5b21378b129918fd5c48e19143dee8669d51d7f41ec98c70cf67:0db483955970deb91660c991badc17710d5ef5944daac9dcad9d33a9fc6592d2": "The function `summarize_chunked` is designed to summarize text by chunking if necessary. It uses an LLM client for summarization and a cache to improve performance. The function handles different prompt types, manages token budgets, and recursively merges partial summaries into a single technical paragraph. If chunking or merging fails, it falls back to direct summarization without chunking."
}