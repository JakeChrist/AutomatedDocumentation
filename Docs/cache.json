{
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\cache.py:2e37ab4b52e9489ed2b2dc8e686dc29df25416d04f5b423c47ba2cc9aecf698c": "A simple on-disk cache for LLM responses. Implements methods to get and set cached values using deterministic keys based on file paths and content. Persists the cache to disk in JSON format.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\cache.py:2e37ab4b52e9489ed2b2dc8e686dc29df25416d04f5b423c47ba2cc9aecf698c:2e37ab4b52e9489ed2b2dc8e686dc29df25416d04f5b423c47ba2cc9aecf698c": "A simple on-disk cache for LLM responses. Implements methods to initialize the cache from a file, generate deterministic keys based on file paths and content, retrieve cached values by key, store new key-value pairs and persist them to disk, and save the current state of the cache to a JSON file.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\cache.py:ResponseCache:15200124333ee58f9ba580b26bb3be6ccedf87f14368d70813e91827cdf7747b:15200124333ee58f9ba580b26bb3be6ccedf87f14368d70813e91827cdf7747b": "The `ResponseCache` class manages caching for responses in a JSON file using SHA-256 hashing. It provides methods to initialize, retrieve, store, and save cached data, ensuring that responses are efficiently stored and can be quickly accessed when needed.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\cache.py:ResponseCache:6c5d657c82e5033f80b13024ac20dfefecdf98e72801d95168c00c9807b0c562": "The `ResponseCache` class manages caching for code summaries generated by an LLM. It initializes with a file path, reads or creates a cache dictionary, provides methods to get and set cached values using a deterministic key based on file content, and saves the cache to disk in JSON format.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\cache.py:ResponseCache:89a4b3e39e24dd9e706ae9f71859d5ca131744e12dec58de2305c3402ccdc2d1:89a4b3e39e24dd9e706ae9f71859d5ca131744e12dec58de2305c3402ccdc2d1": "The `ResponseCache` class manages caching of code file summaries using a JSON file. It provides methods for initializing with a file path, generating a deterministic key based on file content, retrieving cached values, storing new values, and persisting changes to disk.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\cache.py:ResponseCache:__init__:919483e1ff4b05cae685fcac27aa9458bc309d42dd717af59b0942962ccdf4e4": "Initializes an object with a file path. If the file exists, it reads and parses JSON content into a dictionary; otherwise, it initializes an empty dictionary.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\cache.py:ResponseCache:_save:d6c96e0258c810e9fec48856af580533cfc0aa8f13ea666bb1d396aa4abe5e41": "The function `_save` writes the contents of `self._data` to a file using the `write_text` method. The data is serialized as JSON with an indentation of 2 spaces and keys sorted alphabetically. The file's encoding is set to \"utf-8\".",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\cache.py:ResponseCache:bd03b9ad138c9e2de53f5aebfc993b4d90eb518f8d3e29cdcfacc044518f6c88:bd03b9ad138c9e2de53f5aebfc993b4d90eb518f8d3e29cdcfacc044518f6c88": "The `ResponseCache` class manages caching of responses for files using a local Large Language Model (LLM). It provides methods to initialize with a file path, generate a deterministic key based on file content, retrieve cached values, store new values, and persist changes to disk in JSON format.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\cache.py:ResponseCache:get:eeb84b4591575a8ed2767f4abac56f1f2dd0697e81322599734b8b31e94ddcce": "Returns the cached value associated with a given key if it exists in the cache. If the key is not found, returns `None`.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\cache.py:ResponseCache:make_key:4f63c9f618b20a79035ed49cae07b9b800a46f352498e23dc8700f47c38fe96d": "The function `make_key` takes two parameters, `file_path` as a string representing the path to a file, and `content` as a string representing the content of that file. It returns a deterministic key by hashing the content using SHA-256 and appending the file path to the hexadecimal digest of the hash.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\cache.py:ResponseCache:set:0bc8af7637662ae14e3eca8604a4d7155ff442d423955a243d6b586ffee8d8ba": "Stores a value under a given key in an internal data structure and persists the changes to disk.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\docgenerator.py:141aa96a3f27a460be055149bc6ab9765af360960c726b9f0461296b1cf881c6": "This Python script generates HTML documentation for a project using a local language model (LLM). It scans a source tree for Python and MATLAB files, parses them, requests summaries from the LLM, and writes the documentation to an output directory. The script includes functionality to clean the output directory, build prompts for summarization, rewrite docstrings with context, and generate both module-level and class/function-level summaries.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\docgenerator.py:1c613210758d8c09c8eab7c7b1d4b3e3977abe2357a0a0db63b9a7e85a558281:1c613210758d8c09c8eab7c7b1d4b3e3977abe2357a0a0db63b9a7e85a558281": "The script defines a command-line interface (CLI) for generating HTML documentation using a local language model (LLM). It scans a source tree for Python and MATLAB files, parses them, requests summaries from the LLM, and writes the documentation to an output directory. The CLI supports optional arguments for specifying the source directory, output directory, ignored paths, LLM URL, model name, maximum context tokens, and more. The script uses various helper functions to handle file parsing, summarization, tokenization, and writing HTML files. It also includes a project summary based on the structure of the codebase and rewrites docstrings with additional context.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\docgenerator.py:58d55441799677c9e98d11a35d626cd6641098d8c09bb0ac86c5a9de1965581b:merge:980254d2d5e87fb779b9e46e8cd603c6d39f28f7fa5cbe28032b6202d497ef4c": "The `main` function generates HTML documentation using a local Large Language Model (LLM) by parsing Python and MATLAB files in a specified source directory. It summarizes content, caches responses to avoid redundant requests, and outputs summaries as HTML pages for modules, classes, functions, and includes a project summary based on README.md and other Markdown files, all organized into an index page and individual module pages in the output directory.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\docgenerator.py:58d55441799677c9e98d11a35d626cd6641098d8c09bb0ac86c5a9de1965581b:part0:2f5eac7df2d4c692e7ead215647f1c42eb9fe6775e735a993a6eac2bcd399056": "",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\docgenerator.py:58d55441799677c9e98d11a35d626cd6641098d8c09bb0ac86c5a9de1965581b:part1:1ea40b8b1f9ce0a3a928ef9201d31f3206328ddbc4f38b700c2d5e41eadbf4e6": "The code defines a `main` function that generates HTML documentation using a local Large Language Model (LLM). It takes command-line arguments to specify the source directory, output directory, and various options such as ignored paths, LLM URL, model name, and maximum context tokens. The function parses Python and MATLAB files in the source directory, summarizes their content using the LLM, and generates HTML pages for each module, class, and function. It also includes a project summary based on README.md and other Markdown files found in the source directory. The summaries are cached to avoid redundant requests to the LLM. Finally, it writes an index page and individual module pages to the output directory.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\docgenerator.py:_build_function_prompt:5ccb88ec93dae342295b730ed8e626ef483e6bb08234f64132dd78780c06331e": "This function `_build_function_prompt` constructs a prompt for summarizing a Python function. It takes the source code of the function, an optional class name, an optional class summary, and an optional project summary as inputs. The function returns a string that includes these details and instructions on how to summarize the function based solely on its source code.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\docgenerator.py:_build_function_prompt:bb310450bd36f6a9015176918c6749347bbdae9f8e3e3a92292624bb4ad5ee65": "This function `_build_function_prompt` constructs a prompt for summarizing Python source code. It takes the source code as input along with optional parameters for class name, class summary, and project summary. The function generates a multi-line string that serves as a context-enriched prompt for a documentation generator LLM. This prompt includes instructions on how to summarize the function without including unnecessary elements and ensures that the summary is focused solely on the provided source code.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\docgenerator.py:_build_function_prompt:c932d9f8736c455a65ee9a6b1ac0a182cb4a63da473f29f49c8b8952bcc0b414": "This function `_build_function_prompt` constructs a prompt for summarizing a Python function using a language model. It takes the source code of the function, an optional class name and summary, and an optional project summary as inputs. The function returns a multi-line string that serves as the context for the documentation generator to understand the function's place within its class and project before generating a summary based on the provided source code.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\docgenerator.py:_build_function_prompt:e0bc363500c47860a510d9ac659462865009e16e1aac37690610f028f1a4c031": "This function `_build_function_prompt` constructs a prompt for summarizing a Python function based on its source code. It takes three optional parameters: `source` (the function's source code), `class_name` (the name of the class containing the function, if applicable), and `project_summary` (a summary of the project). The function returns a string that includes these details and instructions for summarizing the function without including unnecessary elements.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\docgenerator.py:_chunk_module_by_structure:c75830a48cfe86a560a4b056e5b139a0cd9ab81acdf99b7f6d5f0b42145edd9b": "The function `_chunk_module_by_structure` processes a parsed module dictionary, breaking down its content into text chunks based on token size limits. It starts with the module's docstring, then iterates through classes and their methods, as well as standalone functions. Each block of code is encoded using a tokenizer to determine if it fits within the specified chunk size. If a block exceeds the limit, it is further split into smaller chunks. The function returns a list of text chunks that can be used for documentation generation while respecting token limits.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\docgenerator.py:_get_tokenizer:289352e9746c7ed50b65b7d89a5fea135fdaf2ab4ce3508879a7f2fea838d6ff": "Returns a tokenizer object for estimating token counts. If the `tiktoken` library is installed, it uses the `cl100k_base` encoding; otherwise, it falls back to a simple tokenizer that splits text by spaces and joins tokens with spaces.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\docgenerator.py:_get_tokenizer:46b7825e1fb7d8f9858b45c8f22b63b3b3f6af912a53c85429e5b9df0a6860a4": "The `_get_tokenizer` function returns a tokenizer object used for estimating token counts. It first attempts to import and use the `tiktoken` library with the \"cl100k_base\" encoding. If successful, it returns this tokenizer. If `tiktoken` is not installed or encounters an exception (e.g., due to an unknown model), it prints a warning and returns a simple tokenizer that splits text into words for tokenization and joins them back together for decoding. This ensures that the function can provide approximate token counts even without the `tiktoken` library.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\docgenerator.py:_get_tokenizer:532d47081c0dac540209cf70d2d0990274f26966aed1c54cde6777d42a2f14e4": "Returns a tokenizer object for estimating token counts, using the `tiktoken` library if available. If `tiktoken` is not installed or the specified model is unknown, it falls back to a simple tokenizer that splits text into words and joins them back together.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\docgenerator.py:_rewrite_docstring:07544ae72018dd0e184cf1d68a60d48145ba8c8d8405062f6e37ddcb36131022": "This function `_rewrite_docstring` takes an LLM client, a response cache, a file path, and a dictionary representing an item (likely a code element like a function or method). It optionally accepts class name, class summary, and project summary. The function checks if there is source code or a docstring in the item; if not, it prints a warning and returns.\n\nIt constructs a prompt based on whether context (class and project summaries) is provided. If context is given, it builds a function prompt using `_build_function_prompt`; otherwise, it uses a default `DOC_PROMPT`. It then generates a key for caching by combining the file path, item name, source code, docstring, and any additional context.\n\nThe function calls `_summarize` to generate a new docstring using the constructed prompt. If a summary is generated, it sanitizes it; otherwise, it sets the docstring to \"No summary available.\" The resulting docstring is then updated in the item dictionary.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\docgenerator.py:_rewrite_docstring:be9e7f8482e4741ad0d54b4b7cc011ef8fe12365281e514d469e9e6b3b3aafda": "The function `_rewrite_docstring` rewrites the docstring of a code item using an LLM client. It takes a client, a cache, a file path, and an item dictionary as inputs. The function first checks if there is source code or a docstring in the item. If not, it prints a warning and returns. If there is a docstring, it constructs a prompt based on optional context such as class name, summary, and project summary. It then generates a key for caching purposes and calls `_summarize` to get a rewritten docstring from the LLM client. The result is sanitized and assigned back to the item's docstring field. If no summary is available, it sets the docstring to \"No summary available.\"",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\docgenerator.py:_rewrite_docstring:d1c10b1edb8a9206b059e1be6657343634e16a93ac26f4d7c65c6327e7279d1e": "This function `_rewrite_docstring` rewrites the docstring of a code item using an LLM client and a response cache. It takes parameters for the LLM client, response cache, file path, and item dictionary. The function checks if there is source code or a docstring in the item; if not, it prints a warning and returns. If context (class name, class summary, project summary) is provided, it constructs a prompt using `_build_function_prompt`; otherwise, it uses a default `DOC_PROMPT`. It then generates a cache key based on the file path, item name, source code, and docstring (or context). The function calls `_summarize` to generate a new docstring summary, which is sanitized and assigned back to the item's docstring field. If no summary is available, it sets the docstring to \"No summary available.\"",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\docgenerator.py:_rewrite_docstring:fe567e121b1a4bc524461cc59e1397d905c4bacb4ea6cfa7afcf6172538a1ae9": "The function `_rewrite_docstring` takes an `LLMClient`, a `ResponseCache`, a file path, and a dictionary representing a code item. It optionally accepts parameters for class name, class summary, and project summary. The function checks if the source or docstring is present; otherwise, it prints a warning and returns. If the docstring exists, it constructs a prompt based on whether context (class name, class summary, project summary) is provided. It then generates a key using the file path, item name, and relevant content. The function calls `_summarize` to generate a new docstring using the language model client and updates the item dictionary with the sanitized result or a default message if no summary is available.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\docgenerator.py:_summarize:20efb7c668ec1a9c03edb2f7f4a487fe80012583656735a0cb92480fa91abc4e": "The function `_summarize` takes an `LLMClient`, a `ResponseCache`, a `key`, a `text`, and a `prompt_type` as parameters. It checks if the summary for the given `key` is already cached. If it is, it returns the cached summary. Otherwise, it uses the `client` to generate a summary of the `text` based on the `prompt_type`. The generated summary is then stored in the cache under the specified `key` and returned.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\docgenerator.py:_summarize:381d292254dbc9ee5b0c64e3c3e093b998e0e45dcdff4dafdec2a2cbccde92d8": "The function `_summarize` takes an `LLMClient`, a `ResponseCache`, a `key`, a `text`, and a `prompt_type`. It checks if the summary for the given key is already cached. If it is, it returns the cached summary. Otherwise, it uses the LLM client to generate a summary of the provided text based on the prompt type, caches this new summary under the specified key, and then returns it.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\docgenerator.py:_summarize:542eadce007271f17e9ded5408cc356f31d9d5258bb4ccf82d27ae5594eb0103": "The `_summarize` function takes an `LLMClient`, a `ResponseCache`, a `key`, a `text`, and a `prompt_type`. It checks if the summary for the given key is already cached. If it is, it returns the cached summary. Otherwise, it uses the `client` to generate a summary of the `text` based on the `prompt_type`, caches the result using the provided `key`, and then returns the generated summary.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\docgenerator.py:_summarize:ab18de1807793f20f69a35bf12b1ff90a847eef6a07b67c8fcaf8003a81b2292": "This function `_summarize` takes an LLMClient instance, a ResponseCache instance, a key string, a text string, and a prompt_type string as parameters. It first attempts to retrieve a cached summary using the provided key. If a cached summary exists, it returns that summary. Otherwise, it uses the LLMClient to generate a new summary for the given text and prompt type, caches this new summary under the provided key, and then returns the generated summary.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\docgenerator.py:_summarize_chunked:29faa17e4ce9929de3e3a4e75bf8e557e0a1fe8d9563a748398f810dfc5e4405": "This function `_summarize_chunked` is designed to summarize a given text by breaking it into chunks if necessary. It uses an LLM client for summarization and a response cache to store previously computed summaries. The function handles the following steps:\n\n1. Retrieves a template based on the `prompt_type`.\n2. Calculates overhead tokens for system prompt and template.\n3. Determines available tokens for summarization.\n4. Checks if the text can be summarized in one chunk; if so, it proceeds with summarization using the `_summarize` function.\n5. If the text is too long, it chunks the text into smaller parts based on `chunk_token_budget`.\n6. Summarizes each chunk individually and stores the results in the cache.\n7. Merges the summaries of individual chunks into a single technical summary.\n8. Returns the sanitized final summary.\n\nThe function ensures efficient use of tokens by limiting the size of each chunk and leveraging caching to avoid redundant computations.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\docgenerator.py:_summarize_chunked:6d9a308bb1dd1bf8bf36c3eea6b43a21e56b7ebccc1f30b21c010ca18f82e4e8": "This function `_summarize_chunked` is designed to summarize a given text by chunking it if necessary. It takes several parameters including an LLM client, a response cache, a key prefix, the text to be summarized, a prompt type, a tokenizer, and maximum context tokens and chunk token budget.\n\nThe function first determines the available tokens based on the overhead from system prompts and template usage. If the text can fit within these available tokens, it proceeds to summarize directly using the `_summarize` function.\n\nIf the text is too large, it chunks the text into smaller parts based on the available tokens and a specified chunk token budget. Each part is then summarized individually, and the partial summaries are merged into a single technical summary using another call to the `_summarize` function with a merge prompt.\n\nFinally, the function sanitizes the merged summary before returning it.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\docgenerator.py:_summarize_chunked:dd143fc3a497276f0fdf517471d37896023b7bc84535fdb49feea33a9a16d1d5": "This function `_summarize_chunked` takes a language model client, response cache, key prefix, text to summarize, prompt type, tokenizer, maximum context tokens, and chunk token budget as inputs. It summarizes the given text by first checking if the encoded length of the text is within the maximum context tokens limit. If not, it chunks the text into smaller parts based on the chunk token budget. Each part is then summarized individually using the language model client and response cache. The partial summaries are merged into a single technical summary using another prompt, which is also cached and summarized. Finally, the sanitized final summary is returned.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\docgenerator.py:_summarize_class_recursive:ab8f3963f46935bf2e4e6edc5e4164d66732ea86f675fbe317e1a0f5e8633ac8": "This function recursively summarizes a class and its methods. It first summarizes the methods, then constructs a prompt for summarizing the class itself. Using an LLM client, it generates a summary for the class docstring and updates the class data with this new summary. If the original docstring exists, it rewrites the docstring to include the new summary. The function also recursively processes any subclasses of the current class.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\docgenerator.py:_summarize_methods_recursive:b7e1e18b2d800ff18f5b70761327175929b238105afe8f77ff077f2c94346821": "This function recursively summarizes methods within a class and its subclasses. It iterates through each method in the provided `class_data`, generates a unique key using the class and method names, and fetches or computes a summary using an LLM client. The summary is then assigned to both the \"summary\" and \"docstring\" fields of the method dictionary. If the class has subclasses, the function calls itself recursively to process each subclass.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\docgenerator.py:_summarize_module_chunked:039499ae7dea69069e435db9e22847a09167d4aebc418d65ebed4c8ac2daec43": "This function `_summarize_module_chunked` summarizes a Python module using a structure-aware chunking approach. It takes an LLM client, response cache, key prefix, module text, module dictionary, tokenizer, maximum context tokens, and chunk token budget as inputs. The function first calculates the available tokens for summarization after accounting for overhead from system prompt and template encoding. If the module text fits within the available tokens, it generates a summary directly. Otherwise, it splits the module into chunks based on structure using `_chunk_module_by_structure`. Each chunk is summarized individually, and then all partial summaries are merged into a single technical summary using another summarization call. The final summary is sanitized before being returned.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\docgenerator.py:a835ca662f3455e098988cadeeb07871cf9417addad1d04bd82ff5c45ea5d01f:a835ca662f3455e098988cadeeb07871cf9417addad1d04bd82ff5c45ea5d01f": "The code defines a command-line interface (CLI) for generating HTML documentation using a local language model (LLM). It scans a source tree for Python and MATLAB files, parses them, requests summaries from the LLM, and writes the documentation to an output directory. The CLI supports optional arguments for specifying the source directory, output directory, ignored paths, LLM URL, model name, maximum context tokens, and more.\n\nThe code includes functions for:\n- Cleaning the output directory by removing previously generated HTML files.\n- Summarizing text using the LLM, with caching to avoid redundant requests.\n- Tokenizing text for chunking if necessary.\n- Building prompts for summarizing functions and classes.\n- Rewriting docstrings with additional context.\n- Main logic for parsing source files, generating summaries, and writing documentation.\n\nThe CLI entry point is at the bottom of the file.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\docgenerator.py:chunk_text:173fdcdc6c2856e50b7f6029d4bf367cf965fcf4b8e79af7ff534f0ea04fe6b2": "This function `chunk_text` takes a string `text`, a tokenizer, and an integer `chunk_size_tokens`. It encodes the text into tokens using the provided tokenizer. Then, it splits these tokens into chunks of approximately `chunk_size_tokens` each. Finally, it decodes each chunk back into a string and returns a list of these string chunks.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\docgenerator.py:chunk_text:a1b86eca7ecf3340d22c988b83de1b3ba056ec62abb239ce17369f6552a37a56": "This function `chunk_text` takes a string `text`, a tokenizer object, and an integer `chunk_size_tokens`. It encodes the text into tokens using the provided tokenizer. The function then splits these tokens into chunks of approximately `chunk_size_tokens` each. Each chunk is decoded back into a string and appended to a list of chunks. Finally, the function returns this list of text chunks.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\docgenerator.py:chunk_text:a3e9fbee2a284445f30ba27db55c8b7179db38f6a915a7619dcaf1bb74d56305": "The `chunk_text` function splits a given text into smaller chunks based on the specified number of tokens. It uses a tokenizer to encode the input text into tokens, then iterates through these tokens in steps of `chunk_size_tokens`, decoding each chunk back into text and appending it to the result list.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\docgenerator.py:clean_output_dir:7a5c3ce18da4cb876957dd6cb11cac84ef38b5dbed9bbd24fd5dbb48f5ad8991": "The function `clean_output_dir` takes a string representing an output directory path and iterates through all files within that directory. If a file has a `.html` extension, it reads the first line of the file. If the first line contains the string \"Generated by DocGen-LM\", the file is deleted. If any exceptions occur during this process, a warning message is printed indicating which file could not be checked and the reason for the exception.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\docgenerator.py:clean_output_dir:7fa74f1dc2770b308122d88bcf5302aa3a4a816398c8f847be719c7d1d5ba656": "The `clean_output_dir` function takes a string representing the path to an output directory and iterates through all files within that directory. If a file has a `.html` extension, it reads the first line of the file. If the first line contains the string \"Generated by DocGen-LM\", the function removes the file. Any exceptions encountered during this process are caught and printed with a warning message.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\docgenerator.py:clean_output_dir:a6e9e15659acce3e8532c5245f692d4f3c95ad149a6ab4f59db4658727e63401": "The function `clean_output_dir` takes a string representing the path to an output directory and removes any HTML files within that directory if they contain the specific text \"Generated by DocGen-LM\" in their first line. If an error occurs while checking or removing a file, it prints a warning message with the filename and the exception details.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\docgenerator.py:clean_output_dir:e1a6eccc2217f903fe5182769df23294a114d2d6bdef6bdad5313413b65fb3de": "The function `clean_output_dir` takes a string `output_dir` representing the path to an output directory. It iterates through all files in this directory that end with `.html`. For each file, it attempts to open and read the first line. If the first line contains the string \"Generated by DocGen-LM\", indicating that the file was generated by the tool, it deletes the file. If any exceptions occur during these operations, it prints a warning message with details of the error.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\docgenerator.py:main:9d95440c79b72e74e1aa1e8fff7f921e388178c819d26ee549cdcf247d7351c8": "The `main` function serves as the entry point for generating HTML documentation using a local Large Language Model (LLM). It processes command-line arguments to specify the source directory, output directory, ignored paths, LLM URL, and model name. The function initializes an LLM client, checks connectivity, sets up output directories, and caches responses.\n\nIt scans the source directory for Python and MATLAB files, parses them, and generates summaries using the LLM client. The summaries are stored in a cache to avoid redundant requests. The function also handles project-level documentation from README.md and docstring prompts. It constructs an outline of the project structure and uses this information to generate class and function summaries with context.\n\nFinally, it writes index and module pages to the output directory, containing the generated summaries and links between modules.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\docgenerator.py:main:bad78385d5c35a4478cc525c0670f7517fd295be93a6bd6bd89577ad4edec41b": "The `main` function serves as the entry point for generating HTML documentation from Python and MATLAB projects using a local Large Language Model (LLM). It handles command-line arguments to specify the source directory, output directory, ignored paths, LLM server details, and other options. The function initializes an LLM client, sets up tokenization, and prepares the output directory. It then scans the source directory for Python and MATLAB files, parses them, and generates summaries using the LLM. The summaries are sanitized and stored in a cache to avoid redundant requests. The function also handles project-level documentation, such as README files, and integrates class and function summaries into the overall project context. Finally, it writes the generated documentation to HTML pages and returns an exit status of 0 on success.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\docgenerator.py:main:dedb74c394a5356e1265637d579c2dcbb032ca8be9ee573653a70d6f7051532d": "The `main` function is the entry point of the DocGen-LM tool. It sets up command-line arguments to specify the source directory, output directory, and various optional parameters such as LLM server URL, model name, and token limits. The function initializes an LLM client, checks its connectivity, and configures a tokenizer.\n\nIt then processes each file in the specified source directory:\n- Reads the file content.\n- Parses the file to extract Python or MATLAB code structures (functions and classes).\n- Caches previously generated summaries using a `ResponseCache`.\n- Summarizes each module and its components (classes and functions) using the LLM client, handling potential errors like invalid encoding or syntax issues.\n\nAfter processing all files, it generates an HTML project summary based on the parsed structure. It also reads any README.md files in the source directory to include additional documentation.\n\nFinally, the function writes the generated summaries to HTML files in the output directory, creating an index page and individual pages for each module.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\docgenerator.py:main:df5fbb703eaeaaf80f1509382e1ae2df28d8bb7100e194840f910cdedaabc559": "The `main` function serves as the entry point for the DocGen-LM tool. It sets up command-line argument parsing to specify input and output directories, along with optional settings for the local language model (LLM) server. The function initializes an LLM client, processes source files in the specified directory, generates summaries using the LLM, caches responses, and writes the resulting HTML documentation to the output directory. It handles different file types (Python and MATLAB), ignores specified paths, and ensures that the project structure is accurately represented in the generated documentation.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\html_writer.py:16eccd5fea586efa16f44faa06a446231effaaf425669f204f3de2379898377d": "This module provides utilities for rendering documentation pages using simple template substitution. It includes functions to highlight code snippets and render HTML content based on project summaries and module data. The `write_index` function generates an index page with navigation links, while the `write_module_page` function creates detailed documentation pages for individual modules, including classes, methods, and functions. Both functions use a shared template and apply HTML escaping to ensure safe rendering of user-provided content.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\html_writer.py:16eccd5fea586efa16f44faa06a446231effaaf425669f204f3de2379898377d:16eccd5fea586efa16f44faa06a446231effaaf425669f204f3de2379898377d": "This module provides HTML rendering utilities for generating documentation pages using simple template substitution. It includes functions to highlight code snippets and render HTML content based on project summaries and module data. The `write_index` function generates the main index page with navigation links and project summary. The `write_module_page` function creates detailed documentation pages for individual modules, including classes, methods, and functions, with syntax highlighting for code examples.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\html_writer.py:9c67880c807b6c13cd855d095c53d4913d92121b20e917e7adb6a440a8708ca4:9c67880c807b6c13cd855d095c53d4913d92121b20e917e7adb6a440a8708ca4": "This module provides utilities for rendering documentation pages using simple template substitution. It includes functions to highlight code snippets in various programming languages and to render HTML content based on structured data representing project summaries, modules, classes, and functions. The module can generate `index.html` and individual module pages, each formatted with navigation links and syntax-highlighted code examples.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\html_writer.py:_highlight:1a2e76f43d93c0a1ba8622d7692a5169fc2c9e754d8384b3095a118a0426020a": "The function `_highlight` takes a string `code` and a string `language` as input. It uses the Pygments library to highlight the code based on the specified language. If the language is \"matlab\", it uses the MatlabLexer; if \"python\", it uses the PythonLexer; otherwise, it uses the TextLexer. The highlighted code is then formatted using HtmlFormatter with no classes and nowrap options. The function returns the highlighted code wrapped in `<pre><code>` tags for HTML rendering.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\html_writer.py:_highlight:4c5371e8e5099d7a9869a88a2b3c5bc9059ebb066e9bbe0404dbe14b5b9ae21d": "The function `_highlight` takes a string `code` and a string `language` as input. It uses the Pygments library to highlight the code based on the specified language. If the language is \"matlab\", it uses the MatlabLexer; if \"python\", it uses the PythonLexer; otherwise, it uses the TextLexer for generic text. The highlighted code is then formatted using HtmlFormatter with no classes and without wrapping, and returned within a `<pre><code>` HTML tag.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\html_writer.py:_highlight:c9a247c9b22e1879ff65563d886d4d8c2f39c07ba05bb2c85299980bc28fb0ed": "The `_highlight` function takes a string of code and a language identifier as input. It uses the `pygments` library to highlight the code based on the specified language. If the language is \"matlab\", it uses the `MatlabLexer`; if \"python\", it uses the `PythonLexer`; otherwise, it uses the `TextLexer`. The highlighted code is then formatted using an HTML formatter with no classes and nowrap enabled. Finally, the function returns the highlighted code wrapped in `<pre><code>` tags for proper display in HTML.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\html_writer.py:_highlight:d6540aaa10414bdf295edcd29e6df40d27cca03d0f741432a2a7eb1fc9062aec": "The `_highlight` function takes a string of code and a language identifier as input. It uses the Pygments library to highlight the code based on the specified language. If the language is MATLAB or Python, it selects the corresponding lexer; otherwise, it uses a generic text lexer. The highlighted code is then formatted using an HTML formatter with no classes and without line wrapping. The function returns the highlighted code wrapped in `<pre><code>` tags for proper display in HTML.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\html_writer.py:_render_class:ca1fc1fecc3efa62ec69dab4c5aa87d5b9893f92d42f4d7f1493832d8c497bb0": "This function `_render_class` generates HTML parts for a class and its subclasses. It takes a dictionary representing the class, a language string, and an optional level parameter (default is 2). The function returns a list of HTML strings.\n\nThe function starts by creating an HTML heading tag (`<h1>` to `<h6>`) based on the level parameter, using the class name as the content. It then checks for a docstring or summary in the class dictionary and appends it as a paragraph if available.\n\nNext, the function iterates over any methods associated with the class and calls `_render_function` for each method, appending the returned HTML parts to the list.\n\nFor subclasses of the current class, the function creates a `<details>` element, adds a summary section with the subclass name, and recursively calls `_render_class` on each subclass, increasing the level by 1. The resulting HTML parts are appended to the list.\n\nFinally, the function returns the complete list of HTML strings representing the class and its subclasses in an expandable format.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\html_writer.py:_render_function:d76b62c13792939607ae6c57d70814af833094d09596e40b94d9420352c00eaa": "The function `_render_function` generates HTML parts for a given function and its nested subfunctions. It takes a dictionary representing the function, a programming language (either \"Python\" or \"MATLAB\"), an optional heading level (default is 3), and an optional prefix string. The function returns a list of HTML strings.\n\nThe function starts by creating an HTML tag based on the provided level, ensuring it does not exceed 6. It then retrieves the function's signature or name from the dictionary and appends it as an HTML header with an anchor ID. If the function has a summary or docstring, it is appended as a paragraph. The source code of the function, if available, is highlighted using another internal function `_highlight` and added to the parts list.\n\nThe function then iterates over any nested subfunctions, creating a `<details>` element for each. Inside each `<details>`, a summary is provided, followed by recursive calls to `_render_function` to generate HTML for the subfunction, increasing the heading level by one. Finally, all generated parts are returned as a list of strings.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\html_writer.py:_render_html:54b96f809bd5c40701396752d1cc06d797b4b9122ff5ee7d85c7db5abecea3cd": "This function `_render_html` takes four parameters: `title`, `header`, `body`, and `nav_html`. It reads a template file from `_TEMPLATE_PATH`, formats it with the provided parameters, and returns the formatted HTML string. The function includes a comment indicating that the output is generated by DocGen-LM.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\html_writer.py:_render_html:cf841d0632a70b1946b2b4c140048261f796c48686de64d03509239850de8c3e": "The function `_render_html` takes four parameters: `title`, `header`, `body`, and `nav_html`. It reads a template file from `_TEMPLATE_PATH`, formats it with the provided parameters, and returns the formatted HTML string. The returned HTML includes a comment indicating it was generated by DocGen-LM.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\html_writer.py:_render_html:d129d5b53cbcd718f58b92264ae5f67308b5e582b57662618b2cdf923e098165": "The function `_render_html` takes four parameters: `title`, `header`, `body`, and `nav_html`. It reads a template from a file specified by `_TEMPLATE_PATH` and formats it with the provided title, header, body, and navigation HTML. The formatted content is then returned as a string, prefixed with a comment indicating that it was generated by DocGen-LM.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\html_writer.py:_render_html:e4422a9725f3cd56dd58db29627ba03308b6bd8d88fe24be698854b70ccdbd0f": "This function `_render_html` takes four parameters: `title`, `header`, `body`, and `nav_html`. It reads a template from `_TEMPLATE_PATH` and formats it with the provided parameters. The formatted content is then returned as an HTML string, prefixed with a comment indicating it was generated by DocGen-LM.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\html_writer.py:write_index:9fa8b07ea53975d12fb31e945002a40f800ceeb0b192e03895423c14a5c00831": "This function `write_index` generates the content for an `index.html` file in a specified output directory. It takes parameters for project summary, navigation links, and optional module summaries. The function creates the necessary directory structure if it doesn't exist, constructs HTML elements for the project summary, navigation links, and module summaries, and then writes the complete HTML to `index.html`.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\html_writer.py:write_index:bcdb7a47674080931d80ca66d4643b4216f0d0d7546327044e7cdadce332783d": "This function `write_index` generates the content for an `index.html` file in a specified output directory. It takes parameters for project summary, page links, and optional module summaries. The function creates the necessary directory structure if it doesn't exist. It constructs HTML navigation links from the provided page links and optionally includes summaries for modules. The body of the HTML document is built with the project summary, a horizontal rule, and a section for modules. Each module link is styled and may include an associated summary. Finally, the function renders the complete HTML content using `_render_html` and writes it to `index.html` in the output directory.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\html_writer.py:write_index:be606deeaa56415fcbf5544fbbf8e4224a01b25bce77a9407aafdf40d4ecd472": "This function `write_index` generates the `index.html` file for a project's documentation. It takes three required parameters: `output_dir`, `project_summary`, and `page_links`. Optionally, it accepts `module_summaries`.\n\nThe function creates the output directory if it doesn't exist. It constructs navigation links from `page_links` and includes them in an unordered list. The body of the HTML document is built with a project summary, a horizontal rule, and a section for modules. Each module link is optionally accompanied by a summary.\n\nFinally, it renders the HTML using `_render_html`, which takes the title, subtitle, body content, and navigation HTML as arguments. The resulting HTML is written to `index.html` in the specified output directory.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\html_writer.py:write_index:c2a4a131460ec50b8db6fa4d25a1218bd8686c5bae07ca53cb5f902bccaca693": "The function `write_index` generates the content for an `index.html` file in a specified output directory. It takes parameters for project summary, navigation links, and optional module summaries. The function creates the destination directory if it doesn't exist, constructs HTML elements for the project summary and navigation links, and optionally includes summaries of modules. It then renders these elements into complete HTML content using `_render_html` and writes the output to `index.html`.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\html_writer.py:write_module_page:89bb78edfecd817cc4cb176c5c97e278717767bf4aef020ed6f7ed00ac119a37": "This function `write_module_page` generates an HTML documentation page for a module. It takes three parameters: `output_dir`, which is the directory where the output HTML file will be saved; `module_data`, a dictionary containing information about the module such as its name, summary, classes, and functions; and `page_links`, an iterable of tuples representing links to other pages in the documentation.\n\nThe function first constructs the destination directory for the output HTML file. It then retrieves the module's name and language from the `module_data` dictionary. The navigation items for the page are created, including a link to the project overview and any additional links provided in `page_links`.\n\nThe body of the HTML page is constructed by adding a summary paragraph and rendering each class and function defined in the module. Classes are rendered using the `_render_class` function, while functions are rendered using the `_render_function` function.\n\nFinally, the complete HTML content is generated using the `_render_html` function and written to an HTML file named after the module in the destination directory.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\html_writer.py:write_module_page:a268fe13bc620a4d35aba7599052d11ef76cc86c36856d9741b56e7c81177df0": "This function `write_module_page` generates an HTML documentation page for a Python or MATLAB module. It takes three parameters: `output_dir`, which is the directory where the output file will be saved; `module_data`, which contains information about the module such as its name, language, summary, classes, and functions; and `page_links`, which provides links to other pages in the documentation.\n\nThe function first creates a destination directory if it doesn't exist. It then constructs the HTML content for the page, including navigation items, a summary of the module, details about each class and its methods, and details about each function. The HTML content is generated using another function `_render_html`, which takes the module name, title, body, and navigation HTML as parameters.\n\nFinally, the function writes the generated HTML content to a file named after the module in the specified output directory.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\html_writer.py:write_module_page:d7f74c11da61f336c5835faa152dd731798038c79a0dda4dacc3893042b65caf": "This function `write_module_page` generates an HTML documentation page for a Python or MATLAB module. It takes three parameters: the output directory where the file will be saved, a dictionary containing data about the module, and an iterable of tuples representing links to other pages.\n\nThe function creates a directory structure if it doesn't exist, constructs navigation items based on provided links, and generates body content by iterating over classes and functions within the module. It includes summaries, docstrings, and source code (with syntax highlighting) for each class and method, as well as a list of functions. The final HTML is written to a file named after the module in the specified output directory.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\html_writer.py:write_module_page:ff73f31f31e83dbef302322bcb132e060dcebb97d3431e06b74e0ad107cbf485": "This function `write_module_page` generates an HTML documentation page for a Python or MATLAB module. It takes three parameters: `output_dir`, which is the directory where the output file will be saved; `module_data`, which contains information about the module such as its name, language, summary, classes, and functions; and `page_links`, which are links to other pages in the documentation.\n\nThe function first creates a destination directory if it doesn't exist. It then constructs HTML content for the page, including a navigation bar with links to other pages and a body containing summaries of classes and methods within the module. If there are functions defined in the module, they are also included in the body. The HTML is generated using a helper function `_render_html`, which takes the module name, title, body content, and navigation HTML as arguments. Finally, the generated HTML is written to a file named after the module in the specified output directory.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\llm_client.py:017f9fceffc8768792b7a26edd6d84ef2f0fac121d5ed21de6be7e6e3592b3af": "- Defines an interface to interact with a local language model (LLM) backend using LMStudio.\n- Includes prompts for different types of documentation and code summaries.\n- Implements a `sanitize_summary` function to clean up generated summaries by removing unwanted phrases.\n- Provides a `LLMClient` class that:\n- Initializes with a base URL and model name.\n- Checks connectivity to the LLM server using the `ping` method.\n- Generates summaries for given text using specified prompt types through the `summarize` method.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\llm_client.py:017f9fceffc8768792b7a26edd6d84ef2f0fac121d5ed21de6be7e6e3592b3af:017f9fceffc8768792b7a26edd6d84ef2f0fac121d5ed21de6be7e6e3592b3af": "This module provides an interface to a local language model backend (LMStudio) for generating summaries of code files. It includes:\n\n- A `SYSTEM_PROMPT` defining the role and behavior of the documentation engine.\n- `_COMMON_RULES` containing guidelines for summarization.\n- `README_PROMPT` for enriching project summaries from README files.\n- `PROMPT_TEMPLATES` a dictionary of prompt templates for different types of code elements (module, class, function) and additional types like README and project summary.\n- A `sanitize_summary` function to remove unwanted phrases from the generated summaries.\n- An `LLMClient` class that acts as a thin wrapper around the LMStudio HTTP API:\n- It initializes with a base URL and model name.\n- Provides a `ping` method to check if the API is reachable.\n- Implements a `summarize` method to generate summaries using specified prompts, handling retries on failures.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\llm_client.py:8507043bc5e86fc826385a372aef087c5d4a12ac74a478e75c1ddc0ce048004a:8507043bc5e86fc826385a372aef087c5d4a12ac74a478e75c1ddc0ce048004a": "- Defines an interface to communicate with a local Large Language Model (LLM) backend using the LMStudio HTTP API.\n- Includes prompts for generating summaries of modules, classes, functions, READMEs, and projects.\n- Implements a `sanitize_summary` function to remove unwanted commentary from generated summaries.\n- Provides a `LLMClient` class that:\n- Initializes with a base URL and model name.\n- Offers a `ping` method to check if the API is reachable.\n- Includes a `summarize` method to generate summaries for given text using specified prompts, handling retries on failure.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\llm_client.py:LLMClient:5e966a5e227d2cc9a521f1fed77d2c4dd75ff467e7a0059162a26a0ef95bfcc8:5e966a5e227d2cc9a521f1fed77d2c4dd75ff467e7a0059162a26a0ef95bfcc8": "The `LLMClient` class is designed for interacting with a local language model server to summarize code files in Python and MATLAB projects. It includes methods for initializing the client, checking connectivity to the server, and sending code summaries to the model for processing and sanitizing the responses.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\llm_client.py:LLMClient:5fbf34bca091de06d7395e6157edfa58542adfac36004a452d64d49da37328db": "The `LLMClient` class in the DocGen-LM project is designed for generating documentation summaries from source code files using a local Large Language Model (LLM). It includes methods for initializing with a base URL and model, checking API reachability, and summarizing text based on specified prompt types.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\llm_client.py:LLMClient:7df31939a2b30ef7b04eb91cc0673fa0e55d01a04ff321daa3473f2cd743fdf4:7df31939a2b30ef7b04eb91cc0673fa0e55d01a04ff321daa3473f2cd743fdf4": "The `LLMClient` class is designed to interact with a Large Language Model (LLM) server for generating summaries of code files. It provides methods for initializing the client with a base URL and model, checking connectivity to the API using the `ping` method, and summarizing text based on a given prompt type through the `summarize` method.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\llm_client.py:LLMClient:__init__:700c23b8c0716a1aaf00c10fbc2e056bef4f6e1dca9c72b739185f920ef55cf8": "Initializes an object with a base URL and a model. The base URL is stored after removing any trailing slashes, and the endpoint for chat completions is constructed using this base URL. The model type is also stored.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\llm_client.py:LLMClient:c0eaa352d62f4b3d0c9da6fafbc934e26feb7adf3207961ef64504e88fa23270:c0eaa352d62f4b3d0c9da6fafbc934e26feb7adf3207961ef64504e88fa23270": "The `LLMClient` class manages interactions with a language model for summarization tasks. It includes methods for initializing the client, checking API reachability, and sending text for summarization using specified prompt types.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\llm_client.py:LLMClient:ping:3fe5655e89accd067c6ddc9c1cc323c9dd9eac2dea9be6646ea4d470b3e0a436": "The function `ping` checks if an API is reachable by sending a GET request to the specified base URL. It accepts an optional timeout parameter with a default value of 2.0 seconds. If the server responds successfully, it returns `True`. If there is any issue during the connection or response handling, it raises a `ConnectionError` with a message indicating that the server cannot be reached at the given base URL.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\llm_client.py:LLMClient:summarize:b1a476007dba66e5510bf80c9aee0418d5bacde02f9b1185988415d3f5b7a4f3": "The function `summarize` takes a string `text` and a string `prompt_type` as input. It uses the specified `prompt_type` to format a prompt, then sends this prompt to an endpoint using a payload that includes a model, temperature, and messages. The function attempts to receive a response up to three times, handling HTTP errors and request exceptions by retrying with a one-second delay each time. If successful, it sanitizes and returns the summary content; otherwise, it raises a `RuntimeError` with an error message.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\llm_client.py:sanitize_summary:328b19849b771100857bb8c6444b48431fee1becb835e7d92a9963437cb12900": "The `sanitize_summary` function removes meta-commentary from a given text by filtering out lines that start with specific phrases or contain certain keywords related to summaries, outputs, and responses. It processes the input text by splitting it into lines, filtering out unwanted lines based on predefined criteria, and then joining the remaining lines back together.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\llm_client.py:sanitize_summary:7f8a45bf9bfa4409432aa5aca1fd9a4aaf19cb1b759f28f15145667135df2807": "",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\llm_client.py:sanitize_summary:c32dbb3653f2dd920934bcdb52c63ec8e0470454865c446006f181558be7eeba": "The `sanitize_summary` function takes a string `text` as input and returns a sanitized version of the text by removing lines that start with certain phrases or contain specific keywords related to summaries, outputs, responses, and other meta-commentary. It also removes lines that start with \"this script\", \"this code\", or \"this file\" followed by verbs like \"does\" or \"is\". The function ensures that only relevant content is retained in the summary.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\llm_client.py:sanitize_summary:ddf95a9f600fe1fad2184b4a532b134a55a45480ac493edc76dfbf8e7e8ad64a": "The function `sanitize_summary` processes a given text by removing lines that start with specific phrases or contain certain keywords related to summaries, outputs, responses, and descriptions. It filters out meta commentary and redundant information, returning a sanitized version of the input text.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\parser_matlab.py:15cf90e58e5b33528fe0fc6fa2e48fa77e43bd0fed902a29ea22b67a2f78ff68": "This module provides a parser for MATLAB `.m` files. It extracts the file's header comments and any function declarations found within the file. Each function entry includes the function name and a list of arguments. The parsing uses simple line-based techniques as specified in the Software Requirements Specification (SRS).",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\parser_matlab.py:15cf90e58e5b33528fe0fc6fa2e48fa77e43bd0fed902a29ea22b67a2f78ff68:15cf90e58e5b33528fe0fc6fa2e48fa77e43bd0fed902a29ea22b67a2f78ff68": "This module defines a function `parse_matlab_file` that takes the path to a MATLAB `.m` file and returns a dictionary containing the file's header comments and any function declarations found. Each function entry includes the function name and a list of arguments. The parsing uses simple line-based techniques as specified in the Software Requirements Specification (SRS).",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\parser_matlab.py:parse_matlab_file:33b15c234f880abb1d0d302c71ccb017d78acde32d83f5ee8e322dc56634d78e": "The function `parse_matlab_file` reads and parses a MATLAB `.m` file to extract its header comments and function declarations. It returns a dictionary containing the extracted header as a string and a list of dictionaries for each function found in the body of the file. Each function dictionary includes the function's name and a list of its arguments.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\parser_matlab.py:parse_matlab_file:5ebe027bdfbdf57e73b1702b7b1bf0e3590bb1578f75500cf342a0543c683e95": "The function `parse_matlab_file` reads and parses a MATLAB `.m` file to extract basic structure. It returns a dictionary containing the file's header comments and any function declarations found. Each function entry includes the function name and a list of arguments. The function uses regular expressions to identify and parse function declarations from the file content.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\parser_matlab.py:parse_matlab_file:98e56490608eae9cf5f58ecfcabce614d40fc4adf171eb4f51b1862c1635c59d": "The function `parse_matlab_file` reads and parses a MATLAB `.m` file to extract its header comments and function declarations. It returns a dictionary containing the extracted header as a string and a list of dictionaries, each representing a function declaration with its name and arguments. The function uses regular expressions to identify and parse function definitions within the file's body.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\parser_matlab.py:parse_matlab_file:f7bec8831ec4a10747ad59a4db158f98c16ecc7a8d088a3e841204c7bd5f0c85": "The function `parse_matlab_file` reads and parses a MATLAB `.m` file to extract basic structure. It returns a dictionary containing the file's header comments and any `function` declarations found. The header is collected from lines starting with `%`, and function declarations are identified using a regular expression that matches lines defining functions, capturing their names and arguments.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\parser_python.py:3a2a9b7664504ae6c8ef1905e400d9f06a7eb0f0680741d90e30ce977a1ce987": "This module provides a parser for Python files using the `ast` module to extract structured information according to the Software Requirements Specification (SRS). It includes functions to format arguments and signatures of functions and methods, and a main function to parse a Python source file and return a dictionary containing the module docstring, classes, and functions. Each class and function is represented with its name, signature, docstring, and source code segment.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\parser_python.py:_format_arg:6dc54a59a264082e086aa8817a5c6c853679f87d737445ce181bdafc690974e4": "The function `_format_arg` formats an argument (`arg`) from the Python Abstract Syntax Tree (AST) by appending its type annotation, if present. It returns a string representing the formatted argument.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\parser_python.py:_format_arg:b5cd8bc77d34a5189e9a73e100502b7e73b51f2c7c23249df0805764ca970c31": "This function formats an argument (`arg`) from the Python `ast` module. It constructs a string that includes the argument name and its type annotation, if present. The formatted string is returned.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\parser_python.py:_format_arg:c20be4791c4aa45d8c43905687c6bfb9894818640b8808ac355f0c142902f934": "Formats a function argument by appending its type annotation, if available.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\parser_python.py:_format_arg:cbe6f1a8035c6fe3e86a63f2e84e8c9d5f73d4565f294b2c9730f5b2bf809d44": "Formats an argument from the Abstract Syntax Tree (AST) by appending its type annotation, if available.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\parser_python.py:_format_arguments:001763cfbe543d50a8ccba6465b5a4ff2e0acb4bd9fade8ad42e587230e37b98": "The function `_format_arguments` takes an `ast.arguments` object as input and returns a string representation of the arguments, formatted according to Python syntax rules. It handles positional-only arguments, regular arguments, variable-length positional arguments, keyword-only arguments, and variable-length keyword arguments, including their default values if provided.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\parser_python.py:_format_arguments:8819fc0de1e469407ce37f7be140554dffbb1e4c86023edac0e60bad584078b1": "The function `_format_arguments` takes an `ast.arguments` object as input and returns a string representation of the arguments it contains. It handles positional-only arguments, regular arguments, variable positional arguments, keyword-only arguments, and variable keyword arguments, formatting each according to Python syntax rules. The function uses helper functions like `_format_arg` and `ast.unparse` to convert AST nodes into their string representations.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\parser_python.py:_format_arguments:881b31b9f315a915f96f295e1b615ecf667d48840ad89cab8656aa66b735c2e7": "This function `_format_arguments` takes an `ast.arguments` object as input and returns a string representation of the function arguments. It handles positional-only, regular, variable positional, keyword-only, and variable keyword arguments, including their default values if provided. The function uses helper functions like `_format_arg` to format individual argument names and iterates through the different types of arguments to construct the final string.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\parser_python.py:_format_arguments:f88bd443e6095e721f92fc4ff62adf43cb1a050b9195b25431b977a7764aa19e": "The function `_format_arguments` takes an `ast.arguments` object as input and returns a string representation of its arguments. It handles positional-only, regular, variable positional, keyword-only, and variable keyword arguments, including their default values if provided. The function uses helper functions to format individual arguments and constructs the final string by joining these parts with commas.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\parser_python.py:_format_signature:234e0c8bf59ffb652a9dbdbbc88062eb21c10433db4b359afd2a2a4a42bb6fd5": "This function, `_format_signature`, takes an `ast.FunctionDef` or `ast.AsyncFunctionDef` object as input and returns a string representing the signature of the function. It formats the function name and its arguments using another helper function `_format_arguments`. If the function has a return type specified, it appends this to the signature as well.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\parser_python.py:_format_signature:4ef0c9abbcd2f38f64f076ce12a7beb07346595100595710d104dc9cb3d172eb": "This function `_format_signature` takes an `ast.FunctionDef` or `ast.AsyncFunctionDef` object as input and returns a string representing the signature of the function. It formats the parameters using the `_format_arguments` helper function and appends the return type if specified in the function definition.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\parser_python.py:_format_signature:7cbbc685b884c8d9b84149f4d2718c05f083840ff2f7bda8b86e0b16c9636946": "This function `_format_signature` takes an `ast.FunctionDef` or `ast.AsyncFunctionDef` object as input and returns a string representing the signature of the function. It formats the arguments using the `_format_arguments` helper function and appends the return type if specified, using `ast.unparse` to convert the return type node into a string.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\parser_python.py:_format_signature:b326197de0918098a6e80ac211f31a48b46ed68f0fa4b546661b8b44b92828cd": "The function `_format_signature` takes an `ast.FunctionDef` or `ast.AsyncFunctionDef` object as input and returns a string representing the signature of the function, including its name, parameters, and return type if specified. It uses the helper function `_format_arguments` to format the function's arguments.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\parser_python.py:d62d5ee4e4f3c355da0422588f26c8a164b91c379cc0cc9ee444d287463c03a3:d62d5ee4e4f3c355da0422588f26c8a164b91c379cc0cc9ee444d287463c03a3": "This Python module provides a parser for Python files used by DocGen-LM. It uses the `ast` module to extract structures according to the Software Requirements Specification (SRS). The module includes functions to format arguments, signatures, and parse functions and classes within Python source files. It also contains a function to parse an entire Python file and return structured information about its contents, including docstrings, methods, subfunctions, and subclasses.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\parser_python.py:ffe6713d2268df70ff61edbe228453c42761205a3b6f37898d9c7656e010273c:ffe6713d2268df70ff61edbe228453c42761205a3b6f37898d9c7656e010273c": "This module provides a parser for Python files using the `ast` module to extract structured information according to the Software Requirements Specification (SRS). It includes functions to format arguments and signatures of functions and methods, as well as a main function to parse a Python source file and return a dictionary containing the module's docstring, classes, and functions. Each class and method is represented with its name, signature, docstring, and source code segment.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\parser_python.py:parse_class:813cc3dc9ecebeb4f0eef84c568212afb7fbc9f80176afbf0d5663e2531eea7b": "The function `parse_class` takes an AST node representing a class definition and the source code as input. It returns a dictionary containing information about the class, including its name, docstring, methods, subclasses, and source code segment. The function iterates through the body of the class node, recursively parsing nested classes and extracting method definitions using `parse_function`.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\parser_python.py:parse_function:274a583c86faa0ec453162c5ac88078f8d640e9ce815d6d8b59b62c3ce966bfd": "This function `parse_function` takes an AST node representing a function or asynchronous function and the source code as input. It returns a dictionary containing information about the function, including its name, signature, return type, docstring, source code segment, and any nested functions. The function iterates through the body of the given node to identify and parse any nested functions, recursively calling itself for each nested function found.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\parser_python.py:parse_python_file:025baabb754d3fc7c93184520f3d394a0cfbefe7ef296595cb4fa69062af7834": "This function `parse_python_file` takes a file path as input and returns a dictionary containing structured information about the Python source code. It reads the source code from the specified file, parses it using the `ast` module to extract the abstract syntax tree (AST), and then extracts relevant details such as the module docstring, classes, and functions. For each class and function found, it captures their names, signatures, docstrings, and source code segments. The parsed information is organized into a dictionary and returned.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\parser_python.py:parse_python_file:5d09ced19e639380a05459d612510c194a600e5be2473e9c52baf4862c17da81": "The `parse_python_file` function reads a Python source file and returns structured information about its contents. It uses the `ast` module to parse the source code and extract details such as the module docstring, classes, and functions. For each class and function found, it captures their names, signatures, docstrings, return types (if applicable), and source code segments. The parsed information is returned in a dictionary format.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\parser_python.py:parse_python_file:c67beeb3654ce04ceb13ed285b8aaf2a17adf17172237c58813c9fdeb7c959cb": "The `parse_python_file` function reads a Python source file and extracts structured information. It returns a dictionary containing the module docstring, classes, and functions defined in the file. The function uses the `ast` module to parse the source code and iterates through its body to identify class and function definitions. Each identified class and function is further parsed using helper functions (`parse_class` and `parse_function`).",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\parser_python.py:parse_python_file:cce66fa800281cf00f2894ffed54daf003e7d0d518d96deeb05d3b92e40f8e13": "The `parse_python_file` function reads a Python source file and returns structured information about its contents. It uses the `ast` module to parse the source code and extract the following details:\n\n- **Module Docstring**: The docstring of the entire module.\n- **Classes**: Information about each class defined in the module, including:\n- Class name\n- Class docstring\n- Methods within the class, each with:\n- Method name\n- Signature (formatted)\n- Method docstring\n- Source code segment\n- **Functions**: Information about each function or async function defined at the top level of the module, including:\n- Function name\n- Signature (formatted)\n- Return type (if specified)\n- Function docstring\n- Source code segment\n\nThe function returns a dictionary containing these structured elements.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\reviewer.py:4f9d422499a1acff78c67b05122179a409cbacd25a4c242442e0aef707dbeb81:4f9d422499a1acff78c67b05122179a409cbacd25a4c242442e0aef707dbeb81": "The module implements a post-generation documentation reviewer for HTML output generated by DocGen-LM. It includes functions to check for assistant-like phrases, contradictions, and hallucinations in the HTML content. The `review_directory` function processes all `.html` files in a specified directory, applying checks and optionally fixing issues based on the `autofix` flag. The main function sets up command-line arguments to specify the directory to review and whether to automatically fix detected issues.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\reviewer.py:6a93d618a253fc978a2efb4e7a399150eeb0d2bed5d4abd80181174fa8881fe1": "This module provides a tool for reviewing HTML documentation generated by DocGen-LM. It includes functions to check for assistant-like phrases, contradictions, and hallucinations in the documentation. The `review_directory` function processes all `.html` files in a specified directory, applying checks and optionally fixing issues based on the `autofix` flag. The `main` function sets up command-line arguments to specify the directory to review and whether to automatically fix detected issues.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\reviewer.py:6a93d618a253fc978a2efb4e7a399150eeb0d2bed5d4abd80181174fa8881fe1:6a93d618a253fc978a2efb4e7a399150eeb0d2bed5d4abd80181174fa8881fe1": "This module provides a tool to review HTML documentation generated by DocGen-LM. It includes functions to check for assistant-like phrases, contradictions, and hallucinations in the text. The `review_directory` function processes all `.html` files in a specified directory, applying these checks and optionally fixing issues by sanitizing paragraphs using a `sanitize_summary` function from another module (`llm_client`). The tool can be run as a command-line script, taking a directory path and an optional `--autofix` flag to automatically apply fixes.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\reviewer.py:_extract_tags:0b10d8793c88bb422b39869450f56452b4a4b3e4125b5190da968f3f95c34775": "The function `_extract_tags` extracts all content within HTML tags of a specified type from a given HTML string. It uses a regular expression pattern to match the opening and closing tags along with their contents. The function returns a list of strings, each representing the content of an HTML tag of the specified type.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\reviewer.py:_extract_tags:26a916a73040652f45384417623a215de55de9c0c99931ff54a3aa9d2a7a9f7d": "The function `_extract_tags` takes an HTML string and a tag name as input. It uses a regular expression to find all occurrences of the specified tag within the HTML, capturing the content between the opening and closing tags. The function returns a list of strings, each representing the content of one instance of the specified tag found in the HTML.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\reviewer.py:_find_line_number:12ee52af23a70731af76ffcfdde45eb4138bf79324a53c5430d402dce88eb735": "This function `_find_line_number` searches for a specific phrase within an HTML string and returns the line number where the phrase is found. If the phrase is not present, it returns -1. The search is case-insensitive.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\reviewer.py:_find_line_number:191f5e3abde2c30067ef1809bb006db3dbf5f094ba8521d611a754c67ac3d15c": "The function `_find_line_number` takes two parameters: `html`, which is a string containing HTML content, and `phrase`, which is the substring to search for within the HTML. It returns the line number where the phrase is found, with line numbering starting from 1. If the phrase is not found, it returns -1. The search is case-insensitive.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\reviewer.py:_find_line_number:6391e049e3553c392bd11f5db15aa8f9ec9c140727744ae47c3127d71d1dab89": "The function `_find_line_number` takes two parameters: `html`, which is a string containing HTML content, and `phrase`, which is a string to search for within the HTML. It returns the line number where the phrase is found, with line numbering starting at 1. If the phrase is not found, it returns -1. The search is case-insensitive.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\reviewer.py:_find_line_number:70c08d400ee8480bc73c5e69bad927c045ef4bbf9e7edd29a340bbcc2e9a9dc5": "The function `_find_line_number` searches for a specific phrase within an HTML string and returns the line number where the phrase is found. If the phrase is not present, it returns -1. The search is case-insensitive.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\reviewer.py:_is_generated_html:32d91233a723cdfd78fbe7912f2a84a7f698390d6b1ae0a7319b372a40fef3f4": "This function checks if a given string `text` appears to be output generated by the DocGen-LM tool. It returns `True` if the text contains specific markers indicating it was produced by DocGen-LM, such as the phrase \"Generated by DocGen-LM\", an HTML heading for project documentation, and headings for classes and methods. If none of these indicators are found, it returns `False`.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\reviewer.py:_is_generated_html:3c7180047e02f2d78983ef8a42f4f57871341cce94eb50a673c776c9d042653e": "This function checks if a given string `text` appears to be output from DocGen-LM by looking for specific HTML tags that are characteristic of the tool's documentation format. It returns `True` if any of the following conditions are met:\n1. The text contains an `<h1>` tag with the title \"Project Documentation\".\n2. The text contains an `<h2>` tag with the class name \"Class:\".\n3. The text contains an `<h3>` tag with the class name \"Method:\".",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\reviewer.py:_is_generated_html:ad545853d9d39317ebcbd440d8181232a1f3983a8c8bdc4b12d0d32fe14e069d": "This function checks if a given text appears to be output from DocGen-LM, a tool for generating static HTML documentation for Python and MATLAB projects. It returns `True` if the text contains specific markers indicating it is generated by DocGen-LM, such as \"Generated by DocGen-LM\", an `<h1>` heading titled \"Project Documentation\", or headings for classes and methods formatted with `<h2>` and `<h3>`.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\reviewer.py:_is_generated_html:f71db6cd6fea097c810e3e3390f8520fa34227e1ce03bf977f25e2e3f49d61bd": "The function `_is_generated_html` checks if a given string `text` appears to be output from the DocGen-LM documentation generator. It returns `True` if the text contains specific HTML tags that are characteristic of DocGen-LM's generated documentation, such as an `<h1>` tag with the text \"Project Documentation\", or `<h2>` and `<h3>` tags containing \"Class:\" and \"Method:\", respectively.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\reviewer.py:_review_file:1cbe1182f7cd1978020e92ad54d786205123360a0f324dce5c43b4859a5f2a6e": "The function `_review_file` takes a file path and an optional boolean flag `autofix`. It reads the HTML content of the file, checks for assistant phrasing, contradictions, and hallucinations using separate functions (`check_assistant_phrasing`, `check_contradictions`, `check_hallucinations`). If any issues are found, it appends a formatted string to the results list indicating the type of issue and the file name. If `autofix` is True and there are issues, it sanitizes the HTML paragraphs using `_sanitize_paragraphs` and writes the updated content back to the file. The function returns a list of strings containing the review results.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\reviewer.py:_review_file:22f34ef135a70bc5dc9b227597baa6ee3283ffbad848fc50cc73ad0d0089dcfb": "The function `_review_file` takes a file path and an optional `autofix` flag as input. It reads the HTML content from the specified file, checks for assistant phrasing, contradictions, and hallucinations using predefined functions (`check_assistant_phrasing`, `check_contradictions`, `check_hallucinations`). If any issues are found, it appends a message to the results list indicating the type of issue (assistant phrasing, contradiction, or hallucination) along with the file name. If the `autofix` flag is set and there are issues, it sanitizes the paragraphs in the HTML content using `_sanitize_paragraphs` and writes the modified HTML back to the file. Finally, it returns a list of review results.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\reviewer.py:_review_file:9b184abd21ef122363bceed27379b557acb8aa25b00200d7667c8df0d85ed6e4": "This function `_review_file` takes a file path and an optional `autofix` flag as input. It reads the HTML content of the file, checks for assistant phrasing, contradictions, and hallucinations using respective functions (`check_assistant_phrasing`, `check_contradictions`, `check_hallucinations`). If any issues are found, it appends a message to the results list indicating the type of issue and the file name. If the `autofix` flag is set and there are issues, it sanitizes the paragraphs in the HTML content using `_sanitize_paragraphs` and writes the modified content back to the file. Finally, it returns the list of review results.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\reviewer.py:_review_file:a6e75a23c3e2b5ae7246c4b8a92370eafc482141111a6d17384a5542e212feb1": "The function `_review_file` takes a file path and an optional boolean flag `autofix`. It reads the HTML content of the file. If the HTML is not generated by the tool, it returns an empty list. Otherwise, it checks for assistant phrasing, contradictions, and hallucinations in the HTML using separate functions (`check_assistant_phrasing`, `check_contradictions`, `check_hallucinations`). For each issue found, it appends a formatted string to the results list indicating the type of issue and the file name. If `autofix` is True and there are issues, it sanitizes the HTML paragraphs using `_sanitize_paragraphs` and writes the updated HTML back to the file. Finally, it returns the list of issues found.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\reviewer.py:_sanitize_paragraphs:24efef781c4f3bef05d72a03e04d6e6d3b0781b0e567634fb26a4ba4b49d8886": "The function `_sanitize_paragraphs` takes an HTML string as input and sanitizes the content within paragraph tags. It uses a regular expression to identify paragraphs and applies a replacement function to each one. The replacement function strips HTML from the text within the paragraph, sanitizes it using another function `sanitize_summary`, and then wraps the sanitized text back in paragraph tags. This ensures that all paragraph content is clean and properly formatted for display.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\reviewer.py:_sanitize_paragraphs:4b1924f38307e1de1d7477188cca504d83a80d501239e63235223e0a63a77bbc": "The function `_sanitize_paragraphs` processes a `BeautifulSoup` object to clean up paragraph (`<p>`) elements. It iterates through all `<p>` tags in the provided HTML structure, extracts their text content, sanitizes it using the `sanitize_summary` function, and then updates the text of each `<p>` tag with the sanitized version.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\reviewer.py:_sanitize_paragraphs:8f305cbfae7284bb1aa414a4e9cea54829b859862536f896186c7bb2719b887b": "The function `_sanitize_paragraphs` processes a `BeautifulSoup` object to clean up paragraph (`<p>`) elements. It iterates through all `<p>` tags in the provided HTML structure, extracts their text content using `.get_text()`, sanitizes this text with a function named `sanitize_summary`, and then updates the text of each `<p>` tag with the sanitized version.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\reviewer.py:_sanitize_paragraphs:f52de39a28330d594c27dc4a7121ee14b66fd87d2c40daee62e4914cb70ad798": "The function `_sanitize_paragraphs` takes an HTML string as input and sanitizes the content within `<p>` tags. It uses a regular expression to find all occurrences of `<p>` tags and applies a replacement function `repl` to each match. The replacement function strips any HTML from the text within the `<p>` tags, sanitizes it using another function `sanitize_summary`, and then wraps the sanitized text back in `<p>` tags. This ensures that all paragraph content is clean and properly formatted in the HTML output.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\reviewer.py:_strip_html:21afd718792dbe604dd6c2296250f0cf0d9a12935ab9487b1a4964b3df34645b": "The function `_strip_html` takes a string `text` as input and returns a new string with all HTML tags removed. It uses the `re.sub` method from the `re` module to substitute any sequence of characters enclosed in angle brackets (`<...>`) with an empty string, effectively stripping away HTML markup.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\reviewer.py:_strip_html:403506e138c5045eee735fdac589db8eb96b158acefde0a3eae2e9d9c512ad25": "The function `_strip_html` takes a string `text` as input and returns a new string with all HTML tags removed. It uses the `re.sub` method from the `re` module to substitute any sequence of characters that match the regular expression `<[^>]+>` (which represents an HTML tag) with an empty string, effectively removing them from the text.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\reviewer.py:check_assistant_phrasing:355a727d8cbc0d96c2335b75b7965d888bd0b10cfeed6af75aa2c867a3fb81fe": "The function `check_assistant_phrasing` analyzes an HTML string to identify and list occurrences of assistant-like phrases. It extracts paragraphs from the HTML using `_extract_tags`, strips HTML tags from the text, converts it to lowercase for case-insensitive comparison, and checks if any predefined assistant phrases are present. If a phrase is found, it records the exact text and line number in the HTML where it appears. The function returns a list of these findings.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\reviewer.py:check_assistant_phrasing:893645cb7ecc71511e0caec14bcce562e845e7c14f68212c9455164e6d54256e": "This function `check_assistant_phrasing` takes a BeautifulSoup object and an HTML string as input. It searches for paragraphs in the HTML where any of a list of predefined assistant-like phrases appear. If such a phrase is found, it extracts the text of the paragraph, finds the line number within the original HTML where this text appears, and appends a formatted string containing the phrase and its line number to a list. The function returns this list of findings.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\reviewer.py:check_assistant_phrasing:89a348b78ea890f5aef36de5a42640f4c34e336d19210a6d45fd108f60972f5d": "This function `check_assistant_phrasing` takes an HTML string as input and returns a list of phrases that resemble assistant-like language found within paragraph tags. It iterates over each paragraph extracted from the HTML, strips any HTML tags, converts the text to lowercase for case-insensitive comparison, and checks if any predefined assistant phrases are present. If a match is found, it appends the phrase along with its line number in the original HTML to the findings list.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\reviewer.py:check_assistant_phrasing:99e719c9bbf9ff225127a853a2af99b5dd16b6a37c1af6cd976e99d7e7aafc33": "The function `check_assistant_phrasing` analyzes an HTML document using BeautifulSoup to identify paragraphs containing phrases that resemble assistant-like language. It returns a list of these phrases along with their line numbers in the original HTML source code. The function iterates over all paragraph elements, checks if any predefined assistant phrases are present in the text, and records the findings.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\reviewer.py:check_contradictions:1c635ad152388a378885c7b595d5625fbc979395a84cf85668b6d3ed13b3a15e": "This function `check_contradictions` analyzes HTML documentation to identify contradictions between the text content and the presence of specific elements. It returns a list of contradiction descriptions.\n\nThe function performs the following steps:\n1. Extracts all paragraph (`<p>`) tags from the HTML, strips any HTML tags, converts them to lowercase, and stores them in `paragraphs`.\n2. Joins the first two paragraphs into `summary_text` for quick reference.\n3. Extracts headers with \"Method:\" prefix and stores them in `methods`.\n4. Extracts headers without \"Method:\" prefix (presumably functions) and stores them in `functions`.\n5. Extracts headers with \"Class:\" prefix and stores them in `classes`.\n6. Checks if the summary text mentions the absence of methods, functions, or classes but finds corresponding elements:\n- If \"no methods\" is mentioned but methods are found, it appends a contradiction description.\n- If \"no functions\" is mentioned but functions are found, it appends a contradiction description.\n- If \"no classes\" is mentioned but classes are found, it appends a contradiction description.\n7. Returns the list of contradiction descriptions.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\reviewer.py:check_contradictions:4c1726365b1e371054470bda3cfd1fb800f3ace9517e734bbe94e2450c75cca1": "This function `check_contradictions` analyzes the HTML content using BeautifulSoup to identify contradictions between the text summary and the actual structure of the code. It checks for discrepancies such as:\n\n1. The presence of method headers when the summary states there are no methods.\n2. The presence of function headers when the summary states there are no functions.\n3. The presence of class headers when the summary states there are no classes.\n\nThe function returns a list of strings describing any contradictions found in the documentation.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\reviewer.py:check_contradictions:5b4bba7a53f9ed939fe80729afa805dd22aba6010b72b522657d066501a3e92b": "Function `check_contradictions` takes a BeautifulSoup object as input and returns a list of contradiction descriptions. It checks for contradictions between the text \"no methods,\" \"no functions,\" or \"no classes\" in the summary and the presence of method, function, or class headers in the HTML content. If such contradictions are found, they are added to the findings list and returned.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\reviewer.py:check_contradictions:b974f5e966b3d324901a86973f6aeb7ba0c647162ff1e465529e05f6590564d3": "The `check_contradictions` function analyzes HTML documentation to identify contradictions based on the presence of specific tags and text. It returns a list of contradiction descriptions. The function extracts paragraphs, method headers, function headers, and class headers from the HTML. It checks for contradictions such as stating \"no methods\" but finding method headers, stating \"no functions\" but finding function headers, or stating \"no classes\" but finding class headers.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\reviewer.py:check_hallucinations:086a31f679b6ad06dcbd9ae83f46061b4787852f9f64d406da8caabead432b0b": "The function `check_hallucinations` analyzes an HTML string to detect the presence of hallucination phrases. It returns a list of detected terms that match predefined hallucination terms. The function uses helper functions `_extract_tags` and `_strip_html` to extract paragraph tags from the HTML and strip away any HTML tags, respectively. It then checks each text segment for the presence of any hallucination terms and appends them to the findings list if present.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\reviewer.py:check_hallucinations:23da960708d84e8738fe21fade41b9b6ba2267e4ae347301facd9483011f3b6d": "The function `check_hallucinations` takes an HTML string as input and returns a list of hallucination phrases detected within the HTML. It uses a helper function `_extract_tags` to extract all paragraph (`<p>`) tags from the HTML, then strips any HTML tags and converts the text to lowercase. The function checks each paragraph against a predefined list of hallucination terms stored in `HALLUCINATION_TERMS`. If any term is found within a paragraph, it is added to the `findings` list, which is returned at the end of the function.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\reviewer.py:check_hallucinations:3f87b3b4839688b0b8ed2b0753e1e2d1e57590e85662793ae4aea924932388b4": "This function `check_hallucinations` takes a BeautifulSoup object as input and returns a list of phrases detected as hallucinations. It iterates through all paragraph elements (`<p>`) in the HTML content, extracts their text, converts it to lowercase for case-insensitive comparison, and checks if any predefined hallucination terms are present. If a hallucination term is found, it is added to the findings list.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\reviewer.py:check_hallucinations:babee8fb481df682332191a34d5f7aa7741a3f24a77820a2e3a3a9a7b5b445f6": "Function `check_hallucinations` takes a BeautifulSoup object as input and returns a list of hallucination phrases detected within paragraph tags. It iterates over all paragraph elements, extracts their text content, converts it to lowercase, and checks for the presence of any terms listed in `HALLUCINATION_TERMS`. If a term is found, it is added to the findings list.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\reviewer.py:main:2dca405b6242c98c552640b6bda96ee1a4ca65f93732ff632ecaa2372676789d": "The `main` function serves as the entry point for reviewing generated HTML documentation. It accepts command-line arguments through `argv`, which defaults to `None`. The function uses `argparse` to parse two arguments: `directory`, which specifies the path to the HTML output directory, and `--autofix`, a boolean flag that indicates whether to automatically rewrite files to fix issues.\n\nThe parsed arguments are then passed to the `review_directory` function, along with the `autofix` option. The function returns an integer value of `0`.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\reviewer.py:main:a554c44d0acc1c476ee4de0a16a4af0b07260fc87ada79346f9b71d9373eca73": "The `main` function sets up an argument parser to accept a directory path and an optional flag for automatic fixing of issues. It then calls the `review_directory` function with the provided directory path and the autofix flag. The function returns 0 upon successful execution.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\reviewer.py:main:b739207c29cc8e424f2288084e27c10c6d23b7cc54be73e1915475b640d04530": "The `main` function serves as the entry point for a script that reviews generated HTML documentation. It accepts command-line arguments using the `argparse` module. The function expects a directory path where the HTML output is located and an optional `--autofix` flag to indicate whether files should be rewritten to fix issues. After parsing the arguments, it calls the `review_directory` function with the provided directory path and the autofix setting, then returns 0 to indicate successful execution.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\reviewer.py:main:ebc53b1f0f6a6b474637347930593419ffb26c5c4d2d194f6f90aea4cc923d78": "The `main` function serves as the entry point for reviewing generated HTML documentation. It accepts command-line arguments specifying the directory containing the HTML files and an optional flag to enable automatic fixes for issues in these files. The function uses the `argparse` module to parse these arguments and then calls the `review_directory` function with the provided directory path and autofix setting.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\reviewer.py:review_directory:64740af8b0386998f67875758d218bd872b157039c49cf956b42fb187db7c1ad": "The `review_directory` function scans a directory and its subdirectories for HTML files. It processes each HTML file using the `_review_file` function, which takes an optional `autofix` parameter. If an error occurs during processing, it prints an error message and continues to the next file. The results from `_review_file` are printed line by line.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\reviewer.py:review_directory:a8e85ee2b46c94e5641bebf326d2dc8deff949aa5bdcdc5d9d51bdafaed48dc1": "The `review_directory` function iterates through all `.html` files within a specified directory and its subdirectories. For each file, it calls the `_review_file` function to review and optionally autofix any issues found. If an error occurs during the review process, it prints an error message and continues with the next file. The results of the review are printed line by line.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\reviewer.py:review_directory:f3cda16ac40924e409d3041f9a2238b6d6da800ddfffbc8fc6139d49b3966692": "The `review_directory` function iterates over all HTML files within a specified directory and its subdirectories using `rglob`. For each file, it calls `_review_file` with the file path and an optional `autofix` flag. If an exception occurs during the review process, it prints an error message and continues to the next file. The results from `_review_file` are printed line by line.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\reviewer.py:review_directory:ff14deb96438e4113a86dd640cab708f9d87a8f4c5d4095d5b081e9555219822": "The `review_directory` function processes all HTML files within a specified directory and its subdirectories. It iterates over each file, calls the `_review_file` function to analyze and review the content, and prints the results. If an error occurs during file reading or processing, it catches the exception, prints an error message, and continues with the next file. The `autofix` parameter allows for automatic fixes to be applied if specified.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\scanner.py:_is_subpath:156741183bb1779e4b7014fe63683fba008909ffd3406e0b6d6475d82c6b8750": "This function checks whether a given `path` is either equal to or a subdirectory of another `parent` directory. It uses the `relative_to` method from Python's `Path` class to determine if `path` can be made relative to `parent`. If successful, it returns `True`, indicating that `path` is a subpath of `parent`. If a `ValueError` is raised, it means `path` cannot be made relative to `parent`, and the function returns `False`.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\scanner.py:_is_subpath:c8a93988c5533ebfadb206fc27d4e3da0197d394f70696b5b62cae28e0bfeac6": "This function checks whether a given `path` is either equal to or a subdirectory of another `parent` directory. It uses the `relative_to` method from Python's `Path` class to determine if `path` can be made relative to `parent`. If successful, it returns `True`, indicating that `path` is a subpath of `parent`. If a `ValueError` is raised during this operation, it means `path` is not a subpath of `parent`, and the function returns `False`.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\scanner.py:_is_subpath:cd00e4939e7f8ad39deb1b14945591c3d58602478daf49de02253e0c0c4f99a4": "This function checks if one directory (`path`) is a subdirectory of another directory (`parent`). It returns `True` if `path` is either equal to or inside `parent`, and `False` otherwise. The check is performed using the `relative_to` method, which raises a `ValueError` if `path` is not a subdirectory of `parent`.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\scanner.py:_is_subpath:d26137d7914ea5bdda66d11003f5bb54ce08cb367dcff746569a6fc9eeef65bf": "This function checks whether one file path (`path`) is a subpath of another (`parent`). It returns `True` if `path` is either equal to or inside `parent`, and `False` otherwise. The check is performed using the `relative_to` method, which raises a `ValueError` if `path` is not related to `parent`.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\scanner.py:fd7e0f952dd35ca841116789b2d99cfc36e1d26a7cf0ee616028fe9532c20347": "The module defines a function `scan_directory` that recursively discovers Python (``.py``) and Objective-C (``.m``) source files within a specified directory. It includes an internal helper function `_is_subpath` to check if one path is a subpath of another. The `scan_directory` function also allows for ignoring specific paths or directories during the scan, as defined in the `ignore` list.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\scanner.py:fd7e0f952dd35ca841116789b2d99cfc36e1d26a7cf0ee616028fe9532c20347:fd7e0f952dd35ca841116789b2d99cfc36e1d26a7cf0ee616028fe9532c20347": "The module implements a function to recursively discover Python (``.py``) and Objective-C (``.m``) source files within a specified directory. It includes an optional list of paths to ignore during the search. The function uses `os.walk` for traversal, filters out ignored directories and files, and returns a sorted list of absolute file paths that match the criteria.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\scanner.py:scan_directory:10c412ebbca4b4ff2e7ee873aa70b6a43a382d3b6e959544053aa52ad16e8ada": "The `scan_directory` function recursively discovers Python (``.py``) and MATLAB (``.m``) files under a specified base directory while ignoring certain paths. It returns a list of absolute paths to the discovered source files. The function uses `os.walk` to traverse the directory tree, filters out ignored directories and files, and collects the paths of relevant source files.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\scanner.py:scan_directory:68c9facfc08b922840e4b349ad4c4d75d69f4495b23206a66858423806365957": "The `scan_directory` function recursively discovers Python (``.py``) and MATLAB (``.m``) files under a specified base directory while ignoring certain paths. It returns a list of absolute paths to the discovered source files, excluding those within ignored directories or matching any patterns in the ignore list. The function uses `os.walk` to traverse the directory tree, filters out non-code files, and applies path resolution and pruning based on the provided ignore criteria.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\scanner.py:scan_directory:879a99d66e4170390dca2bf04ad2b6e47aa9ed27477caef970c389526fc1d6cb": "The `scan_directory` function recursively discovers Python (``.py``) and MATLAB (``.m``) files within a specified directory. It excludes directories listed in the `ignore` parameter and skips any file that is a subpath of an ignored directory or `.git` folder. The function returns a sorted list of absolute paths to the discovered source files.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\scanner.py:scan_directory:8e46b1d3ab45c111834319086beeb6b4e051af114f0cec592ceeb0f6bb3d6dbf": "The `scan_directory` function recursively discovers Python (``.py``) and MATLAB (``.m``) files under a specified base directory while ignoring specified paths. It returns a list of absolute paths to the discovered source files, ensuring that directories like `.git` and paths listed in the ignore list are excluded from the search results.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_cache.py:97b2ae8f04e70da29a7fb5d7cb91652ea871818ccc183154b3320347b5835642": "The module defines two functions for testing a response cache implementation. The `test_cache_round_trip` function tests setting and retrieving a value from the cache, ensuring that the value persists across instances of the cache. The `test_cache_get_missing` function verifies that attempting to retrieve a non-existent key returns `None`. Both functions use a temporary file path provided by `tmp_path` for storing the cache data.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_cache.py:97b2ae8f04e70da29a7fb5d7cb91652ea871818ccc183154b3320347b5835642:97b2ae8f04e70da29a7fb5d7cb91652ea871818ccc183154b3320347b5835642": "The module defines two functions for testing a response caching mechanism. The `test_cache_round_trip` function tests setting and retrieving a value from the cache, ensuring that the data persists across instances of the cache. The `test_cache_get_missing` function verifies that attempting to retrieve a non-existent key returns `None`. Both functions use a temporary file path provided by `tmp_path` for storing the cache data.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_cache.py:test_cache_get_missing:949b51987cfc39febab6ddcf35ba3753699419f3b231c4393f974d9c3759e361": "The function `test_cache_get_missing` tests the behavior of a response cache when attempting to retrieve a value for a key that does not exist in the cache. It creates an instance of `ResponseCache` with a temporary JSON file as the cache storage location. The test asserts that calling `get` on the cache with a non-existent key (\"unknown\") returns `None`.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_cache.py:test_cache_get_missing:c9a05214d2dff1d4b421ded685947a088eb5d53d70d5a1a1c88040d4e3417cc6": "This function tests the `get` method of the `ResponseCache` class. It creates a temporary directory using `tmp_path`, initializes a `ResponseCache` object with a path to a JSON file in that directory, and asserts that attempting to retrieve a value for a non-existent key (\"unknown\") returns `None`.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_cache.py:test_cache_get_missing:eaf1c943299620a501ca6ddaf7677617131d12b7aeb7b923ae61c645fb23d0a1": "This function tests the `get` method of a `ResponseCache` class. It creates an instance of `ResponseCache` with a temporary file path for caching. The test asserts that calling the `get` method with a key \"unknown\" returns `None`, indicating that the cache does not contain an entry for this key.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_cache.py:test_cache_get_missing:f8d11d8c2497d5b60471548ac29fd09533fe5b68d175326a520dbe9b66fc89c4": "The function `test_cache_get_missing` tests the `get` method of a `ResponseCache` object. It creates an instance of `ResponseCache` with a temporary file path for caching responses. The test asserts that calling `get` with a key that does not exist in the cache returns `None`.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_cache.py:test_cache_round_trip:1ec3861c1a4ca6135e691d4eab3cf713a16cad30c2547a470a4de18a95c40d98": "This function tests the round-trip functionality of a `ResponseCache` class. It creates a temporary file to store the cache, initializes a `ResponseCache` instance with this file path, and sets a key-value pair in the cache. Then, it reloads the cache from the same file and asserts that the value retrieved matches the original value set.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_cache.py:test_cache_round_trip:a679b04eeca51e82df9d3ae13ab34efbe9b10735392b27a97c2c73e1953b351e": "This function tests the round-trip functionality of a caching mechanism. It creates a temporary file to store cache data, sets a key-value pair in the cache, and then reads it back to verify that the value is correctly stored and retrieved.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_cache.py:test_cache_round_trip:bdb425b3fff28cdb72d4c65c724d33cacb9b9ba614087e6f70c38e94b19fdb4c": "This function tests the caching mechanism of a `ResponseCache` class. It creates a temporary file to store cache data, initializes a `ResponseCache` object with this file path, and sets a cache entry using a key generated from a file name and content. It then reloads the cache from the same file and asserts that the cached value is correctly retrieved.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_cache.py:test_cache_round_trip:c0c4c6af0dc2740035023f954b95ff4c539a17b879f5a0db571e66bd4692ffb1": "The function `test_cache_round_trip` tests the caching mechanism of a response cache. It creates a temporary file for caching responses and uses the `ResponseCache` class to store a summary under a specific key. After saving, it reloads the cache from the same file and verifies that the stored summary can be retrieved correctly using the same key.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_docgenerator.py:08f8b4fbbc3d3d4f2d3c1bee314f32bf48f04afa9b4eab84044de42898bd4e0b:08f8b4fbbc3d3d4f2d3c1bee314f32bf48f04afa9b4eab84044de42898bd4e0b": "The module defines several test functions for a documentation generation tool. It includes tests to ensure that the tool skips invalid Python files, generates summaries for classes and functions, handles non-UTF8 files, processes class without docstrings, sanitizes project summaries, uses README summaries, cleans output directories, splits long text into chunks, and accounts for prompt overhead in chunking.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_docgenerator.py:ace4892a4c3ae2a7ef824df4bc1647c9f5b6c29a704e8adf82bda258899c5ed1": "This module contains unit tests for a code documentation generator. It uses the `unittest.mock` library to patch the `docgenerator.LLMClient` class and test various scenarios, such as skipping invalid Python files, handling different types of summaries (module, class, function), sanitizing project summaries, using README content for summaries, and cleaning up existing output directories before generating new documentation.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_docgenerator.py:ace4892a4c3ae2a7ef824df4bc1647c9f5b6c29a704e8adf82bda258899c5ed1:ace4892a4c3ae2a7ef824df4bc1647c9f5b6c29a704e8adf82bda258899c5ed1": "This module contains unit tests for a code documentation generator. It uses the `unittest.mock.patch` to mock interactions with an `LLMClient`, which is presumably used for summarizing code. The tests check various scenarios, including:\n\n1. Skipping invalid Python files due to syntax errors.\n2. Generating summaries for classes and functions with docstrings.\n3. Handling non-UTF8 encoded files.\n4. Summarizing classes without docstrings.\n5. Sanitizing project summaries.\n6. Using a README file summary if available.\n7. Cleaning the output directory by removing generated HTML files while preserving custom files and assets.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_docgenerator.py:f2ca5450559117c1a1532fb94c1afcd2a671f9748bd262e781e51a0a10c27633:f2ca5450559117c1a1532fb94c1afcd2a671f9748bd262e781e51a0a10c27633": "The module contains unit tests for a documentation generation tool. It uses the `unittest.mock` library to patch dependencies and the `pathlib` library for file operations. The tests cover various scenarios, including:\n\n1. Skipping invalid Python files due to syntax errors.\n2. Generating summaries for classes and functions with valid Python code.\n3. Handling non-UTF8 encoded files.\n4. Summarizing classes without docstrings.\n5. Sanitizing project summaries.\n6. Using README content as a summary if available.\n7. Cleaning the output directory before generating new documentation.\n8. Splitting long texts into chunks for summarization.\n9. Ensuring that functions and methods are summarized atomically within their respective modules or classes.\n10. Summarizing subclass methods correctly.\n\nThe tests interact with an `LLMClient` mock to simulate responses from a language model, ensuring that the documentation generation logic works as expected under different conditions.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_docgenerator.py:test_chunking_accounts_for_prompt_overhead:2a0ea05293cf4a394724838e745ed58f255e2524ebcc5a94461165b96aadb793": "The function `test_chunking_accounts_for_prompt_overhead` tests the `_summarize_chunked` function from the `docgenerator.py` module. It sets up a temporary cache, defines a tokenizer, and calculates prompt overhead based on system and template prompts. The function then calls `_summarize_chunked` with a mock client, cache, key prefix, text, prompt type, tokenizer, maximum context tokens, and chunk token budget. It asserts that the `_summarize` function is called more than once, indicating that the text was chunked to account for prompt overhead.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_docgenerator.py:test_chunking_accounts_for_prompt_overhead:35dded15bc5364e7d37a058c4e1212795217752ca27d2c7cffbc674d02511043": "This function tests the `_summarize_chunked` function from the `docgenerator` module. It sets up a temporary cache, defines a tokenizer, and calculates the prompt overhead by encoding system prompts and template strings. The maximum context tokens are determined based on this overhead plus an additional 10 tokens. The function then patches the `_summarize` function to return a mock summary value. Finally, it calls `_summarize_chunked` with various parameters and asserts that the mock summary function was called more than once, indicating that the text was chunked appropriately to account for prompt overhead.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_docgenerator.py:test_clean_output_dir:3d72fa112d6c2db2433ebd5e9bc3b97498f36b8b131fe5cdf23efd58246a79ea": "The function `test_clean_output_dir` tests the `clean_output_dir` function from the `docgenerator.py` module. It creates a temporary directory structure with files and subdirectories, simulates the output of a documentation generation process, and then calls `clean_output_dir` to clean up the generated files. The test asserts that only files explicitly marked as \"custom\" or \"asset\" remain after the cleanup, while the file \"old.html\", which is considered generated by the tool, is deleted.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_docgenerator.py:test_clean_output_dir:3e6c225e0dd998b6662d427f231844425c515b313956e9455914b672e038fe79": "The function `test_clean_output_dir` is a unit test that verifies the behavior of the `clean_output_dir` function from the `docgenerator` module. It creates a temporary directory, simulates the presence of various files within it (some generated by DocGen-LM and others custom), and then calls `clean_output_dir` to clean the output directory.\n\nThe test asserts that after calling `clean_output_dir`, only the custom HTML file remains, while the generated HTML file and CSS asset are removed. This ensures that the function correctly identifies and deletes files that were created by DocGen-LM, leaving behind only user-provided or other non-generated content.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_docgenerator.py:test_clean_output_dir:94e714fd68d6166fc143c7e32663de6f620853f7ad1d323145f10b199c97da7b": "The function `test_clean_output_dir` is designed to test the behavior of a hypothetical `clean_output_dir` function from the `docgenerator` module. It uses a temporary directory provided by the `tmp_path` fixture to simulate an output directory for documentation files.\n\nHere's what the function does:\n\n1. Creates a subdirectory named \"docs\" within the temporary path.\n2. Writes three files to this \"docs\" directory:\n- `old.html`: A file with content indicating it was generated by DocGen-LM.\n- `custom.html`: A simple HTML file without any specific content.\n- `style.css`: A CSS file containing a basic style rule.\n\n3. Calls the `clean_output_dir` function, passing the path to the \"docs\" directory as a string.\n\n4. Asserts that:\n- The `old.html` file no longer exists in the \"docs\" directory.\n- Both `custom.html` and `style.css` files still exist in the \"docs\" directory.\n\nThis test ensures that the `clean_output_dir` function correctly identifies and removes files that were generated by DocGen-LM, while preserving other user-created or necessary files.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_docgenerator.py:test_clean_output_dir:e3d7bf5c51f9ba73876ac9765fb9398421d6f140bc5d7fd4b4de06418bed9778": "The function `test_clean_output_dir` is a unit test that verifies the behavior of the `clean_output_dir` function from the `docgenerator` module. It creates a temporary directory, simulates the presence of various files within it (including HTML and CSS files), and then calls the `clean_output_dir` function to clean the output directory.\n\nThe test asserts that after calling `clean_output_dir`, only the custom HTML file and the asset CSS file remain in the output directory. The generated HTML file is deleted, demonstrating that the function correctly identifies and removes files that are not essential for documentation purposes.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_docgenerator.py:test_generates_class_and_function_summaries:8488628c8139a8c0b2e2fd8e192c8038ad9af4c2fa80e191303db21749646144": "The function `test_generates_class_and_function_summaries` is a unit test for a documentation generation tool. It sets up a temporary project directory with a Python file containing a class and a function, mocks an LLM client to return predefined summaries for different code elements, runs the main documentation generation function, and asserts that the generated HTML files contain the expected summaries for the class and function.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_docgenerator.py:test_generates_class_and_function_summaries:92cbe4b30edeb9fb61e881b20fe19a5daac6b82d8a60291058729752e7b16015": "The function `test_generates_class_and_function_summaries` tests the generation of summaries for classes and functions within a Python project. It creates a temporary project directory with a Python file containing a class `Foo` and a function `bar`. The function then uses a mock LLM client to simulate responses for summarizing the module, project, class, improved class documentation, function, and improved function documentation. After running the main function with the specified project and output directories, it asserts that the generated HTML files contain the expected summaries for the class and function.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_docgenerator.py:test_generates_class_and_function_summaries:c8cec783c68e4646d0155acd2108bc50325c3c381af13f686b9047266711af03": "The function `test_generates_class_and_function_summaries` is a unit test for the `main` function of the DocGen-LM tool. It creates a temporary project directory with a Python module containing a class and a function, sets up a mock LLM client to return predefined summaries, runs the main function with specified input and output directories, and asserts that the generated HTML files contain the expected summaries for the class and function.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_docgenerator.py:test_generates_class_and_function_summaries:e28e83243652766af797dabfff62ffc80658671e5165d602960a2b5af5ffa66a": "This function tests the generation of summaries for classes and functions within a Python project using the DocGen-LM tool. It creates a temporary project directory with a sample Python module containing a class and a function, sets up a mock LLM client to simulate responses, runs the main function with specified input and output directories, and verifies that the generated HTML files contain the improved summaries for the class and function.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_docgenerator.py:test_handles_class_without_docstring:1f9d5280b47eda9cd09946516b5ad0ec44ed8fb36dda131387cae2614c5d9c46": "The function `test_handles_class_without_docstring` tests the handling of a Python class without a docstring by creating a temporary project directory, writing a Python file with an empty class definition, and then running the documentation generation process. It uses a mock LLM client to simulate responses for module, project, and class summaries. The function asserts that the generated HTML output contains the expected class summary.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_docgenerator.py:test_handles_class_without_docstring:60e97ca2f0f195b91a3034086ab50448a68e7bd2f1a6d502acebf80306e3c207": "This function tests the handling of a Python class without a docstring. It creates a temporary project directory with a single module containing an empty class named `Foo`. The function then calls the `main` function with this project directory and specifies an output directory for the documentation. A mock LLM client is used to simulate responses during the summarization process, ensuring that the class summary is generated correctly. Finally, it asserts that the generated HTML file contains the expected class summary text.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_docgenerator.py:test_handles_class_without_docstring:d05c078e160e88f79049ef4ea4dff3f43c56ab778a50e9707d8aaba1d2aefb5e": "The function `test_handles_class_without_docstring` is a unit test for the `main` function of the DocGen-LM tool. It checks that the tool correctly handles Python classes without docstrings by creating a temporary project directory, writing a Python script with an empty class definition to it, and then invoking the `main` function with the path to this project directory and an output directory specified.\n\nThe test uses a mock LLM client to simulate responses from the language model. It asserts that the `ping` method of the mock client returns `True`, indicating successful connection. The `summarize` method is mocked to return predefined summaries for the module, project, and class.\n\nAfter running the `main` function, the test reads the generated HTML file from the output directory and checks that it contains the expected summary for the class.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_docgenerator.py:test_handles_class_without_docstring:ebecee9a744d4a52210472491b29b642cf1b4a8ebecf82ece02f45c2e70f8c07": "This function `test_handles_class_without_docstring` tests the handling of a Python class without a docstring by a documentation generator tool. It sets up a temporary project directory with a single Python file containing an empty class definition. The function then calls the main documentation generation function with this project directory and an output directory specified by `tmp_path`. Using a mock LLM client, it configures the mock to return predefined summaries for different parts of the project (module, project, and class). After running the main function, it asserts that the returned status code is 0, indicating successful execution. Finally, it checks that the generated HTML file contains the expected summary for the class.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_docgenerator.py:test_project_summary_is_sanitized:0b92fc4eb119590b64d191ca5848a259e966e7e9aae4e4f68a9a5ca005df6d28": "The function `test_project_summary_is_sanitized` is a unit test that verifies the sanitization of project summaries generated by the DocGen-LM tool. It creates a temporary project directory with a Python module, initializes an output directory, and mocks the LLMClient to simulate responses during the documentation generation process. The test asserts that the generated HTML does not contain certain phrases (\"You can run this\" is absent) while ensuring that the summary for the project includes \"project summary\". It also checks that the LLMClient's `summarize` method was called with the correct context type, indicating it processed a project-level summary.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_docgenerator.py:test_project_summary_is_sanitized:6903efd7c76245ca2bbced37be5207c98be2b961446ef03a6b5347ed6f7f373b": "This function `test_project_summary_is_sanitized` tests the sanitization of project summaries generated by a documentation tool. It creates a temporary project directory with a Python module, simulates an LLM client to provide summaries, and checks that the output HTML does not contain unwanted text while ensuring that the project summary is included in the calls to the LLM client's `summarize` method.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_docgenerator.py:test_project_summary_is_sanitized:8f17519064eb5a080d3a215a1048de9b9872dbf1ff5498a99c6076d2bf78354e": "This function `test_project_summary_is_sanitized` tests the functionality of generating documentation summaries for a Python project using the `docgenerator.LLMClient`. It creates a temporary project directory with a simple Python module, sets up a mock LLM client to simulate responses, and runs the main function with specified input and output directories. The test asserts that the generated HTML documentation does not contain certain phrases (\"You can run this\" and \"It prints.\") while ensuring that it contains expected content (\"project summary\").",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_docgenerator.py:test_project_summary_is_sanitized:f345a134da5d197d08404b35a9409d24fe4c21349c4c04c5d8331b20d44737a0": "The function `test_project_summary_is_sanitized` is a unit test for the `main` function of the DocGen-LM tool. It creates a temporary project directory with a Python module, sets up a mock LLM client to simulate responses, and then runs the `main` function with specified output and project directories. The test asserts that the generated HTML documentation does not contain certain phrases (\"You can run this\" is absent) while ensuring another phrase (\"It prints.\" is present).",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_docgenerator.py:test_readme_summary_used:2fe7ac1e233aa228ac0693c3e60c8004ae2f0abfadddd76f6517d651af422167": "This function `test_readme_summary_used` tests the functionality of generating documentation, specifically focusing on summarizing a README file. It creates a temporary project directory with a Python module and a README file. The function then uses a mock LLM client to simulate responses during the documentation generation process. After running the main function with the specified project and output directories, it asserts that the README summary is included in the generated HTML documentation and that the LLM client was called with the appropriate parameters for summarizing the README content.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_docgenerator.py:test_readme_summary_used:427e0fa54b86c5229aa5edd06eea841f9ff83d079b707d204bba2d9ec066d145": "The function `test_readme_summary_used` tests the documentation generation process, specifically focusing on summarizing a README file. It creates a temporary project directory with a Python module and a README file. The function then uses a mock LLM client to simulate the summarization of the README content. After running the main documentation generation function, it checks if the output HTML file contains the summary of the README and if the LLM client was called with the correct parameters.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_docgenerator.py:test_readme_summary_used:510ee4550de3341c9399c8d3fd76e334bf964f95e78e13e625c558e3ab8a81b4": "This function `test_readme_summary_used` tests the functionality of a documentation generation tool. It creates a temporary project directory with a Python module and a README file. The function then calls the main function of the documentation generator tool with the path to this project directory and an output directory for the generated documentation.\n\nA mock LLMClient is used to simulate the language model server. The mock client's `summarize` method is configured to return specific summaries for different parts of the project, including the README file. The function asserts that the main function returns 0, indicating success.\n\nAfter running the main function, the function reads the generated HTML documentation from the output directory and checks if the summary of the README file is included in the HTML. It also verifies that the LLM client was called with the correct arguments to summarize the README file.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_docgenerator.py:test_readme_summary_used:edfabda531c84d59f8779d3ce0f9872d475fa61d7b4d82cf25f3a1f9ae2ca407": "This function tests the generation of a README summary using the `docgenerator` tool. It creates a temporary project directory with a Python module and a README file, then invokes the main function with specified output and input directories. The test uses a mock LLM client to simulate responses for different types of summaries (module, readme, project, function). After running the main function, it checks if the README summary is included in the generated HTML documentation and verifies that the LLM client was called with the correct arguments for summarizing the README.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_docgenerator.py:test_skips_invalid_python_file:06f5d7f049e5cdd970fb455b1fdd5e049c3535811f9ff8f84d78387dbb24a0a6": "This function tests the behavior of the `main` function when encountering a Python file with invalid syntax. It creates a temporary project directory containing a file named `bad.py` with leading zeros in an integer literal, which is syntactically incorrect. The function then calls the `main` function with this project directory and an output directory specified by `tmp_path`. It uses a mock LLM client to simulate successful responses from the language model server. After running the main function, it asserts that only the index page (`index.html`) is generated in the output directory, while no documentation is created for the invalid file (`bad.py`).",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_docgenerator.py:test_skips_invalid_python_file:21aff16e40c629bea23ce01976316010d26e6c19b5b5b82ccd59b3ac967ca49f": "The function `test_skips_invalid_python_file` tests the behavior of the `main` function when encountering a Python file with invalid syntax. It creates a temporary project directory containing an invalid Python file (`bad.py`) and specifies an output directory for documentation. The function uses a mock LLM client to simulate successful pinging and summarization. When the `main` function is called, it processes the project directory and generates documentation. The test asserts that only the index page is generated, while the documentation for the invalid file is skipped.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_docgenerator.py:test_skips_invalid_python_file:2f7be13a05fb9c1ac374f2131c4c716b6a27065f8a7ce6edea5b90b90db474d5": "This function tests the behavior of a documentation generator when encountering an invalid Python file. It creates a temporary project directory with a file containing invalid syntax due to a leading zero in a number. The function then calls the `main` function with this project directory and specifies an output directory for the generated documentation. A mock LLM client is used to simulate responses, ensuring that only the index page is generated and no documentation is created for the invalid file.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_docgenerator.py:test_skips_invalid_python_file:71df0f53ee7c6700cfb72c4bf0775afb6704dc5167f8bef105b749b53f69d975": "This function tests the behavior of the `main` function when encountering a Python file with invalid syntax. It creates a temporary project directory, writes an invalid Python file (`bad.py`) to it, and then calls the `main` function with this project directory and an output directory specified by `tmp_path`. The `main` function is mocked to return a successful ping and a summary for valid files. The test asserts that the `main` function returns 0 (indicating success) and that only the index page (`index.html`) is generated in the output directory, while the invalid file (`bad.py`) does not result in any documentation being generated.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_docgenerator.py:test_skips_non_utf8_file:2a3feaf71e8854895212d42079ca4e2ec62970c04d243f69293943033785b527": "The function `test_skips_non_utf8_file` tests the behavior of a documentation generator when encountering a non-UTF-8 encoded file. It sets up a temporary project directory with a non-UTF-8 encoded Python file and an output directory for documentation. The function then mocks an LLM client to simulate successful pinging and summarization. When running the main function with the specified directories, it asserts that the return value is 0 (indicating success) and that only an `index.html` file is generated in the output directory, while a non-UTF-8 encoded file (`bad.py`) does not result in a corresponding documentation file (`bad.html`).",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_docgenerator.py:test_skips_non_utf8_file:633b5997a47a203462f48f0df4d1a5b2bdd0497e091cc7876c18c636b56a157e": "This function tests the behavior of the `main` function when encountering non-UTF8 encoded files in a project directory. It creates a temporary project directory with a non-UTF8 file and an output directory. The `main` function is called with the project directory and output directory as arguments, using a mock LLM client that returns a successful ping and a summary for valid files. The test asserts that the return value of `main` is 0 (indicating success) and that only an \"index.html\" file is created in the output directory, while no \"bad.html\" file is generated for the non-UTF8 file.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_docgenerator.py:test_skips_non_utf8_file:9c213b94f5b8c61d713df9fc5cb14c82bd27b64bc68ee1f7ddc2753e390532a1": "This function tests the behavior of the `main` function when encountering a non-UTF-8 encoded Python file. It sets up a temporary project directory with a non-UTF-8 encoded file and an output directory. The function uses a mock LLM client to simulate successful pinging and summarization. When running the `main` function, it asserts that the return value is 0 (indicating success) and checks that an index.html file exists in the output directory while no bad.html file is created due to the non-UTF-8 encoded file being skipped.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_docgenerator.py:test_skips_non_utf8_file:ae916fca2af4915fd64398b2f588b7cb2abdba16e32ff00a9596e61b6b75ccdc": "The function `test_skips_non_utf8_file` tests the behavior of a documentation generation tool when encountering non-UTF-8 encoded files. It creates a temporary project directory with a non-UTF-8 file and an output directory for documentation. The function then mocks an LLM client to simulate successful ping and summary responses. When running the main function with the specified directories, it asserts that the return code is 0 (indicating success). Additionally, it checks that only an `index.html` file is generated in the output directory, while a non-UTF-8 file (`bad.py`) does not produce a corresponding documentation file.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_docgenerator.py:test_structured_chunker_keeps_functions_atomic:a5258511054ac8dc1ecc91efc6efac01e36829f77a3e7834edd36d4c3f44bcda": "This function tests the `test_structured_chunker_keeps_functions_atomic` method. It creates a Python file with two functions, `f1` and `f2`, each containing multiple lines of code. The function then parses this file using the `parse_python_file` function from the `parser_python.py` module.\n\nA tokenizer is obtained using `_get_tokenizer` from `docgenerator.py`, and a cache object is created using `ResponseCache` from `cache.py`. The function uses a mock for `_summarize` to return \"sum\" when called. It calculates the budget based on the length of the encoded source code and overhead, then calls `_summarize_module_chunked` with this budget.\n\nThe test asserts that the number of chunks is equal to the number of functions (2) and that each chunk corresponds to one of the function sources in the parsed file.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_docgenerator.py:test_structured_chunker_splits_large_class_by_method:7ea3fa731e829a3ddd56cd2ccf3927a8a9c3637c1a1c9eddcf3376dc20c0aa2c": "This function tests the `_summarize_module_chunked` function from the `docgenerator.py` module. It creates a temporary Python file with a class containing two methods, each with multiple lines of code. The function then parses this file and uses a mock to simulate summarization calls. It asserts that the number of chunks created matches the number of methods in the class and that the content of the chunks corresponds to the source code of the methods.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_docgenerator.py:test_subclass_methods_are_summarized:1926267f2924549c96e6e24b9154b8152adac3aa39f24eb7d1e161ddf336bd44": "The function `test_subclass_methods_are_summarized` tests the summarization of methods within subclasses. It creates a temporary project directory with a Python file containing a class `A` that has a subclass `B`, which includes a method `m`. The function then uses mock objects to simulate an LLM client and its summary generation process. It asserts that the method `m` of the subclass `B` is included in the calls to the mock summary function, indicating that it was successfully summarized.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_docgenerator.py:test_summarize_chunked_splits_long_text:6960379b6a1fe5e2e3e1ff633c05b12be827ff573c3494317d13a876c110a022": "This function tests the `_summarize_chunked` method from the `docgenerator.py` module. It sets up a temporary cache, creates a tokenizer, and defines a long text string. The function then calls `_summarize_chunked` with mock values for the client and cache, specifying parameters such as key prefix, prompt type, tokenizer, max context tokens, and chunk token budget. It asserts that the `_summarize` method is called more than once, indicating that the input text was split into chunks for summarization.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_docgenerator.py:test_summarize_chunked_splits_long_text:883d241c912d33ca614401000d51e87ec6225021ed03961c45aab56007425f24": "This function `test_summarize_chunked_splits_long_text` tests the `_summarize_chunked` function from the `docgenerator` module. It sets up a temporary directory for caching, creates a tokenizer, and defines a long text string to be summarized. The function uses a mock object for the language model client and asserts that the `_summarize` method is called more than once during the execution of `_summarize_chunked`, indicating that the text was chunked and processed multiple times due to its length.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_docgenerator_subclasses.py:0fe483931aa675c30839a1cb49e71a4b7aaf03932ad088e2784291adc1ede8f0:0fe483931aa675c30839a1cb49e71a4b7aaf03932ad088e2784291adc1ede8f0": "This module defines a test function `test_subclass_docs_and_method_summary` that uses the `unittest.mock.patch` decorator to mock an `LLMClient` class from the `docgenerator` module. The function creates a temporary project directory with a Python file containing a nested class and method, then calls the `main` function from the `docgenerator` module with the path to this project directory and an output directory for documentation.\n\nThe test asserts that the return value of the `main` function is 0 (indicating success), and checks that the generated HTML documentation contains summaries for both the class \"B\" and its method \"m\".",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_docgenerator_subclasses.py:test_subclass_docs_and_method_summary:d540a9225d7e95072f422c026b3ab13dd80d1cb6ecac0ecd370248bedc3d06b8": "This function, `test_subclass_docs_and_method_summary`, tests the generation of documentation for a subclass and its methods using an LLM client. It creates a temporary project directory with a Python file containing a class `A` that has a nested class `B` with a method `m`. The function then calls the `main` function from the `docgenerator.py` module, passing the project directory and output directory as arguments. It uses a mock LLM client to simulate responses for summarization tasks. After running the main function, it reads the generated HTML file and checks that it contains summaries for the subclass `B` and its method `m`.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_html_writer.py:435035d70f3c463453fb6feec19e75d7921faf4f58fadafb10f4f3dc0ad1f010": "The module defines two functions: `test_write_index` and `test_write_module_page`. These functions are used to test the functionality of writing HTML index and module pages, respectively. The tests use a temporary path (`tmp_path`) to create HTML files and then validate their content through assertions.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_html_writer.py:435035d70f3c463453fb6feec19e75d7921faf4f58fadafb10f4f3dc0ad1f010:435035d70f3c463453fb6feec19e75d7921faf4f58fadafb10f4f3dc0ad1f010": "The module defines two functions for generating HTML documentation: `write_index` and `write_module_page`. It also includes tests to verify the correctness of these functions. The `write_index` function generates an index page with links to module pages, while the `write_module_page` function generates a detailed page for a specific module, including classes, methods, and functions.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_html_writer.py:a1aeaba6fec7461888e75a51cdc213dbeb5d81eaf06741979e1d495b15314fc9:a1aeaba6fec7461888e75a51cdc213dbeb5d81eaf06741979e1d495b15314fc9": "The module defines functions to write HTML documentation for projects and modules. It includes:\n\n- `write_index`: Generates an index page with links to module pages.\n- `write_module_page`: Generates a detailed HTML page for a single module, including classes, functions, and subfunctions/subclasses.\n\nEach function takes parameters such as file paths, module data, and links, and writes the corresponding HTML content. The tests validate that the generated HTML contains expected elements like headers, summaries, source code snippets, and navigation links.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_html_writer.py:test_subclass_rendering:abc8a45a6659831165ce78ac2bdcfcffaa2bcdc2ce1715b8c90fe47b99dd7c8a": "The function `test_subclass_rendering` is designed to test the rendering of subclass information in HTML documentation. It uses a temporary directory specified by `tmp_path` to create and write a module page for a Python module named \"mod\". The module contains a class `A` with a subclass `B`. Class `B` has a method `m`.\n\nThe function then reads the generated HTML file located at `tmp_path / \"mod.html\"` and asserts that certain elements are present in the HTML content:\n- It checks if the `<details>` tag is included, indicating expandable sections.\n- It verifies that the text \"Class: B\" is present, confirming that subclass information is rendered.\n- It ensures that the method signature `def m(self)` is included.\n- Finally, it asserts that there is exactly one occurrence of the `<pre><code>` tags, which are used for code snippets in HTML.\n\nThis test case is part of a larger suite to validate the functionality of the documentation generation process, specifically focusing on how subclasses and their methods are rendered in the output.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_html_writer.py:test_subfunction_rendering:39bb68b3751383bf93460c7385b7dd9f5c0ab58f21e2d49a7d420545e650235d": "This function tests the rendering of subfunctions in a module's documentation. It creates a mock module data dictionary with an outer function containing an inner subfunction. The `write_module_page` function is called to generate HTML documentation for this module, which includes expanding sections for subfunctions. The test asserts that the generated HTML contains details tags for the subfunction and that both the outer and inner functions are source-highlighted in `<pre><code>` blocks.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_html_writer.py:test_write_index:35f4d6d5f4a0bd0eebf56c1e9b9a0214316046fcf4ffb9bd55fff7adda443244": "This function `test_write_index` is designed to test the `write_index` function, which generates an HTML index file for a project's documentation. The test uses a temporary path (`tmp_path`) to create and validate the output.\n\nThe function takes several parameters:\n- `links`: A list of tuples containing module names and their corresponding HTML file paths.\n- `summaries`: A dictionary where keys are module names and values are their summaries.\n- Additional parameters for the project title and other metadata.\n\nThe test performs the following steps:\n1. Calls `write_index` with the provided parameters.\n2. Reads the generated `index.html` file from the temporary path.\n3. Asserts that the HTML file contains specific tags and content, such as the generator comment, project summary, module links, summaries, and headings.\n\nThe assertions ensure that the HTML output is correctly formatted and includes all necessary elements for a documentation index page.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_html_writer.py:test_write_index:4a655add547d989469db7fbb93f15d12ec890f4fa1d5a611daad2a253cac644c": "The function `test_write_index` tests the `write_index` function from the `html_writer.py` module. It creates a temporary directory, defines links and summaries for modules, calls `write_index`, and then checks if the generated HTML file contains the expected content. The test ensures that the index page is correctly formatted with project summary, module links, and summaries, while handling special characters in module names appropriately.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_html_writer.py:test_write_index:8212791c2bdc2eb5cf565f916c5b7c3ae260ccfc48b2e0148d4979dc3c699949": "The function `test_write_index` is designed to test the generation of an HTML index file for a project's documentation. It takes a temporary path as input, along with links and summaries for different modules. The function writes the index file at the specified path using the provided data. After writing, it reads the generated HTML file and asserts various conditions to ensure that the file is correctly formatted and contains the expected content, including proper encoding, project summary, module links, summaries, and HTML structure elements like headers and lists.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_html_writer.py:test_write_index:bba97818f2be9884b7d0addb225bb867f4344c763dc789f494e64a521c07b915": "This function `test_write_index` is designed to test the `write_index` function, which generates an HTML index file for a project's documentation. It uses a temporary directory provided by `tmp_path` as the output location.\n\nThe function sets up a list of links and summaries for modules, then calls `write_index` with these parameters along with a title for the project documentation. After generating the index file, it reads its content and asserts various conditions to ensure the HTML is correctly formatted:\n\n1. The first line should contain a comment indicating the file was generated by DocGen-LM.\n2. The project title should be included in the HTML.\n3. Both module links (`module1.html` and `module2.html`) should appear twice in the HTML.\n4. Module names with special characters (e.g., `<`, `&`) should be correctly escaped in the HTML.\n5. There should be an `<h2>` heading for \"Modules\".\n6. An unordered list (`<ul>`) containing module links and summaries should exist.\n7. Only one summary should be rendered, even if multiple modules have summaries.\n8. The title of the project documentation should appear as an `<h1>` heading.\n\nThis test ensures that the `write_index` function correctly generates a structured HTML index file for project documentation.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_html_writer.py:test_write_module_page:0596c95132f6e604f19b07443a56d352b2ffabd83fd635e96fa43b79b6df29da": "The function `test_write_module_page` is a unit test for the `write_module_page` function. It verifies that the generated HTML page for a module contains the expected content, including links, module summary, class details, method summaries, and function summaries. The test uses a temporary directory to create the output file and checks various aspects of the HTML content to ensure it matches the expected structure and data from the `module_data` dictionary.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_html_writer.py:test_write_module_page:0680ef06655102579edd439e542010a881b6e3df7b50c1ff1a433aaaa4d43ca1": "This function `test_write_module_page` is a unit test for the `write_module_page` function. It checks if the generated HTML page for a module contains the expected content based on the provided module data and links.\n\nThe function takes a temporary path as an argument, which is used to create the output file. It defines sample data for a module, including its name, summary, classes, and functions. The `write_module_page` function is then called with this data to generate the HTML page.\n\nThe test asserts that the generated HTML file starts with a comment indicating it was generated by DocGen-LM. It checks for specific links, headers, summaries, method signatures, and source code snippets in the HTML output. Additionally, it verifies that the number of occurrences of certain elements (like other module links and pre/code blocks) matches the expected count.\n\nThis test ensures that the `write_module_page` function correctly processes and formats the input data into a structured HTML page for documentation purposes.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_html_writer.py:test_write_module_page:d5511c2236a07277e853219eb89edab0b5de4f586e204574eea739e33fd9b3d2": "The function `test_write_module_page` tests the generation of an HTML page for a Python module using the `write_module_page` function. It creates a temporary directory, defines module data including classes and functions, and calls `write_module_page` to generate the HTML file. The test then reads the generated HTML file and asserts that it contains expected elements such as links, module summaries, class definitions, method signatures, and function declarations.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_html_writer.py:test_write_module_page:e41253db448dbd41e891553c23a4d290c9a8cb913db728b5bd409e0ea4bdc0f3": "The `test_write_module_page` function tests the `write_module_page` function by creating a mock module data dictionary and a temporary path. It then calls `write_module_page` with these inputs and reads the generated HTML file from the temporary path. The function asserts that the HTML content includes specific tags, summaries, class names, method signatures, and function definitions, ensuring that the documentation is correctly formatted and contains all necessary information.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_integration.py:e977cba7f0b91bc157a456c9b49e68be4ca45d263b578fcfe7b372ef54d38deb": "The module defines two test functions for a documentation generator. The first function, `test_docgenerator_generates_html`, tests the generation of HTML files from Python and MATLAB files in a project directory using a mock LLMClient. It verifies that the output directory contains index.html, hello.html, and util.html files, and that the hello.html file includes a summary.\n\nThe second function, `test_static_copied_from_any_cwd`, tests the copying of static files (e.g., style.css) from any current working directory to the output directory. It uses a mock LLMClient and changes the current working directory to the project directory before running the main function. The test asserts that the static file is copied to the output directory.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_integration.py:e977cba7f0b91bc157a456c9b49e68be4ca45d263b578fcfe7b372ef54d38deb:e977cba7f0b91bc157a456c9b49e68be4ca45d263b578fcfe7b372ef54d38deb": "This module contains two test functions for a documentation generator. The first function, `test_docgenerator_generates_html`, tests the generation of HTML files from Python and MATLAB files in a project directory using a mock LLMClient. It verifies that the output directory contains the expected HTML files and that the generated HTML includes a summary.\n\nThe second function, `test_static_copied_from_any_cwd`, tests the copying of static files (e.g., CSS) to the output directory regardless of the current working directory. It uses a mock LLMClient and asserts that the static file is present in the output directory after running the main function with a specified project directory and output directory.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_integration.py:test_docgenerator_generates_html:03875c35fa437dd478befa9311c86ff4d75b2a0edb7505fd6d220ae8e13520a7": "This function `test_docgenerator_generates_html` tests the functionality of a documentation generator for Python and MATLAB projects. It creates a temporary project directory with simple source files (`hello.py` and `util.m`) and an output directory. The function uses a mock LLM client to simulate responses during the summarization process. After running the main function, it verifies that HTML files are generated in the output directory and checks if the expected summary text is present in one of the HTML files.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_integration.py:test_docgenerator_generates_html:0ca9584e117cb5adcf2d9484a42f46693208f4be7ef3c24f99c49bf73bcff726": "This function `test_docgenerator_generates_html` is a unit test for the `main` function of the DocGen-LM tool. It sets up a temporary project directory containing a simple Python file and a MATLAB file, then calls the `main` function with this project directory and an output directory specified by `tmp_path`. The test uses a mock LLMClient to simulate responses from the language model server. After running the main function, it asserts that the return value is 0, indicating success. Finally, it checks that HTML files have been created for each file in the project directory and that the summary text generated by the language model is included in the HTML file for one of the files.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_integration.py:test_docgenerator_generates_html:4a906f759339e992dc8a216815e8b426d4dfe389bf4eabd32be8907645ac5498": "This function, `test_docgenerator_generates_html`, tests the functionality of the `docgenerator` module by simulating a project directory containing both Python and MATLAB files. It uses a mock LLM client to provide predefined responses for summarization tasks. The function asserts that the `main` function from the `docgenerator` module executes successfully, generates HTML output in the specified output directory, and includes summaries in the generated HTML files.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_integration.py:test_docgenerator_generates_html:4da5b85f61ad7c2ef177ce6634118257fec505b4797b0243a033e43f0df80bd4": "The function `test_docgenerator_generates_html` is a unit test for the `main` function of the DocGen-LM tool. It sets up a temporary project directory containing a simple Python file and a simple MATLAB file. The test then mocks an LLM client to return a predefined summary when called. After running the `main` function with the specified project and output directories, it asserts that the function returns 0 (indicating success). Finally, it checks that HTML files for the project directory, Python file, and MATLAB file have been created in the output directory and that the expected summary is present in the generated HTML for the Python file.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_integration.py:test_static_copied_from_any_cwd:1fff726b10c62faca698268594bd9e1f1c4c785fb83a4c9ccc4eb3a6315a63b1": "The function `test_static_copied_from_any_cwd` tests the behavior of a documentation generation tool when run from any working directory. It creates a temporary project directory with a Python module, sets up an output directory, and mocks the LLM client to return a predefined summary. The function changes the current working directory to the temporary path, runs the main function with the specified project and output directories, and asserts that the return value is 0 (indicating success). It also checks that a static file (`style.css`) exists in the output directory's `static` folder after running the test.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_integration.py:test_static_copied_from_any_cwd:2851fb35644b8217be7ad3292c97fd09c19f181325a9466702c08c5178206c47": "This function tests the generation of static documentation from a Python project using a mock LLM client. It creates a temporary project directory with a single Python module, sets up an output directory for the documentation, and configures a mock LLM client to return a predefined summary. The function then changes the current working directory to the temporary project directory, runs the main function with the specified project and output directories, and asserts that the return value is 0 (indicating success). Finally, it checks that the `style.css` file exists in the output directory's static folder.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_integration.py:test_static_copied_from_any_cwd:5c0d90b216470ad732e5b5a0f507db074023c66edc4e6ac0b988a875a583345e": "The function `test_static_copied_from_any_cwd` is a unit test for the `main` function in the `docgenerator` module. It sets up a temporary project directory with a Python script, configures an mock LLM client to return a predefined summary, and then calls the `main` function with the project directory and output documentation directory as arguments. The test asserts that the `main` function returns 0 (indicating success) and that a static CSS file is created in the output directory.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_integration.py:test_static_copied_from_any_cwd:6cbc9117dc48ecc200dd18ae27b1157250eb5ba22daf136737600adb905693fc": "This function `test_static_copied_from_any_cwd` is a test case that verifies the functionality of generating static HTML documentation for a Python project. It sets up a temporary directory, creates a simple Python module within it, and then uses a mock LLM client to simulate responses during the documentation generation process. The function changes the current working directory to the temporary path, invokes the `main` function with the specified project and output directories, and asserts that the return value is 0, indicating successful execution. Additionally, it checks that a static CSS file has been generated in the output directory.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_llm_client.py:ff8a0c5e5d3895b53e3efd3ac0badb2dca6ba723a90e55d61bc0a3a56cb89180": "This module defines a test suite for an `LLMClient` class. It includes tests for the `ping`, `summarize`, and `sanitize_summary` methods of the client. The tests use mocking to simulate HTTP requests and responses, as well as the `pytest` framework for assertions.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_llm_client.py:ff8a0c5e5d3895b53e3efd3ac0badb2dca6ba723a90e55d61bc0a3a56cb89180:ff8a0c5e5d3895b53e3efd3ac0badb2dca6ba723a90e55d61bc0a3a56cb89180": "This module defines a set of tests for an `LLMClient` class, which interacts with a language model API. The tests cover the following functionalities:\n\n1. **Ping Method**: Verifies that the `ping` method successfully checks connectivity to the API by making a GET request and handling potential exceptions.\n\n2. **Summarize Method**:\n- Tests retry logic for the `summarize` method when it encounters request exceptions.\n- Validates that the method returns the correct summary text after retries.\n- Checks if the method raises a `RuntimeError` with a specific message when encountering an HTTP error or JSON parsing issues.\n\n3. **Sanitize Summary Function**: Ensures that the `sanitize_summary` function filters out certain phrases from the input text before returning it as the summary.\n\n4. **Prompt Templates**: Verifies that the `summarize` method uses different prompt templates based on the type of content (e.g., class, function, readme) when making POST requests to the API.\n\nThe tests utilize mocking and patching to simulate API responses and behavior during testing.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_llm_client.py:test_ping_failure:0adba929125f613bc9f52ce9a7239c04677374d860d256ca90a92c010163cfe3": "This function tests the `ping` method of an `LLMClient` class when a connection failure occurs. It uses the `patch` context manager from the `unittest.mock` module to mock the `requests.get` call, causing it to raise a `RequestException`. The function asserts that calling `client.ping()` raises a `ConnectionError`, indicating a successful test of the client's ability to handle connection failures gracefully.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_llm_client.py:test_ping_failure:7c1b5eff95b0d5bb619740ec91213bc566d2df1c0d8a31cc16472425ae30e3b4": "This function tests the `ping` method of an `LLMClient` class when a connection failure occurs. It uses the `patch` function from the `unittest.mock` module to mock the `requests.get` method, causing it to raise a `RequestException`. The test asserts that calling `client.ping()` raises a `ConnectionError`.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_llm_client.py:test_ping_failure:ec6b8d49b17b8bccbc923671aab8eb496985619bddd8a779e3426ca6b6567f8c": "This function tests the `ping` method of an `LLMClient` class. It uses a mock to simulate a request exception when attempting to connect to a fake server URL, and asserts that a `ConnectionError` is raised as a result.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_llm_client.py:test_ping_failure:f6cc14fe5c78c80a168baf63d34dc9944e3a5a0cfc597cece8a21ac42f4cba70": "This function tests the `ping` method of an `LLMClient` class when a connection failure occurs. It uses the `patch` context manager from the `unittest.mock` module to simulate a request exception, raising a `ConnectionError` when attempting to ping the specified URL. The test asserts that the `ping` method raises a `ConnectionError` under these conditions.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_llm_client.py:test_ping_success:25ef3261cce546ee32e6b13915b28601b7c0b47eb2860a8cd496c94c6d63cf4e": "The function `test_ping_success` tests the `ping` method of an `LLMClient` class. It uses a mock object for the response and the `requests.get` function to simulate a successful HTTP GET request. The test asserts that the `ping` method returns `True`, indicating a successful connection, and verifies that the `get` function was called with the correct URL and timeout value, as well as that `raise_for_status` was called on the mock response object.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_llm_client.py:test_ping_success:9f00eb2af6a14b170a85ba907d3c253d3d76e24b798029ec3ef0f25da7ebbc9b": "The function `test_ping_success` tests the `ping` method of an `LLMClient` class. It creates a mock response object that simulates a successful HTTP GET request. The `raise_for_status` method of the mock response is also mocked to ensure it does not raise any exceptions. The function then asserts that calling `client.ping()` returns `True`, indicating a successful ping. It also verifies that the `requests.get` method was called once with the specified URL and a timeout of 2.0 seconds, and that `raise_for_status` was called on the mock response object to confirm it did not raise an exception during the test.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_llm_client.py:test_ping_success:d5de1e58ea7513ef6393af2da827a33270f7878f247e61a0ee2420e17a18b292": "The function `test_ping_success` tests the `ping` method of an `LLMClient` class. It creates a mock response that simulates a successful HTTP GET request and asserts that the `ping` method returns `True`. The test also verifies that the `get` method from the `requests` module is called once with the specified URL and timeout, and that the `raise_for_status` method of the mock response is called to ensure there are no HTTP errors.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_llm_client.py:test_ping_success:d836e83ced1e09ade74faf540cc1e45f52ac66720d2b322eb806808f2e55e930": "This function tests the `ping` method of an `LLMClient` class by mocking its HTTP GET request and response. It asserts that the `ping` method returns `True`, indicating a successful connection, and verifies that the `raise_for_status` method of the mock response is called once to ensure no exceptions are raised during the request.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_llm_client.py:test_prompt_varies_by_type:40cba2ae3655623d7966a65f7250f0a80cd4612dcb9b2e7207b02bf6154bafa7": "The function `test_prompt_varies_by_type` tests the behavior of an `LLMClient` when summarizing code with different types (class and function). It uses a mock response from an LLM server to simulate API calls. The test asserts that the prompts generated for class and function summaries are different, as expected based on predefined prompt templates.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_llm_client.py:test_prompt_varies_by_type:565b7fb1ef90dd208de2eefaee241f0b95565a7c1bfbd1f30bb5c334499b75b9": "This function tests that the prompts generated for summarizing classes and functions vary by type. It uses a mock response from an LLM client to simulate API calls. The function asserts that the prompts for classes and functions are different, ensuring that the system correctly distinguishes between class and function docstrings when generating summaries.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_llm_client.py:test_prompt_varies_by_type:73d3ae3b0d0c0353615b4969a559d282736ba35544523ce371a1db2c390ca325": "This function tests the `summarize` method of an `LLMClient` class. It uses a mock response to simulate an HTTP request made by the client when summarizing text based on its type (either \"class\" or \"function\"). The function asserts that the prompts sent for class and function summaries are different, as they use distinct prompt templates from a predefined dictionary (`PROMPT_TEMPLATES`).",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_llm_client.py:test_prompt_varies_by_type:7500b7446e409be4a02298bb234f62fdbce53050de12941d5dea17f6f1467f56": "This function tests that the prompt sent to an LLM client varies by the type of code being summarized. It uses a mock response from the LLM client and patches the `requests.post` method to simulate different responses based on the type of code (\"class\" or \"function\"). The function then asserts that the prompts for classes and functions are generated using specific templates and that they are not equal, ensuring that the prompt varies by type.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_llm_client.py:test_readme_prompt_template_used:638fa0fe8d25f349acfc21dc210642fa91a2b398156cd56f2b44f2d15a021e96": "This function tests whether the `LLMClient` class correctly uses a predefined prompt template for generating summaries of README files. It creates a mock response from an LLM server and patches the `requests.post` method to return this mock response. The function then calls the `summarize` method of the `LLMClient` instance with \"foo\" as the input text and \"readme\" as the document type. Finally, it asserts that the content of the second message in the JSON payload matches the expected prompt template formatted with the input text \"foo\".",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_llm_client.py:test_readme_prompt_template_used:840445f9fb4a95ffe19f3c9aeaf4da8c1c4bf98e77f366d138beee6694ea7274": "This function tests whether the `LLMClient` class correctly uses a predefined prompt template for generating summaries of README files. It creates an instance of `LLMClient`, mocks its response to simulate an LLM server, and then calls the `summarize` method with \"foo\" as the text and \"readme\" as the context type. The function asserts that the generated prompt matches the expected format based on the `PROMPT_TEMPLATES[\"readme\"]` template, replacing `{text}` with \"foo\".",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_llm_client.py:test_readme_prompt_template_used:a10d6e9ee99f782b81301aff65cc06776a4473f13d0bfda6bd20b00c92d11421": "The function `test_readme_prompt_template_used` tests whether the README prompt template is correctly used when summarizing text using an LLM client. It creates a mock response from an LLM client, simulates a POST request to the client with a sample text and \"readme\" type, and asserts that the generated prompt matches the expected format of the README template applied to the input text.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_llm_client.py:test_readme_prompt_template_used:c2b39b4aaf43b44ad7119794aa9794bbdb198fd916811e749f7e313ec9ad166e": "This function tests whether the README prompt template is used correctly when summarizing text. It creates an instance of `LLMClient`, sets up a mock response with a predefined JSON structure, and patches the `requests.post` method to return this mock response. The function then calls `client.summarize` with \"foo\" as the input text and \"readme\" as the context. After the call, it asserts that the second message content in the POST request matches the expected README prompt template formatted with the input text \"foo\".",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_llm_client.py:test_sanitize_summary_filters_phrases:392d1bd238caadb4edc6df2b118f88692dd3e7741e2c69af7dc436519b2cf8a6": "The function `test_sanitize_summary_filters_phrases` tests the `sanitize_summary` function to ensure it filters out unwanted phrases from the input text. It asserts that the sanitized summary contains only relevant information, excluding phrases like \"You can run this,\" \"Note that it is simple,\" and \"This script does nothing.\"",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_llm_client.py:test_sanitize_summary_filters_phrases:40876aa917d31217fc2e6997a6557f58742ab073547a5d473c766af44a4bd2eb": "",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_llm_client.py:test_sanitize_summary_filters_phrases:8eff3e7c4b28a2c9823c49b3fb229c6d6177bc365d38cfebd64bbe3b9c782c06": "The function `test_sanitize_summary_filters_phrases` tests the `sanitize_summary` function to ensure it correctly filters out specific phrases from the input text. The test checks if the summary is sanitized by removing phrases like \"You can run this.\", \"Note that it is simple.\", and \"This script does nothing.\"",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_llm_client.py:test_sanitize_summary_filters_phrases:b14c8865cc7dabb1d662a1de9c0491b70a31164f1ac46ee77324659b15a9cae6": "The function `test_sanitize_summary_filters_phrases` tests the `sanitize_summary` function to ensure it filters out unwanted phrases from a given text. It asserts that after sanitization, the text only contains relevant information without disclaimers or introductory phrases.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_llm_client.py:test_summarize_raises_runtime_error_with_message:097c3eec709ebcf82cfb8c837c92d06535655850637ba7d6a4afe0d73f4b76dd": "The function `test_summarize_raises_runtime_error_with_message` tests the behavior of the `summarize` method in the `LLMClient` class when an HTTP error occurs. It uses a mock response to simulate an exception being raised during the request, and then asserts that a `RuntimeError` is raised with the message \"server exploded\".",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_llm_client.py:test_summarize_raises_runtime_error_with_message:09f3b2b5f8b46b1f9ffd675a84ea9c4e981080e2f5b609f68718434a0becc366": "This function tests the `summarize` method of an `LLMClient` class. It mocks a response from an HTTP request that raises an `HTTPError` and then a `ValueError`. The function asserts that when calling `client.summarize` with specific arguments, it raises a `RuntimeError` with the message \"server exploded\".",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_llm_client.py:test_summarize_raises_runtime_error_with_message:218096eced558fc61693b31325dfeb4f14eebe3f8be97338728a8707bac66126": "The function `test_summarize_raises_runtime_error_with_message` tests the behavior of the `summarize` method in the `LLMClient` class when an HTTP error occurs. It uses a mock response to simulate an HTTP error and a JSON parsing error, then asserts that a `RuntimeError` is raised with the message \"server exploded\".",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_llm_client.py:test_summarize_raises_runtime_error_with_message:4da5ffecb0764c8f10a5ac436941479d26a562ba06d281f341bb7b1e09c1c693": "The function `test_summarize_raises_runtime_error_with_message` tests the behavior of the `summarize` method in the `LLMClient` class when an HTTP error occurs. It uses a mock response to simulate a server error, raising an `HTTPError` and then a `ValueError`. The test asserts that a `RuntimeError` is raised with the message \"server exploded\" when calling the `summarize` method.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_llm_client.py:test_summarize_retries_and_returns_summary:5d63e8222e377c9f0750cf78104247868e0bafb3d9f65a6a43edca57ca0ddb3a": "The function `test_summarize_retries_and_returns_summary` tests the `summarize` method of an `LLMClient` class. It mocks a request that initially fails with an exception and then succeeds, returning a JSON response containing a summary message. The test verifies that the client retries the request once after a 1-second delay, correctly handles the successful response, and constructs the prompt using a template for the specified module type.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_llm_client.py:test_summarize_retries_and_returns_summary:6e8798ea54fa42db378914304b300a92215748be8e233bd11ed71fa5503200d5": "The function `test_summarize_retries_and_returns_summary` tests the `summarize` method of an `LLMClient` class. It mocks an HTTP client to simulate a request failure and then a successful response. The test verifies that the `summarize` method retries on failure, waits for 1 second between attempts, and returns the summary from the successful response.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_llm_client.py:test_summarize_retries_and_returns_summary:6f46376f58bb9900a899e3b7cf29b111c9e10698a8ee41272572622241d9fe2f": "This function tests the `summarize` method of an `LLMClient` class. It mocks a request to a language model server that initially fails with a `RequestException`, but then succeeds with a mock response containing a summary. The test verifies that the client retries the request once, waits for 1 second between attempts, and sends the correct prompt using a predefined template.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_llm_client.py:test_summarize_retries_and_returns_summary:c39e5c677c06ad95b15fde10e643deff1dc79ba3351b5b8f4746bfe402f12f51": "This function tests the `summarize` method of an `LLMClient` class. It mocks a request to an LLM server that initially fails with a `RequestException`, but then succeeds and returns a JSON response containing a summary. The test asserts that the client retries the request once, waits for 1 second between attempts, and sends the correct prompt formatted by `PROMPT_TEMPLATES[\"module\"]`.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_parser_matlab.py:d371df41f01bfadecc63c5f1bddb7b77eb2309a17405bffe247ca4a3e17973bd": "This module defines two test functions to verify the functionality of a MATLAB file parser. The `test_parse_simple_matlab` function checks if the parser correctly extracts the header and a single function from a simple MATLAB file. The `test_parse_multiple_functions` function ensures that the parser can handle multiple functions within a single MATLAB file, including checking the names and arguments of each function.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_parser_matlab.py:d371df41f01bfadecc63c5f1bddb7b77eb2309a17405bffe247ca4a3e17973bd:d371df41f01bfadecc63c5f1bddb7b77eb2309a17405bffe247ca4a3e17973bd": "The module defines two test functions to verify the functionality of a `parse_matlab_file` function. The tests create temporary MATLAB files with different contents, parse them using the `parse_matlab_file` function, and then check if the parsed results match expected values for headers and function details.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_parser_matlab.py:test_parse_multiple_functions:49d1a5549a10a103f256f44e2b6bce39f63461ee2268ee119652a21cb67b4fb4": "This function tests the `parse_matlab_file` function from the `parser_matlab.py` module. It creates a temporary MATLAB file with multiple functions and uses the parser to extract information about these functions. The test checks that the parser correctly identifies two functions, their names, arguments, and outputs.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_parser_matlab.py:test_parse_multiple_functions:51f108ceac12d81b821ca91bffa89e301bde6eca87220ea226b8cf6f620537a0": "This function, `test_parse_multiple_functions`, is designed to test the functionality of parsing multiple MATLAB functions from a single file. It uses a temporary directory provided by `tmp_path` to create a MATLAB script file named \"multi.m\" containing two functions: `compute` and `square`. The function then calls `parse_matlab_file` with the path to this file as an argument.\n\nThe test asserts that:\n1. The header of the parsed file is empty.\n2. There are exactly two functions in the parsed result.\n3. The names of the functions are \"compute\" and \"square\".\n4. The arguments for the `compute` function are \"a\" and \"b\".\n5. The argument for the `square` function is \"x\".\n\nThis ensures that the parsing logic correctly identifies and extracts multiple functions from a MATLAB script file.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_parser_matlab.py:test_parse_multiple_functions:546d4c9ff4186a34f8dfaf6b43ac6cda5c9e93c640d8c1bdbc38364b5c484916": "This function `test_parse_multiple_functions` tests the `parse_matlab_file` function by providing it with a MATLAB file containing multiple functions. It asserts that the parsed output includes two functions named \"compute\" and \"square\", with the correct arguments for each function. The test ensures that the parser correctly identifies and extracts function names and argument lists from the source code.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_parser_matlab.py:test_parse_multiple_functions:e768f5ee467154e27c7e274dcd344afb710bf9410089000ed95a200a58f97a1b": "This function, `test_parse_multiple_functions`, is designed to test the functionality of parsing multiple MATLAB functions from a single file. It uses a temporary directory (`tmp_path`) to create a MATLAB source file named \"multi.m\" containing two functions: `compute` and `square`. The function then calls `parse_matlab_file` with the path to this file as an argument.\n\nThe test asserts that:\n1. The header of the parsed file is empty.\n2. There are exactly two functions parsed from the file.\n3. The names of the parsed functions match those in the source code: \"compute\" and \"square\".\n4. The arguments for each function are correctly identified: `compute` takes two arguments (`a`, `b`) and `square` takes one argument (`x`).",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_parser_matlab.py:test_parse_simple_matlab:1948f2c1de38c55e739fb66dc6afeb12d6295007729168f676d0c47d1eeddb8d": "This function, `test_parse_simple_matlab`, is a unit test designed to verify the functionality of parsing a simple MATLAB file. It uses a temporary directory provided by `tmp_path` to create a sample MATLAB script named \"sample.m\" with a header and a single function definition.\n\nThe function then calls `parse_matlab_file` with the path to this temporary file as an argument. The expected output is checked against assertions:\n- The header of the MATLAB file should match the provided text.\n- There should be exactly one function defined in the file.\n- The name of the function should be \"add\".\n- The function should have two arguments: \"x\" and \"y\".",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_parser_matlab.py:test_parse_simple_matlab:28110f309534166a131e20f7235d20e96e2d53bc54ee9e01d1a67649d173f944": "This function `test_parse_simple_matlab` tests the parsing of a simple MATLAB file. It creates a temporary file with MATLAB code, then uses the `parse_matlab_file` function to parse this file. The test checks that the header is correctly extracted and that one function named \"add\" with arguments \"x\" and \"y\" is identified in the parsed result.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_parser_matlab.py:test_parse_simple_matlab:313030d6485b0cd78055342faa39bef598fccf4cc180467b708e667951386cfb": "This function, `test_parse_simple_matlab`, tests the parsing of a simple MATLAB file. It creates a temporary file with MATLAB code and uses the `parse_matlab_file` function to parse it. The test checks that the header is correctly extracted and that there is one function defined in the file. It further verifies that the function's name, arguments, and body are accurately parsed.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_parser_matlab.py:test_parse_simple_matlab:8e0f0714301ac6b7c3112b3037564da92f720f870ddfeb7843784c4d5f97f599": "The function `test_parse_simple_matlab` tests the parsing of a simple MATLAB file. It creates a temporary file with MATLAB code, calls the `parse_matlab_file` function to parse it, and asserts that the parsed header and functions match the expected values.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_parser_python.py:c9cd0efc42de5b3182fc1d64d54b126c109e111267c90017988eccb169d8325a": "This module contains tests for parsing Python files using a custom `parse_python_file` function. It includes two test functions:\n\n1. `test_parse_simple_module`: Tests parsing a simple Python module with a class and a function, verifying the extracted docstrings, signatures, and source code.\n\n2. `test_parse_complex_signature`: Tests parsing a function with complex signature parameters, ensuring the correct handling of positional-only arguments (`/`), keyword-only arguments (`*`), default values, and variable-length keyword arguments (`**kw`).",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_parser_python.py:c9cd0efc42de5b3182fc1d64d54b126c109e111267c90017988eccb169d8325a:c9cd0efc42de5b3182fc1d64d54b126c109e111267c90017988eccb169d8325a": "The module defines two test functions to verify the functionality of a `parse_python_file` function. The first function, `test_parse_simple_module`, checks if the parser correctly identifies and extracts the docstrings, class definitions, method signatures, and source code from a simple Python module. The second function, `test_parse_complex_signature`, tests the parser's ability to handle complex function signatures with positional-only parameters, keyword-only parameters, and variable-length arguments.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_parser_python.py:d7f39a3936992256bbbb9f92b040faec5e9e7fa9e116ca4d5c586c4a2f8ee1c6:d7f39a3936992256bbbb9f92b040faec5e9e7fa9e116ca4d5c586c4a2f8ee1c6": "This module contains tests for a Python parser function named `parse_python_file`. The tests create temporary Python files with different structures, such as simple modules, complex signatures, and nested classes/functions. They then parse these files using the `parse_python_file` function and assert that the parsed results match the expected structure and content of the source code.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_parser_python.py:test_parse_complex_signature:4075bad754b2016198cae4bcd1a17e0b1dffa440061f734a9b35f4ad3ebbce41": "This function `test_parse_complex_signature` tests the parsing of a Python file containing a complex function signature. It creates a temporary Python file with a specific docstring and function definition, then parses this file using the `parse_python_file` function. The test checks that the parsed function's signature is correctly extracted and matches the expected string. Additionally, it verifies that the function's docstring is accurately captured and included in the parsed result.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_parser_python.py:test_parse_complex_signature:6fed29868f9bf83ef99c4871946bf8921394457dbe2eb727116ba72d0bb07b57": "This function tests the parsing of a complex Python function signature. It creates a temporary file with a sample Python code snippet containing a function with various parameters and a docstring. The function then parses this file using `parse_python_file` from `parser_python.py`. It asserts that the parsed signature matches the expected value, and that the docstring is correctly extracted and included in the parsed result.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_parser_python.py:test_parse_complex_signature:a9bb94e28d63bb354349b450135d1dadcf36d0b294abcbf131869111d16275d5": "The `test_parse_complex_signature` function tests the parsing of a Python file containing a complex function signature. It creates a temporary Python file with the specified content, parses it using the `parse_python_file` function, and then checks if the parsed signature, docstring, and source code are correctly extracted. The test asserts that the function signature matches the expected format, the docstring is accurately captured, and the docstring is present in the original source code.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_parser_python.py:test_parse_complex_signature:e2ec5447fd25f0b578e907b415b74c1e4c36e83b90d930675c2d21483798a9a6": "The `test_parse_complex_signature` function tests the parsing of a Python function with complex signature. It creates a temporary file with a Python script containing a function definition, then uses the `parse_python_file` function to parse the file and extract information about the function. The test asserts that the parsed signature matches the expected format, the docstring is correctly extracted, and the docstring appears in the source code.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_parser_python.py:test_parse_nested_structures:6e3edbe5e22a52d9683954abd77dbe7eeb7a6658131a3abc8a74161b5617cb52": "This function tests the parsing of nested structures in Python files using the `parse_python_file` function. It creates a temporary file with nested functions and classes, then asserts that the parsed result correctly identifies the outer function, its inner function, and the nested class within the outer class. The test checks for the presence of specific names and source code snippets in the parsed results.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_parser_python.py:test_parse_simple_module:363c2ce5cf69917f2d6db01a5702d4b118f6c4eee02b9ff60000154f6d121a20": "This function `test_parse_simple_module` tests the parsing of a simple Python module. It creates a temporary file with sample Python code, then uses the `parse_python_file` function to parse this file. The test checks that the parsed results include the correct module docstring, class name and docstring, method signature and docstring, function signature and returns information, as well as snippets of the source code for verification.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_parser_python.py:test_parse_simple_module:4933ac2659efba6b09b3ebcc8f09c29e48296ceb014ee28e832b766e30ff705a": "This function `test_parse_simple_module` tests the parsing of a Python module using the `parse_python_file` function. It creates a temporary file with a simple Python module containing a class and a function, then asserts that the parsed result matches the expected structure and content. The test checks for the correctness of the module docstring, class name, class docstring, method signature, method docstring, and function details.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_parser_python.py:test_parse_simple_module:940dfa7f76179b37a9ae48cacf098d95893698d867679f89144fbe1eae1b8de1": "This function tests the `parse_python_file` function from the `parser_python.py` module. It creates a temporary Python file with a simple module containing one class and one function, each with docstrings. The function then parses this file and asserts that the parsed results match the expected values for the module, class, method, and function.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_parser_python.py:test_parse_simple_module:b17a468bb48fd8fa6a1fa9e1bc5a05989bd4ffb196725a2c92e002074abe8696": "This function `test_parse_simple_module` tests the parsing of a Python module using a hypothetical `parse_python_file` function. It creates a temporary file with a simple Python script containing a module docstring, a class with a method, and a standalone function. The test then asserts that the parsed result correctly identifies the module docstring, class name, class docstring, method signature, method docstring, and source code of both the class method and the function.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_reviewer.py:83233473a3bb44ee0c5e26502caa85ad29205c84af0e40280e3fd12a3f730505": "This module defines several functions and tests for a code review tool. It includes:\n\n1. `_make_module`: Creates a temporary module page with specified summary and methods.\n2. `test_assistant_phrasing_detected`: Tests if the assistant phrasing is detected and reported.\n3. `test_contradiction_detected`: Tests if contradictions in method definitions are detected and reported.\n4. `test_hallucination_detected`: Tests if hallucinations (incorrect claims about code features) are detected and reported.\n5. `test_autofix_removes_phrasing`: Tests if autofix removes specified phrases from the generated HTML.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_reviewer.py:83233473a3bb44ee0c5e26502caa85ad29205c84af0e40280e3fd12a3f730505:83233473a3bb44ee0c5e26502caa85ad29205c84af0e40280e3fd12a3f730505": "This module defines several functions and tests for a code review tool. It includes:\n\n1. `_make_module`: A helper function that creates a temporary module with specified summary and methods, then writes an HTML page for it.\n2. `test_assistant_phrasing_detected`: Tests if the reviewer detects phrasing indicative of assistant-generated content.\n3. `test_contradiction_detected`: Tests if the reviewer detects contradictions in the module's documentation.\n4. `test_hallucination_detected`: Tests if the reviewer detects statements that are not supported by the code.\n5. `test_autofix_removes_phrasing`: Tests if the autofix option removes phrasing from the HTML output.\n\nThe tests use a temporary directory to create test modules and capture the output of the reviewer function to verify its behavior.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_reviewer.py:_make_module:133ea9a0b71fc87fc52c415018664a19b3a6bbefe1b94b967e73d97a3d6c696a": "This function `_make_module` creates a mock module page for testing purposes. It takes three parameters: `tmp_path`, which is the temporary directory path where the module page will be created; `summary`, which is a string summarizing the module; and `methods`, an optional list of methods to include in the \"Foo\" class within the module.\n\nThe function initializes a dictionary `data` with keys for the module's name, summary, classes, and functions. If `methods` is provided, it adds a \"Foo\" class to the `classes` list with the specified methods.\n\nIt then calls `write_module_page`, passing the temporary path, the data dictionary, and a tuple specifying the index file and its name. Finally, it returns the path to the generated module page (`mod.html`).",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_reviewer.py:_make_module:46ead35bfc6df08c5ab8bb6d3c4a7814309a97d81366ac26b219ff9627141305": "This function `_make_module` creates a temporary module page for documentation purposes. It takes three parameters: `tmp_path`, which is the path to the temporary directory where the module page will be created; `summary`, which is a string summarizing the module; and `methods`, an optional parameter that specifies methods for a class within the module.\n\nThe function initializes a dictionary `data` with keys for the module's name, summary, classes, and functions. If `methods` are provided, it adds a class named \"Foo\" to the `classes` list in the `data` dictionary. The class has an empty docstring, summary, and the methods specified by the user.\n\nThe function then calls `write_module_page`, passing the path to the temporary directory, the `data` dictionary, and a list of tuples specifying the index file name and its corresponding HTML file name. Finally, it returns the path to the generated module page (`tmp_path / \"mod.html\"`).",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_reviewer.py:_make_module:5f724050de30c857ed3374c1f6961aa5d137ae50cc9641f95bbb59211f58613e": "This function `_make_module` creates a temporary module page for documentation purposes. It takes three parameters: `tmp_path`, which is the path to a temporary directory where the module page will be created; `summary`, which is a string summarizing the module; and `methods`, which is an optional list of methods to include in the module's class. The function constructs a dictionary `data` with keys for the module name, summary, classes, and functions. If `methods` is provided, it adds a class named \"Foo\" with no docstring or summary but includes the specified methods. It then writes this data to an HTML file using the `write_module_page` function, specifying that the index page should be named \"index.html\". Finally, it returns the path to the generated module HTML file (`tmp_path / \"mod.html\"`).",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_reviewer.py:_make_module:e72c9d938f64f7282bcbd027488ce1b37f35793561925f0eee3fba3e6c27570f": "This function `_make_module` generates a temporary HTML module page for documentation purposes. It takes three parameters: `tmp_path`, which is the path to a temporary directory where the module page will be created; `summary`, which is a string summarizing the module; and `methods`, an optional list of dictionaries representing methods within the module.\n\nThe function constructs a dictionary `data` with keys for the module's name, summary, classes, and functions. If `methods` are provided, it adds a class named \"Foo\" to the `classes` list in `data`. Each method is represented as a dictionary with keys for the method's name, docstring, summary, and methods (which recursively includes nested methods).\n\nThe function then calls `write_module_page`, passing the temporary path, the constructed `data`, and a tuple specifying the index file and its name. Finally, it returns the path to the generated module HTML file (`mod.html`).",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_reviewer.py:test_assistant_phrasing_detected:393cd6476becd40a49a10df2e0dd4726dbe3aa5f5720e69e0bbcd258a8977d1b": "The function `test_assistant_phrasing_detected` is designed to test for the detection of assistant phrasing in generated documentation. It creates a temporary module with specific content, runs the main function of the project with the path to this module, and captures the output. The function then asserts that the string \"[ASSISTANT]\" is present in the captured output, indicating that assistant phrasing has been detected. Additionally, it checks that \"mod.html\" is also in the output, suggesting that documentation for the module has been generated successfully.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_reviewer.py:test_assistant_phrasing_detected:cec97957ed0359b8182669af49034d5f259b126be9e70ea55e3e54eecda156cb": "This function `test_assistant_phrasing_detected` is designed to test the detection of assistant phrasing in generated documentation. It creates a temporary module with a specific phrase, runs the main function with the path to this module, and checks if the output contains the \"[ASSISTANT]\" tag and mentions \"mod.html\", indicating that the assistant phrasing was detected and processed correctly during the documentation generation.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_reviewer.py:test_assistant_phrasing_detected:e96ad5f595f9af93bc94a0fcf9d490739b4708e1e044164bbde60051a67c551c": "This function `test_assistant_phrasing_detected` is designed to test if the assistant phrasing \"[ASSISTANT]\" is detected and included in the output when generating documentation for a Python module. It creates a temporary directory, generates a simple Python module with the specified content, runs the main function of the DocGen-LM tool on this directory, captures the standard output, and asserts that both the assistant phrasing and the generated HTML file name \"mod.html\" are present in the output.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_reviewer.py:test_assistant_phrasing_detected:eaf3975a2aa40a9a09f6eac0477c0d5dd1195707d8590fe3b43a5fd739470f0d": "The function `test_assistant_phrasing_detected` is designed to test the detection of assistant phrasing in generated documentation. It creates a temporary module with a class definition containing an assistant phrase, then runs the main function with the path to this temporary directory. The function captures the standard output and checks if both \"[ASSISTANT]\" and \"mod.html\" are present in the output, indicating that the assistant phrasing was detected and the HTML file for the module was generated.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_reviewer.py:test_autofix_removes_phrasing:011a3e200d1608b4a82f31b8c528626c3989d537f4ef641038e77000c314febd": "This function `test_autofix_removes_phrasing` tests the functionality of an autofix feature within a documentation generation tool. It creates a temporary directory, generates a module with specific phrasing (\"You can call this.\"), and then runs the main function with the `--autofix` option. After execution, it reads the generated HTML file and asserts that the specified phrasing has been removed from the content.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_reviewer.py:test_autofix_removes_phrasing:3a2f149a0c2a52022ec4801522ec36bffa1dc274aa0f2669a879b191807806d8": "The function `test_autofix_removes_phrasing` is a unit test for a tool that processes and summarizes code files, specifically focusing on the removal of certain phrases during the process. It uses a temporary directory (`tmp_path`) to create a module with a specific phrase (\"You can call this.\") in its HTML file. The function then calls the main function of the tool with the path to the temporary directory and an `--autofix` flag. After processing, it reads the modified HTML file and asserts that the phrase \"You can\" has been removed from the content.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_reviewer.py:test_autofix_removes_phrasing:cf4d87f8e538eb482b5bb5fd9a696e43e8b7efe79d1d873727dad329666e994a": "This function tests the `--autofix` option of the DocGen-LM tool. It creates a temporary directory, generates an HTML file with a specific phrase (\"You can call this.\") using the `_make_module` function, and then runs the `main` function with the `--autofix` flag. After running the command, it reads the generated HTML file and asserts that the phrase \"You can\" has been removed from the text.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_reviewer.py:test_autofix_removes_phrasing:f5a80d69fc7536aa5def623efb01071ba9d440c1b1dde4abe22e9d09163dc934": "This function tests the `--autofix` option of a command-line tool. It creates a temporary directory with a Python module containing a docstring with unnecessary phrasing (\"You can call this.\"). The function then runs the main command with the `--autofix` flag, which is expected to remove such phrasing from the documentation. After running the command, it reads the generated HTML file and asserts that the unnecessary phrasing has been removed.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_reviewer.py:test_contradiction_detected:288c16f90d269c6f247cbe3cf5b4d1e378c94a17eee12db5bb54fc7aef97e8fc": "This function tests if a contradiction is detected when no methods are defined in the source code. It creates a module with an empty list of methods and runs the main function with the temporary path as input. The output is captured, and it asserts that the string \"[CONTRADICTION]\" is present in the output.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_reviewer.py:test_contradiction_detected:47a7390274b4b1250eee9ae2a3461129c3d6329d644ea74cc099711c0a4d8b54": "The function `test_contradiction_detected` is a unit test that checks if the system detects and reports contradictions in documentation summaries. It creates a temporary module with no methods defined, runs the main function of the project on this module, and captures the output. The test asserts that the string \"[CONTRADICTION]\" appears in the output, indicating that the system has detected a contradiction.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_reviewer.py:test_contradiction_detected:731b5e7a2eb6fec2ed4218e18238b32875a2224caf9984b044661001a094f0dc": "This function tests if a contradiction is detected during the documentation generation process. It creates a temporary module with no methods, runs the main function with the path to this module, and checks if the output contains the string \"[CONTRADICTION]\".",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_reviewer.py:test_contradiction_detected:a144ffadcad8f01b7fbcf239f6676da2a21ef849b24a9c518692b717adccd256": "This function `test_contradiction_detected` is designed to test the detection of contradictions within documentation generated by a tool. It takes two parameters: `tmp_path`, which is a temporary directory path, and `capsys`, which captures standard output and standard error.\n\nThe function performs the following steps:\n1. Defines a list of methods with details such as name, signature, docstring, and source code.\n2. Creates a module in the specified temporary path using `_make_module` function, passing it the temporary path, a description indicating no methods are defined, and the list of methods.\n3. Calls the `main` function with the string representation of the temporary path as an argument.\n4. Reads the captured standard output and standard error using `capsys.readouterr()`.\n5. Asserts that the string \"[CONTRADICTION]\" is present in the captured output, indicating that a contradiction was detected during documentation generation.\n\nThis test ensures that the tool correctly identifies contradictions in the generated documentation.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_reviewer.py:test_hallucination_detected:0085508b601f492ac00fb255ee188e44618f1945c9491ad3e3c2b0209760230a": "This function tests if a hallucination is detected during the documentation generation process. It creates a temporary module with a specified docstring, runs the main function with the temporary path as an argument, and captures the output using `capsys`. The test asserts that the string \"[HALLUCINATION]\" is present in the captured output, indicating that a hallucination was detected.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_reviewer.py:test_hallucination_detected:1a4ddf8a1c758b4de2121c78dbf2b453740a30617e62afbbc4f4ec799121e61f": "This function tests for the detection of hallucination in generated documentation. It creates a module with a specified description, runs the main function with the temporary path containing the module, captures the output, and asserts that the string \"[HALLUCINATION]\" is present in the output.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_reviewer.py:test_hallucination_detected:6ed8467408887ed666867afec318f767a6de4a7a93e91179a27121df7de51f8d": "This function `test_hallucination_detected` is designed to test for the detection of hallucination in documentation generated by a tool. It takes two parameters: `tmp_path`, which is a temporary directory path, and `capsys`, which captures output from standard streams.\n\nThe function performs the following steps:\n1. Calls `_make_module` with `tmp_path` and a docstring \"Implements tic-tac-toe features\" to create a module in the specified temporary directory.\n2. Executes the main function of the tool with the path of the temporary directory as an argument.\n3. Captures any output generated during the execution using `capsys.readouterr().out`.\n4. Asserts that the string \"[HALLUCINATION]\" is present in the captured output, indicating that a hallucination was detected.\n\nThis test ensures that the tool correctly identifies and reports when documentation contains inaccurate or misleading information.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_reviewer.py:test_hallucination_detected:901455f9651c9761a0e669b0834280e079baf97c5534189a0765b2bb02a25749": "This function `test_hallucination_detected` is designed to test for the detection of hallucinations in documentation generation. It creates a temporary module with a specified docstring, runs the main function with the path to this module, and captures the output. The function asserts that the string \"[HALLUCINATION]\" appears in the captured output, indicating that a hallucination has been detected during the documentation generation process.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_scanner.py:3ec32c624e4312ae44349511245ebc4be1d33ae9233f8c4ba760f4c5f65f37f1": "The module defines a function `scan_directory` from the `scanner` module and tests it with `pytest`. It includes three test functions:\n\n1. `test_scan_directory_ignore_folder`: Creates files in a temporary directory, including an \"ignore_me\" folder. Calls `scan_directory` to get a list of file paths, excluding files in the \"ignore_me\" folder. Asserts that only expected files are included.\n\n2. `test_scan_directory_mixed_file_types`: Creates files with various extensions and nested directories. Calls `scan_directory` without ignoring any folders. Asserts that all non-.git files are included in the result.\n\n3. `test_scan_directory_skips_git_folder`: Creates files, including ones inside a .git folder. Calls `scan_directory` without ignoring any folders. Asserts that the .git folder and its contents are excluded from the result.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_scanner.py:3ec32c624e4312ae44349511245ebc4be1d33ae9233f8c4ba760f4c5f65f37f1:3ec32c624e4312ae44349511245ebc4be1d33ae9233f8c4ba760f4c5f65f37f1": "The module defines a test suite for the `scan_directory` function from the `scanner` module. It uses the `pytest` framework to create temporary directories and files, then tests the `scan_directory` function with various configurations of files and ignore patterns. The tests check that the function correctly identifies Python files, ignores specified folders, and avoids scanning Git-related directories.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_scanner.py:create_files:15664a11085953af50602f93473d2c33b61b24fb010d0cb283be24fe186b234c": "The function `create_files` takes a base directory and a list of file paths relative to the base directory. It creates each specified file, ensuring that any necessary parent directories are also created if they do not already exist. Each file is initialized as an empty string.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_scanner.py:create_files:49f9ddc781a76f1c5411952546719c239b8182520e3d3481423b999894e7723e": "This function `create_files` takes a directory path (`base`) and a list of relative file paths (`files`). It iterates over each relative file path, constructs the full path by appending the relative path to the base directory, creates any necessary parent directories if they do not exist, and then writes an empty string to the file at that path.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_scanner.py:create_files:95e79b8a161373bcb6591ab3b2dbae0c82f95d575ad60383cc2fdd6e2580dcf8": "The `create_files` function takes a base directory and a list of relative file paths as input. It iterates over the list, creating any necessary parent directories for each file using `path.parent.mkdir(parents=True, exist_ok=True)`, and then writes an empty string to each file using `path.write_text(\"\")`.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_scanner.py:create_files:ab51be5c856ea5beff7cca7cac3fd159270c33aca080e6c335f560f75ece3792": "The function `create_files` takes a base directory and a list of file paths relative to the base directory. It creates each file, ensuring that any necessary parent directories are also created if they do not already exist. Each file is initialized as an empty string.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_scanner.py:test_scan_directory_ignore_folder:cd82d14517f8aa7e897e3973a4bdc119363a4e32e7df79271591f5be2bfdb1bd": "This function `test_scan_directory_ignore_folder` tests the `scan_directory` function with a temporary directory containing various files and subdirectories. It specifies that the \"ignore_me\" folder should be ignored during the scan. The test asserts that the resulting set of file paths matches the expected set, excluding the \"ignore_me\" folder and its contents.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_scanner.py:test_scan_directory_ignore_folder:eae2fd8a98acd9b26e78302c2a03facfe690dbb9c3cea71e0d3d870b6e7009a5": "This function `test_scan_directory_ignore_folder` tests the `scan_directory` function from the `scanner.py` module. It creates a temporary directory with various files and subdirectories, including an ignored folder named \"ignore_me\". The function then calls `scan_directory` with the path to the temporary directory and a list containing the name of the folder to ignore. The expected result is a set of file paths excluding those in the ignored folder. The test asserts that the actual result matches the expected set of file paths.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_scanner.py:test_scan_directory_ignore_folder:f82556c17639910eb884ce9154227391114a7e759813a436d69a74f6ac17721b": "This function `test_scan_directory_ignore_folder` is designed to test the functionality of scanning a directory while ignoring specified folders. It uses a temporary path provided by `tmp_path` and creates several files within it, including subdirectories. The function then calls `scan_directory` with the path and a list of directories to ignore (`[\"ignore_me\"]`). The expected result is a set of file paths that should be included in the scan, excluding those in the \"ignore_me\" directory. The test asserts that the actual result matches the expected set of file paths.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_scanner.py:test_scan_directory_ignore_folder:f9bff93b9776de58e4eabe399f75e8d8425da709e68f35dc5fe63134f2d02708": "This function `test_scan_directory_ignore_folder` tests the `scan_directory` function with a temporary directory containing various files and subdirectories. It creates files named \"a.py\", \"b.m\", \"c.txt\", \"sub/d.py\", and \"ignore_me/e.py\". The function is called with the path of the temporary directory and a list containing the name of the folder to ignore, which is \"ignore_me\".\n\nThe expected result is a set of file paths excluding those in the \"ignore_me\" folder. The function returns this set, and the test asserts that it matches the expected set of file paths.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_scanner.py:test_scan_directory_mixed_file_types:550fdaff8e300443378400ba483ef19319baad65d947282a847d4120729c165c": "This function `test_scan_directory_mixed_file_types` is designed to test the functionality of scanning a directory for source files, specifically targeting Python and MATLAB files. It uses a temporary path provided by `tmp_path` fixture from pytest. The function creates a set of files within this temporary directory, including both Python (`one.py`, `four.py`) and MATLAB (`two.m`, `six.m`) files, as well as non-code files like `three.txt` and Markdown files in the nested directory.\n\nThe function then calls `scan_directory` with the path to the temporary directory and an empty list of ignored paths. It asserts that the result from `scan_directory` matches the expected set of file paths, which includes only the Python and MATLAB files, excluding non-code files and those within a nested directory.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_scanner.py:test_scan_directory_mixed_file_types:cd17896a4077911873f4575a9d973ab7fece4f6de7bc95360c6e9656ffe5a129": "This function `test_scan_directory_mixed_file_types` tests the `scan_directory` function from the `scanner.py` module. It creates a temporary directory with files of mixed types (Python, MATLAB, text, and nested directories). The function then calls `scan_directory` on this path and asserts that it returns a set of file paths corresponding to Python and MATLAB files, excluding non-code files like `.txt` and Markdown files in nested directories.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_scanner.py:test_scan_directory_mixed_file_types:cf081395bff8f8ea9a4282136c49f4ff05c7c8c20fef7bc8f781a0676926d966": "This function, `test_scan_directory_mixed_file_types`, is designed to test the functionality of scanning a directory for specific file types. It uses a temporary path (`tmp_path`) provided by the testing framework to create various files with different extensions: `.py` (Python), `.m` (MATLAB), and `.txt`. Additionally, it creates nested directories and files within those directories.\n\nThe function then calls `scan_directory` with the path of the temporary directory and an empty list of file types to scan for. The expected result is a set containing the paths of all Python and MATLAB files found in the directory and its subdirectories, excluding any non-code files like `.txt`. The test asserts that the actual result matches the expected set of file paths.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_scanner.py:test_scan_directory_mixed_file_types:fd963c1eef9d5d243d5c7c75ff72a503fafd31943cc8f70bc656e61f6daa3409": "The function `test_scan_directory_mixed_file_types` is a unit test that verifies the functionality of the `scan_directory` function. It creates a temporary directory with files of various types (Python, MATLAB, text, and Markdown) and subdirectories containing Python and MATLAB files. The test then calls `scan_directory` on the temporary directory path and asserts that it returns a set of file paths corresponding to the Python and MATLAB files, excluding any non-code files or nested directories.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_scanner.py:test_scan_directory_skips_git_folder:6d6bc58bdf365bcecb69de5c4506085fc63cb68154f730482fcd96cc0fdb74b5": "The function `test_scan_directory_skips_git_folder` tests the `scan_directory` function to ensure it skips files and directories within a `.git` folder. It creates a temporary directory with various files, including those inside a `.git` subdirectory, and then scans the directory using `scan_directory`. The test asserts that the path to the \"good.py\" file is included in the scan result, while paths containing \".git\" are excluded.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_scanner.py:test_scan_directory_skips_git_folder:7708578763c0d2daa26bfe88d908f39bf9e5cfad38c280470aa74486a07b1397": "This function tests the `scan_directory` function to ensure it skips files within a `.git` directory. It creates a temporary directory with specified files, including ones inside a `.git` subdirectory. The function scans this directory and asserts that only non-`.git` files are included in the result.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_scanner.py:test_scan_directory_skips_git_folder:cd61382eed73a088aece0ccc3731619d1021e052943947c4935dbc7c8231186e": "This function tests the `scan_directory` function to ensure it skips files and directories within a `.git` folder. It creates a temporary directory with specified files, including those inside a `.git` subdirectory. The `scan_directory` function is then called with the path of this temporary directory. The test asserts that the path to \"good.py\" is included in the result, while paths containing \".git\" are not included.",
  "C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_scanner.py:test_scan_directory_skips_git_folder:e3f93b150eceef085ccc8fa3161122ab2328c23614fe38d556d5f5e7252e9b0d": "This function `test_scan_directory_skips_git_folder` tests the behavior of a directory scanning function when it encounters a `.git` folder. It creates a temporary directory with files, including one inside a `.git` subdirectory, and then scans this directory using a hypothetical `scan_directory` function. The test asserts that the path to the file outside the `.git` folder is included in the scan results, while paths within the `.git` folder are excluded.",
  "PROJECT:69c800eac85fc18b9b869f8d91f185b504aa83cdfd2050e8c2e5dcfc86183ddb": "This codebase implements a suite of tools for processing and summarizing code files, including parsing MATLAB and Python scripts, generating documentation summaries using language models, caching responses, and reviewing code quality. It also includes unit tests to ensure the functionality works as expected.",
  "PROJECT:795e750a9218441a35a4a6105bb8134d8e4f5331269b116de36888e00704ab03": "This codebase implements a system for generating documentation summaries from source code files using language models. It includes modules for parsing different programming languages (Python and MATLAB), summarizing code with an LLM client, caching responses, and reviewing generated documentation for quality. The project also contains unit tests to ensure functionality across various components.",
  "PROJECT:b48fe6d82e049ca5b317603fd942b565c57e7cf7e172bea495a6cff95cfd850b:b48fe6d82e049ca5b317603fd942b565c57e7cf7e172bea495a6cff95cfd850b": "This project consists of several modules for generating documentation from code. The `cache.py` module provides a caching mechanism for responses. The `docgenerator.py` module contains functions to clean output directories, summarize text, and generate summaries for Python and MATLAB files using an LLM client. The `html_writer.py` module handles HTML rendering for the generated documentation. The `llm_client.py` class manages interactions with a language model for summarization tasks. The `parser_matlab.py` and `parser_python.py` modules parse MATLAB and Python files, respectively, extracting function and class definitions. The `reviewer.py` module reviews generated documentation for quality issues such as assistant phrasing, contradictions, and hallucinations. The `scanner.py` module scans directories to find code files. Test modules (`test_cache.py`, `test_docgenerator.py`, etc.) validate the functionality of each component through various test cases.",
  "PROJECT:f0c71832f803289f14093d53721a600d415595a535053b26fe107d6b359fcaa5:f0c71832f803289f14093d53721a600d415595a535053b26fe107d6b359fcaa5": "This project consists of several modules for generating documentation from code files. It includes classes and functions for caching responses, summarizing text using a language model client, parsing MATLAB and Python files, reviewing generated documentation for quality, scanning directories for source files, and testing various components' functionality. The system ensures that summaries are sanitized and handles different types of code structures, including class and function docstrings.",
  "README:129fe29f90956d10d0759a0b3c45c6c15e2b693ae386c807d1fcaded4766fc9f": "DocGen-LM is a tool for generating static HTML documentation for Python and MATLAB projects. It analyzes source files and summarizes them using a local language model (LLM) server, such as LMStudio. The tool provides a command-line interface for specifying the input project directory, output documentation directory, and optional flags for customizing the LLM settings.",
  "README:bf66f4f9c94cf2955b0330b5e4c2886a4bcf1c58c87e21cddf2cd67421f1dff0:bf66f4f9c94cf2955b0330b5e4c2886a4bcf1c58c87e21cddf2cd67421f1dff0": "DocGen-LM is a tool that generates static HTML documentation for Python and MATLAB projects by analyzing source files and summarizing them using a local Large Language Model (LLM). It supports custom LLM servers through the `--llm-url` flag, allowing flexibility in model selection and configuration. The tool automatically ignores directories like `.git` and provides options to customize the output directory and skip specific paths during documentation generation.",
  "README:e4c6be0d9ef4e33e98b4b6858d5b88aef6f78e8625e22967371440690fd23324:e4c6be0d9ef4e33e98b4b6858d5b88aef6f78e8625e22967371440690fd23324": "DocGen-LM is a tool for generating static HTML documentation for Python and MATLAB projects by analyzing source files with a local LLM. It supports nested functions and subclasses, rendering them as expandable sections in the output. The tool uses LMStudio or another compatible local LLM server for processing.",
  "README:f43f4e7af6a0afcd043ca9d5320c977629d769e2d3ffb8ce252fa76846d43ab5": "DocGen-LM is a tool for generating static HTML documentation for Python and MATLAB projects. It analyzes source files and summarizes them using a local Large Language Model (LLM), with support for custom LLM servers via the `llm_client.py` interface. The CLI allows specifying output directories, ignoring certain paths, and selecting specific models or API URLs for the LLM.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\cache.py:ResponseCache:4bf39f0ddf33468e133fc0de74e4b5ffcc04454990de01f6d9556f317e81e88f": "The `ResponseCache` class provides a mechanism for caching and persisting mappings from stable keys to language model responses. It initializes by loading existing data from a specified file path, or creating an empty dictionary if the file does not exist. The class includes methods for generating deterministic keys based on file paths and content, retrieving cached values, storing new key-value pairs, and saving the current state of the cache to disk in JSON format.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\cache.py:ResponseCache:b0db65b7fc8663d3ea2f2fc2a4be17323366b9635a8f294571c914ed7bba5175": "The function `persist_mappings` is designed to store key-value pairs where the keys are stable and the values are responses from a language model.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\cache.py:__init__:1a21d3306d451cd49f9dc73378d482180a8d34d5f272323b26f6017b89c3c3ac": "The `__init__` method initializes a new instance of the `ResponseCache` class. It takes a file path as an argument, which specifies where the cache data is stored or will be stored. The method checks if the specified file exists. If it does, the method attempts to read and parse the JSON content from the file into a dictionary named `_data`. If the file does not exist or contains invalid JSON, `_data` is initialized as an empty dictionary. This setup ensures that the cache can be used immediately after initialization, either by loading existing data or starting with an empty cache.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\cache.py:__init__:779128b39db9bfc883bb83eac4df5df387838664f3655d36abe95ba189fe4325": "Initializes a `ResponseCache` instance with a file path. If the file exists, it reads and parses the JSON content into a dictionary; otherwise, it initializes an empty dictionary for storing cached responses.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\cache.py:__init__:9a33407e758bedb6199330d0d24ef3aad1fe8ca6c9c7eff754a7488485053b75": "The `__init__` method initializes a new instance of the `ResponseCache` class. It takes a file path as an argument and sets it as an attribute. The method checks if the file exists at the specified path. If it does, it attempts to read the file's content, parse it as JSON, and store the resulting dictionary in the `_data` attribute. If the file does not exist or contains invalid JSON, it initializes `_data` as an empty dictionary.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\cache.py:_save:352e3f61aa97a5964d1de76b7c9dca770ef86d650b695e7b2ea90164faf47848": "The `_save` method in the `ResponseCache` class writes the current state of the cache data to a JSON file. It uses the `write_text` method of the file object associated with the cache, converting the dictionary stored in `_data` into a JSON string with an indentation of 2 spaces and sorted keys for readability. The encoding is set to \"utf-8\" to ensure proper handling of text characters.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\cache.py:_save:966f229e00eaaaf99fbb269ea63f43e1844ac67afec1b4da7835388da655f966": "The `_save` method in the `ResponseCache` class writes the cached data to a JSON file. It converts the cached data into a JSON string using `json.dumps`, with an indentation of 2 spaces and sorted keys for better readability. The method then writes this JSON string to the file specified by `self.file`, using UTF-8 encoding.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\cache.py:_save:c2437fbbecd48e718288506d01e71779430996002b7708a9237b5c30f9f2a62d": "The `_save` method of the `ResponseCache` class writes the current state of the cache dictionary to a file. It uses the `write_text` method of the `file` attribute, which is assumed to be an instance of a file-like object that supports writing text. The method converts the cache dictionary to a JSON string using `json.dumps`, with an indentation of 2 spaces and sorted keys for better readability. The encoding used for writing the file is set to \"utf-8\".",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\cache.py:get:1bea43709a604f1045813f87051025a825fb8e0c2ea41ec13e5e7307be47e0b9": "The `get` method in the `ResponseCache` class retrieves the cached value associated with a given key. If the key exists in the cache, it returns the corresponding value; otherwise, it returns `None`.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\cache.py:get:467a3b57f6af2039fe40351446dd97265270e0e3f73ad3aba4327ae564181d25": "The `get` method in the `ResponseCache` class retrieves a cached value associated with a given key. If the key exists in the cache, it returns the corresponding value; otherwise, it returns `None`.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\cache.py:get:5ce37bbd8007f61f1e75378e3a0998bb376635cd48fe748f05990396ca2535b3": "The `get` method in the `ResponseCache` class retrieves a cached value associated with a given key. If the key exists in the cache, it returns the corresponding value; otherwise, it returns `None`.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\cache.py:get:78cfae4fb3e6795225d2f6facd1b59cb944e1e6b1a77c5c9e390f1d9c86d5803": "The `get` method in the `ResponseCache` class retrieves a cached value associated with a given key. If the key exists in the cache, it returns the corresponding value; otherwise, it returns `None`.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\cache.py:make_key:704adf7699b7cc0b1dcef0dc8aa93c1bc6ac628e99ae2d45dd0894bb2c2b39e9": "The `make_key` function generates a deterministic key for a given file path and content. It uses the SHA-256 hashing algorithm to create a unique hash from the file's content, which is then combined with the file path to form a stable identifier. This key can be used as a cache lookup or storage index.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\cache.py:make_key:7644a5989e54adb8acba51a8f11fde71654ca1365b434a6f6ce373424f4484a7": "The `make_key` function generates a deterministic key for a given file path and its content. It uses the SHA-256 hash algorithm to create a unique identifier based on the content, ensuring that the same content always produces the same key. The key is formatted as `{file_path}:{digest}`, combining the file path with the hexadecimal digest of the content.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\cache.py:make_key:a43671ff5ea2c08c0a6333088e313d33257710766171e9f31377741c07dbdce5": "The `make_key` function generates a deterministic key for a given file path and content. It uses SHA-256 hashing to create a unique identifier based on the file path and content, formatted as `{file_path}:{digest}`.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\cache.py:make_key:a9f34de87ee36abb31dd9920fa297be2428b1a77306fcda1cd830af4ba46ccec": "This function `make_key` generates a deterministic key for a given file path and its content. It uses the SHA-256 hash algorithm to create a unique identifier based on the file's content, ensuring that any changes in the content result in a different key. The key is formatted as `{file_path}:{digest}`, where `digest` is the hexadecimal representation of the SHA-256 hash of the content. This key can be used to cache and retrieve summaries for specific files efficiently.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\cache.py:set:0aa97afc83252ec675cd61acb85590795d6238544111a6f27810de07b6c92f64": "The `set` method in the `ResponseCache` class stores a given value under a specified key and persists these changes to disk. It updates an internal dictionary `_data` with the provided key-value pair and then calls the `_save` method to write the updated cache data back to the JSON file.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\cache.py:set:145ccfe7964731f9321ced832d9e98d8249ab5fc1d5458741871fc3a34f7043d": "The `set` method in the `ResponseCache` class stores a value associated with a given key and persists this data to disk. It takes two parameters: `key`, which is a string representing the cache key, and `value`, which is a string representing the data to be stored. The method updates an internal dictionary `_data` with the provided key-value pair and then calls the `_save` method to ensure that the updated data is written to a JSON file on disk.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\cache.py:set:3e8438f1f70c7b62e5fdb4055791321ecc49a6b3fa905e04c2f871ccd4f194eb": "The `set` method in the `ResponseCache` class stores a value associated with a specified key and persists this change to disk. It takes two parameters: `key`, which is a string representing the cache key, and `value`, which is a string representing the data to be stored. The method updates an internal dictionary `_data` with the new key-value pair and then calls `_save()` to write the updated cache to a file on disk in JSON format.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\cache.py:set:a6c370df566ed8322a7a86be3c4938864e15315df994f8984e9ec0bfaffe0dec": "The `set` method stores a value in the cache dictionary using a specified key and persists the updated cache to disk.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\docgenerator.py:_build_function_prompt:0ca4b11c95013ddd9e1ec50ce4dfff70bb7293c0b8c1a73325cdca5db923a635": "This function `_build_function_prompt` constructs a prompt for summarizing a Python function based on its source code. It takes three optional parameters: `source`, `class_name`, and `project_summary`. The function returns a string that includes the following elements:\n\n1. A brief introduction as a documentation generator.\n2. Information about the class to which the function belongs, if provided (`class_name`).\n3. A summary of the class, if provided (`class_summary`).\n4. A summary of the project, if provided (`project_summary`).\n5. Instructions on how to summarize the function based solely on its source code.\n6. The actual source code of the function enclosed in a Python code block.\n\nThe purpose of this prompt is to provide context and instructions to a language model (LLM) server, such as LMStudio, for generating accurate and relevant documentation summaries for the given function.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\docgenerator.py:_build_function_prompt:2ebdb027a8be4e56ab013be74f1757038a48c06fb601d55fd5e238668df222c1": "This function `_build_function_prompt` constructs a prompt for summarizing a Python function based on its source code. It takes three optional parameters: `source`, `class_name`, and `project_summary`. The function returns a multi-line string that serves as the context for the documentation generator to produce a summary of the provided function source code. If `class_name` is provided, it indicates that the function belongs to a specific class. If `class_summary` or `project_summary` are provided, they offer additional context about the class and project, respectively. The prompt includes guidelines on how the summary should be formatted and what information to include.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\docgenerator.py:_build_function_prompt:a13e40bf5c41020137e31f49f34cc0acefa5e18044f48e28fc3ad224456aa66d": "This function `_build_function_prompt` constructs a prompt for summarizing Python source code. It includes context about the class, project, and function itself, ensuring the summary focuses solely on the provided code snippet without additional information or unrelated details. The prompt is designed to be used with a language model to generate accurate summaries of functions within a project's documentation.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\docgenerator.py:_build_function_prompt:d0f23ab55bdefeedf359c9eefb253fc698398c46164fba2dd141fe13718788be": "This function `_build_function_prompt` constructs a prompt for summarizing a given Python function's source code. It takes three optional parameters: `source`, `class_name`, and `project_summary`. The function returns a string that includes the following elements:\n\n1. A brief introduction as a documentation generator.\n2. Information about the class the function belongs to, if provided.\n3. A summary of the class, if available.\n4. A summary of the project, if provided.\n5. Instructions on how to summarize the function based on its source code.\n6. The actual source code of the function enclosed in a code block.\n\nThe purpose of this prompt is to provide context and instructions to an LLM (Large Language Model) for generating a concise and accurate documentation summary of the function.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\docgenerator.py:_chunk_module_by_structure:c5b13f6936798d89493fcb5bd868e65fcece11f0a2f6a5aefeddf44c2038cb82": "This function `_chunk_module_by_structure` processes a dictionary representing a module's parsed structure and divides its content into text chunks based on token size limits. It first extracts the module's docstring and adds it to the blocks if present. Then, it iterates through classes, methods, and functions within the module, adding their source code to the blocks list. The function then processes these blocks to create chunks that do not exceed a specified token size. If a block exceeds the token limit, it is further divided into smaller chunks. Finally, any remaining blocks are added to the chunks list, which is returned as the result.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\docgenerator.py:_get_tokenizer:27b7a29cbaaad42943d6ad7608447bb71e6899b256fc2c12f34d2da5d273b52c": "This function `_get_tokenizer` returns a tokenizer object used for estimating token counts. It first attempts to import and use the `tiktoken` library with the \"cl100k_base\" encoding. If successful, it returns this tokenizer. If an exception occurs (e.g., if the model is unknown), or if `tiktoken` is not available, it falls back to a simple tokenizer that splits text into words and joins them back together for tokenization.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\docgenerator.py:_get_tokenizer:8d15f36ad59403678b4901679d3a0e98950b982fee172e7479f98c273b0f8519": "Returns a tokenizer object for estimating token counts. Uses the `tiktoken` library if installed, otherwise provides a simple tokenizer that splits text into words.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\docgenerator.py:_get_tokenizer:96acfe495f2d9679125ef0dea282e41d630ba374a8595f810e3ee9b310d0582f": "Returns a tokenizer object used for estimating token counts. If the `tiktoken` library is installed, it attempts to use the \"cl100k_base\" encoding. If `tiktoken` is not available, it falls back to using a simple tokenizer that splits text into words and joins them back together.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\docgenerator.py:_rewrite_docstring:08d7982fc5dc95d972838464fdd715426ba5b80fe889ae30c4f7ef30966e3c0f": "The function `_rewrite_docstring` rewrites the docstring of a code item using an LLM client and a response cache. It takes parameters for the file path, item dictionary, optional context such as class name, class summary, and project summary. If no source or docstring is available, it prints a warning. If a docstring exists, it constructs a prompt based on the provided context or default template. The function then generates a cache key using the file path, item name, and combined content of source, class name, class summary, and project summary. It uses this key to fetch or generate a rewritten docstring from the LLM client, sanitizes the result, and updates the item dictionary with the new docstring. If no summary is available, it sets the docstring to \"No summary available.\"",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\docgenerator.py:_rewrite_docstring:2cfa2458cce6f8418e72fc62cafe1550b98e5d81c61f5336beca94399e623e37": "The `_rewrite_docstring` function rewrites the docstring of a code item using an LLM client and a response cache. It takes parameters for the file path, item dictionary, and optional context such as class name, class summary, and project summary. If no source or docstring is provided, it prints a warning. The function constructs a prompt based on the source and optional context, generates a key content string, creates a cache key, and uses the LLM client to summarize the docstring. The result is sanitized and assigned back to the item's docstring field. If no summary is available, it defaults to \"No summary available.\"",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\docgenerator.py:_rewrite_docstring:5610bf338907d2ad0e5e8222bf1596f74a7d2b09c23689459753d2348a60511e": "The function `_rewrite_docstring` takes an LLM client, a response cache, a file path, and a dictionary representing an item (likely a code function or method). It optionally accepts class name, class summary, and project summary. The function checks if the source code or docstring is present; if not, it prints a warning and returns. If context information is provided, it constructs a prompt using `_build_function_prompt`; otherwise, it uses a default `DOC_PROMPT`. A cache key is generated based on the file path, item name, and content. The function then summarizes the docstring using the LLM client and updates the item's docstring with the sanitized result or a default message if no summary is available.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\docgenerator.py:_rewrite_docstring:e341bfe41212c5c0573aa79057f16fb0c26ee39c2de409fec9d23737e22acbc4": "This function `_rewrite_docstring` rewrites the docstring of a code item using an LLM client. It takes parameters for the client, cache, file path, and item dictionary. The function checks if there is source or docstring data; if not, it prints a warning and returns. If there's no docstring but source exists, it returns without changes. Depending on whether class or project summaries are provided, it constructs a prompt using `_build_function_prompt` or `DOC_PROMPT`. It then generates a cache key based on the file path, item name, and relevant content. Using the LLM client, it summarizes the docstring and sanitizes the result before updating the item dictionary with the new docstring. If no summary is available, it sets the docstring to \"No summary available.\"",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\docgenerator.py:_summarize:6552542cf6083d470b9d6b1cd49453950f2ee52b4f29344d79005d5b3fcd1b6f": "The function `_summarize` takes an LLMClient, a ResponseCache, a key, some text, and a prompt type as arguments. It attempts to retrieve a cached summary using the provided key. If a cached summary exists, it returns that; otherwise, it uses the client to generate a new summary for the given text and prompt type, caches this new summary under the specified key, and then returns it.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\docgenerator.py:_summarize:9901ceafb5953d6927e419ff0a8ca2f5d1e5e17529549a0e4fd6eef568e0ad9f": "The function `_summarize` takes an `LLMClient`, a `ResponseCache`, a `key`, a `text`, and a `prompt_type`. It checks if the summary for the given key is cached. If it is, it returns the cached summary. Otherwise, it uses the LLM client to generate a summary of the text based on the prompt type, caches the result using the provided key, and then returns the generated summary.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\docgenerator.py:_summarize_chunked:5a71e679d9cd8d758eb5dd61a6cbe0573d26fdae2505cca0957a6229d66bae0c": "This function `_summarize_chunked` is designed to summarize a given text by chunking it if necessary. It takes several parameters including an LLM client, a response cache, a key prefix, the text to be summarized, a prompt type, a tokenizer, and token budgets for context and chunks.\n\nThe function first determines the available tokens based on the provided maximum context tokens and overhead from system and template prompts. If the encoded length of the text is within this budget, it directly summarizes the text using the `_summarize` function. If not, it splits the text into chunks that fit within the chunk token budget. Each chunk is summarized individually, and then these partial summaries are merged into a single technical summary.\n\nThe merging process involves creating a merge prompt with all partial summaries listed under bullet points. This prompt is then summarized using the `_summarize` function with a specific prompt type for docstrings. Finally, the resulting summary is sanitized before being returned.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\docgenerator.py:_summarize_chunked:69ebe2f3d0fccab616983e6b9dad86d805968a7e36a223d3dcce5dd033fe3069": "The function `_summarize_chunked` takes a language model client, a response cache, a key prefix, text to summarize, a prompt type, a tokenizer, and maximum context tokens as inputs. It summarizes the given text by chunking it if necessary. If the text can fit within the available tokens, it generates a summary using the provided client and cache. If not, it splits the text into chunks, summarizes each chunk separately, merges the partial summaries, and then generates a final technical summary. The function returns the sanitized final summary.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\docgenerator.py:_summarize_chunked:86c7d78d02f8f0828a6575ea8bf2d9b43be5f07d50988e85328d1d723c95fe04": "This function `_summarize_chunked` is designed to summarize a given text by chunking it if necessary. It takes several parameters including an LLM client, a response cache, a key prefix, the text to be summarized, a prompt type, a tokenizer, and maximum context token limits.\n\nThe function first checks if the encoded length of the text exceeds the `max_context_tokens`. If not, it generates a unique key using the provided `key_prefix` and the text itself. It then calls another internal function `_summarize` to generate the summary for this chunk.\n\nIf the text is too long, it chunks the text into smaller parts based on the `chunk_token_budget` and processes each part individually. Each part is summarized separately, and the summaries are stored in a list called `partials`.\n\nAfter summarizing all parts, the function merges these partial summaries into a single string with bullet points. It then constructs a merge prompt to instruct the language model to combine these chunk-level summaries into a single technical summary.\n\nFinally, it generates a unique key for the merge prompt and calls `_summarize` again to produce the final merged summary. The resulting summary is sanitized before being returned.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\docgenerator.py:_summarize_class_recursive:f8969e70be0b2d90ab2a0bb69ed2dedf6d4fd4419a7d046a6ebae26ce7ef955b": "This function recursively summarizes a class and its methods. It first summarizes the methods, then constructs a prompt for summarizing the class itself. Using an LLM client and a response cache, it generates a summary for the class docstring. If the original docstring exists, it rewrites the docstring to include the new summary. The function also recursively processes any subclasses of the current class.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\docgenerator.py:_summarize_methods_recursive:b097a8c2289d9daeb262ad32920966661553aeb7c036f43091b53d3bc8421f6c": "This function recursively summarizes methods within a class and its subclasses. It takes a dictionary representing class data, a file path, an LLM client for summarization, and a response cache. For each method in the class, it generates a summary using the provided client and caches the result. The summary is then assigned to both the \"summary\" and \"docstring\" keys of the method dictionary. If the class has subclasses, the function calls itself recursively to process these subclasses.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\docgenerator.py:_summarize_module_chunked:535d58edc8f0c0dafaec0b98e9a9a8d9dd9335c647073fa8143548cc7bf8d9b2": "This function `_summarize_module_chunked` is designed to summarize a Python or MATLAB module using a language model (LLM) client. It employs a structure-aware chunking approach to handle large modules that exceed the token budget for a single summary. The function uses a cache to store intermediate summaries and avoid redundant requests to the LLM.\n\nHere's a breakdown of the key steps:\n\n1. **Template and Overhead Tokens Calculation**: The function starts by defining a template for summarizing a module and calculating the overhead tokens required for the system prompt and the template itself.\n\n2. **Available Tokens**: It determines how many tokens are available for the actual module text based on the maximum context tokens allowed and the overhead tokens.\n\n3. **Chunking**: If the module text is within the available token limit, it generates a cache key and calls `_summarize` to get a summary. If not, it chunks the module into smaller parts based on structure (functions, classes) and token budget.\n\n4. **Partial Summaries**: For each chunk, it generates a cache key and calls `_summarize` to get partial summaries.\n\n5. **Merge Prompt**: It constructs a merge prompt that combines all partial summaries into a single technical summary.\n\n6. **Final Summary**: The function generates another cache key for the merge prompt and calls `_summarize` to get the final merged summary.\n\n7. **Sanitize Summary**: Finally, it sanitizes the generated summary before returning it.\n\nThe function ensures efficient use of tokens by breaking down large modules into manageable chunks and leveraging a caching mechanism to avoid redundant LLM requests.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\docgenerator.py:chunk_text:6380c1b19b49fcf24f6c619192b5ca1bb3ef6d35a596f0b883b4c672cd1f2977": "This function splits a given text into chunks, each containing approximately `chunk_size_tokens` tokens. It uses a tokenizer to encode the text into tokens and then decodes them back into text for each chunk. The function iterates through the encoded tokens in steps of `chunk_size_tokens`, creating new chunks until all tokens are processed.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\docgenerator.py:chunk_text:cc33b855966db68d1e019d30b40593e4f4eaffa70d1452a49a5a38fa0ec13e37": "The `chunk_text` function splits a given text into smaller chunks based on the specified number of tokens. It takes three parameters: `text`, which is the input string to be split; `tokenizer`, an object used for tokenizing and decoding text; and `chunk_size_tokens`, an integer specifying the approximate size of each chunk in terms of tokens.\n\nThe function first encodes the input text into a list of tokens using the provided tokenizer. It then iterates through these tokens, creating chunks of approximately `chunk_size_tokens` size. Each chunk is decoded back into a string and appended to the `chunks` list. Finally, the function returns the list of text chunks.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\docgenerator.py:chunk_text:eb86b8a744ca928a0ec0a905cd3bbf8b39607ef4bbad02fcc56bd704136f049c": "This function `chunk_text` takes a string `text`, a tokenizer, and an integer `chunk_size_tokens`. It encodes the text into tokens using the provided tokenizer. The function then splits these tokens into chunks of approximately `chunk_size_tokens` each. Each chunk is decoded back into a string and appended to a list of chunks. Finally, the function returns this list of text chunks.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\docgenerator.py:clean_output_dir:00ca72264617e284487fe3d8f35907b5e286d90b8a8c5f1d436b3ea657ba9a60": "The function `clean_output_dir` takes a string representing the path to an output directory and iterates over all files within that directory. If a file has a `.html` extension, it reads the first line of the file. If the first line contains the string \"Generated by DocGen-LM\", the file is deleted. Any exceptions encountered during this process are caught and printed as warnings.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\docgenerator.py:clean_output_dir:e479a3832d54e8cce66d11fad90ea488cad904a33e9c151f94e38031fdc98aee": "The function `clean_output_dir` takes a string representing an output directory path and iterates through all files within that directory. If a file has a `.html` extension, it reads the first line of the file. If the first line contains the string \"Generated by DocGen-LM\", the file is deleted. Any exceptions encountered during this process are caught and printed as warnings.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\docgenerator.py:main:a66543e029f1f3d0ed638b58e2769245a6851b25c87875578a018ce7abc462fa": "The `main` function serves as the entry point for generating HTML documentation using a local language model (LLM). It processes command-line arguments to specify the source directory, output directory, and optional settings. The function initializes an LLM client, sets up tokenization parameters, and creates necessary directories for output.\n\nIt then scans the source directory for Python and MATLAB files, parses them, and generates summaries using the LLM. The summaries are cached to avoid redundant requests. The function also handles project-level documentation from README files and integrates these summaries into the generated documentation.\n\nFinally, it writes the index page and individual module pages with the generated summaries and links, ensuring a comprehensive HTML documentation output.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\docgenerator.py:main:b31cca4d757ee26a41800dfd3fbffd17d92f295dc2c7d9303a966226b5433a2c": "The `main` function serves as the entry point for generating HTML documentation using a local Large Language Model (LLM). It parses command-line arguments to specify the source directory, output directory, ignored paths, LLM URL, and model name. The function initializes an LLM client, verifies its connection, sets up the output directory, and cleans it if necessary. It then scans the source directory for Python and MATLAB files, parses them, and generates summaries using the LLM client. The summaries are cached to avoid redundant requests. After summarizing modules, classes, and functions, the function writes an index page and individual module pages to the output directory.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\html_writer.py:_highlight:0772c8ec2590c055ac0e8f6f915ae239320432960758b5eb81a118bce0a3b4df": "The `_highlight` function takes a string of code and a language identifier as input. It uses the Pygments library to lexically analyze the code based on the specified language (MATLAB or Python) and then formats it into HTML with syntax highlighting. If the language is neither MATLAB nor Python, it defaults to using a generic text lexer. The function returns the highlighted code wrapped in `<pre>` and `<code>` tags for proper display in HTML.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\html_writer.py:_highlight:21581e31bbf2f1f088db0c7805d1196aa95526f1893125f9ec4e833d512508c8": "The function `_highlight` takes a string `code` and a string `language`, and returns the code highlighted in HTML using Pygments. It selects the appropriate lexer based on the language (MATLAB or Python), uses an HTML formatter without classes, and wraps the highlighted code in `<pre><code>` tags.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\html_writer.py:_highlight:dc02d9058bdfd7b9eba548ec04b5604d7c94e806a943808b2a1ed0b3e8ca1513": "The `_highlight` function takes a string `code` and a string `language` as input. It uses the Pygments library to highlight the code based on the specified language. If the language is \"matlab\", it uses the MatlabLexer; if \"python\", it uses the PythonLexer; otherwise, it uses the TextLexer. The highlighted code is then formatted as HTML using HtmlFormatter with no classes and nowrap option enabled. The function returns the highlighted code wrapped in `<pre><code>` tags for proper display in HTML documents.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\html_writer.py:_highlight:e94ef778e4433e7449eda0eb3889f01b8525e1f88f79538aa0d8ea63ea377ac0": "The `_highlight` function takes a string of code and a language identifier as input. It uses the Pygments library to highlight the code based on the specified language. If the language is MATLAB or Python, it selects the corresponding lexer (`MatlabLexer` or `PythonLexer`). For other languages, it defaults to using the `TextLexer`. The highlighted code is then formatted with HTML and returned wrapped in `<pre><code>` tags.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\html_writer.py:_render_class:0cbc16e8e639408d2c2241ce4176331caf0d012cceffdb84c19c736a042b4dcf": "This function `_render_class` takes a dictionary representing a class, a programming language string, and an optional level integer. It returns a list of HTML strings representing the class and its subclasses in a structured format.\n\nThe function starts by creating an empty list `parts` to store HTML elements. It determines the HTML heading tag based on the provided level, ensuring it does not exceed `<h6>`. The function then extracts the class name from the input dictionary and appends an HTML header element with the class name to the `parts` list.\n\nNext, it retrieves the docstring or summary of the class (preferring the docstring if both are present) and appends a paragraph element containing the escaped content to the `parts` list.\n\nThe function then iterates over any methods associated with the class, rendering each method using the `_render_function` function and appending the resulting HTML elements to the `parts` list.\n\nFor each subclass of the current class, the function appends an opening `<details>` tag, followed by a summary element containing the subclass name. It recursively calls `_render_class` for the subclass, passing it the language and level incremented by one, and appends the returned HTML elements to the `parts` list. Finally, the function appends a closing `</details>` tag.\n\nThe function returns the complete list of HTML strings representing the class and its subclasses in a structured format suitable for rendering in an HTML document.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\html_writer.py:_render_function:dfff452e0efe6129108a072af1e7a46bb145ffcfbbf773ced251d315d15c5d03": "This function `_render_function` generates HTML parts for a given function and its nested subfunctions. It takes a dictionary representing the function, a programming language string, an optional heading level (default is 3), and an optional prefix string. The function constructs an HTML list of strings that include:\n\n1. An HTML header tag (`<h1>` to `<h6>`) for the function signature.\n2. A paragraph containing the function summary or docstring.\n3. Code highlighting for the function source code using a `_highlight` function (not shown in the snippet).\n4. Details and summaries for any nested subfunctions, each wrapped in a `<details>` tag.\n\nThe function returns this list of HTML parts, which can be further concatenated to form a complete HTML representation of the function and its subfunctions.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\html_writer.py:_render_html:10fcb2145ba2aa93a02d50c7c32500c196999914df56b263ee7b1a8eb0f609dc": "The function `_render_html` takes four parameters: `title`, `header`, `body`, and `nav_html`. It reads a template file from `_TEMPLATE_PATH`, formats it with the provided parameters, and returns the rendered HTML string. The template includes placeholders for `title`, `header`, `body`, and `navigation`, which are replaced by the actual content passed to the function. The returned HTML string is prefixed with a comment indicating that it was generated by DocGen-LM.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\html_writer.py:_render_html:d6cbcb52d009e6e70c91f5ed1ad8b65984697da617e2b07ac80c0254cad218fb": "This function `_render_html` takes in parameters for the title, header, body, and navigation HTML. It reads a template file from `_TEMPLATE_PATH`, formats it with the provided parameters, and appends a comment indicating that the document was generated by DocGen-LM. The function returns the formatted HTML content as a string.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\html_writer.py:write_index:2eaa30dc7a1a2c5e3efb16bc3460479d9577d2542e64be7099aba9dcbd8ee832": "This function `write_index` generates the content for an `index.html` file in a specified output directory. It takes parameters for the project summary, navigation links, and optional module summaries. The function creates the necessary directory if it doesn't exist, constructs HTML elements for the project summary, navigation links, and module summaries, and then writes these elements to the `index.html` file using a helper function `_render_html`.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\html_writer.py:write_index:7a00979053c349ff7eb3d6fa5e3c55e3c2833724abae78f138d38fddc9fed9c9": "The `write_index` function generates the content for an `index.html` file in a specified output directory. It takes parameters for the project summary, navigation links, and optional module summaries. The function creates a directory if it doesn't exist, constructs HTML elements for the project summary and navigation links, and optionally includes summaries of modules. It then renders these elements into an HTML string using `_render_html` and writes the result to `index.html`.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\html_writer.py:write_index:bc2d197629583306d4fa19e8da1f415c5da34e2ade2c6a3b1e81ee136343b344": "This function `write_index` generates the content for an `index.html` file. It takes parameters for the output directory, a project summary, page links, and optional module summaries. The function creates the necessary directory if it doesn't exist, constructs navigation links from the provided page links, and optionally includes module summaries. It then renders the HTML using a `_render_html` function with the specified title, header, body content, and navigation links. Finally, it writes the generated HTML to `index.html` in the output directory.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\html_writer.py:write_index:ef29682f26a44996a98c3d788deca3e57ce272c3b7ee0dabea08ac3fbcdde378": "This function `write_index` generates an HTML file named `index.html` in the specified output directory. It takes three required parameters: `output_dir`, `project_summary`, and `page_links`. Optionally, it accepts a dictionary `module_summaries`.\n\nThe function creates the destination directory if it doesn't exist. It constructs navigation links from `page_links` and project summary text into HTML format. If `module_summaries` are provided, it includes module summaries in the generated HTML.\n\nFinally, it renders the complete HTML content using `_render_html` and writes it to `index.html`.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\html_writer.py:write_module_page:46905bb080dee5dfe312ede1656f06bbaa0b983efbc325aef66dad42f9ce8023": "This function `write_module_page` generates an HTML documentation page for a Python or MATLAB module. It takes three parameters: `output_dir`, which is the directory where the output HTML file will be saved; `module_data`, a dictionary containing information about the module, including its name, language, summary, classes, and functions; and `page_links`, an iterable of tuples representing links to other pages.\n\nThe function first creates the destination directory if it doesn't exist. It then constructs the navigation items for the page, which includes a link to the project overview and any additional links provided in `page_links`.\n\nNext, it builds the body content of the HTML page. This starts with a paragraph containing the module's summary. It then iterates over any classes defined in `module_data`, rendering each class using another function `_render_class`. If there are functions defined, it adds an \"Functions\" heading followed by rendering each function using `_render_function`.\n\nFinally, the function combines all parts into a single HTML string using `_render_html` and writes this string to an HTML file named after the module in the specified output directory.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\html_writer.py:write_module_page:53334783fcb7b59f18fd3ccf065259a7699aa2e383c7892f9a4a13c0fa992cbd": "This function `write_module_page` generates an HTML documentation page for a Python or MATLAB module. It takes three parameters: the output directory where the documentation will be saved (`output_dir`), a dictionary containing data about the module (`module_data`), and an iterable of tuples representing navigation links (`page_links`). The function creates a new directory if it doesn't exist, constructs HTML content based on the module's classes, methods, and functions, and writes this content to an HTML file named after the module.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\html_writer.py:write_module_page:80aceaa8042bcb1b7e657b512659705896970c47f170bc810459ef4d9fabbfe9": "This function `write_module_page` generates an HTML documentation page for a Python or MATLAB module. It takes three parameters: `output_dir`, which is the directory where the output HTML file will be saved; `module_data`, a dictionary containing information about the module, including its name, language, summary, classes, and functions; and `page_links`, an iterable of tuples representing navigation links for the documentation page.\n\nThe function first constructs the destination directory and ensures it exists. It then extracts the module's name and language from `module_data`. Navigation items are created, including a link to the project overview and any additional links provided in `page_links`.\n\nThe body of the HTML page is built by iterating over classes and functions defined in `module_data`. For each class, it generates an HTML section with the class name, docstring, and methods. Each method's signature and docstring are also included. For functions, a similar structure is followed.\n\nFinally, the function renders the complete HTML content using `_render_html`, which takes the module name, title, body, and navigation HTML as arguments. The rendered HTML is then written to a file named after the module in the specified output directory.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\html_writer.py:write_module_page:efe2b9189698f409fde10fd7d42a26176132d59b113fde41c8f7033bccdf3a77": "This function `write_module_page` generates an HTML documentation page for a Python or MATLAB module. It takes three parameters: `output_dir`, which is the directory where the output HTML file will be saved; `module_data`, a dictionary containing metadata about the module, including its name, language, summary, classes, and functions; and `page_links`, an iterable of tuples representing navigation links for the documentation page.\n\nThe function first constructs the destination directory and ensures it exists. It then extracts the module's name and language from the `module_data` dictionary. Navigation items are created, including a link to the project overview and any additional links provided in `page_links`.\n\nThe body of the HTML page is built by iterating over the classes and functions defined in the module. For each class, it generates an HTML section with the class name, summary, and methods (if any). Similarly, for each function, it creates a section with the function signature, summary, and source code.\n\nFinally, the function renders the complete HTML page using `_render_html`, which takes the module name, title, body content, and navigation HTML as parameters. The generated HTML is then written to a file in the destination directory with the filename corresponding to the module's name.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\llm_client.py:LLMClient:5670248690f3cd5fa1b3c69519dfc26e6cc9da85500699ca791b27c1a40f032a": "A thin wrapper around the LMStudio HTTP API.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\llm_client.py:LLMClient:72838e8fd0709fe551641fc0c9f76a75b2b5ff0bb539cfd53f50e846550367c6": "The `LLMClient` class provides a thin wrapper around the LMStudio HTTP API. It includes methods for checking API reachability with the `ping` method and generating summaries of text using specified prompt types with the `summarize` method. The `summarize` method handles retries and error handling for robust request execution.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\llm_client.py:__init__:6232dc18cc36de3da2b085cea52e9e22b76f0b810b56d5a7710e35c979f96e8e": "The `__init__` method initializes an instance of the `LLMClient` class. It sets up the base URL for the language model API and constructs the endpoint for sending requests. The method also allows specifying the model to be used, defaulting to \"local\" if not provided.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\llm_client.py:__init__:766152147f3b60a5d34acc7347d5b7c112ba5061d4649ab7229ee92ef336e610": "The `__init__` method initializes a new instance of the `LLMClient` class. It accepts two parameters: `base_url`, which specifies the URL of the local language model server, and `model`, which indicates the type of model to use. The method sets these parameters as instance variables after stripping any trailing slashes from the `base_url`. It also constructs a full endpoint URL for sending requests to the LLM server's chat completions API.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\llm_client.py:__init__:8026beed38d7bfabca844913b2d3e47cb059e06292ad0822dbe50128f8691af0": "The `__init__` method initializes a new instance of the `LLMClient` class. It takes two optional parameters: `base_url` and `model`. The `base_url` parameter specifies the base URL for the LLM API, defaulting to \"http://localhost:1234\". The `model` parameter specifies the model to use for generating documentation summaries, defaulting to \"local\". The method sets these values as instance variables and constructs an endpoint URL for making API requests.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\llm_client.py:ping:112f99b75604e1889c93b5bdd400c0677fb829987f6af5c73ccbe01d2e534a8c": "The `ping` method checks if the LLM server is reachable. It sends a GET request to the server's base URL with an optional timeout parameter. If the server responds successfully, it returns `True`. If the server cannot be reached or an error occurs during the request, it raises a `ConnectionError` with a message indicating that the server could not be contacted at the specified URL.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\llm_client.py:ping:4a54c81c5bc19d6923596f0070a5da833a7bfed7385cd282c42e0097a96b9b44": "The `ping` method in the `LLMClient` class checks if the API is reachable by sending a GET request to the base URL with a specified timeout. If the server responds successfully, it returns `True`. If there is an exception during the request, such as a connection error or timeout, it raises a `ConnectionError` with a message indicating that the server cannot be contacted.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\llm_client.py:ping:9ce8e14c79a7053d5c40deb9b63894277541cc1f77634d0e68a904caae6c5297": "The `ping` method in the `LLMClient` class checks if the Large Language Model (LLM) server is reachable. It sends a GET request to the base URL specified during initialization and returns `True` if the server responds successfully within the given timeout period. If the server cannot be contacted, it raises a `ConnectionError` with a message indicating that the LLMStudio server at the specified base URL is unreachable.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\llm_client.py:ping:de9447b49b3ebcc48a6c20afa9bfedfd6ff2547b1c9a99f7ab17a1a7215322a7": "The `ping` method checks if the API is reachable by attempting a GET request to the server's base URL. It returns `True` if successful, otherwise it raises a `ConnectionError` with a message indicating that the server cannot be contacted. The method uses a timeout of 2.0 seconds by default.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\llm_client.py:sanitize_summary:0077cf5dc93fdc7a0faaf5ca4c47158bbb97b45ac54bfd84258decaee1077579": "The function `sanitize_summary` takes a string `text` as input and returns a sanitized version of the text by removing meta-commentary phrases, specific start phrases, and certain keywords related to summaries or outputs. It uses a list of bad start phrases and filters out lines that contain these phrases or specific keywords indicating unwanted content. The function then joins the filtered lines back into a single string and returns it.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\llm_client.py:sanitize_summary:00aa78daad50c2558dfaa3339096391cdefbcb8cc90a860fd810da39cbd3b132": "The function `sanitize_summary` takes a string `text` as input and returns a sanitized version of the text by removing lines that start with specific phrases or contain certain keywords related to summaries, outputs, responses, and descriptions. It uses a list of bad start phrases and filters out lines that match these criteria using regular expressions and string methods.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\llm_client.py:sanitize_summary:2bbbd51c8579668e8809ed1f6133c821b9f562511b59fba715c022fd64e27463": "",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\llm_client.py:sanitize_summary:457457f6917f497d4a16e25de9db3ae6554353bde0d74170cc7fefd7b8d2f89c": "The function `sanitize_summary` takes a string `text` as input and returns a sanitized version of the text by removing lines that start with certain phrases or contain specific keywords related to summaries, outputs, responses, and other meta-commentary. The function uses a list of bad start phrases and filters out lines that match these patterns. It also avoids including lines that explicitly state they are summaries, outputs, or responses.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\llm_client.py:summarize:1024a7376f5cbd9b47e56affc7109b266730b0e812f5aeeb16f798143876e4ba": "The `summarize` method in the `LLMClient` class takes a string `text` and a `prompt_type` as input. It uses a template based on the `prompt_type` to format the input text into a prompt for summarization. The method constructs a payload with details such as the model name, temperature, and messages (system and user prompts). It attempts to send this payload to an endpoint using HTTP POST requests up to three times. If successful, it processes the response to extract and sanitize the summary content. If all attempts fail, it raises a `RuntimeError` with the error message from the last failed attempt.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\llm_client.py:summarize:25e2725810253afc0dd49ab39e63c0672d5710e406bb304c63fa5c2f4df6f565": "The `summarize` method in the `LLMClient` class takes a string of text and a prompt type, then generates a summary using a language model. It uses a template based on the prompt type to format the input text into a prompt. The method constructs a payload with the model settings and sends it to the LLM server endpoint via a POST request. If the request fails due to HTTP errors or other exceptions, it retries up to three times before raising a `RuntimeError` with the error message.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\llm_client.py:summarize:64c9cbbe43e401423d1158088aa630a486c40b82b42748675bcf881f625239f1": "The `summarize` method in the `LLMClient` class generates a summary for a given text using a specified prompt type. It uses a template based on the prompt type, formats the text into a prompt, and sends it to an LLM server via a POST request. The method retries up to three times if there are HTTP errors or request exceptions, handling each error by updating an error message and waiting for one second before retrying. If all attempts fail, it raises a `RuntimeError` with the accumulated error message.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\llm_client.py:summarize:d294894746747c3cf4ec30f6cbbc81b90ee53d5a246e5b48d183daf2259fe8a5": "The `summarize` method in the `LLMClient` class generates a summary for a given text using a specified prompt type. It uses a template from `PROMPT_TEMPLATES` based on the prompt type, formats it with the input text, and sends a POST request to an endpoint with the model name, temperature, and formatted prompt as JSON payload. The method retries up to three times in case of HTTP errors or request exceptions, updating an error message each time. If all attempts fail, it raises a `RuntimeError` with the accumulated error message.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\parser_matlab.py:parse_matlab_file:3e88f09359beb2f03ab34b9fd19aee3f4c2d828e7886d668b5ab21ed1e400242": "The function `parse_matlab_file` reads and parses a MATLAB `.m` file to extract its basic structure. It returns a dictionary containing the file's header comments and any function declarations found. The header is collected from lines starting with `%`, and functions are identified using a regular expression that matches lines defining functions, capturing their names and arguments.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\parser_matlab.py:parse_matlab_file:8c601b4070a8b50c1cf6daeadf6a7a20f8f400238ba91af967003ab12312cce2": "The function `parse_matlab_file` takes a file path as input and returns a dictionary containing the header comments and any function declarations found in the MATLAB script. It reads the file content, extracts leading comment lines as the file header, and uses a regular expression to identify and extract function names and their arguments. The extracted information is returned in a structured format.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\parser_matlab.py:parse_matlab_file:9b6a80580283bc1da1e0aad7b5bbf3e7893fafb864e2fbe207d5da879e425da5": "This function `parse_matlab_file` takes the path to a MATLAB `.m` file as input and returns a dictionary containing the file's header comments and any function declarations found within. The function reads the file content, extracts leading comment lines as the header, and uses a regular expression to identify and parse function declarations, extracting their names and arguments.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\parser_matlab.py:parse_matlab_file:a3fed8ea43da280c2bc0f9447dc729f1a32a090ba3d18123a0423e63a83a26eb": "The function `parse_matlab_file` reads and parses a MATLAB `.m` file to extract its header comments and function declarations. It returns a dictionary containing the file's header as a string and a list of dictionaries, each representing a function with its name and arguments. The function uses regular expressions to identify and parse function definitions within the file.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\parser_python.py:_format_arg:1ef58f0b0bbd359d966e9ef75815d1dad707672e99042be69c795b04d9b478ae": "Formats an argument in a Python function signature by appending its type annotation, if available.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\parser_python.py:_format_arg:49dd7af2646dc9a7d2ca708fa3a56f0aa5295b86bcc609a076ffd9fc83dc13d1": "Formats an argument in a function signature by appending its type annotation if available.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\parser_python.py:_format_arg:d4c3fad759769f3ce9a1f10c04a651ff77c9b023ee50cd6ae359ad6a77835a80": "Formats an argument by appending its type annotation, if available, to the argument name.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\parser_python.py:_format_arg:d98c816e8d77421443d183d6edf23330b47c096060a173229dda4cfc335b86d5": "This function formats a Python function argument by appending its type annotation, if available. It takes an `arg` object from the `ast` module and returns a string representing the argument name followed by its type annotation in parentheses. If no annotation is present, it simply returns the argument name.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\parser_python.py:_format_arguments:4f3a48dab48b096ce24edb9b4f94edd17494b75666c9fd85ccd473f3ec82796d": "This function `_format_arguments` takes an `ast.arguments` object as input and returns a string representation of the arguments. It processes positional-only arguments, regular arguments, variable positional arguments, keyword-only arguments, and variable keyword arguments, including their default values if provided. The function uses helper functions like `_format_arg` to format individual argument names and handles the formatting according to Python's syntax rules for function definitions.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\parser_python.py:_format_arguments:594dbd8ee2c5d8eb29c06296f834f4bf1a0fb2ea6798aa9180d6b63fb34b34af": "Formats the arguments of a function or method into a string representation. Handles positional-only, regular, variable positional, and variable keyword arguments, including their default values if provided.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\parser_python.py:_format_arguments:ae811c1d5fdca26d95736209bc0d17e32673903aea1a1f3d280dcebd50e944bb": "This function `_format_arguments` takes an `ast.arguments` object as input and returns a string representation of the arguments. It handles positional-only arguments, regular arguments, variable positional arguments, keyword-only arguments, and variable keyword arguments, formatting each according to its type and default value if provided. The function uses helper functions like `_format_arg` and `ast.unparse` to convert AST nodes into strings.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\parser_python.py:_format_arguments:d01c3ed640c3d7d1aad5264c27428578c15044f1de8643e3bca3a8fee51459f0": "This function `_format_arguments` takes an `ast.arguments` object as input and returns a string representation of the arguments it contains. The function handles positional-only arguments, regular arguments, variable positional arguments, keyword-only arguments, and variable keyword arguments, formatting each according to Python syntax rules. It uses helper functions like `_format_arg` and `ast.unparse` to convert AST nodes into their string representations.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\parser_python.py:_format_signature:0c967781dcf7f00ab4d54e413838abb4f1bea0cf5bc5fb748745f30e9d3b70ba": "This function `_format_signature` takes an `ast.FunctionDef` or `ast.AsyncFunctionDef` object as input and returns a string representing the signature of the function. The signature includes the function name, its parameters formatted by `_format_arguments`, and the return type if specified.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\parser_python.py:_format_signature:38f107ef661dac16e65ca71ffd62b5183c0e19a19dc21aba0aa36b762c8a2ca5": "The function `_format_signature` takes an `ast.FunctionDef` or `ast.AsyncFunctionDef` object as input and returns a string representing the signature of the function. It formats the parameters using the `_format_arguments` function and appends the function name and parameters to form the signature. If the function has a return type specified, it also includes that in the signature.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\parser_python.py:_format_signature:41c45f2e6a0193d8f2d8322fe539892bb128f3b3998f60e853437a9bfaa8f6e3": "This function `_format_signature` takes an `ast.FunctionDef` or `ast.AsyncFunctionDef` object as input and returns a string representing the signature of the function, including its name, parameters, and return type if specified. It uses another helper function `_format_arguments` to format the parameters.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\parser_python.py:_format_signature:ba10902ba267dbc215ba0a837520239085b7ccb114027de170e2122be6e03adb": "This function, `_format_signature`, takes a Python `FunctionDef` or `AsyncFunctionDef` object as input and returns a string representing the signature of the function. It constructs the signature by formatting the function name and its arguments using another helper function `_format_arguments`. If the function has a return type specified, it appends the return type to the signature in a readable format.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\parser_python.py:parse_class:c7c0a8d742327a33144912d61a41d486f24972024577c27ce3cdad873719d616": "The function `parse_class` takes an AST node representing a class and the source code as input. It returns a dictionary containing information about the class, including its name, docstring, methods, subclasses, and source code segment. The function iterates through the body of the class node, identifying nested classes and functions (both synchronous and asynchronous) to include in the returned dictionary.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\parser_python.py:parse_function:84da4807291c8b9202306bc9d8b857cff5ad39969af101c6ba648b82b67feca6": "The `parse_function` function takes an AST node representing a function definition (`ast.FunctionDef` or `ast.AsyncFunctionDef`) and the source code as input. It returns a dictionary containing information about the function, including its name, signature, return type, docstring, source code segment, and any nested functions. The function iterates through the body of the given node to identify and parse any nested functions, recursively calling itself for each nested function found.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\parser_python.py:parse_python_file:071ce52a2b3dd39658db104c10f87d7e222f8fc7a5e7f8167ef4fe248dd6201f": "The `parse_python_file` function takes a file path as input and returns a dictionary containing structured information about the Python source code. It reads the source code from the specified file, parses it using the `ast` module, and extracts the module docstring, classes, and functions. For each class and function found, it captures details such as name, signature, documentation string, and source code segment. The function returns a dictionary with these structured elements organized by modules, classes, and functions.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\parser_python.py:parse_python_file:9ea77fc56f50c0253917873c821cf50b9c2bd6f43cfea23cdc69c3c8f6e123e8": "The function `parse_python_file` reads a Python source file and extracts structured information. It returns a dictionary containing the module docstring, classes, and functions defined in the file. The function uses the `ast` module to parse the source code and identify class and function definitions, which are then processed by helper functions `parse_class` and `parse_function`.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\parser_python.py:parse_python_file:a391b8ac40c883bde8c7145862abbca67d3b4aaa8ba0cd81b6cff656a1ef5415": "The `parse_python_file` function reads and parses a Python source file to extract structured information about the module, classes, and functions. It returns a dictionary containing the module's docstring, class details (including names, docstrings, methods, and source code), and function details (including names, signatures, return types, docstrings, and source code). The parsing is done using Python's `ast` module to handle abstract syntax trees.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\parser_python.py:parse_python_file:a3a72347c1fec4ac4125dc1ba4b53dc983974ce3c2bcb5b8f952c6821771c208": "The function `parse_python_file` takes a file path as input and returns a dictionary containing structured information about the Python source file. It reads the source code from the specified path, parses it using the `ast` module, and extracts the module docstring, classes, and functions. For each class and function, it gathers details such as name, signature, return type (if applicable), docstring, and source code segment. The parsed information is organized into a dictionary and returned.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\reviewer.py:_find_line_number:238734968d03c46cbe881a12b2e367753c6bcbfeeeae797491f79cc5ee6c2464": "The function `_find_line_number` searches for a specific phrase within an HTML string and returns the line number where the phrase is found. If the phrase is not present, it returns -1. The search is case-insensitive.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\reviewer.py:_find_line_number:8f3ed5264d3a52bd480be6b1a4daff6b0b8cbb143db2ef10acf56de8b1395c51": "The function `_find_line_number` searches for a specific phrase within an HTML string and returns the line number where the phrase is found. If the phrase is not present, it returns -1. The search is case-insensitive.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\reviewer.py:_is_generated_html:1558a9430b0d25afb833d85aae4a964bf247393bd269fde3b821f9cd55215fbb": "This function checks if a given string `text` appears to be output from DocGen-LM, a tool for generating static HTML documentation. It returns `True` if the text contains specific markers indicating it was produced by DocGen-LM, such as \"Generated by DocGen-LM\", an HTML header for project documentation, or headings for classes and methods.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\reviewer.py:_is_generated_html:4f9149d1445f6ca605cdb0c56d8c06c2af00d1af4f74ef760ef96b7c8d61bbc2": "This function checks if a given string of text appears to be output from the DocGen-LM documentation generator. It returns `True` if the text contains specific markers indicating it was generated by DocGen-LM, such as \"Generated by DocGen-LM\", an HTML heading for project documentation, and headings for classes and methods.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\reviewer.py:_is_generated_html:630b1b6dfb92ff261b3d03fcd8e28c6a66ff1fc232f7ae24305167008f1d8494": "The function `_is_generated_html` checks if a given string `text` appears to be output from the DocGen-LM tool. It returns `True` if the text contains specific HTML tags that are characteristic of the tool's documentation format, such as `<h1>Project Documentation</h1>`, `<h2>` tags with \"Class:\" content, and `<h3>` tags with \"Method:\" content.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\reviewer.py:_is_generated_html:6441d773a7539c6a87566039a7adc08ed62ab19f558549f0b563b868c1b30c1d": "This function checks if a given string `text` appears to be output from DocGen-LM by looking for specific HTML tags that are characteristic of the tool's documentation format. It returns `True` if any of the following conditions are met:\n1. The text contains an `<h1>` tag with the title \"Project Documentation\".\n2. The text contains an `<h2>` tag with the word \"Class:\".\n3. The text contains an `<h3>` tag with the word \"Method:\".",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\reviewer.py:_review_file:126cca311a3fb96bcd32988bbb9639818d4d85aa03c728049a87ae4aaa658c3d": "The function `_review_file` takes a file path and an optional `autofix` flag as input. It reads the HTML content of the specified file, checks for assistant phrasing, contradictions, and hallucinations using separate functions (`check_assistant_phrasing`, `check_contradictions`, `check_hallucinations`), and appends any issues found to a list. If `autofix` is enabled and there are issues, it sanitizes the paragraphs in the HTML content and writes the updated content back to the file. The function returns a list of strings describing the issues found or fixed.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\reviewer.py:_review_file:5e2a1e9f696f4246711694125403a22d61db8919a5d58c7e692cceed2b3b18b4": "The function `_review_file` processes an HTML file located at the specified `path`. It first reads the content of the file, checking if it is a generated HTML using `_is_generated_html`. If not, it returns an empty list. The function then uses BeautifulSoup to parse the HTML content.\n\nIt iterates over three types of checks:\n1. **Assistant Phrasing**: Calls `check_assistant_phrasing` to find any occurrences of assistant phrasing and appends them to the results list with a prefix indicating they are from the assistant.\n2. **Contradictions**: Calls `check_contradictions` to identify any contradictions in the content and appends each contradiction description to the results list with a prefix indicating it is a contradiction.\n3. **Hallucinations**: Calls `check_hallucinations` to find any terms that are mentioned but not supported or verified, appending each hallucination term to the results list with a prefix indicating it is a hallucination.\n\nIf `autofix` is set to `True` and there are any issues found (i.e., if `results` is not empty), the function calls `_sanitize_paragraphs` to sanitize the paragraphs in the HTML content, then writes the sanitized HTML back to the file at the specified path. Finally, it returns the list of results containing all identified issues.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\reviewer.py:_sanitize_paragraphs:727a8a46269522469692968fdbdc76ca3a86abac99cdafe6970a9b7b1193ef6f": "The function `_sanitize_paragraphs` processes a `BeautifulSoup` object to clean up paragraph text. It iterates through all `<p>` tags within the document, retrieves their text content, sanitizes it using the `sanitize_summary` function, and then replaces the original text with the sanitized version in place.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\reviewer.py:_sanitize_paragraphs:86dbaddd91f3ffca1fb66e584f1d09296214dc6321901beea4a0d55772a56a82": "The function `_sanitize_paragraphs` takes a `BeautifulSoup` object as input and iterates over all paragraph (`<p>`) elements within the HTML document. For each paragraph, it retrieves the text content using `.get_text()`, sanitizes it with the `sanitize_summary` function, and then replaces the original paragraph text with the sanitized version.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\reviewer.py:check_assistant_phrasing:2d4377a283fde811624b265ac045fb9d91df2f1a49b6fe59c0c5638e0f59e9da": "This function `check_assistant_phrasing` analyzes an HTML string to identify and list occurrences of assistant-like phrases. It extracts paragraph tags (`<p>`) from the HTML, strips any HTML tags, converts the text to lowercase for case-insensitive comparison, and checks if any predefined assistant phrases are present. If a phrase is found, it records the exact text and its line number in the HTML. The function returns a list of strings, each representing a found assistant phrase along with its line number.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\reviewer.py:check_assistant_phrasing:5b6c46aca81cd5dcf02c09ef76bb9a6aa1e2061c8189ae609653ac7df2846649": "Function `check_assistant_phrasing` takes a BeautifulSoup object and an HTML string as input. It returns a list of strings identifying any phrases from the predefined set `ASSISTANT_PHRASES` that appear in paragraph tags (`<p>`) within the HTML content. Each found phrase is appended to the list with its line number in the original HTML.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\reviewer.py:check_assistant_phrasing:7b4bf973e970afe4b8cb51a9e525f55427305d5c106067007d8a156781e22f89": "This function `check_assistant_phrasing` takes a BeautifulSoup object and an HTML string as input. It searches for paragraphs in the HTML that contain any of a predefined list of assistant-like phrases. If such a phrase is found, it appends the text of the paragraph along with its line number to a list. The function returns this list of findings.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\reviewer.py:check_assistant_phrasing:9923b68e58e6128c4e9be2ec62b97b85f73c685e85f5c8f46b25716c79306e72": "The function `check_assistant_phrasing` analyzes HTML content to identify and list occurrences of phrases that resemble assistant-generated text. It extracts paragraph tags from the HTML, strips out any HTML formatting, converts the text to lowercase for case-insensitive comparison, and checks if any predefined assistant phrases are present. If a match is found, it records the phrase along with its line number in the original HTML. The function returns a list of these findings.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\reviewer.py:check_contradictions:058ca6fda86216b681f9c11b60e164537bf892bcc949747540c1d6ef81620ece": "The `check_contradictions` function analyzes HTML documentation to identify contradictions based on the presence of specific tags and text. It returns a list of contradiction descriptions. The function extracts paragraphs, method headers, function headers, and class headers from the HTML. It then checks for contradictions in the summary text against the actual content found in the document. Contradictions include stating \"no methods\" but finding method headers, stating \"no functions\" but finding function headers, or stating \"no classes\" but finding class headers.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\reviewer.py:check_contradictions:0b618f54eaba9106d1096c2d915775b5be20f8b773b63d9b5cfe9be37b0b78e1": "The `check_contradictions` function analyzes HTML documentation to identify contradictions between the text content and the presence of specific elements such as methods, functions, and classes. It returns a list of contradiction descriptions based on these checks.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\reviewer.py:check_contradictions:2315595e396fb5020b347ca8eda3b3294b2006ccfe2ce35e5ea03c7a88dfb85e": "This function `check_contradictions` analyzes an HTML document parsed with BeautifulSoup to identify contradictions between the text content and the presence of specific elements. It checks for discrepancies related to the presence or absence of methods, functions, and classes as described in the summary text compared to what is actually found in the HTML structure. The function returns a list of contradiction descriptions if any are found.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\reviewer.py:check_contradictions:a8a10121bedd26dc988142be7f02524ca9a2318acac6705248edef93a28f5523": "This function `check_contradictions` takes a BeautifulSoup object as input and returns a list of contradiction descriptions. It analyzes the text content of paragraph tags and header tags within the soup to check for discrepancies between the declared presence or absence of methods, functions, and classes in the documentation summary versus what is actually found in the code.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\reviewer.py:check_hallucinations:386e6935163a8de8d870eef9f8969c5cbda0c0694d4cb6cca5cfffbf26d5b876": "This function `check_hallucinations` takes a BeautifulSoup object as input and returns a list of hallucination phrases detected within paragraph tags. It iterates through all paragraph elements, extracts their text content after stripping whitespace and converting to lowercase, and checks if any predefined hallucination terms are present in the text. If a term is found, it is added to the findings list, which is then returned.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\reviewer.py:check_hallucinations:710b41eb5115d90961cb6fb84b717bd0dd12d9533bc00cffdb14bbf78f146340": "The function `check_hallucinations` analyzes HTML content to detect the presence of hallucination phrases. It extracts all paragraph (`<p>`) tags from the provided HTML string, strips any HTML tags from the extracted text, converts it to lowercase for case-insensitive comparison, and checks if any predefined hallucination terms are present in the text. If a term is found, it is added to a list of findings. The function returns this list of detected hallucination phrases.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\reviewer.py:check_hallucinations:850dd191e83e8afad1f5244d87e0f82ea3457c711283f25c6675ac2e34f8be99": "The function `check_hallucinations` takes a BeautifulSoup object as input and returns a list of hallucination phrases detected within the paragraph elements (`<p>`) of the HTML content. It iterates through all paragraph tags, extracts their text content in lowercase, and checks if any predefined hallucination terms are present. If a term is found, it is added to the findings list.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\reviewer.py:check_hallucinations:93976813eb113c4560aa6f160c7aed979a3856b7185c3d77dec0d92ef6c71386": "The function `check_hallucinations` takes an HTML string as input and returns a list of hallucination phrases detected within the HTML. It extracts paragraph tags from the HTML using `_extract_tags`, strips any HTML from the extracted text, converts it to lowercase for case-insensitive comparison, and checks if any predefined hallucination terms are present in the text. If a term is found, it is added to the list of findings, which is then returned.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\reviewer.py:main:3666687dbb03ec0b86249eb46b384ac08a4ea0881f27e2dfdb075cbec6c574f7": "The `main` function parses command-line arguments using the `argparse` module. It expects a directory path as an argument and optionally a flag to enable automatic fixing of issues in the HTML files. The parsed arguments are then used to call the `review_directory` function, passing it the specified directory and the autofix option. The function returns 0 to indicate successful execution.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\reviewer.py:main:c98cfda984e32e5fbfbf4d7a6a64f04d53a8302cb8cbdad85e35419efe817079": "The `main` function serves as the entry point for a tool designed to review and optionally fix issues in HTML documentation generated by DocGen-LM. It accepts command-line arguments specifying the path to the HTML output directory and an optional flag (`--autofix`) to enable automatic file rewriting for fixes. The function uses Python's `argparse` module to parse these arguments, then calls another function named `review_directory` with the provided directory path and autofix setting. Finally, it returns an integer value of 0, indicating successful execution.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\reviewer.py:review_directory:754b2a56d48215a1fa87cd98870ba288a5fac5a8aa67895089c11c8ba194ae77": "The `review_directory` function processes all HTML files within a specified directory. It iterates through each file, calling `_review_file` to analyze and potentially autofix issues based on the `autofix` parameter. Any errors encountered during file reading are printed, but processing continues for other files. The results of the review are printed line by line.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\reviewer.py:review_directory:f5c85fd9140470c6e045d7c2314df00efd6e23573185341ab95e1fc2b89a94f0": "The function `review_directory` takes a directory path and an optional boolean flag `autofix`. It recursively searches the specified directory for all `.html` files. For each file, it attempts to review its content using the `_review_file` function with the provided `autofix` flag. If successful, it prints each line of the review results. If an error occurs during file reading or processing, it catches the exception and prints an error message before continuing with the next file.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\scanner.py:_is_subpath:38760d4606d72d30693b5a3bf100969679a7c3f88a00ee4fd0c26174d8a69f23": "This function checks whether a given `path` is either the same as or a subdirectory of another directory specified by `parent`. It uses Python's built-in `Path` class to determine if the relative path from `parent` to `path` can be calculated without raising a `ValueError`, which would indicate that `path` is not within `parent`.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\scanner.py:_is_subpath:3e906e5ed7d839fcfebf7fb7deb2b9ce54dbc2ab6a2104b3bb08abfbcd61393d": "This function checks whether one file system path (`path`) is a subpath of another (`parent`). It returns `True` if `path` is equal to or inside `parent`, and `False` otherwise. The check is performed using the `relative_to` method, which raises a `ValueError` if `path` is not a subpath of `parent`.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\scanner.py:_is_subpath:6102afe496509a66688573ec240f1af92d7665e68a56f17e84667d5be3d621aa": "This function checks whether a given `path` is either equal to or a subdirectory of another `parent` directory. It uses the `relative_to` method from Python's `Path` class, which raises a `ValueError` if `path` is not related to `parent`. If no exception is raised, it returns `True`, indicating that `path` is a subpath of `parent`. Otherwise, it returns `False`.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\scanner.py:_is_subpath:69add20e1b73465b04483415e7c77b01174c003fb8cb09be6fa991a6100255eb": "This function checks if a given `path` is either equal to or a subdirectory of another `parent` directory. It uses the `relative_to` method from the `Path` class in Python's standard library to determine if the `path` can be made relative to the `parent`. If successful, it returns `True`, indicating that `path` is a subpath of `parent`; otherwise, it catches the `ValueError` and returns `False`.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\scanner.py:scan_directory:287078317d78daa613fc6473b093ae738dff1c54a5e3c2780b9b3b3f045a3c24": "The `scan_directory` function recursively discovers Python (`.py`) and MATLAB (`.m`) files within a specified directory while ignoring certain paths. It uses the `os.walk` method to traverse the directory tree, filtering out ignored directories and files based on provided patterns. The function returns a sorted list of absolute paths to discovered source files.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\scanner.py:scan_directory:2a799fce94c1205b8e2d82212fe84237545f6e416c7fceac43362bc939ff9a6d": "The `scan_directory` function recursively discovers Python (``.py``) and MATLAB (``.m``) files under a specified base directory while ignoring certain paths. It returns a list of absolute paths to the discovered source files. The function uses `os.walk` to traverse the directory tree, filters out ignored directories and files, and collects the paths of interest.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\scanner.py:scan_directory:5095f2e6679504d712c0e346b88ae90af1324ae46b2501cd00e949399fd18029": "The `scan_directory` function recursively discovers Python (``.py``) and MATLAB (``.m``) files under a specified base directory while ignoring certain paths. It returns a list of absolute paths to the discovered source files, ensuring that ignored directories and internal `.git` folders are excluded from the search.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\scanner.py:scan_directory:a496d87c3748d02a230a7735e758ba4e17c1570fdfa0fd16ff691e5588cb1409": "The `scan_directory` function recursively discovers Python (``.py``) and MATLAB (``.m``) files under a specified base directory. It ignores specified paths during the search. The function returns a list of absolute paths to discovered source files, ensuring that ignored directories and internal `.git` folders are excluded.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_cache.py:test_cache_get_missing:325eeb2f9a3c5dec737d65ff4544f9209472bf97e9e89bcc7d3eb56af8ba0dfb": "The function `test_cache_get_missing` tests the behavior of a `ResponseCache` class when attempting to retrieve a value for a key that does not exist in the cache. It creates an instance of `ResponseCache` with a temporary file path and asserts that calling `get` with a non-existent key returns `None`.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_cache.py:test_cache_get_missing:b5613f9cef2ffeea2526e6f4f5123a4601953258fadaa0166ddf4ac5401e468d": "This function tests the `get` method of a `ResponseCache` class. It creates an instance of `ResponseCache` with a temporary file path for caching responses. The test asserts that attempting to retrieve a value with a key that does not exist in the cache returns `None`.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_cache.py:test_cache_round_trip:27dbf28d552112c7fa3f624af77b9a66c1fd5adc234da893a4bf0b0f03756ae0": "This function tests the caching functionality of a `ResponseCache` class. It creates a temporary file to store the cache, sets a key-value pair in the cache using the `set` method, and then reads the value back using the `get` method from a new instance of the `ResponseCache`. The test asserts that the value retrieved matches the value originally set, ensuring that the caching is working correctly.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_cache.py:test_cache_round_trip:d1357482d85a22faf5fc84ec805cf67ea7ded0534b201015a0c70895a3c4bd4d": "This function tests the round-trip functionality of a response cache. It creates a temporary file to store the cache, initializes a `ResponseCache` object with this file path, and sets a cache entry for a specific key (\"file.py\", \"content\") with the value \"summary\". Then, it reloads the cache from the same file and asserts that the retrieved value matches the original cached value.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_docgenerator.py:test_clean_output_dir:6f11939300607983fcc6dcdad9a8c050746706cc8f342195a32f866963879d4f": "The function `test_clean_output_dir` is a unit test for the `clean_output_dir` function in the `docgenerator` module. It creates a temporary directory, simulates the presence of various files within it (including a generated HTML file and other assets), and then calls `clean_output_dir` to clean the output directory. The test asserts that the generated HTML file is deleted while other files remain intact.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_docgenerator.py:test_clean_output_dir:8fab799495e273a9b7dc1d291aadb1e0f3ddf43766a4ac1ad8ea754497c96e1f": "The function `test_clean_output_dir` tests the `clean_output_dir` function from the `docgenerator` module. It creates a temporary directory with files and subdirectories, simulates the output of a documentation generation process, and then calls `clean_output_dir` to clean up the output directory. The test asserts that the generated HTML file is removed, while the custom and asset files remain intact.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_docgenerator.py:test_generates_class_and_function_summaries:2f711ce9ae53b8c927ddfe555eb5a1ba87f9bc9760be193d3c06f49d1644ea80": "This function tests the generation of documentation summaries for a Python project using the `docgenerator` tool. It creates a temporary directory with a sample Python file containing a class and a function. The function then uses a mock LLM client to simulate responses for summarizing the module, project, class, improved class docstring, function, and improved function docstring. After running the main function of the `docgenerator` tool with the specified project and output directories, it asserts that the generated HTML files contain the expected summaries.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_docgenerator.py:test_generates_class_and_function_summaries:5b44130a3acbfe34a211d376d82a2c9f8cd2b3583084a4530c8227d89866fe62": "This function, `test_generates_class_and_function_summaries`, is a unit test for the `main` function of the DocGen-LM tool. It creates a temporary project directory with a Python module containing a class and a function. The test then simulates an LLM client that returns predefined summaries for the module, project, class, improved class documentation, function, and improved function documentation. When the `main` function is called with the path to the project directory and output directory, it should return 0 indicating success. The test checks that the generated HTML files in the output directory contain the expected summaries for the class and function.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_docgenerator.py:test_handles_class_without_docstring:1aa76f85a49e14d2088680fc287bcdea1c3a2253b06a4e3c8239483683d6749d": "This function tests the handling of a Python class without a docstring. It creates a temporary project directory with a single Python module containing an unannotated class named `Foo`. The function then calls the `main` function with this project directory and specifies an output directory for the documentation. A mock LLM client is used to simulate responses from the language model server, which are expected to include summaries for the module, project, and class. After running the main function, it asserts that the return code is 0 (indicating success) and checks that a summary for the class is included in the generated HTML documentation file.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_docgenerator.py:test_handles_class_without_docstring:2b5d0fa1580c0b3fda7df5aa5a9a4e71332e7b6936c3e183e3763ab4058fd2bf": "This function tests the handling of a Python class without a docstring. It creates a temporary project directory with a module containing an empty class, sets up a mock LLM client to return predefined summaries for different code elements, and then runs the `main` function with the specified project and output directories. The test asserts that the returned status is 0 (indicating success) and checks that the generated HTML file contains the expected summary for the class.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_docgenerator.py:test_project_summary_is_sanitized:3a02cc559bea78cb172055c5e278a3dd5ab84ff1b6a1b7abb394fd0b9d972292": "This function `test_project_summary_is_sanitized` tests the generation of documentation summaries for a Python project using the DocGen-LM tool. It creates a temporary directory with a sample Python module, sets up a mock LLM client to return predefined summaries, and runs the main function with specified output directories. The test asserts that the generated HTML does not contain certain phrases (\"You can run this\" is absent) while ensuring another phrase (\"It prints.\") is present in the output.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_docgenerator.py:test_project_summary_is_sanitized:4ea2f79997e6b185da3c729ceb1f08539b7ca4ec7d9b87d7321ee816765a4e8a": "The function `test_project_summary_is_sanitized` is a unit test for the `main` function of the DocGen-LM tool. It creates a temporary project directory with a Python module, initializes an mock LLM client to simulate responses, and calls the `main` function with the project and output directories as arguments. The test asserts that the return value of `main` is 0 (indicating success) and checks that the generated HTML documentation does not contain certain phrases while containing others.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_docgenerator.py:test_readme_summary_used:2b691c9293534e2c8dac55592259065c398804af726621b9845c47893f27cf4e": "This function `test_readme_summary_used` is a unit test for the `main` function of the DocGen-LM tool. It sets up a temporary project directory with a Python module and a README file. The test then calls the `main` function with this project directory and an output directory specified by `tmp_path`. A mock LLM client is used to simulate responses from the language model server, including summaries for the module, README, project, and function. The test asserts that the `main` function returns 0 (indicating success) and checks that the \"readme summary\" is included in the generated HTML documentation file located at `output_dir / \"index.html\"`. It also verifies that the LLM client was called with the correct arguments to summarize the README file.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_docgenerator.py:test_readme_summary_used:6d95bb8a09b3dddcc758ee05b2f0bd8423a820096a387a916ed60114dee22766": "This function `test_readme_summary_used` tests the generation of documentation summaries using a mock LLM client. It sets up a temporary project directory with a Python module and a README file. The function then calls the `main` function with the project directory path and an output directory path. It uses a mock LLM client to simulate responses for summarizing different parts of the project, including the README file. After running the main function, it asserts that the output HTML file contains the summary of the README file and that the LLM client was called with \"readme\" as one of its arguments.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_docgenerator.py:test_skips_invalid_python_file:30d6652e2646825de96cef39ebd264b2f1b825384f486c8234d895867889a4dc": "This function tests the behavior of the `main` function when encountering an invalid Python file in a project directory. It sets up a temporary project directory with a file containing invalid syntax (`bad.py`). The function then calls the `main` function with this project directory and an output directory. The test asserts that the return value of `main` is 0, indicating success. Additionally, it checks that only the index page (`index.html`) is generated in the output directory, while no documentation file for the invalid Python file (`bad.html`) is created.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_docgenerator.py:test_skips_invalid_python_file:9605463099a31eddd3c4b577fcd9fa0c89e7b7ca8dab9f8acbf5fe386d6be9e4": "This function tests the behavior of the `main` function when encountering an invalid Python file. It creates a temporary project directory with a file containing invalid syntax due to a leading zero, then calls the `main` function with this directory and an output directory specified. The test uses a mock LLM client that returns a summary for valid files but does not handle errors in invalid files. After running the `main` function, it asserts that only the index page is generated in the output directory, while no documentation is created for the invalid file.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_docgenerator.py:test_skips_non_utf8_file:0a35363ffc839845ff5881baacdd9fbef7e3b23c811669770b635a947b650ca7": "The function `test_skips_non_utf8_file` is a unit test for the `main` function in the DocGen-LM tool. It checks that non-UTF-8 encoded files are skipped during documentation generation.\n\nThe test creates a temporary project directory with a non-UTF-8 file named \"bad.py\" and an output directory. It then patches the `LLMClient` class to simulate successful ping and summary responses. The `main` function is called with the project directory and output directory as arguments, and it returns 0 on success.\n\nThe test asserts that the output directory contains an \"index.html\" file but does not contain a \"bad.html\" file, indicating that the non-UTF-8 file was skipped during documentation generation.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_docgenerator.py:test_skips_non_utf8_file:a829409d5334a55c8b8cdbb7461dd3a6144cb420d02a6647f0d67d9fd9532df6": "This function `test_skips_non_utf8_file` tests the behavior of a documentation generation tool when encountering non-UTF-8 encoded files. It creates a temporary project directory with a file that contains invalid UTF-8 bytes, simulates an LLM client that responds to summarization requests, and runs the main function with specified input and output directories. The test asserts that the non-UTF-8 file is skipped during processing and that only valid documentation files are generated in the output directory.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_html_writer.py:test_write_index:51f567957fa4b2189722bb7565c5c09261325b8226a3ccb3c92ada549221e845": "The function `test_write_index` is a unit test for generating an HTML index file using the `write_index` function. It creates a temporary directory, defines links and summaries for modules, calls `write_index`, reads the generated `index.html` file, and asserts various conditions to ensure the HTML content is correctly formatted and contains the expected information, including module links, summaries, and project summary.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_html_writer.py:test_write_index:c8c6f0eee6772921d9a855757487025a5456f53c767d384b58cd5d3b7a027752": "The function `test_write_index` is a unit test for the `write_index` function. It checks if the generated HTML index file contains the expected content, including project summary, module links, and summaries. The test uses a temporary path to create an output directory, simulates input data for modules and their summaries, and asserts that the resulting HTML file matches the expected structure and content.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_html_writer.py:test_write_module_page:2cbe0be82b3932976fc2e730ec6cfe56a817b8fa4241121fbe706859e1648b77": "The function `test_write_module_page` is a unit test for the `write_module_page` function. It verifies that the HTML page generated by `write_module_page` contains the expected content based on the provided module data and links. The test checks for specific HTML elements such as comments, navigation links, class and method summaries, function summaries, and source code snippets.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_html_writer.py:test_write_module_page:d90b78cc7747f4a969805b81d197ed696600981473a79c87a61b30706eee1fd3": "The function `test_write_module_page` is a unit test for the `write_module_page` function. It creates a temporary directory, defines module data including classes and functions, and writes the module page to this directory using the `write_module_page` function. The test then reads the generated HTML file and asserts that it contains specific elements such as the generation comment, project overview link, links to other modules, class and method summaries, and code snippets.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_integration.py:test_docgenerator_generates_html:512ea6a6edcc0e2c23c7181fb433a33213a921aa5f4535b3b81351d9e21f3a5a": "This function `test_docgenerator_generates_html` tests the functionality of a documentation generator tool. It creates a temporary project directory with Python and MATLAB files, sets up a mock LLM client to simulate responses, runs the main function of the documentation generator with specified input and output directories, and verifies that HTML files are generated in the output directory containing summaries from the LLM client.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_integration.py:test_docgenerator_generates_html:9c0b5b8134c9f101c4f80e203fb406b7f61bdef89b46acca7bdaad151e824d32": "The function `test_docgenerator_generates_html` tests the functionality of a documentation generator tool. It creates a temporary project directory with a simple Python file and a MATLAB file, then calls the main function of the documentation generator with the project directory and an output directory specified as command-line arguments. The test uses a mock LLMClient to simulate responses from the language model server. After running the main function, it asserts that the return value is 0, indicating success. Finally, it checks that HTML files have been created in the output directory for each code file, and that the generated HTML contains the expected summary text.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_integration.py:test_static_copied_from_any_cwd:c53b22e9d48fbab6da262448dd0515bcc7cf44094044d81bd43d0f758ec5f39a": "The function `test_static_copied_from_any_cwd` is a unit test for the `main` function in the DocGen-LM tool. It sets up a temporary project directory with a Python module, specifies an output documentation directory, and uses a mock LLM client to simulate successful ping and summary responses. The test changes the current working directory to the temporary path, runs the `main` function with the specified arguments, and asserts that it returns 0 (indicating success). It also checks that a static CSS file is copied to the output documentation directory.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_integration.py:test_static_copied_from_any_cwd:eb960aa637f4f2b15ddbc20ceb523bc076a7905b534401559298c37ca9fa31b4": "The function `test_static_copied_from_any_cwd` is a unit test for the `main` function in the `docgenerator` module. It creates a temporary project directory with a Python module and an output directory for documentation. The test uses a mock LLM client to simulate responses from the language model, ensuring that the `main` function processes the project directory correctly and generates static HTML documentation in the specified output directory. The test also verifies that a static CSS file is copied to the output directory.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_llm_client.py:test_ping_failure:6bf954bc4d993933b822fab09b683f2b94861b8de4150c8eb920383033f5ed7c": "The function `test_ping_failure` tests the behavior of an `LLMClient` when it fails to ping a server. It uses the `patch` context manager from the `unittest.mock` module to simulate a request exception being raised by the `requests.get` method, which is used for pinging the server. The test asserts that a `ConnectionError` is raised when attempting to ping the server using the client.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_llm_client.py:test_ping_failure:88e030262c311fde2ba211e4ffd0ffe2629a7c739f9903e9a6ddb4344787573a": "The function `test_ping_failure` tests the behavior of an `LLMClient` when it fails to establish a connection. It uses the `patch` context manager from the `unittest.mock` module to simulate a request exception during a ping operation. The `requests.get` method is mocked to raise a `RequestException`, which triggers a `ConnectionError` when attempting to call the `ping` method of the `LLMClient`. This test ensures that the client handles connection failures appropriately by raising an expected exception.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_llm_client.py:test_ping_success:09ac1f4986910a3e000b784114a3362352c91d8797db84c11c9399392fe80b3b": "This function tests the `ping` method of an `LLMClient` class. It creates a mock response object that simulates a successful HTTP GET request without raising any exceptions. The function then asserts that calling `client.ping()` returns `True`, indicating a successful ping. It also verifies that the `requests.get` method was called once with the specified URL and timeout, and that the `raise_for_status` method of the mock response object was called to ensure there were no HTTP errors.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_llm_client.py:test_ping_success:4479849bf99519a7643f6172271fdce7cf2e9e8550cc6be81ceb8a2b6a895af6": "This function tests the `ping` method of an `LLMClient` class. It uses a mock response to simulate a successful HTTP GET request. The test asserts that the `ping` method returns `True`, indicating a successful connection, and verifies that the `requests.get` method was called once with the specified URL and timeout. Additionally, it checks that the `raise_for_status` method of the mock response was called once to ensure no exceptions were raised during the request.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_llm_client.py:test_prompt_varies_by_type:5425a4524023046d73b5d46873aac77aef7a4c862147b277a3a2048675104aa5": "This function tests that the prompt used by an `LLMClient` instance varies depending on whether it is summarizing a class or a function. It uses a mock response from an LLM server and patches the `requests.post` method to return this mock response. The function then calls `client.summarize` twice, once with \"class\" and once with \"function\", capturing the prompts used in each call. Finally, it asserts that the class prompt is formatted according to the `PROMPT_TEMPLATES[\"class\"]` template, the function prompt is formatted according to the `PROMPT_TEMPLATES[\"function\"]` template, and that the two prompts are not equal.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_llm_client.py:test_prompt_varies_by_type:dc769a059a32c6b83f795026d4cca27ede94db70da4e80a99c6050cc9f7136c3": "This function tests that the prompts generated by the `summarize` method of an `LLMClient` instance vary based on the type of code being summarized. It uses a mock response from an LLM client and patches the HTTP POST request to return this mock response. The function then calls the `summarize` method with different types (\"class\" and \"function\") and asserts that the prompts generated for each type are as expected according to predefined templates (`PROMPT_TEMPLATES`). Finally, it checks that the prompts for classes and functions are not equal, ensuring that the prompt generation logic correctly varies by code type.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_llm_client.py:test_readme_prompt_template_used:7f749a4ca95f6cc2e67d34a7f9deb14d3f6ddf60b026408be8796702e24e9e2f": "This function tests the `summarize` method of an `LLMClient` class. It mocks an HTTP POST request to simulate a response from an LLM server. The test checks if the correct prompt template is used for generating documentation summaries, specifically for README files. The prompt template is formatted with the provided text and compared against the expected value.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_llm_client.py:test_readme_prompt_template_used:8fbb4811af123906fe38cb82790fe51e637f65b8f599e8e7d5e7daa1a850106a": "The function `test_readme_prompt_template_used` tests whether the README prompt template is correctly used when summarizing text with an LLM client. It creates a mock response from an LLM server, simulates sending a request to the server using the `LLMClient`, and asserts that the content of the second message in the request matches the expected README prompt formatted with the input text \"foo\".",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_llm_client.py:test_sanitize_summary_filters_phrases:6682721685b8a7fbde493ff08b5f89f161fc0fffa098a6af10b332f16c05e337": "The function `test_sanitize_summary_filters_phrases` tests the `sanitize_summary` function to ensure it filters out specific phrases from the input text. The test case provides a sample text containing various phrases, and the expected output is defined as the text with certain phrases removed. The assertion checks if the `sanitize_summary` function correctly processes the input text to match the expected output.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_llm_client.py:test_sanitize_summary_filters_phrases:ed583b909712934ee3d84874830d151edda27e8cd237726b15224af213fc608b": "The function `test_sanitize_summary_filters_phrases` tests the `sanitize_summary` function to ensure it filters out unwanted phrases from a given text. The test case provides a string containing various phrases, and the expected result is a string with specific phrases removed.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_llm_client.py:test_summarize_raises_runtime_error_with_message:06539a25d9841dc5d40a02d03bf31a3221eb18a2f5f04fff5f10f48924970b0b": "This function tests that the `summarize` method of the `LLMClient` class raises a `RuntimeError` with a specific message when an HTTP error occurs during the request. The test uses mocking to simulate an HTTP error and a JSON parsing error, and then asserts that the expected exception is raised with the correct message.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_llm_client.py:test_summarize_raises_runtime_error_with_message:bc6efa89e152871e6491e50e830e9277ca3756254d27b08b5ba3ef36b5645dfa": "This function tests that the `summarize` method of an `LLMClient` raises a `RuntimeError` with the message \"server exploded\" when it encounters an HTTP error and a JSON parsing error during the request.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_llm_client.py:test_summarize_retries_and_returns_summary:3493e5cb79979bc018fe953048dd9857fbafed7624c89bf333266c44e29c27cb": "This function tests the `summarize` method of an `LLMClient` class. It mocks an HTTP request to simulate a failure and then a successful response from a language model server. The test asserts that the `summarize` method retries on failure, waits for 1 second between attempts, and returns the summary text from the successful response.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_llm_client.py:test_summarize_retries_and_returns_summary:bdd9f2c326ba98287bcce2b140a163a7a58075603c6b88e5f2af466514da7e01": "The function `test_summarize_retries_and_returns_summary` tests the `summarize` method of an `LLMClient` class. It sets up a mock response from a language model server that initially raises an exception and then returns a valid JSON response with a summary message. The test uses patches to simulate network requests and sleep calls. It asserts that the `summarize` method retries once after encountering a request exception, successfully receives the summary, and includes the expected prompt in its second call.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_parser_matlab.py:test_parse_multiple_functions:cc1c5547a2fcd4e4b09aff958a44d4df671d3af9e9a5a6fe4ed7ef61d80d9ab5": "This function `test_parse_multiple_functions` tests the parsing of MATLAB files containing multiple functions. It creates a temporary file with two MATLAB functions, `compute` and `square`, and then uses the `parse_matlab_file` function to parse this file. The test asserts that the parsed result contains an empty header, two functions named \"compute\" and \"square\", and correct argument lists for each function.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_parser_matlab.py:test_parse_multiple_functions:eaa7af864a72465b310fb2a65867014a4b7807b1e5802650be96c474ce4fcb86": "This function, `test_parse_multiple_functions`, is a unit test for parsing MATLAB files. It creates a temporary file with multiple MATLAB functions and uses the `parse_matlab_file` function to parse it. The test checks that the parsed result contains two functions named \"compute\" and \"square\", with the correct arguments.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_parser_matlab.py:test_parse_simple_matlab:5609a258a357bfc9ccad57965167abeb737d8f6e64ecb38b93bbfaa4b54b0198": "This function `test_parse_simple_matlab` tests the parsing of a simple MATLAB file. It creates a temporary file with MATLAB code, then uses the `parse_matlab_file` function to parse it. The test checks that the header is correctly extracted and that one function named `add` with arguments `x` and `y` is identified.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_parser_matlab.py:test_parse_simple_matlab:92b1b4236de3ca9c991e516a6ab1dbd4f416830f3792ff135e9442bdfbbf7bd8": "This function, `test_parse_simple_matlab`, is a unit test for parsing MATLAB files. It creates a temporary file with simple MATLAB code and uses the `parse_matlab_file` function to parse it. The test checks that the header of the MATLAB file is correctly extracted and that there is one function defined, named \"add\", which takes two arguments: \"x\" and \"y\".",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_parser_python.py:test_parse_complex_signature:6ae21a92dadcbd05e2d258e3f3519fda5cd9cfdb63caefed9eeafebcc5c1ff83": "This function tests the parsing of a complex Python function signature. It creates a temporary file with a Python source code snippet containing a function with various parameters and a docstring. The function then uses `parse_python_file` to parse this file and extracts the signature and docstring of the first function defined in the file. Finally, it asserts that the extracted signature matches the expected format and that the docstring is correctly identified within the source code.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_parser_python.py:test_parse_complex_signature:adf8d582d36ead8baf85d3a13f5aba52f8f91e1a15e961e2a73fe425315a9ef0": "This function `test_parse_complex_signature` tests the parsing of a Python file containing a complex function signature. It creates a temporary Python file with a specific docstring and function definition, then uses the `parse_python_file` function to parse this file. The test checks that the parsed signature matches the expected string, that the function's docstring is correctly extracted, and that the docstring appears in the source code of the function.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_parser_python.py:test_parse_simple_module:5b578954a535d4aa34fe9fc7cc4c1add3f67bce57e344c544988fea09d89ef59": "This function tests the `parse_python_file` function by creating a temporary Python file with a simple module containing a class and a function. It then asserts that the parsed result contains the correct module docstring, class name, class docstring, method signature, method docstring, source code of the method, function name, function signature, return type, function docstring, and source code of the function.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_parser_python.py:test_parse_simple_module:7e96abf46f3f7bd623178a9e4efa5ac71ac101080130207bbc99e5cfab58fd55": "This function tests the parsing of a simple Python module. It creates a temporary file with a Python script containing a module docstring, a class with a method, and a standalone function. The `parse_python_file` function is called to parse this file, and the results are asserted to ensure that the parsed data matches the expected values for the module, classes, methods, and functions.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_reviewer.py:_make_module:2e82e1292f7eff8b571cad0af9e456c489fb256bbb3c14d1d3d7e9088735b281": "This function `_make_module` generates a module documentation page for Python projects. It takes three parameters: `tmp_path`, which is the temporary directory where the module will be created; `summary`, which is a summary of the module; and `methods`, which is an optional list of methods to include in the module's class.\n\nThe function creates a dictionary `data` with keys for the module name, summary, classes, and functions. If `methods` is provided, it adds a class named \"Foo\" with empty docstring, summary, and the specified methods to the `data` dictionary under the \"classes\" key.\n\nIt then calls the `write_module_page` function to write the module page to the temporary directory using the provided data and a list of tuples specifying the index file. Finally, it returns the path to the generated module HTML file (`mod.html`).",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_reviewer.py:_make_module:2fa8fa17be65114c249d2a83f30259c9aab503d8f8aa3f9d2921c5308d6a1e08": "The function `_make_module` creates a temporary directory containing a mock Python module page. It takes three parameters: `tmp_path`, which is the path to the temporary directory; `summary`, which is a string summarizing the module; and `methods`, an optional list of dictionaries describing methods within the module's class.\n\nThe function constructs a dictionary `data` representing the module, including its name, summary, classes, and functions. If `methods` are provided, it adds a class named \"Foo\" with empty docstring, summary, and the specified methods to the `classes` list in `data`.\n\nIt then calls `write_module_page` to generate an HTML file for the module page at the specified path, using the `data` dictionary and a list of tuples specifying the index file. The function returns the path to the generated module HTML file (`tmp_path / \"mod.html\"`).",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_reviewer.py:test_assistant_phrasing_detected:4e09942cbef845615eaa3e7f945ac2d2de4e738770331c7f84623a91a15fc981": "This function `test_assistant_phrasing_detected` is designed to test the detection of assistant phrasing in generated documentation. It creates a temporary Python module with a specific phrase, runs the main function of the tool with the temporary directory as input, and captures the output. The function then checks if the output contains both the phrase \"[ASSISTANT]\" and the filename \"mod.html\", indicating that the assistant phrasing was detected and processed correctly during the documentation generation.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_reviewer.py:test_assistant_phrasing_detected:cecd58aafc1f7ff6ff802b2f6a7311f9f5fc059a28790e0a569c6d3bc3e5f95b": "This function tests if assistant phrasing is detected and included in the output when generating documentation. It creates a temporary module with specific content, runs the main function with the path to this module, captures the output, and asserts that both \"[ASSISTANT]\" and \"mod.html\" are present in the output.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_reviewer.py:test_autofix_removes_phrasing:05c2ed98bb01aa45bbf82f73d60220ffa8eef9a6eeda5ea8d35af32e64af04a5": "This function tests the `--autofix` option of the DocGen-LM tool. It creates a temporary directory, generates an HTML file with a specific phrase using `_make_module`, runs the main function with the `--autofix` flag pointing to the temporary directory, and then checks that the phrase has been removed from the generated HTML file.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_reviewer.py:test_autofix_removes_phrasing:12c910b44a08a511a786f0c2de87869d9dcb1e46cea05ac337462fd5bbfc6331": "The function `test_autofix_removes_phrasing` is a unit test for the DocGen-LM project. It checks that the `--autofix` option removes specific phrasing from generated HTML documentation.\n\nHere's what the function does:\n\n1. Creates a temporary directory and generates a Python module file (`_make_module`) with the content \"You can call this.\".\n2. Runs the main function of the DocGen-LM tool with the temporary directory path and the `--autofix` option.\n3. Reads the generated HTML file from the temporary directory.\n4. Asserts that the phrasing \"You can\" is not present in the HTML content, indicating that the autofix feature has successfully removed it.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_reviewer.py:test_contradiction_detected:bc7072b5863d9ba83acb03cd6e0c8e39353929729f50ae4a20d7bed396ce75d8": "This function tests if a contradiction is detected when no methods are defined in a module. It creates a temporary directory, simulates a module with no methods, runs the main function of the documentation generator on this directory, and checks if the output contains the string \"[CONTRADICTION]\".",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_reviewer.py:test_contradiction_detected:ff12ba05eb4c59c33cc696563275631926482ba7981ecf93ac53f12bad3a6ead": "This function `test_contradiction_detected` is designed to test the detection of contradictions within a Python project. It takes two parameters: `tmp_path`, which represents a temporary directory for testing, and `capsys`, which captures the output generated during the test.\n\nThe function starts by defining a list of methods, each represented as a dictionary with keys for the method's name, signature, docstring, and source code. In this case, there is one method named \"bar\" without any implementation details.\n\nNext, the function calls `_make_module` to create a Python module within the temporary directory `tmp_path`. The module is created with a specific content that indicates no methods are defined.\n\nAfter setting up the test environment, the function invokes the `main` function with the path of the temporary directory as an argument. This simulates running the documentation generation tool on the test project.\n\nFinally, the function reads the captured output using `capsys.readouterr().out`. It then asserts that the string \"[CONTRADICTION]\" is present in the output, indicating that a contradiction was detected during the processing of the code files.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_reviewer.py:test_hallucination_detected:29422bf749ed2556c1ad414a7adb7263839fae38e38f6f3fcb6ab632db199386": "This function `test_hallucination_detected` is designed to test for the detection of hallucinations during the documentation generation process. It creates a temporary directory, simulates the creation of a module with a specific description (\"Implements tic-tac-toe features\"), and then runs the main function with this directory as input. The output is captured using `capsys`, and it asserts that the string \"[HALLUCINATION]\" is present in the output, indicating that the system has detected a hallucination during the documentation generation.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_reviewer.py:test_hallucination_detected:bcda0dcd03df9af566deffe2083830dfd3c293ed6bc0b2152e88af2eb2c79fa6": "This function tests for the detection of hallucination in generated documentation. It creates a temporary module with specified content, runs the main function with the path to this module, and captures the output. The test asserts that the string \"[HALLUCINATION]\" is present in the captured output, indicating that the system has detected an anomaly or incorrect information in the generated documentation.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_scanner.py:create_files:1b3bfe74e661982135f820ea40bd70e1792d794fd9972e9e6a6e0eafe9965954": "This function `create_files` takes a base directory and a list of file paths relative to that base. It iterates over each file path, constructs the full path by joining the base directory with the relative path, ensures all parent directories exist (creating them if necessary), and writes an empty string to each file.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_scanner.py:create_files:8dea2fed53d75a54d9cf4b075344a0b16e2b475f8f4ce7344ef30c9bc8836ca7": "The function `create_files` takes a base directory and a list of file paths relative to that base. It iterates over the list, creating any necessary parent directories for each file path using `path.parent.mkdir(parents=True, exist_ok=True)`, and then writes an empty string to each file using `path.write_text(\"\")`.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_scanner.py:test_scan_directory_ignore_folder:3bd703322d553070a04ea880720b2e2c172df8825930d88b9fddc42a5e8b109f": "This function `test_scan_directory_ignore_folder` tests the functionality of scanning a directory while ignoring specified folders. It creates a temporary directory with various files and subdirectories, including some that should be ignored. The function then calls `scan_directory` with the path to the temporary directory and a list of folders to ignore. The result is compared to an expected set of file paths, ensuring that only the files not in the ignored folders are included.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_scanner.py:test_scan_directory_ignore_folder:be5274f17b2ec1526903e0a227069bf75dd8ff6e70cffd88a9aaf89b0c03d6d6": "The function `test_scan_directory_ignore_folder` is a unit test for the `scan_directory` function. It creates a temporary directory with various files and subdirectories, including some that should be ignored based on a specified list of folders to exclude. The test then calls `scan_directory` with the path to the temporary directory and a list containing the folder to ignore (`\"ignore_me\"`). It asserts that the result returned by `scan_directory` matches the expected set of file paths, excluding those within the `\"ignore_me\"` folder.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_scanner.py:test_scan_directory_mixed_file_types:e622a334bdb6c62eecb812acc6a2b831d854548493726916ec20aa3ac8fa1134": "The function `test_scan_directory_mixed_file_types` is a unit test that verifies the functionality of scanning a directory for Python and MATLAB files. It creates a temporary directory with various file types, including Python (`one.py`, `four.py`), MATLAB (`two.m`, `six.m`), text (`three.txt`), and Markdown (`five.md`). The function then calls `scan_directory` with the path to this temporary directory and an empty list of exclude patterns. The expected result is a set containing the paths of all Python and MATLAB files, excluding any other file types. The test asserts that the actual result matches the expected set of file paths.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_scanner.py:test_scan_directory_mixed_file_types:ed422d5f0e8a2ed1bef3333e4ffaee1763a9a255ec94b3f39aa8141acbc92b3f": "The function `test_scan_directory_mixed_file_types` tests the `scan_directory` function with a directory containing files of mixed types (Python, MATLAB, and text). It creates a temporary directory with specified file names and then calls `scan_directory` to get a list of Python paths. The test asserts that the returned set of paths matches the expected set, excluding files with unsupported extensions like `.txt` and `.md`.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_scanner.py:test_scan_directory_skips_git_folder:283034388aa0c075d6b83487f3c6340314e9dd939dc89ba77a6f202f674e427a": "This function tests the `scan_directory` function to ensure it skips files and directories within a `.git` folder. It creates a temporary directory with specified files, including ones inside a `.git` subdirectory. The `scan_directory` function is called with this temporary path and an empty list of ignore patterns. The test asserts that the path to \"good.py\" is included in the result, while paths containing \".git\" are excluded.",
  "REWRITE:C:\\Users\\jtpch\\Documents\\Programming\\PythonProjects\\AutomatedCodeDocumentation\\tests\\test_scanner.py:test_scan_directory_skips_git_folder:e93639b41d1c6b8c3f05c2fd3143d611cb4f7f8dc3ec9e5fc50fa4d6e50d7e58": ""
}