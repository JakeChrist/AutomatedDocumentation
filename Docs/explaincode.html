<!-- Generated by DocGen-LM -->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>explaincode</title>
    <link rel="stylesheet" href="static/style.css">
</head>
<body>
    <button id="sidebar-toggle">Menu</button>
    <div class="sidebar">
        <h2>Navigation</h2>
        <ul>
        <li><a href="index.html"><strong>üè† Project Overview</strong></a></li>
<li><a href="cache.html">cache</a></li>
<li><a href="chunk_utils.html">chunk_utils</a></li>
<li><a href="docgenerator.html">docgenerator</a></li>
<li><a href="explaincode.html">explaincode</a></li>
<li><a href="gui_wrapper.html">gui_wrapper</a></li>
<li><a href="html_writer.html">html_writer</a></li>
<li><a href="llm_client.html">llm_client</a></li>
<li><a href="manual_utils.html">manual_utils</a></li>
<li><a href="parser_matlab.html">parser_matlab</a></li>
<li><a href="parser_python.html">parser_python</a></li>
<li><a href="reviewer.html">reviewer</a></li>
<li><a href="scanner.html">scanner</a></li>
<li><a href="setup.html">setup</a></li>
<li><a href="summarize_utils.html">summarize_utils</a></li>
<li><a href="test_cache.html">test_cache</a></li>
<li><a href="test_chunk_utils.html">test_chunk_utils</a></li>
<li><a href="test_docgenerator.html">test_docgenerator</a></li>
<li><a href="test_docgenerator_subclasses.html">test_docgenerator_subclasses</a></li>
<li><a href="test_explaincode.html">test_explaincode</a></li>
<li><a href="test_html_writer.html">test_html_writer</a></li>
<li><a href="test_integration.html">test_integration</a></li>
<li><a href="test_llm_client.html">test_llm_client</a></li>
<li><a href="test_manual_utils.html">test_manual_utils</a></li>
<li><a href="test_parser_matlab.html">test_parser_matlab</a></li>
<li><a href="test_parser_python.html">test_parser_python</a></li>
<li><a href="test_reviewer.html">test_reviewer</a></li>
<li><a href="test_scanner.html">test_scanner</a></li>
        </ul>
    </div>
    <div class="content">
        <h1>explaincode</h1>
        <p>This module defines a comprehensive project summary generator from existing documentation and sample files. It includes classes and functions for parsing configuration, collecting relevant files, slugifying text, inserting navigation entries into an index file, extracting plain text from various file types, detecting placeholders, mapping evidence to sections, ranking code files based on heuristics, and more. The module also defines functions to extract relevant code snippets from files, collect these snippets based on sections, and generate a manual using an LLM client. It includes utilities for rendering HTML, parsing text into structured sections, validating references, inferring missing sections, and writing the rendered output as a PDF. Additionally, it provides a `main` function that sets up argument parsing for summarizing project documentation, processes command-line arguments to configure parameters, collects documentation files, extracts text, initializes an LLM client, and generates a manual, handling placeholders and rendering the final output in specified formats.</p>
<h2 id="Config">Class: Config</h2>
<p>The `Config` class represents configuration settings parsed from command-line interface arguments. It includes properties such as file paths, output format, title, and various flags controlling behavior like code scanning, chunking, and limits on file size and number.</p>
<h2>Functions</h2>
<h3 id="collect_docs">collect_docs(base: Path) -&gt; list[Path]</h3>
<p>The function `collect_docs` takes a directory path as input and returns a list of paths to documentation files within that directory. It searches for specific file types (`README.md`, `.md`, `.txt`, `.html`, `.docx`) in the project root and within a subdirectory named &quot;docs&quot;. The function ensures that only unique files are returned by using a set to track seen files.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">collect_docs</span>(base: Path) <span style="color: #666666">-&gt;</span> <span style="color: #008000">list</span>[Path]:
<span style="color: #bbbbbb">    </span><span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;Return documentation files under ``base``.</span>

<span style="color: #BA2121; font-style: italic">    Only the following locations and patterns are included:</span>

<span style="color: #BA2121; font-style: italic">    * ``docs/**/*.html`` and ``docs/**/*.md``</span>
<span style="color: #BA2121; font-style: italic">    * Project root ``README.md`` and any ``*.md``, ``*.txt``, ``*.html`` or</span>
<span style="color: #BA2121; font-style: italic">      ``*.docx`` files</span>
<span style="color: #BA2121; font-style: italic">    &quot;&quot;&quot;</span>

    files: <span style="color: #008000">list</span>[Path] <span style="color: #666666">=</span> []
    <span style="color: #008000; font-weight: bold">for</span> pattern <span style="color: #AA22FF; font-weight: bold">in</span> [<span style="color: #BA2121">&quot;README.md&quot;</span>, <span style="color: #BA2121">&quot;*.md&quot;</span>, <span style="color: #BA2121">&quot;*.txt&quot;</span>, <span style="color: #BA2121">&quot;*.html&quot;</span>, <span style="color: #BA2121">&quot;*.docx&quot;</span>]:
        files<span style="color: #666666">.</span>extend(base<span style="color: #666666">.</span>glob(pattern))

    docs_dir <span style="color: #666666">=</span> base <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;docs&quot;</span>
    <span style="color: #008000; font-weight: bold">if</span> docs_dir<span style="color: #666666">.</span>exists():
        <span style="color: #008000; font-weight: bold">for</span> pattern <span style="color: #AA22FF; font-weight: bold">in</span> [<span style="color: #BA2121">&quot;**/*.html&quot;</span>, <span style="color: #BA2121">&quot;**/*.md&quot;</span>]:
            files<span style="color: #666666">.</span>extend(docs_dir<span style="color: #666666">.</span>glob(pattern))

    seen: <span style="color: #008000">set</span>[Path] <span style="color: #666666">=</span> <span style="color: #008000">set</span>()
    unique: <span style="color: #008000">list</span>[Path] <span style="color: #666666">=</span> []
    <span style="color: #008000; font-weight: bold">for</span> f <span style="color: #AA22FF; font-weight: bold">in</span> files:
        <span style="color: #008000; font-weight: bold">if</span> f<span style="color: #666666">.</span>is_file() <span style="color: #AA22FF; font-weight: bold">and</span> f <span style="color: #AA22FF; font-weight: bold">not</span> <span style="color: #AA22FF; font-weight: bold">in</span> seen:
            unique<span style="color: #666666">.</span>append(f)
            seen<span style="color: #666666">.</span>add(f)
    <span style="color: #008000; font-weight: bold">return</span> unique
</code></pre>
<h3 id="collect_files">collect_files(base: Path, extra_patterns: Iterable[str] | None=None) -&gt; Iterable[Path]</h3>
<p>The `collect_files` function returns a list of file paths from the specified base directory that are relevant for summarization. It starts with predefined patterns for common documentation and text files, then adds any additional patterns provided by the user. The function ensures that only unique files are returned by using a set to track seen files.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">collect_files</span>(base: Path, extra_patterns: Iterable[<span style="color: #008000">str</span>] <span style="color: #666666">|</span> <span style="color: #008000; font-weight: bold">None</span> <span style="color: #666666">=</span> <span style="color: #008000; font-weight: bold">None</span>) <span style="color: #666666">-&gt;</span> Iterable[Path]:
<span style="color: #bbbbbb">    </span><span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;Return files from *base* relevant for summarisation.&quot;&quot;&quot;</span>
    patterns <span style="color: #666666">=</span> [
        <span style="color: #BA2121">&quot;README.md&quot;</span>,
        <span style="color: #BA2121">&quot;*.txt&quot;</span>,
        <span style="color: #BA2121">&quot;*.html&quot;</span>,
        <span style="color: #BA2121">&quot;*.docx&quot;</span>,
        <span style="color: #BA2121">&quot;*.csv&quot;</span>,
        <span style="color: #BA2121">&quot;*.json&quot;</span>,
    ]

    files: <span style="color: #008000">list</span>[Path] <span style="color: #666666">=</span> []
    <span style="color: #008000; font-weight: bold">for</span> pattern <span style="color: #AA22FF; font-weight: bold">in</span> patterns:
        files<span style="color: #666666">.</span>extend(base<span style="color: #666666">.</span>rglob(pattern))

    <span style="color: #008000; font-weight: bold">if</span> extra_patterns:
        <span style="color: #008000; font-weight: bold">for</span> pattern <span style="color: #AA22FF; font-weight: bold">in</span> extra_patterns:
            files<span style="color: #666666">.</span>extend(base<span style="color: #666666">.</span>rglob(pattern))

    seen: <span style="color: #008000">set</span>[Path] <span style="color: #666666">=</span> <span style="color: #008000">set</span>()
    unique: <span style="color: #008000">list</span>[Path] <span style="color: #666666">=</span> []
    <span style="color: #008000; font-weight: bold">for</span> f <span style="color: #AA22FF; font-weight: bold">in</span> files:
        <span style="color: #008000; font-weight: bold">if</span> f<span style="color: #666666">.</span>is_file() <span style="color: #AA22FF; font-weight: bold">and</span> f <span style="color: #AA22FF; font-weight: bold">not</span> <span style="color: #AA22FF; font-weight: bold">in</span> seen:
            unique<span style="color: #666666">.</span>append(f)
            seen<span style="color: #666666">.</span>add(f)
    <span style="color: #008000; font-weight: bold">return</span> unique
</code></pre>
<h3 id="slugify">slugify(text: str) -&gt; str</h3>
<p>The `slugify` function takes a string `text` and returns a filesystem-friendly slug. It removes all characters except lowercase letters and digits, replaces them with underscores, strips leading and trailing underscores, and ensures the result is not empty by defaulting to `&quot;user_manual&quot;` if the input is invalid or empty.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">slugify</span>(text: <span style="color: #008000">str</span>) <span style="color: #666666">-&gt;</span> <span style="color: #008000">str</span>:
<span style="color: #bbbbbb">    </span><span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;Return filesystem-friendly slug from ``text``.&quot;&quot;&quot;</span>
    slug <span style="color: #666666">=</span> re<span style="color: #666666">.</span>sub(<span style="color: #BA2121">r&quot;[^a-z0-9]+&quot;</span>, <span style="color: #BA2121">&quot;_&quot;</span>, text<span style="color: #666666">.</span>strip()<span style="color: #666666">.</span>lower())
    <span style="color: #008000; font-weight: bold">return</span> slug<span style="color: #666666">.</span>strip(<span style="color: #BA2121">&quot;_&quot;</span>) <span style="color: #AA22FF; font-weight: bold">or</span> <span style="color: #BA2121">&quot;user_manual&quot;</span>
</code></pre>
<h3 id="insert_into_index">insert_into_index(index_path: Path, title: str, filename: str) -&gt; None</h3>
<p>The function `insert_into_index` appends a navigation entry linking to a specified file into an HTML index file. It reads the existing content of the index file using BeautifulSoup, finds or creates a `&lt;ul&gt;` or `&lt;nav&gt;` container element, and checks if an entry for the given filename already exists. If not, it creates a new anchor tag with the provided title and appends it to the container. Finally, it writes the updated HTML back to the index file.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">insert_into_index</span>(index_path: Path, title: <span style="color: #008000">str</span>, filename: <span style="color: #008000">str</span>) <span style="color: #666666">-&gt;</span> <span style="color: #008000; font-weight: bold">None</span>:
<span style="color: #bbbbbb">    </span><span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;Append a navigation entry linking to ``filename`` into ``index_path``.&quot;&quot;&quot;</span>
    <span style="color: #008000; font-weight: bold">try</span>:
        soup <span style="color: #666666">=</span> BeautifulSoup(index_path<span style="color: #666666">.</span>read_text(encoding<span style="color: #666666">=</span><span style="color: #BA2121">&quot;utf-8&quot;</span>), <span style="color: #BA2121">&quot;html.parser&quot;</span>)
    <span style="color: #008000; font-weight: bold">except</span> <span style="color: #CB3F38; font-weight: bold">Exception</span>:
        <span style="color: #008000; font-weight: bold">return</span>

    container <span style="color: #666666">=</span> soup<span style="color: #666666">.</span>find(<span style="color: #BA2121">&quot;ul&quot;</span>) <span style="color: #AA22FF; font-weight: bold">or</span> soup<span style="color: #666666">.</span>find(<span style="color: #BA2121">&quot;nav&quot;</span>)
    <span style="color: #008000; font-weight: bold">if</span> container <span style="color: #AA22FF; font-weight: bold">is</span> <span style="color: #008000; font-weight: bold">None</span>:
        <span style="color: #008000; font-weight: bold">return</span>

    <span style="color: #008000; font-weight: bold">if</span> container<span style="color: #666666">.</span>find(<span style="color: #BA2121">&quot;a&quot;</span>, href<span style="color: #666666">=</span>filename):
        <span style="color: #008000; font-weight: bold">return</span>

    a <span style="color: #666666">=</span> soup<span style="color: #666666">.</span>new_tag(<span style="color: #BA2121">&quot;a&quot;</span>, href<span style="color: #666666">=</span>filename)
    a<span style="color: #666666">.</span>string <span style="color: #666666">=</span> title

    <span style="color: #008000; font-weight: bold">if</span> container<span style="color: #666666">.</span>name <span style="color: #666666">==</span> <span style="color: #BA2121">&quot;ul&quot;</span>:
        li <span style="color: #666666">=</span> soup<span style="color: #666666">.</span>new_tag(<span style="color: #BA2121">&quot;li&quot;</span>)
        li<span style="color: #666666">.</span>append(a)
        container<span style="color: #666666">.</span>append(li)
    <span style="color: #008000; font-weight: bold">else</span>:  <span style="color: #3D7B7B; font-style: italic"># append directly to a nav element</span>
        container<span style="color: #666666">.</span>append(a)

    index_path<span style="color: #666666">.</span>write_text(<span style="color: #008000">str</span>(soup), encoding<span style="color: #666666">=</span><span style="color: #BA2121">&quot;utf-8&quot;</span>)
</code></pre>
<h3 id="inject_user_manual">inject_user_manual(index_path: Path, title: str, filename: str) -&gt; None</h3>
<p>Inserts a top-level link to a user manual into an HTML file specified by `index_path`. The link is added to the first `&lt;nav&gt;` or `&lt;ul&gt;` element if present; otherwise, it is inserted at the start of the first `&lt;body&gt;` element or the document root.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">inject_user_manual</span>(index_path: Path, title: <span style="color: #008000">str</span>, filename: <span style="color: #008000">str</span>) <span style="color: #666666">-&gt;</span> <span style="color: #008000; font-weight: bold">None</span>:
<span style="color: #bbbbbb">    </span><span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;Insert a top-level link to the manual into ``index_path``.</span>

<span style="color: #BA2121; font-style: italic">    The link is prepended to the first navigation element (``&lt;nav&gt;`` or ``&lt;ul&gt;``)</span>
<span style="color: #BA2121; font-style: italic">    if present. If neither is found, it is inserted at the start of the first</span>
<span style="color: #BA2121; font-style: italic">    element in ``&lt;body&gt;`` or the document root.</span>
<span style="color: #BA2121; font-style: italic">    &quot;&quot;&quot;</span>

    <span style="color: #008000; font-weight: bold">try</span>:
        soup <span style="color: #666666">=</span> BeautifulSoup(index_path<span style="color: #666666">.</span>read_text(encoding<span style="color: #666666">=</span><span style="color: #BA2121">&quot;utf-8&quot;</span>), <span style="color: #BA2121">&quot;html.parser&quot;</span>)
    <span style="color: #008000; font-weight: bold">except</span> <span style="color: #CB3F38; font-weight: bold">Exception</span>:
        <span style="color: #008000; font-weight: bold">return</span>

    a <span style="color: #666666">=</span> soup<span style="color: #666666">.</span>new_tag(<span style="color: #BA2121">&quot;a&quot;</span>, href<span style="color: #666666">=</span>filename)
    a<span style="color: #666666">.</span>string <span style="color: #666666">=</span> title

    nav <span style="color: #666666">=</span> soup<span style="color: #666666">.</span>find(<span style="color: #BA2121">&quot;nav&quot;</span>)
    <span style="color: #008000; font-weight: bold">if</span> nav <span style="color: #AA22FF; font-weight: bold">is</span> <span style="color: #AA22FF; font-weight: bold">not</span> <span style="color: #008000; font-weight: bold">None</span>:
        container <span style="color: #666666">=</span> nav<span style="color: #666666">.</span>find(<span style="color: #BA2121">&quot;ul&quot;</span>) <span style="color: #AA22FF; font-weight: bold">or</span> nav
    <span style="color: #008000; font-weight: bold">else</span>:
        hero <span style="color: #666666">=</span> soup<span style="color: #666666">.</span>find(class_<span style="color: #666666">=</span>re<span style="color: #666666">.</span>compile(<span style="color: #BA2121">&quot;hero&quot;</span>, re<span style="color: #666666">.</span>IGNORECASE))
        container <span style="color: #666666">=</span> hero <span style="color: #AA22FF; font-weight: bold">or</span> soup<span style="color: #666666">.</span>find(<span style="color: #BA2121">&quot;ul&quot;</span>) <span style="color: #AA22FF; font-weight: bold">or</span> soup<span style="color: #666666">.</span>body <span style="color: #AA22FF; font-weight: bold">or</span> soup

    <span style="color: #008000; font-weight: bold">if</span> container<span style="color: #666666">.</span>name <span style="color: #666666">==</span> <span style="color: #BA2121">&quot;ul&quot;</span>:
        li <span style="color: #666666">=</span> soup<span style="color: #666666">.</span>new_tag(<span style="color: #BA2121">&quot;li&quot;</span>)
        li<span style="color: #666666">.</span>append(a)
        container<span style="color: #666666">.</span>insert(<span style="color: #666666">0</span>, li)
    <span style="color: #008000; font-weight: bold">else</span>:
        container<span style="color: #666666">.</span>insert(<span style="color: #666666">0</span>, a)

    index_path<span style="color: #666666">.</span>write_text(<span style="color: #008000">str</span>(soup), encoding<span style="color: #666666">=</span><span style="color: #BA2121">&quot;utf-8&quot;</span>)
</code></pre>
<h3 id="extract_text">extract_text(path: Path) -&gt; str</h3>
<p>The function `extract_text` reads and processes the content of a file located at the given `path`. It determines the file type based on its suffix (extension) and extracts plain text accordingly. For HTML files, it uses BeautifulSoup to clean and modify the content by replacing headings with Markdown-style headers and code blocks with fenced code blocks. Markdown files are read directly. For `.docx` files, if the `Document` class from the `python-docx` library is available, it reads the document and converts headings to Markdown-style headers while preserving other text. If any exceptions occur during processing, an empty string is returned.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">extract_text</span>(path: Path) <span style="color: #666666">-&gt;</span> <span style="color: #008000">str</span>:
<span style="color: #bbbbbb">    </span><span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;Extract plain text from ``path`` based on its file type.&quot;&quot;&quot;</span>
    suffix <span style="color: #666666">=</span> path<span style="color: #666666">.</span>suffix<span style="color: #666666">.</span>lower()
    <span style="color: #008000; font-weight: bold">try</span>:
        <span style="color: #008000; font-weight: bold">if</span> suffix <span style="color: #666666">==</span> <span style="color: #BA2121">&quot;.html&quot;</span>:
            content <span style="color: #666666">=</span> path<span style="color: #666666">.</span>read_text(encoding<span style="color: #666666">=</span><span style="color: #BA2121">&quot;utf-8&quot;</span>)
            soup <span style="color: #666666">=</span> BeautifulSoup(content, <span style="color: #BA2121">&quot;html.parser&quot;</span>)
            <span style="color: #008000; font-weight: bold">for</span> heading <span style="color: #AA22FF; font-weight: bold">in</span> soup<span style="color: #666666">.</span>find_all([<span style="color: #BA2121">f&quot;h</span><span style="color: #A45A77; font-weight: bold">{</span>i<span style="color: #A45A77; font-weight: bold">}</span><span style="color: #BA2121">&quot;</span> <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(<span style="color: #666666">1</span>, <span style="color: #666666">7</span>)]):
                level <span style="color: #666666">=</span> <span style="color: #008000">int</span>(heading<span style="color: #666666">.</span>name[<span style="color: #666666">1</span>])
                text <span style="color: #666666">=</span> heading<span style="color: #666666">.</span>get_text(<span style="color: #BA2121">&quot; &quot;</span>, strip<span style="color: #666666">=</span><span style="color: #008000; font-weight: bold">True</span>)
                heading<span style="color: #666666">.</span>replace_with(soup<span style="color: #666666">.</span>new_string(<span style="color: #BA2121">&quot;#&quot;</span> <span style="color: #666666">*</span> level <span style="color: #666666">+</span> <span style="color: #BA2121">&quot; &quot;</span> <span style="color: #666666">+</span> text))
            <span style="color: #008000; font-weight: bold">for</span> pre <span style="color: #AA22FF; font-weight: bold">in</span> soup<span style="color: #666666">.</span>find_all(<span style="color: #BA2121">&quot;pre&quot;</span>):
                code <span style="color: #666666">=</span> pre<span style="color: #666666">.</span>get_text()
                fenced <span style="color: #666666">=</span> <span style="color: #BA2121">&quot;```</span><span style="color: #AA5D1F; font-weight: bold">\n</span><span style="color: #BA2121">&quot;</span> <span style="color: #666666">+</span> code<span style="color: #666666">.</span>strip(<span style="color: #BA2121">&quot;</span><span style="color: #AA5D1F; font-weight: bold">\n</span><span style="color: #BA2121">&quot;</span>) <span style="color: #666666">+</span> <span style="color: #BA2121">&quot;</span><span style="color: #AA5D1F; font-weight: bold">\n</span><span style="color: #BA2121">```&quot;</span>
                pre<span style="color: #666666">.</span>replace_with(soup<span style="color: #666666">.</span>new_string(fenced))
            text <span style="color: #666666">=</span> soup<span style="color: #666666">.</span>get_text(<span style="color: #BA2121">&quot;</span><span style="color: #AA5D1F; font-weight: bold">\n</span><span style="color: #BA2121">&quot;</span>)
            lines <span style="color: #666666">=</span> [line<span style="color: #666666">.</span>strip() <span style="color: #008000; font-weight: bold">for</span> line <span style="color: #AA22FF; font-weight: bold">in</span> text<span style="color: #666666">.</span>splitlines()]
            <span style="color: #008000; font-weight: bold">return</span> <span style="color: #BA2121">&quot;</span><span style="color: #AA5D1F; font-weight: bold">\n</span><span style="color: #BA2121">&quot;</span><span style="color: #666666">.</span>join(line <span style="color: #008000; font-weight: bold">for</span> line <span style="color: #AA22FF; font-weight: bold">in</span> lines <span style="color: #008000; font-weight: bold">if</span> line)
        <span style="color: #008000; font-weight: bold">if</span> suffix <span style="color: #AA22FF; font-weight: bold">in</span> {<span style="color: #BA2121">&quot;.md&quot;</span>}:
            <span style="color: #008000; font-weight: bold">return</span> path<span style="color: #666666">.</span>read_text(encoding<span style="color: #666666">=</span><span style="color: #BA2121">&quot;utf-8&quot;</span>)
        <span style="color: #008000; font-weight: bold">if</span> suffix <span style="color: #666666">==</span> <span style="color: #BA2121">&quot;.docx&quot;</span> <span style="color: #AA22FF; font-weight: bold">and</span> Document <span style="color: #AA22FF; font-weight: bold">is</span> <span style="color: #AA22FF; font-weight: bold">not</span> <span style="color: #008000; font-weight: bold">None</span>:
            doc <span style="color: #666666">=</span> Document(<span style="color: #008000">str</span>(path))
            lines <span style="color: #666666">=</span> []
            <span style="color: #008000; font-weight: bold">for</span> p <span style="color: #AA22FF; font-weight: bold">in</span> doc<span style="color: #666666">.</span>paragraphs:
                text <span style="color: #666666">=</span> p<span style="color: #666666">.</span>text<span style="color: #666666">.</span>strip()
                <span style="color: #008000; font-weight: bold">if</span> <span style="color: #AA22FF; font-weight: bold">not</span> text:
                    <span style="color: #008000; font-weight: bold">continue</span>
                style <span style="color: #666666">=</span> <span style="color: #008000">getattr</span>(p<span style="color: #666666">.</span>style, <span style="color: #BA2121">&quot;name&quot;</span>, <span style="color: #BA2121">&quot;&quot;</span>)
                <span style="color: #008000; font-weight: bold">if</span> style<span style="color: #666666">.</span>startswith(<span style="color: #BA2121">&quot;Heading&quot;</span>):
                    <span style="color: #008000; font-weight: bold">try</span>:
                        level <span style="color: #666666">=</span> <span style="color: #008000">int</span>(style<span style="color: #666666">.</span>split()[<span style="color: #666666">1</span>])
                        lines<span style="color: #666666">.</span>append(<span style="color: #BA2121">&quot;#&quot;</span> <span style="color: #666666">*</span> level <span style="color: #666666">+</span> <span style="color: #BA2121">&quot; &quot;</span> <span style="color: #666666">+</span> text)
                    <span style="color: #008000; font-weight: bold">except</span> <span style="color: #CB3F38; font-weight: bold">Exception</span>:
                        lines<span style="color: #666666">.</span>append(text)
                <span style="color: #008000; font-weight: bold">else</span>:
                    lines<span style="color: #666666">.</span>append(text)
            <span style="color: #008000; font-weight: bold">return</span> <span style="color: #BA2121">&quot;</span><span style="color: #AA5D1F; font-weight: bold">\n</span><span style="color: #BA2121">&quot;</span><span style="color: #666666">.</span>join(lines)
        <span style="color: #008000; font-weight: bold">return</span> path<span style="color: #666666">.</span>read_text(encoding<span style="color: #666666">=</span><span style="color: #BA2121">&quot;utf-8&quot;</span>)
    <span style="color: #008000; font-weight: bold">except</span> <span style="color: #CB3F38; font-weight: bold">Exception</span>:
        <span style="color: #008000; font-weight: bold">return</span> <span style="color: #BA2121">&quot;&quot;</span>
</code></pre>
<h3 id="detect_placeholders">detect_placeholders(text: str) -&gt; list[str]</h3>
<p>The function `detect_placeholders` takes a string `text` as input and returns a list of section names that are still marked by placeholder tokens. It uses the helper function `find_placeholders` to identify all placeholders in the text. Then, it filters these placeholders against a predefined dictionary `SECTION_PLACEHOLDERS`, which maps section names to their corresponding placeholder tokens. The function collects and returns the names of sections where the placeholder token is found in the input text.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">detect_placeholders</span>(text: <span style="color: #008000">str</span>) <span style="color: #666666">-&gt;</span> <span style="color: #008000">list</span>[<span style="color: #008000">str</span>]:
<span style="color: #bbbbbb">    </span><span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;Return section names still marked by placeholder tokens.&quot;&quot;&quot;</span>
    tokens <span style="color: #666666">=</span> find_placeholders(text)
    <span style="color: #008000; font-weight: bold">return</span> [name <span style="color: #008000; font-weight: bold">for</span> name, token <span style="color: #AA22FF; font-weight: bold">in</span> SECTION_PLACEHOLDERS<span style="color: #666666">.</span>items() <span style="color: #008000; font-weight: bold">if</span> token <span style="color: #AA22FF; font-weight: bold">in</span> tokens]
</code></pre>
<h3 id="map_evidence_to_sections">map_evidence_to_sections(docs: dict[Path, str]) -&gt; tuple[dict[str, list[tuple[Path, str]]], dict[Path, set[str]]]</h3>
<p>The function `map_evidence_to_sections` processes a dictionary of documentation snippets indexed by file paths and maps them to sections based on predefined keywords. It returns a tuple containing two dictionaries: `section_map`, which maps section names to a list of tuples (file path, snippet), and `file_map`, which maps each file path to the set of sections it contributes to. The function ensures that only the top 10 snippets per section are kept, with an exception for the &quot;Overview&quot; section in excluded directories. It also handles sorting based on priority and snippet length.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">map_evidence_to_sections</span>(
    docs: <span style="color: #008000">dict</span>[Path, <span style="color: #008000">str</span>]
) <span style="color: #666666">-&gt;</span> <span style="color: #008000">tuple</span>[<span style="color: #008000">dict</span>[<span style="color: #008000">str</span>, <span style="color: #008000">list</span>[<span style="color: #008000">tuple</span>[Path, <span style="color: #008000">str</span>]]], <span style="color: #008000">dict</span>[Path, <span style="color: #008000">set</span>[<span style="color: #008000">str</span>]]]:
<span style="color: #bbbbbb">    </span><span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;Map documentation snippets to manual sections.</span>

<span style="color: #BA2121; font-style: italic">    Returns a tuple ``(section_map, file_map)`` where ``section_map`` maps</span>
<span style="color: #BA2121; font-style: italic">    section names to a list of ``(source_path, snippet)`` tuples and</span>
<span style="color: #BA2121; font-style: italic">    ``file_map`` maps each ``source_path`` to the set of sections it</span>
<span style="color: #BA2121; font-style: italic">    contributed to. Only the top 10 snippets (by length) are kept per</span>
<span style="color: #BA2121; font-style: italic">    section.</span>
<span style="color: #BA2121; font-style: italic">    &quot;&quot;&quot;</span>

    section_map: <span style="color: #008000">dict</span>[<span style="color: #008000">str</span>, <span style="color: #008000">list</span>[<span style="color: #008000">tuple</span>[Path, <span style="color: #008000">str</span>]]] <span style="color: #666666">=</span> {
        name: [] <span style="color: #008000; font-weight: bold">for</span> name <span style="color: #AA22FF; font-weight: bold">in</span> SECTION_KEYWORDS
    }
    file_map: <span style="color: #008000">dict</span>[Path, <span style="color: #008000">set</span>[<span style="color: #008000">str</span>]] <span style="color: #666666">=</span> {}

    skip_dirs <span style="color: #666666">=</span> {<span style="color: #BA2121">&quot;tests&quot;</span>, <span style="color: #BA2121">&quot;examples&quot;</span>, <span style="color: #BA2121">&quot;fixtures&quot;</span>}
    <span style="color: #008000; font-weight: bold">for</span> path, text <span style="color: #AA22FF; font-weight: bold">in</span> docs<span style="color: #666666">.</span>items():
        parts_lower <span style="color: #666666">=</span> {p<span style="color: #666666">.</span>lower() <span style="color: #008000; font-weight: bold">for</span> p <span style="color: #AA22FF; font-weight: bold">in</span> path<span style="color: #666666">.</span>parts}
        in_excluded_dir <span style="color: #666666">=</span> <span style="color: #008000">bool</span>(skip_dirs <span style="color: #666666">&amp;</span> parts_lower)
        lines <span style="color: #666666">=</span> text<span style="color: #666666">.</span>splitlines()
        <span style="color: #008000; font-weight: bold">for</span> idx, line <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">enumerate</span>(lines):
            lowered <span style="color: #666666">=</span> line<span style="color: #666666">.</span>strip()<span style="color: #666666">.</span>lower()
            <span style="color: #008000; font-weight: bold">for</span> section, keywords <span style="color: #AA22FF; font-weight: bold">in</span> SECTION_KEYWORDS<span style="color: #666666">.</span>items():
                <span style="color: #008000; font-weight: bold">if</span> <span style="color: #008000">any</span>(re<span style="color: #666666">.</span>search(<span style="color: #BA2121">rf&quot;\b</span><span style="color: #A45A77; font-weight: bold">{</span>re<span style="color: #666666">.</span>escape(k)<span style="color: #A45A77; font-weight: bold">}</span><span style="color: #BA2121">\b&quot;</span>, lowered) <span style="color: #008000; font-weight: bold">for</span> k <span style="color: #AA22FF; font-weight: bold">in</span> keywords):
                    max_lines <span style="color: #666666">=</span> <span style="color: #666666">0</span> <span style="color: #008000; font-weight: bold">if</span> in_excluded_dir <span style="color: #008000; font-weight: bold">else</span> MAX_SNIPPET_LINES
                    snippet_lines: <span style="color: #008000">list</span>[<span style="color: #008000">str</span>] <span style="color: #666666">=</span> []
                    j <span style="color: #666666">=</span> idx <span style="color: #666666">+</span> <span style="color: #666666">1</span>
                    <span style="color: #008000; font-weight: bold">while</span> j <span style="color: #666666">&lt;</span> <span style="color: #008000">len</span>(lines) <span style="color: #AA22FF; font-weight: bold">and</span> <span style="color: #008000">len</span>(snippet_lines) <span style="color: #666666">&lt;</span> max_lines:
                        nxt <span style="color: #666666">=</span> lines[j]
                        <span style="color: #008000; font-weight: bold">if</span> <span style="color: #AA22FF; font-weight: bold">not</span> nxt<span style="color: #666666">.</span>strip():
                            <span style="color: #008000; font-weight: bold">break</span>
                        <span style="color: #008000; font-weight: bold">if</span> nxt<span style="color: #666666">.</span>lstrip()<span style="color: #666666">.</span>startswith(<span style="color: #BA2121">&quot;#&quot;</span>) <span style="color: #AA22FF; font-weight: bold">or</span> re<span style="color: #666666">.</span>match(<span style="color: #BA2121">r&quot;\s*&lt;h[1-6]&quot;</span>, nxt):
                            <span style="color: #008000; font-weight: bold">break</span>
                        snippet_lines<span style="color: #666666">.</span>append(nxt<span style="color: #666666">.</span>strip())
                        j <span style="color: #666666">+=</span> <span style="color: #666666">1</span>
                    snippet <span style="color: #666666">=</span> line<span style="color: #666666">.</span>strip()
                    <span style="color: #008000; font-weight: bold">if</span> snippet_lines:
                        snippet <span style="color: #666666">+=</span> <span style="color: #BA2121">&quot;</span><span style="color: #AA5D1F; font-weight: bold">\n</span><span style="color: #BA2121">&quot;</span> <span style="color: #666666">+</span> <span style="color: #BA2121">&quot; &quot;</span><span style="color: #666666">.</span>join(snippet_lines)<span style="color: #666666">.</span>strip()
                    <span style="color: #008000; font-weight: bold">if</span> snippet:
                        <span style="color: #008000; font-weight: bold">if</span> section <span style="color: #666666">==</span> <span style="color: #BA2121">&quot;Overview&quot;</span> <span style="color: #AA22FF; font-weight: bold">and</span> in_excluded_dir:
                            <span style="color: #008000; font-weight: bold">break</span>
                        section_map[section]<span style="color: #666666">.</span>append((path, snippet))
                        file_map<span style="color: #666666">.</span>setdefault(path, <span style="color: #008000">set</span>())<span style="color: #666666">.</span>add(section)
                    <span style="color: #008000; font-weight: bold">break</span>

    <span style="color: #008000; font-weight: bold">for</span> section <span style="color: #AA22FF; font-weight: bold">in</span> section_map:
        entries <span style="color: #666666">=</span> section_map[section]
        <span style="color: #008000; font-weight: bold">if</span> section <span style="color: #666666">==</span> <span style="color: #BA2121">&quot;Overview&quot;</span>:
            <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">_key</span>(item: <span style="color: #008000">tuple</span>[Path, <span style="color: #008000">str</span>]) <span style="color: #666666">-&gt;</span> <span style="color: #008000">tuple</span>[<span style="color: #008000">int</span>, <span style="color: #008000">int</span>]:
                p, snip <span style="color: #666666">=</span> item
                parts_lower <span style="color: #666666">=</span> [part<span style="color: #666666">.</span>lower() <span style="color: #008000; font-weight: bold">for</span> part <span style="color: #AA22FF; font-weight: bold">in</span> p<span style="color: #666666">.</span>parts]
                in_docs <span style="color: #666666">=</span> <span style="color: #BA2121">&quot;docs&quot;</span> <span style="color: #AA22FF; font-weight: bold">in</span> parts_lower
                is_readme <span style="color: #666666">=</span> p<span style="color: #666666">.</span>name<span style="color: #666666">.</span>lower() <span style="color: #666666">==</span> <span style="color: #BA2121">&quot;readme.md&quot;</span>
                priority <span style="color: #666666">=</span> <span style="color: #666666">0</span> <span style="color: #008000; font-weight: bold">if</span> is_readme <span style="color: #AA22FF; font-weight: bold">or</span> in_docs <span style="color: #008000; font-weight: bold">else</span> <span style="color: #666666">1</span>
                <span style="color: #008000; font-weight: bold">return</span> (priority, <span style="color: #666666">-</span><span style="color: #008000">len</span>(snip))

            entries<span style="color: #666666">.</span>sort(key<span style="color: #666666">=</span>_key)
        <span style="color: #008000; font-weight: bold">else</span>:
            entries<span style="color: #666666">.</span>sort(key<span style="color: #666666">=</span><span style="color: #008000; font-weight: bold">lambda</span> x: <span style="color: #008000">len</span>(x[<span style="color: #666666">1</span>]), reverse<span style="color: #666666">=</span><span style="color: #008000; font-weight: bold">True</span>)
        section_map[section] <span style="color: #666666">=</span> entries[:<span style="color: #666666">10</span>]

    <span style="color: #008000; font-weight: bold">return</span> section_map, file_map
</code></pre>
<h3 id="rank_code_files">rank_code_files(root: Path, patterns: list[str]) -&gt; list[Path]</h3>
<p>The function `rank_code_files` ranks Python, MATLAB, C++, C header, and Java code files within a specified directory based on their relevance to documentation. It uses a combination of file extensions, directory names, and keyword patterns to assign scores to each file. The ranking is determined by the highest score, with ties broken by lexicographical order of the file paths.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">rank_code_files</span>(root: Path, patterns: <span style="color: #008000">list</span>[<span style="color: #008000">str</span>]) <span style="color: #666666">-&gt;</span> <span style="color: #008000">list</span>[Path]:
<span style="color: #bbbbbb">    </span><span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;Return code files under ``root`` ranked by simple heuristics.

    Supports ``.py``, ``.m``, ``.ipynb``, ``.cpp``, ``.h``, and ``.java`` files.
    &quot;&quot;&quot;</span>

    allowed_exts <span style="color: #666666">=</span> {<span style="color: #BA2121">&quot;.py&quot;</span>, <span style="color: #BA2121">&quot;.m&quot;</span>, <span style="color: #BA2121">&quot;.ipynb&quot;</span>, <span style="color: #BA2121">&quot;.cpp&quot;</span>, <span style="color: #BA2121">&quot;.h&quot;</span>, <span style="color: #BA2121">&quot;.java&quot;</span>}
    skip_dirs <span style="color: #666666">=</span> {
        <span style="color: #BA2121">&quot;venv&quot;</span>,
        <span style="color: #BA2121">&quot;.git&quot;</span>,
        <span style="color: #BA2121">&quot;__pycache__&quot;</span>,
        <span style="color: #BA2121">&quot;node_modules&quot;</span>,
        <span style="color: #BA2121">&quot;dist&quot;</span>,
        <span style="color: #BA2121">&quot;build&quot;</span>,
        <span style="color: #BA2121">&quot;tests&quot;</span>,
        <span style="color: #BA2121">&quot;test&quot;</span>,
        <span style="color: #BA2121">&quot;examples&quot;</span>,
        <span style="color: #BA2121">&quot;example&quot;</span>,
        <span style="color: #BA2121">&quot;samples&quot;</span>,
        <span style="color: #BA2121">&quot;sample&quot;</span>,
        <span style="color: #BA2121">&quot;fixtures&quot;</span>,
        <span style="color: #BA2121">&quot;fixture&quot;</span>,
    }
    keyword_re <span style="color: #666666">=</span> re<span style="color: #666666">.</span>compile(
        <span style="color: #BA2121">r&quot;run|main|cli|config|io|dataset|reader|writer|pipeline&quot;</span>, re<span style="color: #666666">.</span>IGNORECASE
    )
    doc_refs <span style="color: #666666">=</span> {p<span style="color: #666666">.</span>lower() <span style="color: #008000; font-weight: bold">for</span> p <span style="color: #AA22FF; font-weight: bold">in</span> patterns}

    ranked: <span style="color: #008000">list</span>[<span style="color: #008000">tuple</span>[<span style="color: #008000">int</span>, Path]] <span style="color: #666666">=</span> []
    <span style="color: #008000; font-weight: bold">for</span> dirpath, dirnames, filenames <span style="color: #AA22FF; font-weight: bold">in</span> os<span style="color: #666666">.</span>walk(root):
        dirnames[:] <span style="color: #666666">=</span> [
            d <span style="color: #008000; font-weight: bold">for</span> d <span style="color: #AA22FF; font-weight: bold">in</span> dirnames
            <span style="color: #008000; font-weight: bold">if</span> d<span style="color: #666666">.</span>lower() <span style="color: #AA22FF; font-weight: bold">not</span> <span style="color: #AA22FF; font-weight: bold">in</span> skip_dirs <span style="color: #AA22FF; font-weight: bold">and</span> <span style="color: #AA22FF; font-weight: bold">not</span> d<span style="color: #666666">.</span>endswith(<span style="color: #BA2121">&quot;.egg-info&quot;</span>)
        ]
        <span style="color: #008000; font-weight: bold">for</span> filename <span style="color: #AA22FF; font-weight: bold">in</span> filenames:
            path <span style="color: #666666">=</span> Path(dirpath) <span style="color: #666666">/</span> filename
            <span style="color: #008000; font-weight: bold">if</span> path<span style="color: #666666">.</span>suffix <span style="color: #AA22FF; font-weight: bold">not</span> <span style="color: #AA22FF; font-weight: bold">in</span> allowed_exts:
                <span style="color: #008000; font-weight: bold">continue</span>
            rel <span style="color: #666666">=</span> <span style="color: #008000">str</span>(path<span style="color: #666666">.</span>relative_to(root))<span style="color: #666666">.</span>lower()
            score <span style="color: #666666">=</span> <span style="color: #666666">0</span>
            <span style="color: #008000; font-weight: bold">if</span> keyword_re<span style="color: #666666">.</span>search(rel):
                score <span style="color: #666666">+=</span> <span style="color: #666666">2</span>
            <span style="color: #008000; font-weight: bold">for</span> ptn <span style="color: #AA22FF; font-weight: bold">in</span> doc_refs:
                <span style="color: #008000; font-weight: bold">if</span> ptn <span style="color: #AA22FF; font-weight: bold">and</span> ptn <span style="color: #AA22FF; font-weight: bold">in</span> rel:
                    score <span style="color: #666666">+=</span> <span style="color: #666666">1</span>
            ranked<span style="color: #666666">.</span>append((score, path))

    ranked<span style="color: #666666">.</span>sort(key<span style="color: #666666">=</span><span style="color: #008000; font-weight: bold">lambda</span> x: (<span style="color: #666666">-</span>x[<span style="color: #666666">0</span>], <span style="color: #008000">str</span>(x[<span style="color: #666666">1</span>])))
    <span style="color: #008000; font-weight: bold">return</span> [p <span style="color: #008000; font-weight: bold">for</span> _, p <span style="color: #AA22FF; font-weight: bold">in</span> ranked]
</code></pre>
<h3 id="extract_snippets">extract_snippets(files: Iterable[Path], *, max_files: int, time_budget: int, max_bytes: int) -&gt; dict[Path, str]</h3>
<p>The function `extract_snippets` processes a list of Python files to extract relevant code snippets. It filters files based on the number of files processed (`max_files`), time spent processing (`time_budget`), and file size (`max_bytes`). For each file, it reads up to `max_bytes` of text and extracts:
- Module docstrings
- Docstrings from classes, functions, and async functions
- Function signatures containing terms like &quot;path&quot;, &quot;file&quot;, &quot;config&quot;, or &quot;io&quot;
- Lines related to command-line interface (CLI) parsing
- The content of the `__main__` block if present

The extracted snippets are stored in a dictionary with file paths as keys.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">extract_snippets</span>(
    files: Iterable[Path],
    <span style="color: #666666">*</span>,
    max_files: <span style="color: #008000">int</span>,
    time_budget: <span style="color: #008000">int</span>,
    max_bytes: <span style="color: #008000">int</span>,
) <span style="color: #666666">-&gt;</span> <span style="color: #008000">dict</span>[Path, <span style="color: #008000">str</span>]:
<span style="color: #bbbbbb">    </span><span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;Extract relevant code snippets from ``files``.&quot;&quot;&quot;</span>

    snippets: <span style="color: #008000">dict</span>[Path, <span style="color: #008000">str</span>] <span style="color: #666666">=</span> {}
    start <span style="color: #666666">=</span> time<span style="color: #666666">.</span>perf_counter()
    <span style="color: #008000; font-weight: bold">for</span> idx, path <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">enumerate</span>(tqdm(<span style="color: #008000">list</span>(files), desc<span style="color: #666666">=</span><span style="color: #BA2121">&quot;Scanning code files&quot;</span>)):
        elapsed <span style="color: #666666">=</span> time<span style="color: #666666">.</span>perf_counter() <span style="color: #666666">-</span> start
        logging<span style="color: #666666">.</span>info(<span style="color: #BA2121">&quot;Considering </span><span style="color: #A45A77; font-weight: bold">%s</span><span style="color: #BA2121"> (elapsed </span><span style="color: #A45A77; font-weight: bold">%.2f</span><span style="color: #BA2121">s)&quot;</span>, path, elapsed)
        <span style="color: #008000; font-weight: bold">if</span> idx <span style="color: #666666">&gt;=</span> max_files:
            logging<span style="color: #666666">.</span>info(<span style="color: #BA2121">&quot;Skipping </span><span style="color: #A45A77; font-weight: bold">%s</span><span style="color: #BA2121">: file limit reached (elapsed </span><span style="color: #A45A77; font-weight: bold">%.2f</span><span style="color: #BA2121">s)&quot;</span>, path, elapsed)
            <span style="color: #008000; font-weight: bold">break</span>
        <span style="color: #008000; font-weight: bold">if</span> elapsed <span style="color: #666666">&gt;</span> time_budget:
            logging<span style="color: #666666">.</span>info(
                <span style="color: #BA2121">&quot;Skipping </span><span style="color: #A45A77; font-weight: bold">%s</span><span style="color: #BA2121">: time budget exceeded (elapsed </span><span style="color: #A45A77; font-weight: bold">%.2f</span><span style="color: #BA2121">s)&quot;</span>, path, elapsed
            )
            <span style="color: #008000; font-weight: bold">break</span>
        <span style="color: #008000; font-weight: bold">try</span>:
            size <span style="color: #666666">=</span> path<span style="color: #666666">.</span>stat()<span style="color: #666666">.</span>st_size
        <span style="color: #008000; font-weight: bold">except</span> <span style="color: #CB3F38; font-weight: bold">Exception</span>:
            logging<span style="color: #666666">.</span>info(
                <span style="color: #BA2121">&quot;Skipping </span><span style="color: #A45A77; font-weight: bold">%s</span><span style="color: #BA2121">: cannot stat file (elapsed </span><span style="color: #A45A77; font-weight: bold">%.2f</span><span style="color: #BA2121">s)&quot;</span>, path, elapsed
            )
            <span style="color: #008000; font-weight: bold">continue</span>
        <span style="color: #008000; font-weight: bold">if</span> size <span style="color: #666666">&gt;</span> max_bytes:
            logging<span style="color: #666666">.</span>info(
                <span style="color: #BA2121">&quot;Skipping </span><span style="color: #A45A77; font-weight: bold">%s</span><span style="color: #BA2121">: file size </span><span style="color: #A45A77; font-weight: bold">%d</span><span style="color: #BA2121"> exceeds limit </span><span style="color: #A45A77; font-weight: bold">%d</span><span style="color: #BA2121"> bytes (elapsed </span><span style="color: #A45A77; font-weight: bold">%.2f</span><span style="color: #BA2121">s)&quot;</span>,
                path,
                size,
                max_bytes,
                elapsed,
            )
            <span style="color: #008000; font-weight: bold">continue</span>
        <span style="color: #008000; font-weight: bold">try</span>:
            text <span style="color: #666666">=</span> path<span style="color: #666666">.</span>read_text(encoding<span style="color: #666666">=</span><span style="color: #BA2121">&quot;utf-8&quot;</span>)[:max_bytes]
        <span style="color: #008000; font-weight: bold">except</span> <span style="color: #CB3F38; font-weight: bold">Exception</span>:
            logging<span style="color: #666666">.</span>info(
                <span style="color: #BA2121">&quot;Skipping </span><span style="color: #A45A77; font-weight: bold">%s</span><span style="color: #BA2121">: unreadable (elapsed </span><span style="color: #A45A77; font-weight: bold">%.2f</span><span style="color: #BA2121">s)&quot;</span>, path, elapsed
            )
            <span style="color: #008000; font-weight: bold">continue</span>

        parts: <span style="color: #008000">list</span>[<span style="color: #008000">str</span>] <span style="color: #666666">=</span> []
        <span style="color: #008000; font-weight: bold">if</span> path<span style="color: #666666">.</span>suffix <span style="color: #666666">==</span> <span style="color: #BA2121">&quot;.py&quot;</span>:
            <span style="color: #008000; font-weight: bold">try</span>:
                tree <span style="color: #666666">=</span> ast<span style="color: #666666">.</span>parse(text)
            <span style="color: #008000; font-weight: bold">except</span> <span style="color: #CB3F38; font-weight: bold">Exception</span>:
                tree <span style="color: #666666">=</span> <span style="color: #008000; font-weight: bold">None</span>
            <span style="color: #008000; font-weight: bold">if</span> tree <span style="color: #AA22FF; font-weight: bold">is</span> <span style="color: #AA22FF; font-weight: bold">not</span> <span style="color: #008000; font-weight: bold">None</span>:
                module_doc <span style="color: #666666">=</span> ast<span style="color: #666666">.</span>get_docstring(tree)
                <span style="color: #008000; font-weight: bold">if</span> module_doc:
                    parts<span style="color: #666666">.</span>append(<span style="color: #BA2121">f&quot;Module docstring:</span><span style="color: #AA5D1F; font-weight: bold">\n</span><span style="color: #A45A77; font-weight: bold">{</span>module_doc<span style="color: #A45A77; font-weight: bold">}</span><span style="color: #BA2121">&quot;</span>)
                <span style="color: #008000; font-weight: bold">for</span> node <span style="color: #AA22FF; font-weight: bold">in</span> ast<span style="color: #666666">.</span>walk(tree):
                    <span style="color: #008000; font-weight: bold">if</span> <span style="color: #008000">isinstance</span>(node, (ast<span style="color: #666666">.</span>ClassDef, ast<span style="color: #666666">.</span>FunctionDef, ast<span style="color: #666666">.</span>AsyncFunctionDef)):
                        doc <span style="color: #666666">=</span> ast<span style="color: #666666">.</span>get_docstring(node)
                        <span style="color: #008000; font-weight: bold">if</span> doc:
                            kind <span style="color: #666666">=</span> <span style="color: #BA2121">&quot;Class&quot;</span> <span style="color: #008000; font-weight: bold">if</span> <span style="color: #008000">isinstance</span>(node, ast<span style="color: #666666">.</span>ClassDef) <span style="color: #008000; font-weight: bold">else</span> <span style="color: #BA2121">&quot;Function&quot;</span>
                            parts<span style="color: #666666">.</span>append(<span style="color: #BA2121">f&quot;</span><span style="color: #A45A77; font-weight: bold">{</span>kind<span style="color: #A45A77; font-weight: bold">}</span><span style="color: #BA2121"> </span><span style="color: #A45A77; font-weight: bold">{</span>node<span style="color: #666666">.</span>name<span style="color: #A45A77; font-weight: bold">}</span><span style="color: #BA2121"> docstring:</span><span style="color: #AA5D1F; font-weight: bold">\n</span><span style="color: #A45A77; font-weight: bold">{</span>doc<span style="color: #A45A77; font-weight: bold">}</span><span style="color: #BA2121">&quot;</span>)
                        <span style="color: #008000; font-weight: bold">if</span> <span style="color: #008000">isinstance</span>(node, (ast<span style="color: #666666">.</span>FunctionDef, ast<span style="color: #666666">.</span>AsyncFunctionDef)):
                            args <span style="color: #666666">=</span> [a<span style="color: #666666">.</span>arg <span style="color: #008000; font-weight: bold">for</span> a <span style="color: #AA22FF; font-weight: bold">in</span> node<span style="color: #666666">.</span>args<span style="color: #666666">.</span>args]
                            <span style="color: #008000; font-weight: bold">if</span> <span style="color: #008000">any</span>(
                                re<span style="color: #666666">.</span>search(<span style="color: #BA2121">r&quot;(path|file|config|io)&quot;</span>, a, re<span style="color: #666666">.</span>IGNORECASE)
                                <span style="color: #008000; font-weight: bold">for</span> a <span style="color: #AA22FF; font-weight: bold">in</span> args
                            ):
                                sig <span style="color: #666666">=</span> <span style="color: #BA2121">f&quot;def </span><span style="color: #A45A77; font-weight: bold">{</span>node<span style="color: #666666">.</span>name<span style="color: #A45A77; font-weight: bold">}</span><span style="color: #BA2121">(</span><span style="color: #A45A77; font-weight: bold">{</span><span style="color: #BA2121">&#39;, &#39;</span><span style="color: #666666">.</span>join(args)<span style="color: #A45A77; font-weight: bold">}</span><span style="color: #BA2121">):&quot;</span>
                                parts<span style="color: #666666">.</span>append(<span style="color: #BA2121">f&quot;I/O signature: </span><span style="color: #A45A77; font-weight: bold">{</span>sig<span style="color: #A45A77; font-weight: bold">}</span><span style="color: #BA2121">&quot;</span>)
                cli_lines <span style="color: #666666">=</span> [
                    line<span style="color: #666666">.</span>strip()
                    <span style="color: #008000; font-weight: bold">for</span> line <span style="color: #AA22FF; font-weight: bold">in</span> text<span style="color: #666666">.</span>splitlines()
                    <span style="color: #008000; font-weight: bold">if</span> <span style="color: #BA2121">&quot;ArgumentParser&quot;</span> <span style="color: #AA22FF; font-weight: bold">in</span> line <span style="color: #AA22FF; font-weight: bold">or</span> <span style="color: #BA2121">&quot;add_argument&quot;</span> <span style="color: #AA22FF; font-weight: bold">in</span> line
                ]
                <span style="color: #008000; font-weight: bold">if</span> cli_lines:
                    parts<span style="color: #666666">.</span>append(<span style="color: #BA2121">&quot;CLI parser:</span><span style="color: #AA5D1F; font-weight: bold">\n</span><span style="color: #BA2121">&quot;</span> <span style="color: #666666">+</span> <span style="color: #BA2121">&quot;</span><span style="color: #AA5D1F; font-weight: bold">\n</span><span style="color: #BA2121">&quot;</span><span style="color: #666666">.</span>join(cli_lines))
                main_match <span style="color: #666666">=</span> re<span style="color: #666666">.</span>search(
                    <span style="color: #BA2121">r&quot;if __name__ == [&#39;</span><span style="color: #AA5D1F; font-weight: bold">\&quot;</span><span style="color: #BA2121">]__main__[&#39;</span><span style="color: #AA5D1F; font-weight: bold">\&quot;</span><span style="color: #BA2121">]:(.*)&quot;</span>, text, re<span style="color: #666666">.</span>DOTALL
                )
                <span style="color: #008000; font-weight: bold">if</span> main_match:
                    parts<span style="color: #666666">.</span>append(<span style="color: #BA2121">&quot;__main__ block:</span><span style="color: #AA5D1F; font-weight: bold">\n</span><span style="color: #BA2121">&quot;</span> <span style="color: #666666">+</span> main_match<span style="color: #666666">.</span>group(<span style="color: #666666">0</span>)<span style="color: #666666">.</span>strip())
        <span style="color: #008000; font-weight: bold">else</span>:
            parts<span style="color: #666666">.</span>append(text)

        <span style="color: #008000; font-weight: bold">if</span> parts:
            snippets[path] <span style="color: #666666">=</span> <span style="color: #BA2121">&quot;</span><span style="color: #AA5D1F; font-weight: bold">\n</span><span style="color: #BA2121">&quot;</span><span style="color: #666666">.</span>join(parts)
            logging<span style="color: #666666">.</span>info(
                <span style="color: #BA2121">&quot;Scanned </span><span style="color: #A45A77; font-weight: bold">%s</span><span style="color: #BA2121"> (elapsed </span><span style="color: #A45A77; font-weight: bold">%.2f</span><span style="color: #BA2121">s)&quot;</span>, path, time<span style="color: #666666">.</span>perf_counter() <span style="color: #666666">-</span> start
            )
    <span style="color: #008000; font-weight: bold">return</span> snippets
</code></pre>
<h3 id="scan_code">scan_code(base: Path, sections: list[str] | None=None, *, max_files: int=12, time_budget: int=20, max_bytes_per_file: int=200000) -&gt; dict[str, dict[str, str]]</h3>
<p>The `scan_code` function collects source code snippets from a specified directory (`base`) and groups them by manual section. It searches for keywords associated with given sections (defaulting to all known sections) within the text extracted from source files. The function returns a dictionary mapping section names to another dictionary of relative file paths and their corresponding snippet texts.

Key steps include:
1. Collecting patterns from documentation using `collect_docs` and extracting text.
2. Ranking code files based on these patterns using `rank_code_files`.
3. Extracting snippets from the ranked files within specified limits (`max_files`, `time_budget`, `max_bytes_per_file`).
4. Categorizing collected snippets by section, filtering out unwanted sections if provided.

The function uses regular expressions to identify relevant patterns and tqdm for progress tracking during snippet collection.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">scan_code</span>(
    base: Path,
    sections: <span style="color: #008000">list</span>[<span style="color: #008000">str</span>] <span style="color: #666666">|</span> <span style="color: #008000; font-weight: bold">None</span> <span style="color: #666666">=</span> <span style="color: #008000; font-weight: bold">None</span>,
    <span style="color: #666666">*</span>,
    max_files: <span style="color: #008000">int</span> <span style="color: #666666">=</span> <span style="color: #666666">12</span>,
    time_budget: <span style="color: #008000">int</span> <span style="color: #666666">=</span> <span style="color: #666666">20</span>,
    max_bytes_per_file: <span style="color: #008000">int</span> <span style="color: #666666">=</span> <span style="color: #666666">200_000</span>,
) <span style="color: #666666">-&gt;</span> <span style="color: #008000">dict</span>[<span style="color: #008000">str</span>, <span style="color: #008000">dict</span>[<span style="color: #008000">str</span>, <span style="color: #008000">str</span>]]:
<span style="color: #bbbbbb">    </span><span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;Collect source code snippets from ``base`` grouped by manual section.</span>

<span style="color: #BA2121; font-style: italic">    The function searches source files for keywords associated with</span>
<span style="color: #BA2121; font-style: italic">    ``sections`` (defaulting to all known sections) and returns a mapping from</span>
<span style="color: #BA2121; font-style: italic">    section name to a mapping of relative file paths and their snippet text.</span>
<span style="color: #BA2121; font-style: italic">    &quot;&quot;&quot;</span>

    patterns: <span style="color: #008000">list</span>[<span style="color: #008000">str</span>] <span style="color: #666666">=</span> []
    <span style="color: #008000; font-weight: bold">for</span> doc <span style="color: #AA22FF; font-weight: bold">in</span> collect_docs(base):
        <span style="color: #008000; font-weight: bold">try</span>:
            text <span style="color: #666666">=</span> extract_text(doc)
        <span style="color: #008000; font-weight: bold">except</span> <span style="color: #CB3F38; font-weight: bold">Exception</span>:
            <span style="color: #008000; font-weight: bold">continue</span>
        <span style="color: #008000; font-weight: bold">for</span> match <span style="color: #AA22FF; font-weight: bold">in</span> re<span style="color: #666666">.</span>findall(<span style="color: #BA2121">r&quot;[\w/.-]+&quot;</span>, text):
            <span style="color: #008000; font-weight: bold">if</span> <span style="color: #BA2121">&quot;/&quot;</span> <span style="color: #AA22FF; font-weight: bold">in</span> match <span style="color: #AA22FF; font-weight: bold">or</span> match<span style="color: #666666">.</span>endswith(<span style="color: #BA2121">&quot;.py&quot;</span>):
                patterns<span style="color: #666666">.</span>append(match)

    files <span style="color: #666666">=</span> rank_code_files(base, patterns)
    snippets <span style="color: #666666">=</span> extract_snippets(
        files,
        max_files<span style="color: #666666">=</span>max_files,
        time_budget<span style="color: #666666">=</span>time_budget,
        max_bytes<span style="color: #666666">=</span>max_bytes_per_file,
    )

    wanted <span style="color: #666666">=</span> sections <span style="color: #008000; font-weight: bold">if</span> sections <span style="color: #AA22FF; font-weight: bold">is</span> <span style="color: #AA22FF; font-weight: bold">not</span> <span style="color: #008000; font-weight: bold">None</span> <span style="color: #008000; font-weight: bold">else</span> <span style="color: #008000">list</span>(SECTION_KEYWORDS<span style="color: #666666">.</span>keys())
    categorized: <span style="color: #008000">dict</span>[<span style="color: #008000">str</span>, <span style="color: #008000">dict</span>[<span style="color: #008000">str</span>, <span style="color: #008000">str</span>]] <span style="color: #666666">=</span> {sec: {} <span style="color: #008000; font-weight: bold">for</span> sec <span style="color: #AA22FF; font-weight: bold">in</span> wanted}

    <span style="color: #008000; font-weight: bold">for</span> path, text <span style="color: #AA22FF; font-weight: bold">in</span> tqdm(snippets<span style="color: #666666">.</span>items(), desc<span style="color: #666666">=</span><span style="color: #BA2121">&quot;Collecting snippets&quot;</span>):
        rel <span style="color: #666666">=</span> path<span style="color: #666666">.</span>relative_to(base)
        lower <span style="color: #666666">=</span> text<span style="color: #666666">.</span>lower()
        <span style="color: #008000; font-weight: bold">for</span> section <span style="color: #AA22FF; font-weight: bold">in</span> wanted:
            keywords <span style="color: #666666">=</span> SECTION_KEYWORDS<span style="color: #666666">.</span>get(section, [])
            <span style="color: #008000; font-weight: bold">if</span> <span style="color: #008000">any</span>(k <span style="color: #AA22FF; font-weight: bold">in</span> lower <span style="color: #008000; font-weight: bold">for</span> k <span style="color: #AA22FF; font-weight: bold">in</span> keywords):
                categorized<span style="color: #666666">.</span>setdefault(section, {})[<span style="color: #008000">str</span>(rel)] <span style="color: #666666">=</span> text
    <span style="color: #008000; font-weight: bold">return</span> {k: v <span style="color: #008000; font-weight: bold">for</span> k, v <span style="color: #AA22FF; font-weight: bold">in</span> categorized<span style="color: #666666">.</span>items() <span style="color: #008000; font-weight: bold">if</span> v}
</code></pre>
<h3 id="llm_generate_manual">llm_generate_manual(docs: dict[Path, str], client: LLMClient, cache: ResponseCache, chunking: str=&#x27;auto&#x27;) -&gt; tuple[str, dict[Path, set[str]], dict[str, dict[str, object]]]</h3>
<p>The function `llm_generate_manual` generates a user manual from provided documentation snippets by interacting with a language model (LLM). It maps the snippets to manual sections, performs LLM calls per section, and assembles the final manual text. The function returns the manual text, a mapping of source files to the sections they contributed, and an evidence map capturing the snippets used for each section.

The process involves:
1. Mapping documentation snippets to manual sections using `map_evidence_to_sections`.
2. Iterating over required sections, collecting entries from the snippet map.
3. For each section, checking if entries are inferred or provided.
4. Creating a context string from the collected snippets.
5. Generating a prompt and system prompt for the LLM call.
6. Handling chunking of the prompt if it exceeds token limits using `summarize_chunked`.
7. Caching results to avoid redundant calls to the LLM.
8. Parsing the LLM response to extract the section text.
9. Replacing placeholders with actual content if necessary.
10. Logging information about each section&#x27;s generation process.
11. Assembling the final manual text from the generated sections.

The function returns a tuple containing the manual text, a file map, and an evidence map.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">llm_generate_manual</span>(
    docs: <span style="color: #008000">dict</span>[Path, <span style="color: #008000">str</span>],
    client: LLMClient,
    cache: ResponseCache,
    chunking: <span style="color: #008000">str</span> <span style="color: #666666">=</span> <span style="color: #BA2121">&quot;auto&quot;</span>,
) <span style="color: #666666">-&gt;</span> <span style="color: #008000">tuple</span>[<span style="color: #008000">str</span>, <span style="color: #008000">dict</span>[Path, <span style="color: #008000">set</span>[<span style="color: #008000">str</span>]], <span style="color: #008000">dict</span>[<span style="color: #008000">str</span>, <span style="color: #008000">dict</span>[<span style="color: #008000">str</span>, <span style="color: #008000">object</span>]]]:
<span style="color: #bbbbbb">    </span><span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;Generate a manual from supplied documentation ``docs``.</span>

<span style="color: #BA2121; font-style: italic">    The function maps documentation snippets to manual sections, performs an</span>
<span style="color: #BA2121; font-style: italic">    LLM call per section, and assembles the final manual text. It returns the</span>
<span style="color: #BA2121; font-style: italic">    manual text, a mapping of source files to the sections they contributed,</span>
<span style="color: #BA2121; font-style: italic">    and an evidence map capturing the snippets used for each section.</span>
<span style="color: #BA2121; font-style: italic">    &quot;&quot;&quot;</span>

    section_map, file_map <span style="color: #666666">=</span> map_evidence_to_sections(docs)

    sections: <span style="color: #008000">dict</span>[<span style="color: #008000">str</span>, <span style="color: #008000">str</span>] <span style="color: #666666">=</span> {}
    evidence_map: <span style="color: #008000">dict</span>[<span style="color: #008000">str</span>, <span style="color: #008000">dict</span>[<span style="color: #008000">str</span>, <span style="color: #008000">object</span>]] <span style="color: #666666">=</span> {}
    <span style="color: #008000; font-weight: bold">for</span> section <span style="color: #AA22FF; font-weight: bold">in</span> REQUIRED_SECTIONS:
        entries <span style="color: #666666">=</span> section_map<span style="color: #666666">.</span>get(section, [])
        inferred <span style="color: #666666">=</span> <span style="color: #AA22FF; font-weight: bold">not</span> entries
        evidence_map[section] <span style="color: #666666">=</span> {
            <span style="color: #BA2121">&quot;inferred&quot;</span>: inferred,
            <span style="color: #BA2121">&quot;evidence&quot;</span>: [
                {<span style="color: #BA2121">&quot;file&quot;</span>: <span style="color: #008000">str</span>(path), <span style="color: #BA2121">&quot;snippet&quot;</span>: snippet}
                <span style="color: #008000; font-weight: bold">for</span> path, snippet <span style="color: #AA22FF; font-weight: bold">in</span> entries
            ],
        }
        <span style="color: #008000; font-weight: bold">if</span> inferred:
            sections[section] <span style="color: #666666">=</span> SECTION_PLACEHOLDERS[section]
            logging<span style="color: #666666">.</span>info(
                <span style="color: #BA2121">&quot;Section </span><span style="color: #A45A77; font-weight: bold">%s</span><span style="color: #BA2121"> generated with inferred content; evidence: none&quot;</span>, section
            )
            <span style="color: #008000; font-weight: bold">continue</span>
        context <span style="color: #666666">=</span> <span style="color: #BA2121">&quot;</span><span style="color: #AA5D1F; font-weight: bold">\n\n</span><span style="color: #BA2121">&quot;</span><span style="color: #666666">.</span>join(snippet <span style="color: #008000; font-weight: bold">for</span> _, snippet <span style="color: #AA22FF; font-weight: bold">in</span> entries)
        <span style="color: #008000; font-weight: bold">for</span> path, snippet <span style="color: #AA22FF; font-weight: bold">in</span> entries:
            logging<span style="color: #666666">.</span>info(<span style="color: #BA2121">&quot;Section </span><span style="color: #A45A77; font-weight: bold">%s</span><span style="color: #BA2121"> snippet from </span><span style="color: #A45A77; font-weight: bold">%s</span><span style="color: #BA2121">&quot;</span>, section, path)
        prompt <span style="color: #666666">=</span> (
            <span style="color: #BA2121">f&quot;Write the &#39;</span><span style="color: #A45A77; font-weight: bold">{</span>section<span style="color: #A45A77; font-weight: bold">}</span><span style="color: #BA2121">&#39; section of a user manual using the &quot;</span>
            <span style="color: #BA2121">&quot;following documentation snippets.&quot;</span>
            <span style="color: #BA2121">f&quot;</span><span style="color: #AA5D1F; font-weight: bold">\n\n</span><span style="color: #A45A77; font-weight: bold">{</span>context<span style="color: #A45A77; font-weight: bold">}</span><span style="color: #BA2121">&quot;</span>
        )
        placeholder <span style="color: #666666">=</span> SECTION_PLACEHOLDERS[section]
        system_prompt <span style="color: #666666">=</span> (
            <span style="color: #BA2121">f&quot;You write the &#39;</span><span style="color: #A45A77; font-weight: bold">{</span>section<span style="color: #A45A77; font-weight: bold">}</span><span style="color: #BA2121">&#39; section of a user manual. &quot;</span>
            <span style="color: #BA2121">&quot;Use only the provided snippets; if they lack relevant facts, &quot;</span>
            <span style="color: #BA2121">f&quot;respond with the placeholder token </span><span style="color: #A45A77; font-weight: bold">{</span>placeholder<span style="color: #A45A77; font-weight: bold">}</span><span style="color: #BA2121">. Do not infer &quot;</span>
            <span style="color: #BA2121">&quot;information not present in the snippets.&quot;</span>
        )
        tokenizer <span style="color: #666666">=</span> get_tokenizer()
        template <span style="color: #666666">=</span> PROMPT_TEMPLATES[<span style="color: #BA2121">&quot;docstring&quot;</span>]
        overhead <span style="color: #666666">=</span> <span style="color: #008000">len</span>(tokenizer<span style="color: #666666">.</span>encode(system_prompt)) <span style="color: #666666">+</span> <span style="color: #008000">len</span>(
            tokenizer<span style="color: #666666">.</span>encode(template<span style="color: #666666">.</span>format(text<span style="color: #666666">=</span><span style="color: #BA2121">&quot;&quot;</span>))
        )
        max_context_tokens <span style="color: #666666">=</span> <span style="color: #666666">4096</span>
        chunk_token_budget <span style="color: #666666">=</span> <span style="color: #008000">int</span>(max_context_tokens <span style="color: #666666">*</span> <span style="color: #666666">0.75</span>)
        available <span style="color: #666666">=</span> max_context_tokens <span style="color: #666666">-</span> overhead
        <span style="color: #008000; font-weight: bold">if</span> <span style="color: #008000">len</span>(tokenizer<span style="color: #666666">.</span>encode(prompt)) <span style="color: #666666">&gt;</span> available:
            result <span style="color: #666666">=</span> summarize_chunked(
                client,
                cache,
                <span style="color: #BA2121">f&quot;section:</span><span style="color: #A45A77; font-weight: bold">{</span>section<span style="color: #A45A77; font-weight: bold">}</span><span style="color: #BA2121">&quot;</span>,
                prompt,
                <span style="color: #BA2121">&quot;docstring&quot;</span>,
                system_prompt<span style="color: #666666">=</span>system_prompt,
                max_context_tokens<span style="color: #666666">=</span>max_context_tokens,
                chunk_token_budget<span style="color: #666666">=</span>chunk_token_budget,
            )
        <span style="color: #008000; font-weight: bold">else</span>:
            key <span style="color: #666666">=</span> ResponseCache<span style="color: #666666">.</span>make_key(<span style="color: #BA2121">f&quot;section:</span><span style="color: #A45A77; font-weight: bold">{</span>section<span style="color: #A45A77; font-weight: bold">}</span><span style="color: #BA2121">&quot;</span>, prompt)
            cached <span style="color: #666666">=</span> cache<span style="color: #666666">.</span>get(key)
            <span style="color: #008000; font-weight: bold">if</span> cached <span style="color: #AA22FF; font-weight: bold">is</span> <span style="color: #AA22FF; font-weight: bold">not</span> <span style="color: #008000; font-weight: bold">None</span>:
                result <span style="color: #666666">=</span> cached
            <span style="color: #008000; font-weight: bold">else</span>:
                result <span style="color: #666666">=</span> client<span style="color: #666666">.</span>summarize(
                    prompt,
                    <span style="color: #BA2121">&quot;docstring&quot;</span>,
                    system_prompt<span style="color: #666666">=</span>system_prompt,
                )
                cache<span style="color: #666666">.</span>set(key, result)
        parsed <span style="color: #666666">=</span> parse_manual(result, infer_missing<span style="color: #666666">=</span><span style="color: #008000; font-weight: bold">False</span>)
        text <span style="color: #666666">=</span> parsed<span style="color: #666666">.</span>get(section, result<span style="color: #666666">.</span>strip())
        <span style="color: #008000; font-weight: bold">if</span> placeholder <span style="color: #AA22FF; font-weight: bold">in</span> find_placeholders(text):
            sections[section] <span style="color: #666666">=</span> placeholder
        <span style="color: #008000; font-weight: bold">else</span>:
            sections[section] <span style="color: #666666">=</span> text
        summary <span style="color: #666666">=</span> <span style="color: #BA2121">&quot;, &quot;</span><span style="color: #666666">.</span>join(
            <span style="color: #BA2121">f&quot;</span><span style="color: #A45A77; font-weight: bold">{</span>path<span style="color: #A45A77; font-weight: bold">}</span><span style="color: #BA2121">: </span><span style="color: #A45A77; font-weight: bold">{</span>snippet[:<span style="color: #666666">30</span>]<span style="color: #A45A77; font-weight: bold">}</span><span style="color: #BA2121">&quot;</span> <span style="color: #008000; font-weight: bold">for</span> path, snippet <span style="color: #AA22FF; font-weight: bold">in</span> entries
        )
        logging<span style="color: #666666">.</span>info(
            <span style="color: #BA2121">&quot;Section </span><span style="color: #A45A77; font-weight: bold">%s</span><span style="color: #BA2121"> generated using [</span><span style="color: #A45A77; font-weight: bold">%s</span><span style="color: #BA2121">]; inferred=</span><span style="color: #A45A77; font-weight: bold">%s</span><span style="color: #BA2121">&quot;</span>,
            section,
            summary <span style="color: #AA22FF; font-weight: bold">or</span> <span style="color: #BA2121">&quot;none&quot;</span>,
            inferred,
        )

    manual_text <span style="color: #666666">=</span> <span style="color: #BA2121">&quot;</span><span style="color: #AA5D1F; font-weight: bold">\n</span><span style="color: #BA2121">&quot;</span><span style="color: #666666">.</span>join(<span style="color: #BA2121">f&quot;</span><span style="color: #A45A77; font-weight: bold">{</span>sec<span style="color: #A45A77; font-weight: bold">}</span><span style="color: #BA2121">: </span><span style="color: #A45A77; font-weight: bold">{</span>txt<span style="color: #A45A77; font-weight: bold">}</span><span style="color: #BA2121">&quot;</span> <span style="color: #008000; font-weight: bold">for</span> sec, txt <span style="color: #AA22FF; font-weight: bold">in</span> sections<span style="color: #666666">.</span>items())
    <span style="color: #008000; font-weight: bold">return</span> manual_text, file_map, evidence_map
</code></pre>
<h3 id="llm_fill_placeholders">llm_fill_placeholders(manual_text: str, code_snippets: dict[str, dict[str, str]], client: LLMClient, cache: ResponseCache, *, max_context_tokens: int=4096, chunk_token_budget: int | None=None) -&gt; str</h3>
<p>The function `llm_fill_placeholders` processes a manual text by filling placeholders with relevant code snippets. It uses an LLM client to interact with a language model and a response cache for efficient reuse of responses. The function handles the following steps:

1. **Tokenization**: It initializes a tokenizer to measure token usage.
2. **Chunk Token Budget Calculation**: If not provided, it calculates a chunk token budget as 75% of the maximum context tokens.
3. **Iterate Over Sections**: For each section in `code_snippets`, it constructs a snippet text by joining code snippets from different files.
4. **Token Usage Check and Summarization**: It checks if the combined length of the manual text and snippet text exceeds the maximum context tokens. If so, it summarizes the snippet text to fit within the token limit.
5. **Prompt Construction**: It constructs a prompt that includes the manual text, section title, and code snippets.
6. **Update Manual**: It updates the manual by replacing placeholders with information from the code snippets using the LLM client and response cache.
7. **Logging**: It logs which section was updated and which files were used.

The function returns the updated manual text after processing all sections.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">llm_fill_placeholders</span>(
    manual_text: <span style="color: #008000">str</span>,
    code_snippets: <span style="color: #008000">dict</span>[<span style="color: #008000">str</span>, <span style="color: #008000">dict</span>[<span style="color: #008000">str</span>, <span style="color: #008000">str</span>]],
    client: LLMClient,
    cache: ResponseCache,
    <span style="color: #666666">*</span>,
    max_context_tokens: <span style="color: #008000">int</span> <span style="color: #666666">=</span> <span style="color: #666666">4096</span>,
    chunk_token_budget: <span style="color: #008000">int</span> <span style="color: #666666">|</span> <span style="color: #008000; font-weight: bold">None</span> <span style="color: #666666">=</span> <span style="color: #008000; font-weight: bold">None</span>,
) <span style="color: #666666">-&gt;</span> <span style="color: #008000">str</span>:
<span style="color: #bbbbbb">    </span><span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;Fill placeholder tokens in ``manual_text`` using ``code_snippets``.</span>

<span style="color: #BA2121; font-style: italic">    ``code_snippets`` maps section names to dictionaries of ``path -&gt; text``</span>
<span style="color: #BA2121; font-style: italic">    containing evidence for that section. A separate LLM call is made for each</span>
<span style="color: #BA2121; font-style: italic">    section to update the manual incrementally. Long snippets are summarized</span>
<span style="color: #BA2121; font-style: italic">    before being sent to the model so that prompts stay within the model&#39;s</span>
<span style="color: #BA2121; font-style: italic">    context window.</span>
<span style="color: #BA2121; font-style: italic">    &quot;&quot;&quot;</span>

    tokenizer <span style="color: #666666">=</span> get_tokenizer()
    <span style="color: #008000; font-weight: bold">if</span> chunk_token_budget <span style="color: #AA22FF; font-weight: bold">is</span> <span style="color: #008000; font-weight: bold">None</span>:
        chunk_token_budget <span style="color: #666666">=</span> <span style="color: #008000">int</span>(max_context_tokens <span style="color: #666666">*</span> <span style="color: #666666">0.75</span>)

    <span style="color: #008000; font-weight: bold">for</span> section, files <span style="color: #AA22FF; font-weight: bold">in</span> code_snippets<span style="color: #666666">.</span>items():
        <span style="color: #008000; font-weight: bold">if</span> <span style="color: #AA22FF; font-weight: bold">not</span> files:
            <span style="color: #008000; font-weight: bold">continue</span>
        snippet_text <span style="color: #666666">=</span> <span style="color: #BA2121">&quot;</span><span style="color: #AA5D1F; font-weight: bold">\n\n</span><span style="color: #BA2121">&quot;</span><span style="color: #666666">.</span>join(
            <span style="color: #BA2121">f&quot;# File: </span><span style="color: #A45A77; font-weight: bold">{</span>path<span style="color: #A45A77; font-weight: bold">}</span><span style="color: #AA5D1F; font-weight: bold">\n</span><span style="color: #A45A77; font-weight: bold">{</span>text<span style="color: #A45A77; font-weight: bold">}</span><span style="color: #BA2121">&quot;</span> <span style="color: #008000; font-weight: bold">for</span> path, text <span style="color: #AA22FF; font-weight: bold">in</span> files<span style="color: #666666">.</span>items()
        )

        token_usage <span style="color: #666666">=</span> <span style="color: #008000">len</span>(tokenizer<span style="color: #666666">.</span>encode(manual_text)) <span style="color: #666666">+</span> <span style="color: #008000">len</span>(
            tokenizer<span style="color: #666666">.</span>encode(snippet_text)
        )
        <span style="color: #008000; font-weight: bold">if</span> token_usage <span style="color: #666666">&gt;</span> max_context_tokens:
            snippet_text <span style="color: #666666">=</span> summarize_chunked(
                client,
                cache,
                <span style="color: #BA2121">f&quot;fill_manual:</span><span style="color: #A45A77; font-weight: bold">{</span>section<span style="color: #A45A77; font-weight: bold">}</span><span style="color: #BA2121">:snippet&quot;</span>,
                snippet_text,
                <span style="color: #BA2121">&quot;docstring&quot;</span>,
                system_prompt<span style="color: #666666">=</span>FILL_SYSTEM_PROMPT,
                max_context_tokens<span style="color: #666666">=</span>max_context_tokens,
                chunk_token_budget<span style="color: #666666">=</span>chunk_token_budget,
            )

        prompt <span style="color: #666666">=</span> (
            <span style="color: #BA2121">f&quot;Manual:</span><span style="color: #AA5D1F; font-weight: bold">\n</span><span style="color: #A45A77; font-weight: bold">{</span>manual_text<span style="color: #A45A77; font-weight: bold">}</span><span style="color: #AA5D1F; font-weight: bold">\n\n</span><span style="color: #BA2121">&quot;</span>
            <span style="color: #BA2121">f&quot;Section: </span><span style="color: #A45A77; font-weight: bold">{</span>section<span style="color: #A45A77; font-weight: bold">}</span><span style="color: #AA5D1F; font-weight: bold">\n</span><span style="color: #BA2121">&quot;</span>
            <span style="color: #BA2121">f&quot;Code Snippets:</span><span style="color: #AA5D1F; font-weight: bold">\n</span><span style="color: #A45A77; font-weight: bold">{</span>snippet_text<span style="color: #A45A77; font-weight: bold">}</span><span style="color: #AA5D1F; font-weight: bold">\n\n</span><span style="color: #BA2121">&quot;</span>
            <span style="color: #BA2121">&quot;Update the manual by replacing the placeholder for this section with the relevant information from the code snippets.&quot;</span>
        )

        manual_text <span style="color: #666666">=</span> summarize_chunked(
            client,
            cache,
            <span style="color: #BA2121">f&quot;fill_manual:</span><span style="color: #A45A77; font-weight: bold">{</span>section<span style="color: #A45A77; font-weight: bold">}</span><span style="color: #BA2121">&quot;</span>,
            prompt,
            <span style="color: #BA2121">&quot;docstring&quot;</span>,
            system_prompt<span style="color: #666666">=</span>FILL_SYSTEM_PROMPT,
            max_context_tokens<span style="color: #666666">=</span>max_context_tokens,
            chunk_token_budget<span style="color: #666666">=</span>chunk_token_budget,
        )

        logging<span style="color: #666666">.</span>info(
            <span style="color: #BA2121">&quot;Filled </span><span style="color: #A45A77; font-weight: bold">%s</span><span style="color: #BA2121"> using code from: </span><span style="color: #A45A77; font-weight: bold">%s</span><span style="color: #BA2121">&quot;</span>, section, <span style="color: #BA2121">&quot;, &quot;</span><span style="color: #666666">.</span>join(files<span style="color: #666666">.</span>keys())
        )
    <span style="color: #008000; font-weight: bold">return</span> manual_text
</code></pre>
<h3 id="_edit_chunks_in_editor">_edit_chunks_in_editor(chunks: list[str]) -&gt; list[str]</h3>
<p>The function `_edit_chunks_in_editor` takes a list of code chunks as input, joins them into a single string with separators, writes the string to a temporary file, opens the file in the user&#x27;s default editor for modification, reads the edited content back from the file, and returns the modified chunks. Empty chunks are discarded.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">_edit_chunks_in_editor</span>(chunks: <span style="color: #008000">list</span>[<span style="color: #008000">str</span>]) <span style="color: #666666">-&gt;</span> <span style="color: #008000">list</span>[<span style="color: #008000">str</span>]:
<span style="color: #bbbbbb">    </span><span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;Open ``chunks`` in user&#39;s editor for optional modification.</span>

<span style="color: #BA2121; font-style: italic">    Chunks are separated by lines containing ``---``. Returns the edited</span>
<span style="color: #BA2121; font-style: italic">    chunks after the editor is closed. Empty chunks are discarded.</span>
<span style="color: #BA2121; font-style: italic">    &quot;&quot;&quot;</span>

    separator <span style="color: #666666">=</span> <span style="color: #BA2121">&quot;</span><span style="color: #AA5D1F; font-weight: bold">\n\n</span><span style="color: #BA2121">---</span><span style="color: #AA5D1F; font-weight: bold">\n\n</span><span style="color: #BA2121">&quot;</span>
    initial <span style="color: #666666">=</span> separator<span style="color: #666666">.</span>join(chunks)
    <span style="color: #008000; font-weight: bold">with</span> tempfile<span style="color: #666666">.</span>NamedTemporaryFile(<span style="color: #BA2121">&quot;w+&quot;</span>, suffix<span style="color: #666666">=</span><span style="color: #BA2121">&quot;.md&quot;</span>, delete<span style="color: #666666">=</span><span style="color: #008000; font-weight: bold">False</span>) <span style="color: #008000; font-weight: bold">as</span> tmp:
        tmp<span style="color: #666666">.</span>write(initial)
        tmp<span style="color: #666666">.</span>flush()
        editor <span style="color: #666666">=</span> os<span style="color: #666666">.</span>environ<span style="color: #666666">.</span>get(<span style="color: #BA2121">&quot;EDITOR&quot;</span>) <span style="color: #AA22FF; font-weight: bold">or</span> os<span style="color: #666666">.</span>environ<span style="color: #666666">.</span>get(<span style="color: #BA2121">&quot;VISUAL&quot;</span>) <span style="color: #AA22FF; font-weight: bold">or</span> <span style="color: #BA2121">&quot;vi&quot;</span>
        subprocess<span style="color: #666666">.</span>call([editor, tmp<span style="color: #666666">.</span>name])
        tmp<span style="color: #666666">.</span>seek(<span style="color: #666666">0</span>)
        data <span style="color: #666666">=</span> tmp<span style="color: #666666">.</span>read()
    Path(tmp<span style="color: #666666">.</span>name)<span style="color: #666666">.</span>unlink(missing_ok<span style="color: #666666">=</span><span style="color: #008000; font-weight: bold">True</span>)
    parts <span style="color: #666666">=</span> re<span style="color: #666666">.</span>split(<span style="color: #BA2121">r&quot;\n\s*---\s*\n&quot;</span>, data)
    <span style="color: #008000; font-weight: bold">return</span> [p<span style="color: #666666">.</span>strip() <span style="color: #008000; font-weight: bold">for</span> p <span style="color: #AA22FF; font-weight: bold">in</span> parts <span style="color: #008000; font-weight: bold">if</span> p<span style="color: #666666">.</span>strip()]
</code></pre>
<h3 id="render_html">render_html(sections: Dict[str, str], title: str, evidence_map: dict[str, dict[str, object]] | None=None) -&gt; str</h3>
<p>The function `render_html` generates HTML documentation from a dictionary of sections, a title, and an optional evidence map. It slugifies section titles for navigation links, constructs navigation items, and processes content to include evidence snippets when available. The function supports rendering Markdown content and includes styles for the output.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">render_html</span>(
    sections: Dict[<span style="color: #008000">str</span>, <span style="color: #008000">str</span>],
    title: <span style="color: #008000">str</span>,
    evidence_map: <span style="color: #008000">dict</span>[<span style="color: #008000">str</span>, <span style="color: #008000">dict</span>[<span style="color: #008000">str</span>, <span style="color: #008000">object</span>]] <span style="color: #666666">|</span> <span style="color: #008000; font-weight: bold">None</span> <span style="color: #666666">=</span> <span style="color: #008000; font-weight: bold">None</span>,
) <span style="color: #666666">-&gt;</span> <span style="color: #008000">str</span>:
<span style="color: #bbbbbb">    </span><span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;Return HTML for ``sections`` with ``title``.</span>

<span style="color: #BA2121; font-style: italic">    ``evidence_map`` contains supporting snippets for each section. When a</span>
<span style="color: #BA2121; font-style: italic">    section&#39;s content is empty or marked as lacking information, available</span>
<span style="color: #BA2121; font-style: italic">    evidence snippets are rendered instead so that the manual always reflects</span>
<span style="color: #BA2121; font-style: italic">    the extracted documentation.</span>
<span style="color: #BA2121; font-style: italic">    &quot;&quot;&quot;</span>

    <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">_slugify</span>(text: <span style="color: #008000">str</span>) <span style="color: #666666">-&gt;</span> <span style="color: #008000">str</span>:
        slug <span style="color: #666666">=</span> re<span style="color: #666666">.</span>sub(<span style="color: #BA2121">r&quot;[^a-z0-9]+&quot;</span>, <span style="color: #BA2121">&quot;-&quot;</span>, text<span style="color: #666666">.</span>lower())
        <span style="color: #008000; font-weight: bold">return</span> slug<span style="color: #666666">.</span>strip(<span style="color: #BA2121">&quot;-&quot;</span>)

    nav_items: <span style="color: #008000">list</span>[<span style="color: #008000">str</span>] <span style="color: #666666">=</span> []
    body_parts: <span style="color: #008000">list</span>[<span style="color: #008000">str</span>] <span style="color: #666666">=</span> []

    <span style="color: #008000; font-weight: bold">for</span> sec_title, content <span style="color: #AA22FF; font-weight: bold">in</span> sections<span style="color: #666666">.</span>items():
        anchor <span style="color: #666666">=</span> _slugify(sec_title)
        nav_items<span style="color: #666666">.</span>append(
            <span style="color: #BA2121">f&quot;&lt;li&gt;&lt;a href=&#39;#&quot;</span> <span style="color: #666666">+</span> anchor <span style="color: #666666">+</span> <span style="color: #BA2121">f&quot;&#39;&gt;</span><span style="color: #A45A77; font-weight: bold">{</span>html<span style="color: #666666">.</span>escape(sec_title)<span style="color: #A45A77; font-weight: bold">}</span><span style="color: #BA2121">&lt;/a&gt;&lt;/li&gt;&quot;</span>
        )

        evidence <span style="color: #666666">=</span> []
        <span style="color: #008000; font-weight: bold">if</span> evidence_map:
            evidence <span style="color: #666666">=</span> evidence_map<span style="color: #666666">.</span>get(sec_title, {})<span style="color: #666666">.</span>get(<span style="color: #BA2121">&quot;evidence&quot;</span>, [])
        text <span style="color: #666666">=</span> content<span style="color: #666666">.</span>strip()
        <span style="color: #008000; font-weight: bold">if</span> (<span style="color: #AA22FF; font-weight: bold">not</span> text <span style="color: #AA22FF; font-weight: bold">or</span> text<span style="color: #666666">.</span>lower() <span style="color: #666666">==</span> <span style="color: #BA2121">&quot;no information provided.&quot;</span>) <span style="color: #AA22FF; font-weight: bold">and</span> evidence:
            snippets <span style="color: #666666">=</span> <span style="color: #BA2121">&quot;&lt;br/&gt;&quot;</span><span style="color: #666666">.</span>join(
                html<span style="color: #666666">.</span>escape(e<span style="color: #666666">.</span>get(<span style="color: #BA2121">&quot;snippet&quot;</span>, <span style="color: #BA2121">&quot;&quot;</span>)) <span style="color: #008000; font-weight: bold">for</span> e <span style="color: #AA22FF; font-weight: bold">in</span> evidence <span style="color: #008000; font-weight: bold">if</span> e<span style="color: #666666">.</span>get(<span style="color: #BA2121">&quot;snippet&quot;</span>)
            )
            src_items <span style="color: #666666">=</span> [
                <span style="color: #BA2121">f&quot;&lt;li&gt;</span><span style="color: #A45A77; font-weight: bold">{</span>html<span style="color: #666666">.</span>escape(e<span style="color: #666666">.</span>get(<span style="color: #BA2121">&#39;file&#39;</span>,<span style="color: #bbbbbb"> </span><span style="color: #BA2121">&#39;&#39;</span>))<span style="color: #A45A77; font-weight: bold">}</span><span style="color: #BA2121">&lt;/li&gt;&quot;</span>
                <span style="color: #008000; font-weight: bold">for</span> e <span style="color: #AA22FF; font-weight: bold">in</span> evidence
                <span style="color: #008000; font-weight: bold">if</span> e<span style="color: #666666">.</span>get(<span style="color: #BA2121">&quot;file&quot;</span>)
            ]
            sources_block <span style="color: #666666">=</span> (
                <span style="color: #BA2121">f&quot;&lt;div class=&#39;sources&#39;&gt;&lt;ul&gt;</span><span style="color: #A45A77; font-weight: bold">{</span><span style="color: #BA2121">&#39;&#39;</span><span style="color: #666666">.</span>join(src_items)<span style="color: #A45A77; font-weight: bold">}</span><span style="color: #BA2121">&lt;/ul&gt;&lt;/div&gt;&quot;</span>
                <span style="color: #008000; font-weight: bold">if</span> src_items
                <span style="color: #008000; font-weight: bold">else</span> <span style="color: #BA2121">&quot;&quot;</span>
            )
            body_parts<span style="color: #666666">.</span>append(
                <span style="color: #BA2121">f&quot;&lt;h2 id=&#39;</span><span style="color: #A45A77; font-weight: bold">{</span>anchor<span style="color: #A45A77; font-weight: bold">}</span><span style="color: #BA2121">&#39;&gt;</span><span style="color: #A45A77; font-weight: bold">{</span>html<span style="color: #666666">.</span>escape(sec_title)<span style="color: #A45A77; font-weight: bold">}</span><span style="color: #BA2121">&lt;/h2&gt;&lt;p&gt;</span><span style="color: #A45A77; font-weight: bold">{</span>snippets<span style="color: #A45A77; font-weight: bold">}</span><span style="color: #BA2121">&lt;/p&gt;</span><span style="color: #A45A77; font-weight: bold">{</span>sources_block<span style="color: #A45A77; font-weight: bold">}</span><span style="color: #BA2121">&quot;</span>
            )
        <span style="color: #008000; font-weight: bold">else</span>:
            <span style="color: #008000; font-weight: bold">if</span> <span style="color: #AA22FF; font-weight: bold">not</span> text:
                text <span style="color: #666666">=</span> <span style="color: #BA2121">&quot;No information provided.&quot;</span>
            <span style="color: #008000; font-weight: bold">if</span> markdown <span style="color: #AA22FF; font-weight: bold">is</span> <span style="color: #AA22FF; font-weight: bold">not</span> <span style="color: #008000; font-weight: bold">None</span>:
                <span style="color: #008000; font-weight: bold">try</span>:
                    rendered <span style="color: #666666">=</span> markdown<span style="color: #666666">.</span>markdown(
                        text, extensions<span style="color: #666666">=</span>[<span style="color: #BA2121">&quot;fenced_code&quot;</span>, <span style="color: #BA2121">&quot;tables&quot;</span>]
                    )
                <span style="color: #008000; font-weight: bold">except</span> <span style="color: #CB3F38; font-weight: bold">Exception</span>:
                    rendered <span style="color: #666666">=</span> html<span style="color: #666666">.</span>escape(text)
            <span style="color: #008000; font-weight: bold">else</span>:  <span style="color: #3D7B7B; font-style: italic"># pragma: no cover - optional dependency missing</span>
                rendered <span style="color: #666666">=</span> html<span style="color: #666666">.</span>escape(text)
            body_parts<span style="color: #666666">.</span>append(
                <span style="color: #BA2121">f&quot;&lt;h2 id=&#39;</span><span style="color: #A45A77; font-weight: bold">{</span>anchor<span style="color: #A45A77; font-weight: bold">}</span><span style="color: #BA2121">&#39;&gt;</span><span style="color: #A45A77; font-weight: bold">{</span>html<span style="color: #666666">.</span>escape(sec_title)<span style="color: #A45A77; font-weight: bold">}</span><span style="color: #BA2121">&lt;/h2&gt;</span><span style="color: #A45A77; font-weight: bold">{</span>rendered<span style="color: #A45A77; font-weight: bold">}</span><span style="color: #BA2121">&quot;</span>
            )

    parts <span style="color: #666666">=</span> [
        <span style="color: #BA2121">&quot;&lt;html&gt;&lt;head&gt;&lt;meta charset=&#39;utf-8&#39;&gt;&quot;</span>,
        (
            <span style="color: #BA2121">&quot;&lt;style&gt;body{font-family:Arial,sans-serif;margin:20px;}h2{color:#2c3e50;}&quot;</span>
            <span style="color: #BA2121">&quot;.evidence{margin-left:1em;color:#555;font-size:0.9em;}&quot;</span>
            <span style="color: #BA2121">&quot;.sources{margin-left:1em;font-size:0.9em;}&quot;</span>
            <span style="color: #BA2121">&quot;.sources ul{margin:0;padding-left:1.2em;}&lt;/style&gt;&quot;</span>
        ),
        <span style="color: #BA2121">&quot;&lt;/head&gt;&lt;body&gt;&quot;</span>,
        <span style="color: #BA2121">f&quot;&lt;h1&gt;</span><span style="color: #A45A77; font-weight: bold">{</span>html<span style="color: #666666">.</span>escape(title)<span style="color: #A45A77; font-weight: bold">}</span><span style="color: #BA2121">&lt;/h1&gt;&quot;</span>,
        <span style="color: #BA2121">&quot;&lt;nav&gt;&lt;ul&gt;&quot;</span>,
        <span style="color: #BA2121">&quot;&quot;</span><span style="color: #666666">.</span>join(nav_items),
        <span style="color: #BA2121">&quot;&lt;/ul&gt;&lt;/nav&gt;&quot;</span>,
        <span style="color: #BA2121">&quot;&quot;</span><span style="color: #666666">.</span>join(body_parts),
        <span style="color: #BA2121">&quot;&lt;/body&gt;&lt;/html&gt;&quot;</span>,
    ]
    <span style="color: #008000; font-weight: bold">return</span> <span style="color: #BA2121">&quot;</span><span style="color: #AA5D1F; font-weight: bold">\n</span><span style="color: #BA2121">&quot;</span><span style="color: #666666">.</span>join(parts)
</code></pre>
<details>
<summary>Subfunction: _slugify(text: str) -&gt; str</summary>
<h4 id="_slugify">_slugify(text: str) -&gt; str</h4>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">_slugify</span>(text: <span style="color: #008000">str</span>) <span style="color: #666666">-&gt;</span> <span style="color: #008000">str</span>:
        slug <span style="color: #666666">=</span> re<span style="color: #666666">.</span>sub(<span style="color: #BA2121">r&quot;[^a-z0-9]+&quot;</span>, <span style="color: #BA2121">&quot;-&quot;</span>, text<span style="color: #666666">.</span>lower())
        <span style="color: #008000; font-weight: bold">return</span> slug<span style="color: #666666">.</span>strip(<span style="color: #BA2121">&quot;-&quot;</span>)
</code></pre>
</details>
<h3 id="parse_manual">parse_manual(text: str, client: &#x27;LLMClient | None&#x27;=None, infer_missing: bool=True) -&gt; Dict[str, str]</h3>
<p>The function `parse_manual` takes a string of text, an optional language model client, and a boolean flag to infer missing sections. It parses the input text into structured sections based on lines containing a colon. If required sections are missing and inference is enabled, it uses the provided language model client to generate summaries for these sections and marks them as inferred in the output. The function returns a dictionary where keys are section titles and values are their corresponding content.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">parse_manual</span>(
    text: <span style="color: #008000">str</span>,
    client: <span style="color: #BA2121">&quot;LLMClient | None&quot;</span> <span style="color: #666666">=</span> <span style="color: #008000; font-weight: bold">None</span>,
    infer_missing: <span style="color: #008000">bool</span> <span style="color: #666666">=</span> <span style="color: #008000; font-weight: bold">True</span>,
) <span style="color: #666666">-&gt;</span> Dict[<span style="color: #008000">str</span>, <span style="color: #008000">str</span>]:
<span style="color: #bbbbbb">    </span><span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;Parse ``text`` from the LLM into structured sections.</span>

<span style="color: #BA2121; font-style: italic">    The language model may return any set of headings. This parser splits the</span>
<span style="color: #BA2121; font-style: italic">    input on lines containing a colon (``Section: content``) and keeps the</span>
<span style="color: #BA2121; font-style: italic">    sections in the order they appear. When ``infer_missing`` is ``True``,</span>
<span style="color: #BA2121; font-style: italic">    absent required sections are inferred using the language model and marked</span>
<span style="color: #BA2121; font-style: italic">    as ``(inferred)``.</span>
<span style="color: #BA2121; font-style: italic">    &quot;&quot;&quot;</span>

    sections: Dict[<span style="color: #008000">str</span>, <span style="color: #008000">str</span>] <span style="color: #666666">=</span> {}
    current: <span style="color: #008000">str</span> <span style="color: #666666">|</span> <span style="color: #008000; font-weight: bold">None</span> <span style="color: #666666">=</span> <span style="color: #008000; font-weight: bold">None</span>
    <span style="color: #008000; font-weight: bold">for</span> line <span style="color: #AA22FF; font-weight: bold">in</span> text<span style="color: #666666">.</span>splitlines():
        stripped <span style="color: #666666">=</span> line<span style="color: #666666">.</span>strip()
        <span style="color: #008000; font-weight: bold">if</span> <span style="color: #AA22FF; font-weight: bold">not</span> stripped:
            <span style="color: #008000; font-weight: bold">continue</span>
        match <span style="color: #666666">=</span> re<span style="color: #666666">.</span>match(<span style="color: #BA2121">r&quot;^([A-Za-z &amp;]+):\s*(.*)$&quot;</span>, stripped)
        <span style="color: #008000; font-weight: bold">if</span> match:
            current <span style="color: #666666">=</span> match<span style="color: #666666">.</span>group(<span style="color: #666666">1</span>)<span style="color: #666666">.</span>strip()
            sections[current] <span style="color: #666666">=</span> match<span style="color: #666666">.</span>group(<span style="color: #666666">2</span>)<span style="color: #666666">.</span>strip()
        <span style="color: #008000; font-weight: bold">elif</span> current:
            sections[current] <span style="color: #666666">+=</span> (<span style="color: #BA2121">&quot;</span><span style="color: #AA5D1F; font-weight: bold">\n</span><span style="color: #BA2121">&quot;</span> <span style="color: #008000; font-weight: bold">if</span> sections[current] <span style="color: #008000; font-weight: bold">else</span> <span style="color: #BA2121">&quot;&quot;</span>) <span style="color: #666666">+</span> stripped

    missing <span style="color: #666666">=</span> [key <span style="color: #008000; font-weight: bold">for</span> key <span style="color: #AA22FF; font-weight: bold">in</span> REQUIRED_SECTIONS <span style="color: #008000; font-weight: bold">if</span> <span style="color: #AA22FF; font-weight: bold">not</span> sections<span style="color: #666666">.</span>get(key, <span style="color: #BA2121">&quot;&quot;</span>)<span style="color: #666666">.</span>strip()]
    <span style="color: #008000; font-weight: bold">if</span> infer_missing <span style="color: #AA22FF; font-weight: bold">and</span> missing:
        <span style="color: #008000; font-weight: bold">if</span> client <span style="color: #AA22FF; font-weight: bold">is</span> <span style="color: #008000; font-weight: bold">None</span>:
            client <span style="color: #666666">=</span> LLMClient()
        <span style="color: #008000; font-weight: bold">for</span> key <span style="color: #AA22FF; font-weight: bold">in</span> missing:
            prompt <span style="color: #666666">=</span> (
                <span style="color: #BA2121">f&quot;Based on the following manual draft, write a short &#39;</span><span style="color: #A45A77; font-weight: bold">{</span>key<span style="color: #A45A77; font-weight: bold">}</span><span style="color: #BA2121">&#39; section.</span><span style="color: #AA5D1F; font-weight: bold">\n\n</span><span style="color: #A45A77; font-weight: bold">{</span>text<span style="color: #A45A77; font-weight: bold">}</span><span style="color: #BA2121">&quot;</span>
            )
            <span style="color: #008000; font-weight: bold">try</span>:
                guess <span style="color: #666666">=</span> client<span style="color: #666666">.</span>summarize(
                    prompt,
                    <span style="color: #BA2121">&quot;docstring&quot;</span>,
                    system_prompt<span style="color: #666666">=</span><span style="color: #BA2121">f&quot;You fill in the &#39;</span><span style="color: #A45A77; font-weight: bold">{</span>key<span style="color: #A45A77; font-weight: bold">}</span><span style="color: #BA2121">&#39; section of a user manual.&quot;</span>,
                )
            <span style="color: #008000; font-weight: bold">except</span> <span style="color: #CB3F38; font-weight: bold">Exception</span>:  <span style="color: #3D7B7B; font-style: italic"># pragma: no cover - network issues</span>
                guess <span style="color: #666666">=</span> <span style="color: #BA2121">&quot;&quot;</span>
            sections[key] <span style="color: #666666">=</span> (guess<span style="color: #666666">.</span>strip() <span style="color: #AA22FF; font-weight: bold">or</span> <span style="color: #BA2121">f&quot;</span><span style="color: #A45A77; font-weight: bold">{</span>key<span style="color: #A45A77; font-weight: bold">}</span><span style="color: #BA2121"> details&quot;</span>) <span style="color: #666666">+</span> <span style="color: #BA2121">&quot; (inferred)&quot;</span>

    <span style="color: #008000; font-weight: bold">return</span> sections
</code></pre>
<h3 id="validate_manual_references">validate_manual_references(sections: Dict[str, str], project_root: Path, evidence_map: dict[str, dict[str, object]] | None=None) -&gt; None</h3>
<p>This function `validate_manual_references` checks for missing file references in documentation sections. It scans each section&#x27;s text for substrings that resemble file paths or module names and flags those that cannot be found under the specified project root directory. If a reference is missing, it appends &quot;[missing]&quot; to the reference in the section text. Additionally, if an `evidence_map` is provided, it records the missing references under the corresponding section in a list called `missing_references`. The function modifies the `sections` dictionary in place.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">validate_manual_references</span>(
    sections: Dict[<span style="color: #008000">str</span>, <span style="color: #008000">str</span>],
    project_root: Path,
    evidence_map: <span style="color: #008000">dict</span>[<span style="color: #008000">str</span>, <span style="color: #008000">dict</span>[<span style="color: #008000">str</span>, <span style="color: #008000">object</span>]] <span style="color: #666666">|</span> <span style="color: #008000; font-weight: bold">None</span> <span style="color: #666666">=</span> <span style="color: #008000; font-weight: bold">None</span>,
) <span style="color: #666666">-&gt;</span> <span style="color: #008000; font-weight: bold">None</span>:
<span style="color: #bbbbbb">    </span><span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;Flag references in ``sections`` that lack corresponding files.</span>

<span style="color: #BA2121; font-style: italic">    Each section&#39;s text is scanned for substrings that resemble file paths or</span>
<span style="color: #BA2121; font-style: italic">    module names (e.g., ``module.py`` or ``sub/dir/file.m``). If a referenced</span>
<span style="color: #BA2121; font-style: italic">    file cannot be found anywhere under ``project_root``, the reference is</span>
<span style="color: #BA2121; font-style: italic">    annotated with ``[missing]`` in the section text. When ``evidence_map`` is</span>
<span style="color: #BA2121; font-style: italic">    provided, missing references are also recorded under the corresponding</span>
<span style="color: #BA2121; font-style: italic">    section in a ``missing_references`` list.</span>

<span style="color: #BA2121; font-style: italic">    The ``sections`` mapping is modified in place.</span>
<span style="color: #BA2121; font-style: italic">    &quot;&quot;&quot;</span>

    pattern <span style="color: #666666">=</span> re<span style="color: #666666">.</span>compile(
        <span style="color: #BA2121">r&quot;\b[\w./-]+\.(?:py|m|md|rst|txt|json|yaml|yml|csv)\b&quot;</span>
    )

    existing_paths <span style="color: #666666">=</span> {
        p<span style="color: #666666">.</span>relative_to(project_root)<span style="color: #666666">.</span>as_posix()
        <span style="color: #008000; font-weight: bold">for</span> p <span style="color: #AA22FF; font-weight: bold">in</span> project_root<span style="color: #666666">.</span>rglob(<span style="color: #BA2121">&quot;*&quot;</span>)
        <span style="color: #008000; font-weight: bold">if</span> p<span style="color: #666666">.</span>is_file()
    }
    existing_names <span style="color: #666666">=</span> {Path(p)<span style="color: #666666">.</span>name <span style="color: #008000; font-weight: bold">for</span> p <span style="color: #AA22FF; font-weight: bold">in</span> existing_paths}

    <span style="color: #008000; font-weight: bold">for</span> title, text <span style="color: #AA22FF; font-weight: bold">in</span> sections<span style="color: #666666">.</span>items():
        missing: <span style="color: #008000">list</span>[<span style="color: #008000">str</span>] <span style="color: #666666">=</span> []

        <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">repl</span>(match: re<span style="color: #666666">.</span>Match[<span style="color: #008000">str</span>]) <span style="color: #666666">-&gt;</span> <span style="color: #008000">str</span>:
            ref <span style="color: #666666">=</span> match<span style="color: #666666">.</span>group(<span style="color: #666666">0</span>)
            <span style="color: #008000; font-weight: bold">if</span> ref <span style="color: #AA22FF; font-weight: bold">in</span> existing_paths <span style="color: #AA22FF; font-weight: bold">or</span> ref <span style="color: #AA22FF; font-weight: bold">in</span> existing_names:
                <span style="color: #008000; font-weight: bold">return</span> ref
            missing<span style="color: #666666">.</span>append(ref)
            <span style="color: #008000; font-weight: bold">return</span> <span style="color: #BA2121">f&quot;</span><span style="color: #A45A77; font-weight: bold">{</span>ref<span style="color: #A45A77; font-weight: bold">}</span><span style="color: #BA2121"> [missing]&quot;</span>

        updated <span style="color: #666666">=</span> pattern<span style="color: #666666">.</span>sub(repl, text)
        sections[title] <span style="color: #666666">=</span> updated
        <span style="color: #008000; font-weight: bold">if</span> missing <span style="color: #AA22FF; font-weight: bold">and</span> evidence_map <span style="color: #AA22FF; font-weight: bold">is</span> <span style="color: #AA22FF; font-weight: bold">not</span> <span style="color: #008000; font-weight: bold">None</span>:
            evidence_map<span style="color: #666666">.</span>setdefault(title, {})<span style="color: #666666">.</span>setdefault(
                <span style="color: #BA2121">&quot;missing_references&quot;</span>, []
            )<span style="color: #666666">.</span>extend(missing)
</code></pre>
<h3 id="infer_sections">infer_sections(text: str) -&gt; Dict[str, str]</h3>
<p>The function `infer_sections` takes a string `text` as input and returns a dictionary where keys are section names and values are the content of those sections. If the input text is non-empty, it places the entire text under an &quot;Overview&quot; section and generates placeholder content for other required sections labeled &quot;(inferred)&quot;. If the input text is empty, it initializes all required sections with a default message indicating no information is available.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">infer_sections</span>(text: <span style="color: #008000">str</span>) <span style="color: #666666">-&gt;</span> Dict[<span style="color: #008000">str</span>, <span style="color: #008000">str</span>]:
<span style="color: #bbbbbb">    </span><span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;Infer manual sections heuristically from plain ``text``.</span>

<span style="color: #BA2121; font-style: italic">    This is a lightweight fallback used when the language model cannot provide</span>
<span style="color: #BA2121; font-style: italic">    a structured summary. When ``text`` is non-empty, the combined text is</span>
<span style="color: #BA2121; font-style: italic">    placed in the ``Overview`` section and placeholder content labelled</span>
<span style="color: #BA2121; font-style: italic">    ``(inferred)`` is generated for the remaining sections. If ``text`` is</span>
<span style="color: #BA2121; font-style: italic">    empty, a default message is used to indicate that no information exists.</span>
<span style="color: #BA2121; font-style: italic">    &quot;&quot;&quot;</span>

    sections: Dict[<span style="color: #008000">str</span>, <span style="color: #008000">str</span>] <span style="color: #666666">=</span> {}
    text <span style="color: #666666">=</span> text<span style="color: #666666">.</span>strip()
    <span style="color: #008000; font-weight: bold">if</span> text:
        sections[<span style="color: #BA2121">&quot;Overview&quot;</span>] <span style="color: #666666">=</span> text
        <span style="color: #008000; font-weight: bold">for</span> key <span style="color: #AA22FF; font-weight: bold">in</span> REQUIRED_SECTIONS:
            sections<span style="color: #666666">.</span>setdefault(key, <span style="color: #BA2121">f&quot;</span><span style="color: #A45A77; font-weight: bold">{</span>key<span style="color: #A45A77; font-weight: bold">}</span><span style="color: #BA2121"> details (inferred)&quot;</span>)
    <span style="color: #008000; font-weight: bold">else</span>:
        <span style="color: #008000; font-weight: bold">for</span> key <span style="color: #AA22FF; font-weight: bold">in</span> REQUIRED_SECTIONS:
            sections[key] <span style="color: #666666">=</span> <span style="color: #BA2121">&quot;No information provided.&quot;</span>
    <span style="color: #008000; font-weight: bold">return</span> sections
</code></pre>
<h3 id="write_pdf">write_pdf(html: str, path: Path) -&gt; bool</h3>
<p>The function `write_pdf` takes an HTML string and a file path as input. It checks if the `canvas` module is available; if not, it returns `False`. Otherwise, it converts the HTML to plain text, creates a PDF canvas, writes the text to the PDF, saves the PDF to the specified path, and returns `True` on success.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">write_pdf</span>(html: <span style="color: #008000">str</span>, path: Path) <span style="color: #666666">-&gt;</span> <span style="color: #008000">bool</span>:
<span style="color: #bbbbbb">    </span><span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;Write ``html`` to ``path`` as a PDF. Returns ``True`` on success.&quot;&quot;&quot;</span>
    <span style="color: #008000; font-weight: bold">if</span> canvas <span style="color: #AA22FF; font-weight: bold">is</span> <span style="color: #008000; font-weight: bold">None</span>:  <span style="color: #3D7B7B; font-style: italic"># pragma: no cover - optional branch</span>
        <span style="color: #008000; font-weight: bold">return</span> <span style="color: #008000; font-weight: bold">False</span>
    text <span style="color: #666666">=</span> BeautifulSoup(html, <span style="color: #BA2121">&quot;html.parser&quot;</span>)<span style="color: #666666">.</span>get_text()<span style="color: #666666">.</span>splitlines()
    c <span style="color: #666666">=</span> canvas<span style="color: #666666">.</span>Canvas(<span style="color: #008000">str</span>(path), pagesize<span style="color: #666666">=</span>letter)
    textobject <span style="color: #666666">=</span> c<span style="color: #666666">.</span>beginText(<span style="color: #666666">40</span>, <span style="color: #666666">750</span>)
    <span style="color: #008000; font-weight: bold">for</span> line <span style="color: #AA22FF; font-weight: bold">in</span> text:
        textobject<span style="color: #666666">.</span>textLine(line)
    c<span style="color: #666666">.</span>drawText(textobject)
    c<span style="color: #666666">.</span>save()
    <span style="color: #008000; font-weight: bold">return</span> <span style="color: #008000; font-weight: bold">True</span>
</code></pre>
<h3 id="main">main(argv: list[str] | None=None) -&gt; int</h3>
<p>The `main` function serves as the entry point for generating project documentation. It parses command-line arguments to configure settings such as the target project directory, output format, and various options related to code scanning and chunking. The function initializes a configuration object based on these arguments and proceeds with the following steps:

1. Collects documentation files from the specified path.
2. Reads and processes the text content of these files.
3. Initializes logging based on the chunking mode.
4. Generates an initial summary using a language model client, handling exceptions if summarization fails.
5. If placeholders are detected in the initial response, it optionally scans project code to fill these placeholders.
6. Renders the final HTML or PDF output based on the configured format.
7. Optionally inserts a link to the generated manual into an index file.
8. Saves evidence data related to the documentation process.

The function returns an integer status code indicating success (0) or failure (non-zero).</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">main</span>(argv: <span style="color: #008000">list</span>[<span style="color: #008000">str</span>] <span style="color: #666666">|</span> <span style="color: #008000; font-weight: bold">None</span> <span style="color: #666666">=</span> <span style="color: #008000; font-weight: bold">None</span>) <span style="color: #666666">-&gt;</span> <span style="color: #008000">int</span>:
    parser <span style="color: #666666">=</span> argparse<span style="color: #666666">.</span>ArgumentParser(description<span style="color: #666666">=</span><span style="color: #BA2121">&quot;Summarise project documentation&quot;</span>)
    parser<span style="color: #666666">.</span>add_argument(<span style="color: #BA2121">&quot;--path&quot;</span>, default<span style="color: #666666">=</span><span style="color: #BA2121">&quot;.&quot;</span>, help<span style="color: #666666">=</span><span style="color: #BA2121">&quot;target project directory&quot;</span>)
    parser<span style="color: #666666">.</span>add_argument(
        <span style="color: #BA2121">&quot;--output-format&quot;</span>, choices<span style="color: #666666">=</span>[<span style="color: #BA2121">&quot;html&quot;</span>, <span style="color: #BA2121">&quot;pdf&quot;</span>], default<span style="color: #666666">=</span><span style="color: #BA2121">&quot;html&quot;</span>,
        help<span style="color: #666666">=</span><span style="color: #BA2121">&quot;output format for the summary&quot;</span>,
    )
    parser<span style="color: #666666">.</span>add_argument(<span style="color: #BA2121">&quot;--output&quot;</span>, help<span style="color: #666666">=</span><span style="color: #BA2121">&quot;Destination directory for generated summary&quot;</span>)
    parser<span style="color: #666666">.</span>add_argument(<span style="color: #BA2121">&quot;--title&quot;</span>, default<span style="color: #666666">=</span><span style="color: #BA2121">&quot;User Manual&quot;</span>, help<span style="color: #666666">=</span><span style="color: #BA2121">&quot;Title for the generated manual&quot;</span>)
    parser<span style="color: #666666">.</span>add_argument(
        <span style="color: #BA2121">&quot;--insert-into-index&quot;</span>,
        action<span style="color: #666666">=</span><span style="color: #BA2121">&quot;store_true&quot;</span>,
        help<span style="color: #666666">=</span><span style="color: #BA2121">&quot;Insert link to the manual into index.html in the output directory&quot;</span>,
    )
    parser<span style="color: #666666">.</span>add_argument(
        <span style="color: #BA2121">&quot;--chunking&quot;</span>,
        choices<span style="color: #666666">=</span>[<span style="color: #BA2121">&quot;auto&quot;</span>, <span style="color: #BA2121">&quot;manual&quot;</span>, <span style="color: #BA2121">&quot;none&quot;</span>],
        default<span style="color: #666666">=</span><span style="color: #BA2121">&quot;auto&quot;</span>,
        help<span style="color: #666666">=</span><span style="color: #BA2121">&quot;Chunking mode: auto (default) chunks only when needed; manual always chunks; none disables chunking.&quot;</span>,
    )
    parser<span style="color: #666666">.</span>add_argument(
        <span style="color: #BA2121">&quot;--scan-code-if-needed&quot;</span>,
        action<span style="color: #666666">=</span><span style="color: #BA2121">&quot;store_true&quot;</span>,
        help<span style="color: #666666">=</span><span style="color: #BA2121">&quot;Scan project code if manual sections are missing after doc pass&quot;</span>,
    )
    parser<span style="color: #666666">.</span>add_argument(<span style="color: #BA2121">&quot;--no-code&quot;</span>, action<span style="color: #666666">=</span><span style="color: #BA2121">&quot;store_true&quot;</span>, help<span style="color: #666666">=</span><span style="color: #BA2121">&quot;Do not scan project code&quot;</span>)
    parser<span style="color: #666666">.</span>add_argument(<span style="color: #BA2121">&quot;--force-code&quot;</span>, action<span style="color: #666666">=</span><span style="color: #BA2121">&quot;store_true&quot;</span>, help<span style="color: #666666">=</span><span style="color: #BA2121">&quot;Always scan project code&quot;</span>)
    parser<span style="color: #666666">.</span>add_argument(<span style="color: #BA2121">&quot;--max-code-files&quot;</span>, <span style="color: #008000">type</span><span style="color: #666666">=</span><span style="color: #008000">int</span>, default<span style="color: #666666">=12</span>, help<span style="color: #666666">=</span><span style="color: #BA2121">&quot;Maximum number of code files to scan&quot;</span>)
    parser<span style="color: #666666">.</span>add_argument(
        <span style="color: #BA2121">&quot;--code-time-budget-seconds&quot;</span>,
        <span style="color: #008000">type</span><span style="color: #666666">=</span><span style="color: #008000">int</span>,
        default<span style="color: #666666">=20</span>,
        help<span style="color: #666666">=</span><span style="color: #BA2121">&quot;Time budget in seconds for scanning code&quot;</span>,
    )
    parser<span style="color: #666666">.</span>add_argument(
        <span style="color: #BA2121">&quot;--max-bytes-per-file&quot;</span>,
        <span style="color: #008000">type</span><span style="color: #666666">=</span><span style="color: #008000">int</span>,
        default<span style="color: #666666">=200_000</span>,
        help<span style="color: #666666">=</span><span style="color: #BA2121">&quot;Maximum bytes to read from each code file&quot;</span>,
    )
    args <span style="color: #666666">=</span> parser<span style="color: #666666">.</span>parse_args(argv)

    config <span style="color: #666666">=</span> Config(
        path<span style="color: #666666">=</span>Path(args<span style="color: #666666">.</span>path),
        output_format<span style="color: #666666">=</span>args<span style="color: #666666">.</span>output_format,
        output<span style="color: #666666">=</span>Path(args<span style="color: #666666">.</span>output) <span style="color: #008000; font-weight: bold">if</span> args<span style="color: #666666">.</span>output <span style="color: #008000; font-weight: bold">else</span> <span style="color: #008000; font-weight: bold">None</span>,
        title<span style="color: #666666">=</span>args<span style="color: #666666">.</span>title,
        insert_into_index<span style="color: #666666">=</span>args<span style="color: #666666">.</span>insert_into_index,
        chunking<span style="color: #666666">=</span>args<span style="color: #666666">.</span>chunking,
        scan_code_if_needed<span style="color: #666666">=</span>args<span style="color: #666666">.</span>scan_code_if_needed,
        no_code<span style="color: #666666">=</span>args<span style="color: #666666">.</span>no_code,
        force_code<span style="color: #666666">=</span>args<span style="color: #666666">.</span>force_code,
        max_code_files<span style="color: #666666">=</span>args<span style="color: #666666">.</span>max_code_files,
        code_time_budget_seconds<span style="color: #666666">=</span>args<span style="color: #666666">.</span>code_time_budget_seconds,
        max_bytes_per_file<span style="color: #666666">=</span>args<span style="color: #666666">.</span>max_bytes_per_file,
    )

    target <span style="color: #666666">=</span> config<span style="color: #666666">.</span>path
    docs_index <span style="color: #666666">=</span> target <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;docs&quot;</span> <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;index.html&quot;</span>
    <span style="color: #008000; font-weight: bold">if</span> config<span style="color: #666666">.</span>output:
        out_dir <span style="color: #666666">=</span> config<span style="color: #666666">.</span>output
    <span style="color: #008000; font-weight: bold">else</span>:
        out_dir <span style="color: #666666">=</span> docs_index<span style="color: #666666">.</span>parent <span style="color: #008000; font-weight: bold">if</span> docs_index<span style="color: #666666">.</span>exists() <span style="color: #008000; font-weight: bold">else</span> target
    out_dir<span style="color: #666666">.</span>mkdir(parents<span style="color: #666666">=</span><span style="color: #008000; font-weight: bold">True</span>, exist_ok<span style="color: #666666">=</span><span style="color: #008000; font-weight: bold">True</span>)
    files <span style="color: #666666">=</span> collect_docs(target)
    doc_texts <span style="color: #666666">=</span> {f: extract_text(f) <span style="color: #008000; font-weight: bold">for</span> f <span style="color: #AA22FF; font-weight: bold">in</span> tqdm(files, desc<span style="color: #666666">=</span><span style="color: #BA2121">&quot;Reading docs&quot;</span>)}
    texts <span style="color: #666666">=</span> <span style="color: #008000">list</span>(doc_texts<span style="color: #666666">.</span>values())
    logging<span style="color: #666666">.</span>basicConfig(
        level<span style="color: #666666">=</span>logging<span style="color: #666666">.</span>DEBUG <span style="color: #008000; font-weight: bold">if</span> config<span style="color: #666666">.</span>chunking <span style="color: #666666">!=</span> <span style="color: #BA2121">&quot;none&quot;</span> <span style="color: #008000; font-weight: bold">else</span> logging<span style="color: #666666">.</span>INFO
    )

    logging<span style="color: #666666">.</span>info(<span style="color: #BA2121">&quot;DOC PASS started with </span><span style="color: #A45A77; font-weight: bold">%d</span><span style="color: #BA2121"> files&quot;</span>, <span style="color: #008000">len</span>(files))
    logging<span style="color: #666666">.</span>info(<span style="color: #BA2121">&quot;Files: </span><span style="color: #A45A77; font-weight: bold">%s</span><span style="color: #BA2121">&quot;</span>, <span style="color: #BA2121">&quot;, &quot;</span><span style="color: #666666">.</span>join(<span style="color: #008000">str</span>(f) <span style="color: #008000; font-weight: bold">for</span> f <span style="color: #AA22FF; font-weight: bold">in</span> files))

    client <span style="color: #666666">=</span> LLMClient()
    cache <span style="color: #666666">=</span> ResponseCache(<span style="color: #008000">str</span>(out_dir <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;cache.json&quot;</span>))
    evidence_map: <span style="color: #008000">dict</span>[<span style="color: #008000">str</span>, <span style="color: #008000">dict</span>[<span style="color: #008000">str</span>, <span style="color: #008000">object</span>]] <span style="color: #666666">=</span> {}
    <span style="color: #008000; font-weight: bold">try</span>:
        ping <span style="color: #666666">=</span> <span style="color: #008000">getattr</span>(client, <span style="color: #BA2121">&quot;ping&quot;</span>, <span style="color: #008000; font-weight: bold">None</span>)
        <span style="color: #008000; font-weight: bold">if</span> callable(ping):
            ping()
        response, file_sections, evidence_map <span style="color: #666666">=</span> llm_generate_manual(
            doc_texts, client, cache, config<span style="color: #666666">.</span>chunking
        )
        <span style="color: #008000; font-weight: bold">for</span> f <span style="color: #AA22FF; font-weight: bold">in</span> files:
            sections <span style="color: #666666">=</span> <span style="color: #008000">sorted</span>(file_sections<span style="color: #666666">.</span>get(f, <span style="color: #008000">set</span>()))
            logging<span style="color: #666666">.</span>info(
                <span style="color: #BA2121">&quot;</span><span style="color: #A45A77; font-weight: bold">%s</span><span style="color: #BA2121"> contributes to sections: </span><span style="color: #A45A77; font-weight: bold">%s</span><span style="color: #BA2121">&quot;</span>,
                f,
                <span style="color: #BA2121">&quot;, &quot;</span><span style="color: #666666">.</span>join(sections) <span style="color: #008000; font-weight: bold">if</span> sections <span style="color: #008000; font-weight: bold">else</span> <span style="color: #BA2121">&quot;none&quot;</span>,
            )
        missing <span style="color: #666666">=</span> detect_placeholders(response)
        <span style="color: #008000; font-weight: bold">if</span> missing:
            logging<span style="color: #666666">.</span>info(<span style="color: #BA2121">&quot;Pass 1 missing sections: </span><span style="color: #A45A77; font-weight: bold">%s</span><span style="color: #BA2121">&quot;</span>, <span style="color: #BA2121">&quot;, &quot;</span><span style="color: #666666">.</span>join(missing))
        <span style="color: #008000; font-weight: bold">else</span>:
            logging<span style="color: #666666">.</span>info(<span style="color: #BA2121">&quot;Pass 1 complete: no sections missing&quot;</span>)

        <span style="color: #008000; font-weight: bold">if</span> config<span style="color: #666666">.</span>no_code:
            logging<span style="color: #666666">.</span>info(<span style="color: #BA2121">&quot;Code scan skipped: --no-code specified&quot;</span>)
            should_scan <span style="color: #666666">=</span> <span style="color: #008000; font-weight: bold">False</span>
        <span style="color: #008000; font-weight: bold">elif</span> config<span style="color: #666666">.</span>force_code:
            logging<span style="color: #666666">.</span>info(<span style="color: #BA2121">&quot;Code scan triggered: --force-code enabled&quot;</span>)
            should_scan <span style="color: #666666">=</span> <span style="color: #008000; font-weight: bold">True</span>
        <span style="color: #008000; font-weight: bold">elif</span> config<span style="color: #666666">.</span>scan_code_if_needed:
            <span style="color: #008000; font-weight: bold">if</span> missing:
                logging<span style="color: #666666">.</span>info(
                    <span style="color: #BA2121">&quot;Code scan triggered: missing sections </span><span style="color: #A45A77; font-weight: bold">%s</span><span style="color: #BA2121">&quot;</span>,
                    <span style="color: #BA2121">&quot;, &quot;</span><span style="color: #666666">.</span>join(missing),
                )
                should_scan <span style="color: #666666">=</span> <span style="color: #008000; font-weight: bold">True</span>
            <span style="color: #008000; font-weight: bold">else</span>:
                logging<span style="color: #666666">.</span>info(<span style="color: #BA2121">&quot;Code scan skipped: placeholders resolved&quot;</span>)
                should_scan <span style="color: #666666">=</span> <span style="color: #008000; font-weight: bold">False</span>
        <span style="color: #008000; font-weight: bold">else</span>:
            logging<span style="color: #666666">.</span>info(<span style="color: #BA2121">&quot;Code scan skipped: no scan flags provided&quot;</span>)
            should_scan <span style="color: #666666">=</span> <span style="color: #008000; font-weight: bold">False</span>

        <span style="color: #008000; font-weight: bold">if</span> should_scan:
            code_context <span style="color: #666666">=</span> scan_code(
                target,
                missing,
                max_files<span style="color: #666666">=</span>config<span style="color: #666666">.</span>max_code_files,
                time_budget<span style="color: #666666">=</span>config<span style="color: #666666">.</span>code_time_budget_seconds,
                max_bytes_per_file<span style="color: #666666">=</span>config<span style="color: #666666">.</span>max_bytes_per_file,
            )
            <span style="color: #008000; font-weight: bold">if</span> code_context <span style="color: #AA22FF; font-weight: bold">and</span> missing:
                response <span style="color: #666666">=</span> llm_fill_placeholders(
                    response, code_context, client, cache
                )
                missing <span style="color: #666666">=</span> detect_placeholders(response)
        logging<span style="color: #666666">.</span>info(
            <span style="color: #BA2121">&quot;Pass 2 complete. Unresolved placeholders: </span><span style="color: #A45A77; font-weight: bold">%s</span><span style="color: #BA2121">&quot;</span>,
            <span style="color: #BA2121">&quot;, &quot;</span><span style="color: #666666">.</span>join(missing) <span style="color: #008000; font-weight: bold">if</span> missing <span style="color: #008000; font-weight: bold">else</span> <span style="color: #BA2121">&quot;none&quot;</span>,
        )
        <span style="color: #008000; font-weight: bold">for</span> token <span style="color: #AA22FF; font-weight: bold">in</span> SECTION_PLACEHOLDERS<span style="color: #666666">.</span>values():
            response <span style="color: #666666">=</span> response<span style="color: #666666">.</span>replace(token, <span style="color: #BA2121">&quot;&quot;</span>)
        sections <span style="color: #666666">=</span> parse_manual(response, infer_missing<span style="color: #666666">=</span><span style="color: #008000; font-weight: bold">False</span>)
        validate_manual_references(sections, target, evidence_map)
    <span style="color: #008000; font-weight: bold">except</span> <span style="color: #CB3F38; font-weight: bold">Exception</span> <span style="color: #008000; font-weight: bold">as</span> exc:  <span style="color: #3D7B7B; font-style: italic"># pragma: no cover - network or attribute failure</span>
        <span style="color: #008000">print</span>(
            <span style="color: #BA2121">f&quot;[INFO] LLM summarization failed; using fallback: </span><span style="color: #A45A77; font-weight: bold">{</span>exc<span style="color: #A45A77; font-weight: bold">}</span><span style="color: #BA2121">&quot;</span>,
            file<span style="color: #666666">=</span>sys<span style="color: #666666">.</span>stderr,
        )
        combined <span style="color: #666666">=</span> <span style="color: #BA2121">&quot;</span><span style="color: #AA5D1F; font-weight: bold">\n</span><span style="color: #BA2121">&quot;</span><span style="color: #666666">.</span>join(t <span style="color: #008000; font-weight: bold">for</span> t <span style="color: #AA22FF; font-weight: bold">in</span> texts <span style="color: #008000; font-weight: bold">if</span> t)
        sections <span style="color: #666666">=</span> infer_sections(combined)
        evidence_map <span style="color: #666666">=</span> {}
        validate_manual_references(sections, target, evidence_map)
    html <span style="color: #666666">=</span> render_html(sections, config<span style="color: #666666">.</span>title, evidence_map)

    base_name <span style="color: #666666">=</span> slugify(config<span style="color: #666666">.</span>title)
    out_file <span style="color: #666666">=</span> out_dir <span style="color: #666666">/</span> <span style="color: #BA2121">f&quot;</span><span style="color: #A45A77; font-weight: bold">{</span>base_name<span style="color: #A45A77; font-weight: bold">}</span><span style="color: #BA2121">.</span><span style="color: #A45A77; font-weight: bold">{</span><span style="color: #BA2121">&#39;html&#39;</span><span style="color: #bbbbbb"> </span><span style="color: #008000; font-weight: bold">if</span><span style="color: #bbbbbb"> </span>config<span style="color: #666666">.</span>output_format<span style="color: #bbbbbb"> </span><span style="color: #666666">==</span><span style="color: #bbbbbb"> </span><span style="color: #BA2121">&#39;html&#39;</span><span style="color: #bbbbbb"> </span><span style="color: #008000; font-weight: bold">else</span><span style="color: #bbbbbb"> </span><span style="color: #BA2121">&#39;pdf&#39;</span><span style="color: #A45A77; font-weight: bold">}</span><span style="color: #BA2121">&quot;</span>
    <span style="color: #008000; font-weight: bold">if</span> config<span style="color: #666666">.</span>output_format <span style="color: #666666">==</span> <span style="color: #BA2121">&quot;html&quot;</span>:
        out_file<span style="color: #666666">.</span>write_text(html, encoding<span style="color: #666666">=</span><span style="color: #BA2121">&quot;utf-8&quot;</span>)
    <span style="color: #008000; font-weight: bold">else</span>:
        success <span style="color: #666666">=</span> write_pdf(html, out_file)
        <span style="color: #008000; font-weight: bold">if</span> <span style="color: #AA22FF; font-weight: bold">not</span> success:
            <span style="color: #008000">print</span>(<span style="color: #BA2121">&quot;PDF generation requires the reportlab package.&quot;</span>)
            <span style="color: #008000; font-weight: bold">return</span> <span style="color: #666666">1</span>

    <span style="color: #008000; font-weight: bold">if</span> config<span style="color: #666666">.</span>insert_into_index:
        <span style="color: #008000; font-weight: bold">if</span> docs_index<span style="color: #666666">.</span>exists() <span style="color: #AA22FF; font-weight: bold">and</span> <span style="color: #AA22FF; font-weight: bold">not</span> config<span style="color: #666666">.</span>output:
            index_file <span style="color: #666666">=</span> docs_index
            inject_user_manual(index_file, config<span style="color: #666666">.</span>title, out_file<span style="color: #666666">.</span>name)
        <span style="color: #008000; font-weight: bold">else</span>:
            index_file <span style="color: #666666">=</span> out_dir <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;index.html&quot;</span>
            <span style="color: #008000; font-weight: bold">if</span> index_file<span style="color: #666666">.</span>exists():
                <span style="color: #008000; font-weight: bold">if</span> <span style="color: #AA22FF; font-weight: bold">not</span> docs_index<span style="color: #666666">.</span>exists() <span style="color: #AA22FF; font-weight: bold">and</span> <span style="color: #AA22FF; font-weight: bold">not</span> config<span style="color: #666666">.</span>output:
                    docs_dir <span style="color: #666666">=</span> target <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;docs&quot;</span>
                    docs_dir<span style="color: #666666">.</span>mkdir(parents<span style="color: #666666">=</span><span style="color: #008000; font-weight: bold">True</span>, exist_ok<span style="color: #666666">=</span><span style="color: #008000; font-weight: bold">True</span>)
                    new_path <span style="color: #666666">=</span> docs_dir <span style="color: #666666">/</span> out_file<span style="color: #666666">.</span>name
                    shutil<span style="color: #666666">.</span>move(<span style="color: #008000">str</span>(out_file), new_path)
                    out_file <span style="color: #666666">=</span> new_path
                    rel <span style="color: #666666">=</span> os<span style="color: #666666">.</span>path<span style="color: #666666">.</span>relpath(out_file, index_file<span style="color: #666666">.</span>parent)
                <span style="color: #008000; font-weight: bold">else</span>:
                    rel <span style="color: #666666">=</span> out_file<span style="color: #666666">.</span>name
                inject_user_manual(index_file, config<span style="color: #666666">.</span>title, rel)

    evidence_path <span style="color: #666666">=</span> out_file<span style="color: #666666">.</span>with_name(<span style="color: #BA2121">f&quot;</span><span style="color: #A45A77; font-weight: bold">{</span>out_file<span style="color: #666666">.</span>stem<span style="color: #A45A77; font-weight: bold">}</span><span style="color: #BA2121">_evidence.json&quot;</span>)
    evidence_path<span style="color: #666666">.</span>write_text(
        json<span style="color: #666666">.</span>dumps(evidence_map, ensure_ascii<span style="color: #666666">=</span><span style="color: #008000; font-weight: bold">False</span>, indent<span style="color: #666666">=2</span>), encoding<span style="color: #666666">=</span><span style="color: #BA2121">&quot;utf-8&quot;</span>
    )

    <span style="color: #008000; font-weight: bold">return</span> <span style="color: #666666">0</span>
</code></pre>
    </div>
    <script src="static/toggle.js"></script>
</body>
</html>
