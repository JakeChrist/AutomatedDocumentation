<!-- Generated by DocGen-LM -->
<!DOCTYPE html>

<html lang="en">
<head>
<meta charset="utf-8"/><meta content="width=device-width, initial-scale=1" name="viewport"/>
    
<title>explaincode</title>
<link href="static/style.css" rel="stylesheet"/>
</head>
<body class="doc-body">
<button aria-label="Toggle navigation menu" class="sidebar-toggle" id="sidebar-toggle">Menu</button>
<div aria-label="Documentation navigation" class="sidebar" role="navigation">
<h2>Navigation</h2>
<ul><li><a href="index.html"><strong>üè† Project Overview</strong></a></li><li><a href="cache.html">cache</a></li><li><a href="chunk_utils.html">chunk_utils</a></li><li><a href="docgenerator.html">docgenerator</a></li><li><a href="explaincode.html">explaincode</a></li><li><a href="gui_wrapper.html">gui_wrapper</a></li><li><a href="html_writer.html">html_writer</a></li><li><a href="llm_client.html">llm_client</a></li><li><a href="manual_utils.html">manual_utils</a></li><li><a href="parser_cpp.html">parser_cpp</a></li><li><a href="parser_java.html">parser_java</a></li><li><a href="parser_matlab.html">parser_matlab</a></li><li><a href="parser_python.html">parser_python</a></li><li><a href="retrofit_sidebar.html">retrofit_sidebar</a></li><li><a href="reviewer.html">reviewer</a></li><li><a href="sanitize_docs.html">sanitize_docs</a></li><li><a href="scanner.html">scanner</a></li><li><a href="setup.html">setup</a></li><li><a href="summarize_utils.html">summarize_utils</a></li><li><details><summary>tests</summary><ul><li><a href="test_cache.html">test_cache</a></li><li><a href="test_chunk_utils.html">test_chunk_utils</a></li><li><a href="test_docgenerator.html">test_docgenerator</a></li><li><a href="test_docgenerator_subclasses.html">test_docgenerator_subclasses</a></li><li><a href="test_explaincode.html">test_explaincode</a></li><li><a href="test_html_writer.html">test_html_writer</a></li><li><a href="test_integration.html">test_integration</a></li><li><a href="test_llm_client.html">test_llm_client</a></li><li><a href="test_manual_utils.html">test_manual_utils</a></li><li><a href="test_parser_cpp.html">test_parser_cpp</a></li><li><a href="test_parser_java.html">test_parser_java</a></li><li><a href="test_parser_matlab.html">test_parser_matlab</a></li><li><a href="test_parser_python.html">test_parser_python</a></li><li><a href="test_resume_progress.html">test_resume_progress</a></li><li><a href="test_retrofit_sidebar.html">test_retrofit_sidebar</a></li><li><a href="test_reviewer.html">test_reviewer</a></li><li><a href="test_sanitize_docs.html">test_sanitize_docs</a></li><li><a href="test_scanner.html">test_scanner</a></li></ul></details></li></ul>
</div>
<main class="content" role="main">
        <div class="content-inner">
<h1>explaincode</h1>
<p>This module provides functionality for generating project documentation summaries by processing documentation and code files. It includes configuration handling, file collection from specified paths, and text extraction from various document formats. The module supports section mapping based on keywords, ranking of code files using heuristics, and insertion of navigation links into HTML index files. It defines functions for extracting code snippets from files, organizing them by manual sections, and generating documentation using LLMs, including logic to scan code files, parse Python syntax, and collect relevant documentation parts such as docstrings, CLI parsers, and main blocks. The `scan_code` function ranks files based on patterns and categorizes snippets into sections, while `llm_generate_manual` creates manual sections from documentation snippets and `llm_fill_placeholders` updates the manual by replacing placeholder tokens with information extracted from code snippets. An auxiliary function `_edit_chunks_in_editor` allows users to manually edit documentation chunks in their preferred editor. The module also includes functions for rendering HTML from structured sections, parsing manual content into sections, validating file references within those sections, inferring section structure from plain text, and writing HTML content to PDF format. The `render_html` function generates an HTML document with navigation and styled content, incorporating evidence snippets when section content is missing.</p>
<h2 id="Config">Class: Config</h2>
<p>The `Config` class defines a configuration structure for managing settings derived from command-line arguments. It includes attributes for file paths, output formatting, title, and various flags controlling code processing behavior. The class uses type hints to specify the expected types for each configuration parameter.</p>
<h2>Functions</h2>
<h3 id="collect_docs">collect_docs(base: Path) -&gt; list[Path]</h3>
<p>The function `collect_docs` gathers documentation files located under a specified base directory. It identifies files matching certain patterns in two locations: the project root and a `docs` subdirectory. Specifically, it collects files with extensions `.md`, `.txt`, `.html`, and `.docx` in the root, and recursively finds all `.html` and `.md` files within the `docs` directory. The function ensures that each file is included only once by tracking seen paths and returns a list of unique documentation file paths.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">collect_docs</span>(base: Path) <span style="color: #666666">-&gt;</span> <span style="color: #008000">list</span>[Path]:
<span style="color: #bbbbbb">    </span><span style="color: #BA2121; font-style: italic">"""Return documentation files under ``base``.</span>

<span style="color: #BA2121; font-style: italic">    Only the following locations and patterns are included:</span>

<span style="color: #BA2121; font-style: italic">    * ``docs/**/*.html`` and ``docs/**/*.md``</span>
<span style="color: #BA2121; font-style: italic">    * Project root ``README.md`` and any ``*.md``, ``*.txt``, ``*.html`` or</span>
<span style="color: #BA2121; font-style: italic">      ``*.docx`` files</span>
<span style="color: #BA2121; font-style: italic">    """</span>

    files: <span style="color: #008000">list</span>[Path] <span style="color: #666666">=</span> []
    <span style="color: #008000; font-weight: bold">for</span> pattern <span style="color: #AA22FF; font-weight: bold">in</span> [<span style="color: #BA2121">"README.md"</span>, <span style="color: #BA2121">"*.md"</span>, <span style="color: #BA2121">"*.txt"</span>, <span style="color: #BA2121">"*.html"</span>, <span style="color: #BA2121">"*.docx"</span>]:
        files<span style="color: #666666">.</span>extend(base<span style="color: #666666">.</span>glob(pattern))

    docs_dir <span style="color: #666666">=</span> base <span style="color: #666666">/</span> <span style="color: #BA2121">"docs"</span>
    <span style="color: #008000; font-weight: bold">if</span> docs_dir<span style="color: #666666">.</span>exists():
        <span style="color: #008000; font-weight: bold">for</span> pattern <span style="color: #AA22FF; font-weight: bold">in</span> [<span style="color: #BA2121">"**/*.html"</span>, <span style="color: #BA2121">"**/*.md"</span>]:
            files<span style="color: #666666">.</span>extend(docs_dir<span style="color: #666666">.</span>glob(pattern))

    seen: <span style="color: #008000">set</span>[Path] <span style="color: #666666">=</span> <span style="color: #008000">set</span>()
    unique: <span style="color: #008000">list</span>[Path] <span style="color: #666666">=</span> []
    <span style="color: #008000; font-weight: bold">for</span> f <span style="color: #AA22FF; font-weight: bold">in</span> files:
        <span style="color: #008000; font-weight: bold">if</span> f<span style="color: #666666">.</span>is_file() <span style="color: #AA22FF; font-weight: bold">and</span> f <span style="color: #AA22FF; font-weight: bold">not</span> <span style="color: #AA22FF; font-weight: bold">in</span> seen:
            unique<span style="color: #666666">.</span>append(f)
            seen<span style="color: #666666">.</span>add(f)
    <span style="color: #008000; font-weight: bold">return</span> unique
</code></pre>
<h3 id="collect_files">collect_files(base: Path, extra_patterns: Iterable[str] | None=None) -&gt; Iterable[Path]</h3>
<p>The function `collect_files` takes a base directory path and an optional list of additional file patterns, then returns a list of unique file paths within the base directory that match the specified patterns. It first defines a default set of file patterns including README.md, text files, HTML files, DOCX files, CSV files, and JSON files. It then recursively searches for files matching these patterns in the base directory and any additional patterns provided. The function ensures that each file path appears only once in the returned list by tracking seen files.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">collect_files</span>(base: Path, extra_patterns: Iterable[<span style="color: #008000">str</span>] <span style="color: #666666">|</span> <span style="color: #008000; font-weight: bold">None</span> <span style="color: #666666">=</span> <span style="color: #008000; font-weight: bold">None</span>) <span style="color: #666666">-&gt;</span> Iterable[Path]:
<span style="color: #bbbbbb">    </span><span style="color: #BA2121; font-style: italic">"""Return files from *base* relevant for summarisation."""</span>
    patterns <span style="color: #666666">=</span> [
        <span style="color: #BA2121">"README.md"</span>,
        <span style="color: #BA2121">"*.txt"</span>,
        <span style="color: #BA2121">"*.html"</span>,
        <span style="color: #BA2121">"*.docx"</span>,
        <span style="color: #BA2121">"*.csv"</span>,
        <span style="color: #BA2121">"*.json"</span>,
    ]

    files: <span style="color: #008000">list</span>[Path] <span style="color: #666666">=</span> []
    <span style="color: #008000; font-weight: bold">for</span> pattern <span style="color: #AA22FF; font-weight: bold">in</span> patterns:
        files<span style="color: #666666">.</span>extend(base<span style="color: #666666">.</span>rglob(pattern))

    <span style="color: #008000; font-weight: bold">if</span> extra_patterns:
        <span style="color: #008000; font-weight: bold">for</span> pattern <span style="color: #AA22FF; font-weight: bold">in</span> extra_patterns:
            files<span style="color: #666666">.</span>extend(base<span style="color: #666666">.</span>rglob(pattern))

    seen: <span style="color: #008000">set</span>[Path] <span style="color: #666666">=</span> <span style="color: #008000">set</span>()
    unique: <span style="color: #008000">list</span>[Path] <span style="color: #666666">=</span> []
    <span style="color: #008000; font-weight: bold">for</span> f <span style="color: #AA22FF; font-weight: bold">in</span> files:
        <span style="color: #008000; font-weight: bold">if</span> f<span style="color: #666666">.</span>is_file() <span style="color: #AA22FF; font-weight: bold">and</span> f <span style="color: #AA22FF; font-weight: bold">not</span> <span style="color: #AA22FF; font-weight: bold">in</span> seen:
            unique<span style="color: #666666">.</span>append(f)
            seen<span style="color: #666666">.</span>add(f)
    <span style="color: #008000; font-weight: bold">return</span> unique
</code></pre>
<h3 id="slugify">slugify(text: str) -&gt; str</h3>
<p>The function `slugify` converts a given string into a filesystem-friendly slug. It takes a string input, converts it to lowercase, and replaces any sequence of non-alphanumeric characters with underscores. Leading and trailing underscores are removed from the result. If the resulting string is empty, it defaults to returning "user_manual".</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">slugify</span>(text: <span style="color: #008000">str</span>) <span style="color: #666666">-&gt;</span> <span style="color: #008000">str</span>:
<span style="color: #bbbbbb">    </span><span style="color: #BA2121; font-style: italic">"""Return filesystem-friendly slug from ``text``."""</span>
    slug <span style="color: #666666">=</span> re<span style="color: #666666">.</span>sub(<span style="color: #BA2121">r"[^a-z0-9]+"</span>, <span style="color: #BA2121">"_"</span>, text<span style="color: #666666">.</span>strip()<span style="color: #666666">.</span>lower())
    <span style="color: #008000; font-weight: bold">return</span> slug<span style="color: #666666">.</span>strip(<span style="color: #BA2121">"_"</span>) <span style="color: #AA22FF; font-weight: bold">or</span> <span style="color: #BA2121">"user_manual"</span>
</code></pre>
<h3 id="insert_into_index">insert_into_index(index_path: Path, title: str, filename: str) -&gt; None</h3>
<p>The function `insert_into_index` appends a navigation link to an HTML file. It takes the path to an index file, a title for the link, and the filename to link to. The function reads the HTML content of the index file, parses it using BeautifulSoup, and finds either a `&lt;ul&gt;` or `&lt;nav&gt;` element to insert the new link into. If a link with the same `href` already exists, it does nothing. Otherwise, it creates a new `&lt;a&gt;` tag with the provided title and filename, wraps it in a `&lt;li&gt;` tag if the container is a `&lt;ul&gt;`, and appends it to the container. Finally, it writes the modified HTML back to the index file. If any error occurs during parsing or writing, the function silently returns without making changes.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">insert_into_index</span>(index_path: Path, title: <span style="color: #008000">str</span>, filename: <span style="color: #008000">str</span>) <span style="color: #666666">-&gt;</span> <span style="color: #008000; font-weight: bold">None</span>:
<span style="color: #bbbbbb">    </span><span style="color: #BA2121; font-style: italic">"""Append a navigation entry linking to ``filename`` into ``index_path``."""</span>
    <span style="color: #008000; font-weight: bold">try</span>:
        soup <span style="color: #666666">=</span> BeautifulSoup(index_path<span style="color: #666666">.</span>read_text(encoding<span style="color: #666666">=</span><span style="color: #BA2121">"utf-8"</span>), <span style="color: #BA2121">"html.parser"</span>)
    <span style="color: #008000; font-weight: bold">except</span> <span style="color: #CB3F38; font-weight: bold">Exception</span>:
        <span style="color: #008000; font-weight: bold">return</span>

    container <span style="color: #666666">=</span> soup<span style="color: #666666">.</span>find(<span style="color: #BA2121">"ul"</span>) <span style="color: #AA22FF; font-weight: bold">or</span> soup<span style="color: #666666">.</span>find(<span style="color: #BA2121">"nav"</span>)
    <span style="color: #008000; font-weight: bold">if</span> container <span style="color: #AA22FF; font-weight: bold">is</span> <span style="color: #008000; font-weight: bold">None</span>:
        <span style="color: #008000; font-weight: bold">return</span>

    <span style="color: #008000; font-weight: bold">if</span> container<span style="color: #666666">.</span>find(<span style="color: #BA2121">"a"</span>, href<span style="color: #666666">=</span>filename):
        <span style="color: #008000; font-weight: bold">return</span>

    a <span style="color: #666666">=</span> soup<span style="color: #666666">.</span>new_tag(<span style="color: #BA2121">"a"</span>, href<span style="color: #666666">=</span>filename)
    a<span style="color: #666666">.</span>string <span style="color: #666666">=</span> title

    <span style="color: #008000; font-weight: bold">if</span> container<span style="color: #666666">.</span>name <span style="color: #666666">==</span> <span style="color: #BA2121">"ul"</span>:
        li <span style="color: #666666">=</span> soup<span style="color: #666666">.</span>new_tag(<span style="color: #BA2121">"li"</span>)
        li<span style="color: #666666">.</span>append(a)
        container<span style="color: #666666">.</span>append(li)
    <span style="color: #008000; font-weight: bold">else</span>:  <span style="color: #3D7B7B; font-style: italic"># append directly to a nav element</span>
        container<span style="color: #666666">.</span>append(a)

    index_path<span style="color: #666666">.</span>write_text(<span style="color: #008000">str</span>(soup), encoding<span style="color: #666666">=</span><span style="color: #BA2121">"utf-8"</span>)
</code></pre>
<h3 id="inject_user_manual">inject_user_manual(index_path: Path, title: str, filename: str) -&gt; None</h3>
<p>The function `inject_user_manual` inserts a hyperlink to a user manual into an HTML file specified by `index_path`. The link, with the text defined by `title` and pointing to `filename`, is added as the first element within the first navigation structure (`&lt;nav&gt;` or `&lt;ul&gt;`) found in the document. If no such structure exists, the link is inserted at the beginning of the first element within the `&lt;body&gt;` tag or the root of the document. The function reads the HTML content using BeautifulSoup, modifies it to include the new link, and writes the updated content back to the file. If reading the file fails, the function silently returns without making changes.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">inject_user_manual</span>(index_path: Path, title: <span style="color: #008000">str</span>, filename: <span style="color: #008000">str</span>) <span style="color: #666666">-&gt;</span> <span style="color: #008000; font-weight: bold">None</span>:
<span style="color: #bbbbbb">    </span><span style="color: #BA2121; font-style: italic">"""Insert a top-level link to the manual into ``index_path``.</span>

<span style="color: #BA2121; font-style: italic">    The link is prepended to the first navigation element (``&lt;nav&gt;`` or ``&lt;ul&gt;``)</span>
<span style="color: #BA2121; font-style: italic">    if present. If neither is found, it is inserted at the start of the first</span>
<span style="color: #BA2121; font-style: italic">    element in ``&lt;body&gt;`` or the document root.</span>
<span style="color: #BA2121; font-style: italic">    """</span>

    <span style="color: #008000; font-weight: bold">try</span>:
        soup <span style="color: #666666">=</span> BeautifulSoup(index_path<span style="color: #666666">.</span>read_text(encoding<span style="color: #666666">=</span><span style="color: #BA2121">"utf-8"</span>), <span style="color: #BA2121">"html.parser"</span>)
    <span style="color: #008000; font-weight: bold">except</span> <span style="color: #CB3F38; font-weight: bold">Exception</span>:
        <span style="color: #008000; font-weight: bold">return</span>

    a <span style="color: #666666">=</span> soup<span style="color: #666666">.</span>new_tag(<span style="color: #BA2121">"a"</span>, href<span style="color: #666666">=</span>filename)
    a<span style="color: #666666">.</span>string <span style="color: #666666">=</span> title

    nav <span style="color: #666666">=</span> soup<span style="color: #666666">.</span>find(<span style="color: #BA2121">"nav"</span>)
    <span style="color: #008000; font-weight: bold">if</span> nav <span style="color: #AA22FF; font-weight: bold">is</span> <span style="color: #AA22FF; font-weight: bold">not</span> <span style="color: #008000; font-weight: bold">None</span>:
        container <span style="color: #666666">=</span> nav<span style="color: #666666">.</span>find(<span style="color: #BA2121">"ul"</span>) <span style="color: #AA22FF; font-weight: bold">or</span> nav
    <span style="color: #008000; font-weight: bold">else</span>:
        hero <span style="color: #666666">=</span> soup<span style="color: #666666">.</span>find(class_<span style="color: #666666">=</span>re<span style="color: #666666">.</span>compile(<span style="color: #BA2121">"hero"</span>, re<span style="color: #666666">.</span>IGNORECASE))
        container <span style="color: #666666">=</span> hero <span style="color: #AA22FF; font-weight: bold">or</span> soup<span style="color: #666666">.</span>find(<span style="color: #BA2121">"ul"</span>) <span style="color: #AA22FF; font-weight: bold">or</span> soup<span style="color: #666666">.</span>body <span style="color: #AA22FF; font-weight: bold">or</span> soup

    <span style="color: #008000; font-weight: bold">if</span> container<span style="color: #666666">.</span>name <span style="color: #666666">==</span> <span style="color: #BA2121">"ul"</span>:
        li <span style="color: #666666">=</span> soup<span style="color: #666666">.</span>new_tag(<span style="color: #BA2121">"li"</span>)
        li<span style="color: #666666">.</span>append(a)
        container<span style="color: #666666">.</span>insert(<span style="color: #666666">0</span>, li)
    <span style="color: #008000; font-weight: bold">else</span>:
        container<span style="color: #666666">.</span>insert(<span style="color: #666666">0</span>, a)

    index_path<span style="color: #666666">.</span>write_text(<span style="color: #008000">str</span>(soup), encoding<span style="color: #666666">=</span><span style="color: #BA2121">"utf-8"</span>)
</code></pre>
<h3 id="extract_text">extract_text(path: Path) -&gt; str</h3>
<p>The function `extract_text` reads and extracts plain text from a file located at the given path, handling different file types based on their suffix. It supports HTML, Markdown (.md), and Word (.docx) files. For HTML files, it processes headings by converting them to markdown-style headers and code blocks into fenced code blocks before extracting the text. For Markdown files, it returns the raw text content. For Word documents, it converts paragraphs into text, formatting headings as markdown headers and preserving regular paragraphs. If the file type is not specifically handled or an error occurs during processing, the function returns an empty string.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">extract_text</span>(path: Path) <span style="color: #666666">-&gt;</span> <span style="color: #008000">str</span>:
<span style="color: #bbbbbb">    </span><span style="color: #BA2121; font-style: italic">"""Extract plain text from ``path`` based on its file type."""</span>
    suffix <span style="color: #666666">=</span> path<span style="color: #666666">.</span>suffix<span style="color: #666666">.</span>lower()
    <span style="color: #008000; font-weight: bold">try</span>:
        <span style="color: #008000; font-weight: bold">if</span> suffix <span style="color: #666666">==</span> <span style="color: #BA2121">".html"</span>:
            content <span style="color: #666666">=</span> path<span style="color: #666666">.</span>read_text(encoding<span style="color: #666666">=</span><span style="color: #BA2121">"utf-8"</span>)
            soup <span style="color: #666666">=</span> BeautifulSoup(content, <span style="color: #BA2121">"html.parser"</span>)
            <span style="color: #008000; font-weight: bold">for</span> heading <span style="color: #AA22FF; font-weight: bold">in</span> soup<span style="color: #666666">.</span>find_all([<span style="color: #BA2121">f"h</span><span style="color: #A45A77; font-weight: bold">{</span>i<span style="color: #A45A77; font-weight: bold">}</span><span style="color: #BA2121">"</span> <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(<span style="color: #666666">1</span>, <span style="color: #666666">7</span>)]):
                level <span style="color: #666666">=</span> <span style="color: #008000">int</span>(heading<span style="color: #666666">.</span>name[<span style="color: #666666">1</span>])
                text <span style="color: #666666">=</span> heading<span style="color: #666666">.</span>get_text(<span style="color: #BA2121">" "</span>, strip<span style="color: #666666">=</span><span style="color: #008000; font-weight: bold">True</span>)
                heading<span style="color: #666666">.</span>replace_with(soup<span style="color: #666666">.</span>new_string(<span style="color: #BA2121">"#"</span> <span style="color: #666666">*</span> level <span style="color: #666666">+</span> <span style="color: #BA2121">" "</span> <span style="color: #666666">+</span> text))
            <span style="color: #008000; font-weight: bold">for</span> pre <span style="color: #AA22FF; font-weight: bold">in</span> soup<span style="color: #666666">.</span>find_all(<span style="color: #BA2121">"pre"</span>):
                code <span style="color: #666666">=</span> pre<span style="color: #666666">.</span>get_text()
                fenced <span style="color: #666666">=</span> <span style="color: #BA2121">"```</span><span style="color: #AA5D1F; font-weight: bold">\n</span><span style="color: #BA2121">"</span> <span style="color: #666666">+</span> code<span style="color: #666666">.</span>strip(<span style="color: #BA2121">"</span><span style="color: #AA5D1F; font-weight: bold">\n</span><span style="color: #BA2121">"</span>) <span style="color: #666666">+</span> <span style="color: #BA2121">"</span><span style="color: #AA5D1F; font-weight: bold">\n</span><span style="color: #BA2121">```"</span>
                pre<span style="color: #666666">.</span>replace_with(soup<span style="color: #666666">.</span>new_string(fenced))
            text <span style="color: #666666">=</span> soup<span style="color: #666666">.</span>get_text(<span style="color: #BA2121">"</span><span style="color: #AA5D1F; font-weight: bold">\n</span><span style="color: #BA2121">"</span>)
            lines <span style="color: #666666">=</span> [line<span style="color: #666666">.</span>strip() <span style="color: #008000; font-weight: bold">for</span> line <span style="color: #AA22FF; font-weight: bold">in</span> text<span style="color: #666666">.</span>splitlines()]
            <span style="color: #008000; font-weight: bold">return</span> <span style="color: #BA2121">"</span><span style="color: #AA5D1F; font-weight: bold">\n</span><span style="color: #BA2121">"</span><span style="color: #666666">.</span>join(line <span style="color: #008000; font-weight: bold">for</span> line <span style="color: #AA22FF; font-weight: bold">in</span> lines <span style="color: #008000; font-weight: bold">if</span> line)
        <span style="color: #008000; font-weight: bold">if</span> suffix <span style="color: #AA22FF; font-weight: bold">in</span> {<span style="color: #BA2121">".md"</span>}:
            <span style="color: #008000; font-weight: bold">return</span> path<span style="color: #666666">.</span>read_text(encoding<span style="color: #666666">=</span><span style="color: #BA2121">"utf-8"</span>)
        <span style="color: #008000; font-weight: bold">if</span> suffix <span style="color: #666666">==</span> <span style="color: #BA2121">".docx"</span> <span style="color: #AA22FF; font-weight: bold">and</span> Document <span style="color: #AA22FF; font-weight: bold">is</span> <span style="color: #AA22FF; font-weight: bold">not</span> <span style="color: #008000; font-weight: bold">None</span>:
            doc <span style="color: #666666">=</span> Document(<span style="color: #008000">str</span>(path))
            lines <span style="color: #666666">=</span> []
            <span style="color: #008000; font-weight: bold">for</span> p <span style="color: #AA22FF; font-weight: bold">in</span> doc<span style="color: #666666">.</span>paragraphs:
                text <span style="color: #666666">=</span> p<span style="color: #666666">.</span>text<span style="color: #666666">.</span>strip()
                <span style="color: #008000; font-weight: bold">if</span> <span style="color: #AA22FF; font-weight: bold">not</span> text:
                    <span style="color: #008000; font-weight: bold">continue</span>
                style <span style="color: #666666">=</span> <span style="color: #008000">getattr</span>(p<span style="color: #666666">.</span>style, <span style="color: #BA2121">"name"</span>, <span style="color: #BA2121">""</span>)
                <span style="color: #008000; font-weight: bold">if</span> style<span style="color: #666666">.</span>startswith(<span style="color: #BA2121">"Heading"</span>):
                    <span style="color: #008000; font-weight: bold">try</span>:
                        level <span style="color: #666666">=</span> <span style="color: #008000">int</span>(style<span style="color: #666666">.</span>split()[<span style="color: #666666">1</span>])
                        lines<span style="color: #666666">.</span>append(<span style="color: #BA2121">"#"</span> <span style="color: #666666">*</span> level <span style="color: #666666">+</span> <span style="color: #BA2121">" "</span> <span style="color: #666666">+</span> text)
                    <span style="color: #008000; font-weight: bold">except</span> <span style="color: #CB3F38; font-weight: bold">Exception</span>:
                        lines<span style="color: #666666">.</span>append(text)
                <span style="color: #008000; font-weight: bold">else</span>:
                    lines<span style="color: #666666">.</span>append(text)
            <span style="color: #008000; font-weight: bold">return</span> <span style="color: #BA2121">"</span><span style="color: #AA5D1F; font-weight: bold">\n</span><span style="color: #BA2121">"</span><span style="color: #666666">.</span>join(lines)
        <span style="color: #008000; font-weight: bold">return</span> path<span style="color: #666666">.</span>read_text(encoding<span style="color: #666666">=</span><span style="color: #BA2121">"utf-8"</span>)
    <span style="color: #008000; font-weight: bold">except</span> <span style="color: #CB3F38; font-weight: bold">Exception</span>:
        <span style="color: #008000; font-weight: bold">return</span> <span style="color: #BA2121">""</span>
</code></pre>
<h3 id="detect_placeholders">detect_placeholders(text: str) -&gt; list[str]</h3>
<p>The function `detect_placeholders` identifies and returns a list of section names from a given text that are still marked by placeholder tokens. It takes a string input `text`, uses the helper function `find_placeholders` to locate tokens within the text, and then filters these tokens against a predefined dictionary `SECTION_PLACEHOLDERS`. The result is a list of section names whose corresponding placeholder tokens were found in the input text.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">detect_placeholders</span>(text: <span style="color: #008000">str</span>) <span style="color: #666666">-&gt;</span> <span style="color: #008000">list</span>[<span style="color: #008000">str</span>]:
<span style="color: #bbbbbb">    </span><span style="color: #BA2121; font-style: italic">"""Return section names still marked by placeholder tokens."""</span>
    tokens <span style="color: #666666">=</span> find_placeholders(text)
    <span style="color: #008000; font-weight: bold">return</span> [name <span style="color: #008000; font-weight: bold">for</span> name, token <span style="color: #AA22FF; font-weight: bold">in</span> SECTION_PLACEHOLDERS<span style="color: #666666">.</span>items() <span style="color: #008000; font-weight: bold">if</span> token <span style="color: #AA22FF; font-weight: bold">in</span> tokens]
</code></pre>
<h3 id="map_evidence_to_sections">map_evidence_to_sections(docs: dict[Path, str]) -&gt; tuple[dict[str, list[tuple[Path, str]]], dict[Path, set[str]]]</h3>
<p>The function `map_evidence_to_sections` maps documentation snippets from source files to predefined manual sections based on keyword matching. It takes a dictionary of file paths to their content and returns a tuple containing:

1. A mapping (`section_map`) from section names to lists of tuples, each containing a file path and a snippet of text belonging to that section.
2. A mapping (`file_map`) from each file path to the set of sections it contributed to.

The function processes each file's content line-by-line, searching for lines that match keywords associated with specific sections. When a match is found, it collects subsequent non-empty lines up to a maximum number of lines (`MAX_SNIPPET_LINES`), excluding lines that are empty, start with `#`, or are HTML header tags. Snippets are limited to the top 10 longest per section, except for "Overview" entries which are prioritized based on file path characteristics.

Sections are sorted differently depending on whether they are "Overview" or not:

Only snippets from files not in excluded directories (`tests`, `examples</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">map_evidence_to_sections</span>(
    docs: <span style="color: #008000">dict</span>[Path, <span style="color: #008000">str</span>]
) <span style="color: #666666">-&gt;</span> <span style="color: #008000">tuple</span>[<span style="color: #008000">dict</span>[<span style="color: #008000">str</span>, <span style="color: #008000">list</span>[<span style="color: #008000">tuple</span>[Path, <span style="color: #008000">str</span>]]], <span style="color: #008000">dict</span>[Path, <span style="color: #008000">set</span>[<span style="color: #008000">str</span>]]]:
<span style="color: #bbbbbb">    </span><span style="color: #BA2121; font-style: italic">"""Map documentation snippets to manual sections.</span>

<span style="color: #BA2121; font-style: italic">    Returns a tuple ``(section_map, file_map)`` where ``section_map`` maps</span>
<span style="color: #BA2121; font-style: italic">    section names to a list of ``(source_path, snippet)`` tuples and</span>
<span style="color: #BA2121; font-style: italic">    ``file_map`` maps each ``source_path`` to the set of sections it</span>
<span style="color: #BA2121; font-style: italic">    contributed to. Only the top 10 snippets (by length) are kept per</span>
<span style="color: #BA2121; font-style: italic">    section.</span>
<span style="color: #BA2121; font-style: italic">    """</span>

    section_map: <span style="color: #008000">dict</span>[<span style="color: #008000">str</span>, <span style="color: #008000">list</span>[<span style="color: #008000">tuple</span>[Path, <span style="color: #008000">str</span>]]] <span style="color: #666666">=</span> {
        name: [] <span style="color: #008000; font-weight: bold">for</span> name <span style="color: #AA22FF; font-weight: bold">in</span> SECTION_KEYWORDS
    }
    file_map: <span style="color: #008000">dict</span>[Path, <span style="color: #008000">set</span>[<span style="color: #008000">str</span>]] <span style="color: #666666">=</span> {}

    skip_dirs <span style="color: #666666">=</span> {<span style="color: #BA2121">"tests"</span>, <span style="color: #BA2121">"examples"</span>, <span style="color: #BA2121">"fixtures"</span>}
    <span style="color: #008000; font-weight: bold">for</span> path, text <span style="color: #AA22FF; font-weight: bold">in</span> docs<span style="color: #666666">.</span>items():
        parts_lower <span style="color: #666666">=</span> {p<span style="color: #666666">.</span>lower() <span style="color: #008000; font-weight: bold">for</span> p <span style="color: #AA22FF; font-weight: bold">in</span> path<span style="color: #666666">.</span>parts}
        in_excluded_dir <span style="color: #666666">=</span> <span style="color: #008000">bool</span>(skip_dirs <span style="color: #666666">&amp;</span> parts_lower)
        lines <span style="color: #666666">=</span> text<span style="color: #666666">.</span>splitlines()
        <span style="color: #008000; font-weight: bold">for</span> idx, line <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">enumerate</span>(lines):
            lowered <span style="color: #666666">=</span> line<span style="color: #666666">.</span>strip()<span style="color: #666666">.</span>lower()
            <span style="color: #008000; font-weight: bold">for</span> section, keywords <span style="color: #AA22FF; font-weight: bold">in</span> SECTION_KEYWORDS<span style="color: #666666">.</span>items():
                <span style="color: #008000; font-weight: bold">if</span> <span style="color: #008000">any</span>(re<span style="color: #666666">.</span>search(<span style="color: #BA2121">rf"\b</span><span style="color: #A45A77; font-weight: bold">{</span>re<span style="color: #666666">.</span>escape(k)<span style="color: #A45A77; font-weight: bold">}</span><span style="color: #BA2121">\b"</span>, lowered) <span style="color: #008000; font-weight: bold">for</span> k <span style="color: #AA22FF; font-weight: bold">in</span> keywords):
                    max_lines <span style="color: #666666">=</span> <span style="color: #666666">0</span> <span style="color: #008000; font-weight: bold">if</span> in_excluded_dir <span style="color: #008000; font-weight: bold">else</span> MAX_SNIPPET_LINES
                    snippet_lines: <span style="color: #008000">list</span>[<span style="color: #008000">str</span>] <span style="color: #666666">=</span> []
                    j <span style="color: #666666">=</span> idx <span style="color: #666666">+</span> <span style="color: #666666">1</span>
                    <span style="color: #008000; font-weight: bold">while</span> j <span style="color: #666666">&lt;</span> <span style="color: #008000">len</span>(lines) <span style="color: #AA22FF; font-weight: bold">and</span> <span style="color: #008000">len</span>(snippet_lines) <span style="color: #666666">&lt;</span> max_lines:
                        nxt <span style="color: #666666">=</span> lines[j]
                        <span style="color: #008000; font-weight: bold">if</span> <span style="color: #AA22FF; font-weight: bold">not</span> nxt<span style="color: #666666">.</span>strip():
                            <span style="color: #008000; font-weight: bold">break</span>
                        <span style="color: #008000; font-weight: bold">if</span> nxt<span style="color: #666666">.</span>lstrip()<span style="color: #666666">.</span>startswith(<span style="color: #BA2121">"#"</span>) <span style="color: #AA22FF; font-weight: bold">or</span> re<span style="color: #666666">.</span>match(<span style="color: #BA2121">r"\s*&lt;h[1-6]"</span>, nxt):
                            <span style="color: #008000; font-weight: bold">break</span>
                        snippet_lines<span style="color: #666666">.</span>append(nxt<span style="color: #666666">.</span>strip())
                        j <span style="color: #666666">+=</span> <span style="color: #666666">1</span>
                    snippet <span style="color: #666666">=</span> line<span style="color: #666666">.</span>strip()
                    <span style="color: #008000; font-weight: bold">if</span> snippet_lines:
                        snippet <span style="color: #666666">+=</span> <span style="color: #BA2121">"</span><span style="color: #AA5D1F; font-weight: bold">\n</span><span style="color: #BA2121">"</span> <span style="color: #666666">+</span> <span style="color: #BA2121">" "</span><span style="color: #666666">.</span>join(snippet_lines)<span style="color: #666666">.</span>strip()
                    <span style="color: #008000; font-weight: bold">if</span> snippet:
                        <span style="color: #008000; font-weight: bold">if</span> section <span style="color: #666666">==</span> <span style="color: #BA2121">"Overview"</span> <span style="color: #AA22FF; font-weight: bold">and</span> in_excluded_dir:
                            <span style="color: #008000; font-weight: bold">break</span>
                        section_map[section]<span style="color: #666666">.</span>append((path, snippet))
                        file_map<span style="color: #666666">.</span>setdefault(path, <span style="color: #008000">set</span>())<span style="color: #666666">.</span>add(section)
                    <span style="color: #008000; font-weight: bold">break</span>

    <span style="color: #008000; font-weight: bold">for</span> section <span style="color: #AA22FF; font-weight: bold">in</span> section_map:
        entries <span style="color: #666666">=</span> section_map[section]
        <span style="color: #008000; font-weight: bold">if</span> section <span style="color: #666666">==</span> <span style="color: #BA2121">"Overview"</span>:
            <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">_key</span>(item: <span style="color: #008000">tuple</span>[Path, <span style="color: #008000">str</span>]) <span style="color: #666666">-&gt;</span> <span style="color: #008000">tuple</span>[<span style="color: #008000">int</span>, <span style="color: #008000">int</span>]:
                p, snip <span style="color: #666666">=</span> item
                parts_lower <span style="color: #666666">=</span> [part<span style="color: #666666">.</span>lower() <span style="color: #008000; font-weight: bold">for</span> part <span style="color: #AA22FF; font-weight: bold">in</span> p<span style="color: #666666">.</span>parts]
                in_docs <span style="color: #666666">=</span> <span style="color: #BA2121">"docs"</span> <span style="color: #AA22FF; font-weight: bold">in</span> parts_lower
                is_readme <span style="color: #666666">=</span> p<span style="color: #666666">.</span>name<span style="color: #666666">.</span>lower() <span style="color: #666666">==</span> <span style="color: #BA2121">"readme.md"</span>
                priority <span style="color: #666666">=</span> <span style="color: #666666">0</span> <span style="color: #008000; font-weight: bold">if</span> is_readme <span style="color: #AA22FF; font-weight: bold">or</span> in_docs <span style="color: #008000; font-weight: bold">else</span> <span style="color: #666666">1</span>
                <span style="color: #008000; font-weight: bold">return</span> (priority, <span style="color: #666666">-</span><span style="color: #008000">len</span>(snip))

            entries<span style="color: #666666">.</span>sort(key<span style="color: #666666">=</span>_key)
        <span style="color: #008000; font-weight: bold">else</span>:
            entries<span style="color: #666666">.</span>sort(key<span style="color: #666666">=</span><span style="color: #008000; font-weight: bold">lambda</span> x: <span style="color: #008000">len</span>(x[<span style="color: #666666">1</span>]), reverse<span style="color: #666666">=</span><span style="color: #008000; font-weight: bold">True</span>)
        section_map[section] <span style="color: #666666">=</span> entries[:<span style="color: #666666">10</span>]

    <span style="color: #008000; font-weight: bold">return</span> section_map, file_map
</code></pre>
<h3 id="rank_code_files">rank_code_files(root: Path, patterns: list[str]) -&gt; list[Path]</h3>
<p>The function `rank_code_files` takes a root directory path and a list of patterns, and returns a sorted list of code file paths under the root directory. The files are ranked based on simple heuristics that consider the presence of specific keywords in the relative file paths and matches against provided patterns. Supported file extensions include Python (.py), MATLAB (.m), Jupyter Notebook (.ipynb), C++ (.cpp, .h), and Java (.java). The function excludes certain directories such as virtual environments, version control folders, build artifacts, and test-related directories from consideration. Files are scored based on keyword matches and pattern inclusion, with higher scores indicating priority. The final list is sorted by score (descending) and then lexicographically by path.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">rank_code_files</span>(root: Path, patterns: <span style="color: #008000">list</span>[<span style="color: #008000">str</span>]) <span style="color: #666666">-&gt;</span> <span style="color: #008000">list</span>[Path]:
<span style="color: #bbbbbb">    </span><span style="color: #BA2121; font-style: italic">"""Return code files under ``root`` ranked by simple heuristics.</span>

<span style="color: #BA2121; font-style: italic">    Supports ``.py``, ``.m``, ``.ipynb``, ``.cpp``, ``.h``, and ``.java`` files.</span>
<span style="color: #BA2121; font-style: italic">    """</span>

    allowed_exts <span style="color: #666666">=</span> {<span style="color: #BA2121">".py"</span>, <span style="color: #BA2121">".m"</span>, <span style="color: #BA2121">".ipynb"</span>, <span style="color: #BA2121">".cpp"</span>, <span style="color: #BA2121">".h"</span>, <span style="color: #BA2121">".java"</span>}
    skip_dirs <span style="color: #666666">=</span> {
        <span style="color: #BA2121">"venv"</span>,
        <span style="color: #BA2121">".git"</span>,
        <span style="color: #BA2121">"__pycache__"</span>,
        <span style="color: #BA2121">"node_modules"</span>,
        <span style="color: #BA2121">"dist"</span>,
        <span style="color: #BA2121">"build"</span>,
        <span style="color: #BA2121">"tests"</span>,
        <span style="color: #BA2121">"test"</span>,
        <span style="color: #BA2121">"examples"</span>,
        <span style="color: #BA2121">"example"</span>,
        <span style="color: #BA2121">"samples"</span>,
        <span style="color: #BA2121">"sample"</span>,
        <span style="color: #BA2121">"fixtures"</span>,
        <span style="color: #BA2121">"fixture"</span>,
    }
    keyword_re <span style="color: #666666">=</span> re<span style="color: #666666">.</span>compile(
        <span style="color: #BA2121">r"run|main|cli|config|io|dataset|reader|writer|pipeline"</span>, re<span style="color: #666666">.</span>IGNORECASE
    )
    doc_refs <span style="color: #666666">=</span> {p<span style="color: #666666">.</span>lower() <span style="color: #008000; font-weight: bold">for</span> p <span style="color: #AA22FF; font-weight: bold">in</span> patterns}

    ranked: <span style="color: #008000">list</span>[<span style="color: #008000">tuple</span>[<span style="color: #008000">int</span>, Path]] <span style="color: #666666">=</span> []
    <span style="color: #008000; font-weight: bold">for</span> dirpath, dirnames, filenames <span style="color: #AA22FF; font-weight: bold">in</span> os<span style="color: #666666">.</span>walk(root):
        dirnames[:] <span style="color: #666666">=</span> [
            d <span style="color: #008000; font-weight: bold">for</span> d <span style="color: #AA22FF; font-weight: bold">in</span> dirnames
            <span style="color: #008000; font-weight: bold">if</span> d<span style="color: #666666">.</span>lower() <span style="color: #AA22FF; font-weight: bold">not</span> <span style="color: #AA22FF; font-weight: bold">in</span> skip_dirs <span style="color: #AA22FF; font-weight: bold">and</span> <span style="color: #AA22FF; font-weight: bold">not</span> d<span style="color: #666666">.</span>endswith(<span style="color: #BA2121">".egg-info"</span>)
        ]
        <span style="color: #008000; font-weight: bold">for</span> filename <span style="color: #AA22FF; font-weight: bold">in</span> filenames:
            path <span style="color: #666666">=</span> Path(dirpath) <span style="color: #666666">/</span> filename
            <span style="color: #008000; font-weight: bold">if</span> path<span style="color: #666666">.</span>suffix <span style="color: #AA22FF; font-weight: bold">not</span> <span style="color: #AA22FF; font-weight: bold">in</span> allowed_exts:
                <span style="color: #008000; font-weight: bold">continue</span>
            rel <span style="color: #666666">=</span> <span style="color: #008000">str</span>(path<span style="color: #666666">.</span>relative_to(root))<span style="color: #666666">.</span>lower()
            score <span style="color: #666666">=</span> <span style="color: #666666">0</span>
            <span style="color: #008000; font-weight: bold">if</span> keyword_re<span style="color: #666666">.</span>search(rel):
                score <span style="color: #666666">+=</span> <span style="color: #666666">2</span>
            <span style="color: #008000; font-weight: bold">for</span> ptn <span style="color: #AA22FF; font-weight: bold">in</span> doc_refs:
                <span style="color: #008000; font-weight: bold">if</span> ptn <span style="color: #AA22FF; font-weight: bold">and</span> ptn <span style="color: #AA22FF; font-weight: bold">in</span> rel:
                    score <span style="color: #666666">+=</span> <span style="color: #666666">1</span>
            ranked<span style="color: #666666">.</span>append((score, path))

    ranked<span style="color: #666666">.</span>sort(key<span style="color: #666666">=</span><span style="color: #008000; font-weight: bold">lambda</span> x: (<span style="color: #666666">-</span>x[<span style="color: #666666">0</span>], <span style="color: #008000">str</span>(x[<span style="color: #666666">1</span>])))
    <span style="color: #008000; font-weight: bold">return</span> [p <span style="color: #008000; font-weight: bold">for</span> _, p <span style="color: #AA22FF; font-weight: bold">in</span> ranked]
</code></pre>
<h3 id="extract_snippets">extract_snippets(files: Iterable[Path], *, max_files: int, time_budget: int, max_bytes: int) -&gt; dict[Path, str]</h3>
<p>The function `extract_snippets` extracts relevant code snippets from a collection of files, returning a dictionary mapping file paths to their extracted content. It iterates through the provided files, respecting limits on the number of files, total time, and individual file size. For Python files, it parses the abstract syntax tree to extract module docstrings, function and class docstrings, I/O signatures, CLI parser information, and `__main__` blocks. For non-Python files, it includes the entire file content. The function skips files that exceed size limits, cannot be read, or fail to parse. Progress is logged, and the output is structured into parts based on the file type and content.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">extract_snippets</span>(
    files: Iterable[Path],
    <span style="color: #666666">*</span>,
    max_files: <span style="color: #008000">int</span>,
    time_budget: <span style="color: #008000">int</span>,
    max_bytes: <span style="color: #008000">int</span>,
) <span style="color: #666666">-&gt;</span> <span style="color: #008000">dict</span>[Path, <span style="color: #008000">str</span>]:
<span style="color: #bbbbbb">    </span><span style="color: #BA2121; font-style: italic">"""Extract relevant code snippets from ``files``."""</span>

    snippets: <span style="color: #008000">dict</span>[Path, <span style="color: #008000">str</span>] <span style="color: #666666">=</span> {}
    start <span style="color: #666666">=</span> time<span style="color: #666666">.</span>perf_counter()
    <span style="color: #008000; font-weight: bold">for</span> idx, path <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">enumerate</span>(
        tqdm(files, desc<span style="color: #666666">=</span><span style="color: #BA2121">"Scanning code files"</span>, total<span style="color: #666666">=</span><span style="color: #008000">len</span>(files))
    ):
        elapsed <span style="color: #666666">=</span> time<span style="color: #666666">.</span>perf_counter() <span style="color: #666666">-</span> start
        logging<span style="color: #666666">.</span>info(<span style="color: #BA2121">"Considering </span><span style="color: #A45A77; font-weight: bold">%s</span><span style="color: #BA2121"> (elapsed </span><span style="color: #A45A77; font-weight: bold">%.2f</span><span style="color: #BA2121">s)"</span>, path, elapsed)
        <span style="color: #008000; font-weight: bold">if</span> idx <span style="color: #666666">&gt;=</span> max_files:
            logging<span style="color: #666666">.</span>info(<span style="color: #BA2121">"Skipping </span><span style="color: #A45A77; font-weight: bold">%s</span><span style="color: #BA2121">: file limit reached (elapsed </span><span style="color: #A45A77; font-weight: bold">%.2f</span><span style="color: #BA2121">s)"</span>, path, elapsed)
            <span style="color: #008000; font-weight: bold">break</span>
        <span style="color: #008000; font-weight: bold">if</span> elapsed <span style="color: #666666">&gt;</span> time_budget:
            logging<span style="color: #666666">.</span>info(
                <span style="color: #BA2121">"Skipping </span><span style="color: #A45A77; font-weight: bold">%s</span><span style="color: #BA2121">: time budget exceeded (elapsed </span><span style="color: #A45A77; font-weight: bold">%.2f</span><span style="color: #BA2121">s)"</span>, path, elapsed
            )
            <span style="color: #008000; font-weight: bold">break</span>
        <span style="color: #008000; font-weight: bold">try</span>:
            size <span style="color: #666666">=</span> path<span style="color: #666666">.</span>stat()<span style="color: #666666">.</span>st_size
        <span style="color: #008000; font-weight: bold">except</span> <span style="color: #CB3F38; font-weight: bold">Exception</span>:
            logging<span style="color: #666666">.</span>info(
                <span style="color: #BA2121">"Skipping </span><span style="color: #A45A77; font-weight: bold">%s</span><span style="color: #BA2121">: cannot stat file (elapsed </span><span style="color: #A45A77; font-weight: bold">%.2f</span><span style="color: #BA2121">s)"</span>, path, elapsed
            )
            <span style="color: #008000; font-weight: bold">continue</span>
        <span style="color: #008000; font-weight: bold">if</span> size <span style="color: #666666">&gt;</span> max_bytes:
            logging<span style="color: #666666">.</span>info(
                <span style="color: #BA2121">"Skipping </span><span style="color: #A45A77; font-weight: bold">%s</span><span style="color: #BA2121">: file size </span><span style="color: #A45A77; font-weight: bold">%d</span><span style="color: #BA2121"> exceeds limit </span><span style="color: #A45A77; font-weight: bold">%d</span><span style="color: #BA2121"> bytes (elapsed </span><span style="color: #A45A77; font-weight: bold">%.2f</span><span style="color: #BA2121">s)"</span>,
                path,
                size,
                max_bytes,
                elapsed,
            )
            <span style="color: #008000; font-weight: bold">continue</span>
        <span style="color: #008000; font-weight: bold">try</span>:
            text <span style="color: #666666">=</span> path<span style="color: #666666">.</span>read_text(encoding<span style="color: #666666">=</span><span style="color: #BA2121">"utf-8"</span>)[:max_bytes]
        <span style="color: #008000; font-weight: bold">except</span> <span style="color: #CB3F38; font-weight: bold">Exception</span>:
            logging<span style="color: #666666">.</span>info(
                <span style="color: #BA2121">"Skipping </span><span style="color: #A45A77; font-weight: bold">%s</span><span style="color: #BA2121">: unreadable (elapsed </span><span style="color: #A45A77; font-weight: bold">%.2f</span><span style="color: #BA2121">s)"</span>, path, elapsed
            )
            <span style="color: #008000; font-weight: bold">continue</span>

        parts: <span style="color: #008000">list</span>[<span style="color: #008000">str</span>] <span style="color: #666666">=</span> []
        <span style="color: #008000; font-weight: bold">if</span> path<span style="color: #666666">.</span>suffix <span style="color: #666666">==</span> <span style="color: #BA2121">".py"</span>:
            <span style="color: #008000; font-weight: bold">try</span>:
                tree <span style="color: #666666">=</span> ast<span style="color: #666666">.</span>parse(text)
            <span style="color: #008000; font-weight: bold">except</span> <span style="color: #CB3F38; font-weight: bold">Exception</span>:
                tree <span style="color: #666666">=</span> <span style="color: #008000; font-weight: bold">None</span>
            <span style="color: #008000; font-weight: bold">if</span> tree <span style="color: #AA22FF; font-weight: bold">is</span> <span style="color: #AA22FF; font-weight: bold">not</span> <span style="color: #008000; font-weight: bold">None</span>:
                module_doc <span style="color: #666666">=</span> ast<span style="color: #666666">.</span>get_docstring(tree)
                <span style="color: #008000; font-weight: bold">if</span> module_doc:
                    parts<span style="color: #666666">.</span>append(<span style="color: #BA2121">f"Module docstring:</span><span style="color: #AA5D1F; font-weight: bold">\n</span><span style="color: #A45A77; font-weight: bold">{</span>module_doc<span style="color: #A45A77; font-weight: bold">}</span><span style="color: #BA2121">"</span>)
                <span style="color: #008000; font-weight: bold">for</span> node <span style="color: #AA22FF; font-weight: bold">in</span> ast<span style="color: #666666">.</span>walk(tree):
                    <span style="color: #008000; font-weight: bold">if</span> <span style="color: #008000">isinstance</span>(node, (ast<span style="color: #666666">.</span>ClassDef, ast<span style="color: #666666">.</span>FunctionDef, ast<span style="color: #666666">.</span>AsyncFunctionDef)):
                        doc <span style="color: #666666">=</span> ast<span style="color: #666666">.</span>get_docstring(node)
                        <span style="color: #008000; font-weight: bold">if</span> doc:
                            kind <span style="color: #666666">=</span> <span style="color: #BA2121">"Class"</span> <span style="color: #008000; font-weight: bold">if</span> <span style="color: #008000">isinstance</span>(node, ast<span style="color: #666666">.</span>ClassDef) <span style="color: #008000; font-weight: bold">else</span> <span style="color: #BA2121">"Function"</span>
                            parts<span style="color: #666666">.</span>append(<span style="color: #BA2121">f"</span><span style="color: #A45A77; font-weight: bold">{</span>kind<span style="color: #A45A77; font-weight: bold">}</span><span style="color: #BA2121"> </span><span style="color: #A45A77; font-weight: bold">{</span>node<span style="color: #666666">.</span>name<span style="color: #A45A77; font-weight: bold">}</span><span style="color: #BA2121"> docstring:</span><span style="color: #AA5D1F; font-weight: bold">\n</span><span style="color: #A45A77; font-weight: bold">{</span>doc<span style="color: #A45A77; font-weight: bold">}</span><span style="color: #BA2121">"</span>)
                        <span style="color: #008000; font-weight: bold">if</span> <span style="color: #008000">isinstance</span>(node, (ast<span style="color: #666666">.</span>FunctionDef, ast<span style="color: #666666">.</span>AsyncFunctionDef)):
                            args <span style="color: #666666">=</span> [a<span style="color: #666666">.</span>arg <span style="color: #008000; font-weight: bold">for</span> a <span style="color: #AA22FF; font-weight: bold">in</span> node<span style="color: #666666">.</span>args<span style="color: #666666">.</span>args]
                            <span style="color: #008000; font-weight: bold">if</span> <span style="color: #008000">any</span>(
                                re<span style="color: #666666">.</span>search(<span style="color: #BA2121">r"(path|file|config|io)"</span>, a, re<span style="color: #666666">.</span>IGNORECASE)
                                <span style="color: #008000; font-weight: bold">for</span> a <span style="color: #AA22FF; font-weight: bold">in</span> args
                            ):
                                sig <span style="color: #666666">=</span> <span style="color: #BA2121">f"def </span><span style="color: #A45A77; font-weight: bold">{</span>node<span style="color: #666666">.</span>name<span style="color: #A45A77; font-weight: bold">}</span><span style="color: #BA2121">(</span><span style="color: #A45A77; font-weight: bold">{</span><span style="color: #BA2121">', '</span><span style="color: #666666">.</span>join(args)<span style="color: #A45A77; font-weight: bold">}</span><span style="color: #BA2121">):"</span>
                                parts<span style="color: #666666">.</span>append(<span style="color: #BA2121">f"I/O signature: </span><span style="color: #A45A77; font-weight: bold">{</span>sig<span style="color: #A45A77; font-weight: bold">}</span><span style="color: #BA2121">"</span>)
                cli_lines <span style="color: #666666">=</span> [
                    line<span style="color: #666666">.</span>strip()
                    <span style="color: #008000; font-weight: bold">for</span> line <span style="color: #AA22FF; font-weight: bold">in</span> text<span style="color: #666666">.</span>splitlines()
                    <span style="color: #008000; font-weight: bold">if</span> <span style="color: #BA2121">"ArgumentParser"</span> <span style="color: #AA22FF; font-weight: bold">in</span> line <span style="color: #AA22FF; font-weight: bold">or</span> <span style="color: #BA2121">"add_argument"</span> <span style="color: #AA22FF; font-weight: bold">in</span> line
                ]
                <span style="color: #008000; font-weight: bold">if</span> cli_lines:
                    parts<span style="color: #666666">.</span>append(<span style="color: #BA2121">"CLI parser:</span><span style="color: #AA5D1F; font-weight: bold">\n</span><span style="color: #BA2121">"</span> <span style="color: #666666">+</span> <span style="color: #BA2121">"</span><span style="color: #AA5D1F; font-weight: bold">\n</span><span style="color: #BA2121">"</span><span style="color: #666666">.</span>join(cli_lines))
                main_match <span style="color: #666666">=</span> re<span style="color: #666666">.</span>search(
                    <span style="color: #BA2121">r"if __name__ == ['</span><span style="color: #AA5D1F; font-weight: bold">\"</span><span style="color: #BA2121">]__main__['</span><span style="color: #AA5D1F; font-weight: bold">\"</span><span style="color: #BA2121">]:(.*)"</span>, text, re<span style="color: #666666">.</span>DOTALL
                )
                <span style="color: #008000; font-weight: bold">if</span> main_match:
                    parts<span style="color: #666666">.</span>append(<span style="color: #BA2121">"__main__ block:</span><span style="color: #AA5D1F; font-weight: bold">\n</span><span style="color: #BA2121">"</span> <span style="color: #666666">+</span> main_match<span style="color: #666666">.</span>group(<span style="color: #666666">0</span>)<span style="color: #666666">.</span>strip())
        <span style="color: #008000; font-weight: bold">else</span>:
            parts<span style="color: #666666">.</span>append(text)

        <span style="color: #008000; font-weight: bold">if</span> parts:
            snippets[path] <span style="color: #666666">=</span> <span style="color: #BA2121">"</span><span style="color: #AA5D1F; font-weight: bold">\n</span><span style="color: #BA2121">"</span><span style="color: #666666">.</span>join(parts)
            logging<span style="color: #666666">.</span>info(
                <span style="color: #BA2121">"Scanned </span><span style="color: #A45A77; font-weight: bold">%s</span><span style="color: #BA2121"> (elapsed </span><span style="color: #A45A77; font-weight: bold">%.2f</span><span style="color: #BA2121">s)"</span>, path, time<span style="color: #666666">.</span>perf_counter() <span style="color: #666666">-</span> start
            )
    <span style="color: #008000; font-weight: bold">return</span> snippets
</code></pre>
<h3 id="scan_code">scan_code(base: Path, sections: list[str] | None=None, *, max_files: int=12, time_budget: int=20, max_bytes_per_file: int=200000) -&gt; dict[str, dict[str, str]]</h3>
<p>The function `scan_code` collects source code snippets from a specified base directory, organizing them by manual sections based on keyword matching. It accepts parameters to limit the number of files processed, the time budget, and the maximum bytes per file. The function first gathers documentation files, extracts text, and identifies patterns such as file paths or Python file extensions. These patterns are used to rank code files, which are then extracted into snippets with size and time constraints. The resulting snippets are categorized by section based on predefined keywords, and only sections with matching snippets are returned in the output dictionary.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">scan_code</span>(
    base: Path,
    sections: <span style="color: #008000">list</span>[<span style="color: #008000">str</span>] <span style="color: #666666">|</span> <span style="color: #008000; font-weight: bold">None</span> <span style="color: #666666">=</span> <span style="color: #008000; font-weight: bold">None</span>,
    <span style="color: #666666">*</span>,
    max_files: <span style="color: #008000">int</span> <span style="color: #666666">=</span> <span style="color: #666666">12</span>,
    time_budget: <span style="color: #008000">int</span> <span style="color: #666666">=</span> <span style="color: #666666">20</span>,
    max_bytes_per_file: <span style="color: #008000">int</span> <span style="color: #666666">=</span> <span style="color: #666666">200_000</span>,
) <span style="color: #666666">-&gt;</span> <span style="color: #008000">dict</span>[<span style="color: #008000">str</span>, <span style="color: #008000">dict</span>[<span style="color: #008000">str</span>, <span style="color: #008000">str</span>]]:
<span style="color: #bbbbbb">    </span><span style="color: #BA2121; font-style: italic">"""Collect source code snippets from ``base`` grouped by manual section.</span>

<span style="color: #BA2121; font-style: italic">    The function searches source files for keywords associated with</span>
<span style="color: #BA2121; font-style: italic">    ``sections`` (defaulting to all known sections) and returns a mapping from</span>
<span style="color: #BA2121; font-style: italic">    section name to a mapping of relative file paths and their snippet text.</span>
<span style="color: #BA2121; font-style: italic">    """</span>

    patterns: <span style="color: #008000">list</span>[<span style="color: #008000">str</span>] <span style="color: #666666">=</span> []
    <span style="color: #008000; font-weight: bold">for</span> doc <span style="color: #AA22FF; font-weight: bold">in</span> collect_docs(base):
        <span style="color: #008000; font-weight: bold">try</span>:
            text <span style="color: #666666">=</span> extract_text(doc)
        <span style="color: #008000; font-weight: bold">except</span> <span style="color: #CB3F38; font-weight: bold">Exception</span>:
            <span style="color: #008000; font-weight: bold">continue</span>
        <span style="color: #008000; font-weight: bold">for</span> match <span style="color: #AA22FF; font-weight: bold">in</span> re<span style="color: #666666">.</span>findall(<span style="color: #BA2121">r"[\w/.-]+"</span>, text):
            <span style="color: #008000; font-weight: bold">if</span> <span style="color: #BA2121">"/"</span> <span style="color: #AA22FF; font-weight: bold">in</span> match <span style="color: #AA22FF; font-weight: bold">or</span> match<span style="color: #666666">.</span>endswith(<span style="color: #BA2121">".py"</span>):
                patterns<span style="color: #666666">.</span>append(match)

    files <span style="color: #666666">=</span> rank_code_files(base, patterns)
    snippets <span style="color: #666666">=</span> extract_snippets(
        files,
        max_files<span style="color: #666666">=</span>max_files,
        time_budget<span style="color: #666666">=</span>time_budget,
        max_bytes<span style="color: #666666">=</span>max_bytes_per_file,
    )

    wanted <span style="color: #666666">=</span> sections <span style="color: #008000; font-weight: bold">if</span> sections <span style="color: #AA22FF; font-weight: bold">is</span> <span style="color: #AA22FF; font-weight: bold">not</span> <span style="color: #008000; font-weight: bold">None</span> <span style="color: #008000; font-weight: bold">else</span> <span style="color: #008000">list</span>(SECTION_KEYWORDS<span style="color: #666666">.</span>keys())
    categorized: <span style="color: #008000">dict</span>[<span style="color: #008000">str</span>, <span style="color: #008000">dict</span>[<span style="color: #008000">str</span>, <span style="color: #008000">str</span>]] <span style="color: #666666">=</span> {sec: {} <span style="color: #008000; font-weight: bold">for</span> sec <span style="color: #AA22FF; font-weight: bold">in</span> wanted}

    <span style="color: #008000; font-weight: bold">for</span> path, text <span style="color: #AA22FF; font-weight: bold">in</span> tqdm(snippets<span style="color: #666666">.</span>items(), desc<span style="color: #666666">=</span><span style="color: #BA2121">"Collecting snippets"</span>):
        rel <span style="color: #666666">=</span> path<span style="color: #666666">.</span>relative_to(base)
        lower <span style="color: #666666">=</span> text<span style="color: #666666">.</span>lower()
        <span style="color: #008000; font-weight: bold">for</span> section <span style="color: #AA22FF; font-weight: bold">in</span> wanted:
            keywords <span style="color: #666666">=</span> SECTION_KEYWORDS<span style="color: #666666">.</span>get(section, [])
            <span style="color: #008000; font-weight: bold">if</span> <span style="color: #008000">any</span>(k <span style="color: #AA22FF; font-weight: bold">in</span> lower <span style="color: #008000; font-weight: bold">for</span> k <span style="color: #AA22FF; font-weight: bold">in</span> keywords):
                categorized<span style="color: #666666">.</span>setdefault(section, {})[<span style="color: #008000">str</span>(rel)] <span style="color: #666666">=</span> text
    <span style="color: #008000; font-weight: bold">return</span> {k: v <span style="color: #008000; font-weight: bold">for</span> k, v <span style="color: #AA22FF; font-weight: bold">in</span> categorized<span style="color: #666666">.</span>items() <span style="color: #008000; font-weight: bold">if</span> v}
</code></pre>
<h3 id="llm_generate_manual">llm_generate_manual(docs: dict[Path, str], client: LLMClient, cache: ResponseCache, chunking: str='auto') -&gt; tuple[str, dict[Path, set[str]], dict[str, dict[str, object]]]</h3>
<p>The function `llm_generate_manual` generates a user manual from provided documentation snippets by mapping them to predefined sections, performing LLM-based summarization for each section, and assembling the final output. It takes a dictionary of documentation paths to content, an LLM client for generating summaries, a response cache for storing and retrieving prior results, and an optional chunking strategy.

For each required section, it retrieves relevant documentation snippets, constructs a prompt using those snippets, and determines whether the section content should be inferred or generated from the snippets. If inference is needed, it uses a placeholder; otherwise, it sends the context to the LLM with a system prompt that restricts responses to only the provided information.

The function handles large inputs by chunking when necessary, using token limits and a tokenizer to manage context size. It caches results to avoid redundant processing and sanitizes outputs before use. The output includes the final manual text, a mapping of source files to sections they contributed to, and an evidence map detailing which snippets were used for each section.

The function relies on helper utilities such as `map_evidence_to_sections`, `summarize_chunked`, `sanitize_summary`, `parse_manual`, and `find_placeholders` to manage the documentation processing pipeline. It logs information</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">llm_generate_manual</span>(
    docs: <span style="color: #008000">dict</span>[Path, <span style="color: #008000">str</span>],
    client: LLMClient,
    cache: ResponseCache,
    chunking: <span style="color: #008000">str</span> <span style="color: #666666">=</span> <span style="color: #BA2121">"auto"</span>,
) <span style="color: #666666">-&gt;</span> <span style="color: #008000">tuple</span>[<span style="color: #008000">str</span>, <span style="color: #008000">dict</span>[Path, <span style="color: #008000">set</span>[<span style="color: #008000">str</span>]], <span style="color: #008000">dict</span>[<span style="color: #008000">str</span>, <span style="color: #008000">dict</span>[<span style="color: #008000">str</span>, <span style="color: #008000">object</span>]]]:
<span style="color: #bbbbbb">    </span><span style="color: #BA2121; font-style: italic">"""Generate a manual from supplied documentation ``docs``.</span>

<span style="color: #BA2121; font-style: italic">    The function maps documentation snippets to manual sections, performs an</span>
<span style="color: #BA2121; font-style: italic">    LLM call per section, and assembles the final manual text. It returns the</span>
<span style="color: #BA2121; font-style: italic">    manual text, a mapping of source files to the sections they contributed,</span>
<span style="color: #BA2121; font-style: italic">    and an evidence map capturing the snippets used for each section.</span>
<span style="color: #BA2121; font-style: italic">    """</span>

    section_map, file_map <span style="color: #666666">=</span> map_evidence_to_sections(docs)

    sections: <span style="color: #008000">dict</span>[<span style="color: #008000">str</span>, <span style="color: #008000">str</span>] <span style="color: #666666">=</span> {}
    evidence_map: <span style="color: #008000">dict</span>[<span style="color: #008000">str</span>, <span style="color: #008000">dict</span>[<span style="color: #008000">str</span>, <span style="color: #008000">object</span>]] <span style="color: #666666">=</span> {}
    <span style="color: #008000; font-weight: bold">for</span> section <span style="color: #AA22FF; font-weight: bold">in</span> REQUIRED_SECTIONS:
        entries <span style="color: #666666">=</span> section_map<span style="color: #666666">.</span>get(section, [])
        inferred <span style="color: #666666">=</span> <span style="color: #AA22FF; font-weight: bold">not</span> entries
        evidence_map[section] <span style="color: #666666">=</span> {
            <span style="color: #BA2121">"inferred"</span>: inferred,
            <span style="color: #BA2121">"evidence"</span>: [
                {<span style="color: #BA2121">"file"</span>: <span style="color: #008000">str</span>(path), <span style="color: #BA2121">"snippet"</span>: snippet}
                <span style="color: #008000; font-weight: bold">for</span> path, snippet <span style="color: #AA22FF; font-weight: bold">in</span> entries
            ],
        }
        <span style="color: #008000; font-weight: bold">if</span> inferred:
            sections[section] <span style="color: #666666">=</span> SECTION_PLACEHOLDERS[section]
            logging<span style="color: #666666">.</span>info(
                <span style="color: #BA2121">"Section </span><span style="color: #A45A77; font-weight: bold">%s</span><span style="color: #BA2121"> generated with inferred content; evidence: none"</span>, section
            )
            <span style="color: #008000; font-weight: bold">continue</span>
        context <span style="color: #666666">=</span> <span style="color: #BA2121">"</span><span style="color: #AA5D1F; font-weight: bold">\n\n</span><span style="color: #BA2121">"</span><span style="color: #666666">.</span>join(snippet <span style="color: #008000; font-weight: bold">for</span> _, snippet <span style="color: #AA22FF; font-weight: bold">in</span> entries)
        <span style="color: #008000; font-weight: bold">for</span> path, snippet <span style="color: #AA22FF; font-weight: bold">in</span> entries:
            logging<span style="color: #666666">.</span>info(<span style="color: #BA2121">"Section </span><span style="color: #A45A77; font-weight: bold">%s</span><span style="color: #BA2121"> snippet from </span><span style="color: #A45A77; font-weight: bold">%s</span><span style="color: #BA2121">"</span>, section, path)
        prompt <span style="color: #666666">=</span> (
            <span style="color: #BA2121">f"Write the '</span><span style="color: #A45A77; font-weight: bold">{</span>section<span style="color: #A45A77; font-weight: bold">}</span><span style="color: #BA2121">' section of a user manual using the "</span>
            <span style="color: #BA2121">"following documentation snippets."</span>
            <span style="color: #BA2121">f"</span><span style="color: #AA5D1F; font-weight: bold">\n\n</span><span style="color: #A45A77; font-weight: bold">{</span>context<span style="color: #A45A77; font-weight: bold">}</span><span style="color: #BA2121">"</span>
        )
        placeholder <span style="color: #666666">=</span> SECTION_PLACEHOLDERS[section]
        system_prompt <span style="color: #666666">=</span> (
            <span style="color: #BA2121">f"You write the '</span><span style="color: #A45A77; font-weight: bold">{</span>section<span style="color: #A45A77; font-weight: bold">}</span><span style="color: #BA2121">' section of a user manual. "</span>
            <span style="color: #BA2121">"Use only the provided snippets; if they lack relevant facts, "</span>
            <span style="color: #BA2121">f"respond with the placeholder token </span><span style="color: #A45A77; font-weight: bold">{</span>placeholder<span style="color: #A45A77; font-weight: bold">}</span><span style="color: #BA2121">. Do not infer "</span>
            <span style="color: #BA2121">"information not present in the snippets."</span>
        )
        tokenizer <span style="color: #666666">=</span> get_tokenizer()
        template <span style="color: #666666">=</span> PROMPT_TEMPLATES[<span style="color: #BA2121">"docstring"</span>]
        overhead <span style="color: #666666">=</span> <span style="color: #008000">len</span>(tokenizer<span style="color: #666666">.</span>encode(system_prompt)) <span style="color: #666666">+</span> <span style="color: #008000">len</span>(
            tokenizer<span style="color: #666666">.</span>encode(template<span style="color: #666666">.</span>format(text<span style="color: #666666">=</span><span style="color: #BA2121">""</span>))
        )
        max_context_tokens <span style="color: #666666">=</span> <span style="color: #666666">4096</span>
        chunk_token_budget <span style="color: #666666">=</span> <span style="color: #008000">int</span>(max_context_tokens <span style="color: #666666">*</span> <span style="color: #666666">0.75</span>)
        available <span style="color: #666666">=</span> max_context_tokens <span style="color: #666666">-</span> overhead
        <span style="color: #008000; font-weight: bold">if</span> <span style="color: #008000">len</span>(tokenizer<span style="color: #666666">.</span>encode(prompt)) <span style="color: #666666">&gt;</span> available:
            result <span style="color: #666666">=</span> summarize_chunked(
                client,
                cache,
                <span style="color: #BA2121">f"section:</span><span style="color: #A45A77; font-weight: bold">{</span>section<span style="color: #A45A77; font-weight: bold">}</span><span style="color: #BA2121">"</span>,
                prompt,
                <span style="color: #BA2121">"docstring"</span>,
                system_prompt<span style="color: #666666">=</span>system_prompt,
                max_context_tokens<span style="color: #666666">=</span>max_context_tokens,
                chunk_token_budget<span style="color: #666666">=</span>chunk_token_budget,
            )
        <span style="color: #008000; font-weight: bold">else</span>:
            key <span style="color: #666666">=</span> ResponseCache<span style="color: #666666">.</span>make_key(<span style="color: #BA2121">f"section:</span><span style="color: #A45A77; font-weight: bold">{</span>section<span style="color: #A45A77; font-weight: bold">}</span><span style="color: #BA2121">"</span>, prompt)
            cached <span style="color: #666666">=</span> cache<span style="color: #666666">.</span>get(key)
            <span style="color: #008000; font-weight: bold">if</span> cached <span style="color: #AA22FF; font-weight: bold">is</span> <span style="color: #AA22FF; font-weight: bold">not</span> <span style="color: #008000; font-weight: bold">None</span>:
                result <span style="color: #666666">=</span> sanitize_summary(cached)
            <span style="color: #008000; font-weight: bold">else</span>:
                result <span style="color: #666666">=</span> client<span style="color: #666666">.</span>summarize(
                    prompt,
                    <span style="color: #BA2121">"docstring"</span>,
                    system_prompt<span style="color: #666666">=</span>system_prompt,
                )
                result <span style="color: #666666">=</span> sanitize_summary(result)
                cache<span style="color: #666666">.</span>set(key, result)
        parsed <span style="color: #666666">=</span> parse_manual(result, infer_missing<span style="color: #666666">=</span><span style="color: #008000; font-weight: bold">False</span>)
        text <span style="color: #666666">=</span> parsed<span style="color: #666666">.</span>get(section, result<span style="color: #666666">.</span>strip())
        <span style="color: #008000; font-weight: bold">if</span> placeholder <span style="color: #AA22FF; font-weight: bold">in</span> find_placeholders(text):
            sections[section] <span style="color: #666666">=</span> placeholder
        <span style="color: #008000; font-weight: bold">else</span>:
            sections[section] <span style="color: #666666">=</span> text
        summary <span style="color: #666666">=</span> <span style="color: #BA2121">", "</span><span style="color: #666666">.</span>join(
            <span style="color: #BA2121">f"</span><span style="color: #A45A77; font-weight: bold">{</span>path<span style="color: #A45A77; font-weight: bold">}</span><span style="color: #BA2121">: </span><span style="color: #A45A77; font-weight: bold">{</span>snippet[:<span style="color: #666666">30</span>]<span style="color: #A45A77; font-weight: bold">}</span><span style="color: #BA2121">"</span> <span style="color: #008000; font-weight: bold">for</span> path, snippet <span style="color: #AA22FF; font-weight: bold">in</span> entries
        )
        logging<span style="color: #666666">.</span>info(
            <span style="color: #BA2121">"Section </span><span style="color: #A45A77; font-weight: bold">%s</span><span style="color: #BA2121"> generated using [</span><span style="color: #A45A77; font-weight: bold">%s</span><span style="color: #BA2121">]; inferred=</span><span style="color: #A45A77; font-weight: bold">%s</span><span style="color: #BA2121">"</span>,
            section,
            summary <span style="color: #AA22FF; font-weight: bold">or</span> <span style="color: #BA2121">"none"</span>,
            inferred,
        )

    manual_text <span style="color: #666666">=</span> <span style="color: #BA2121">"</span><span style="color: #AA5D1F; font-weight: bold">\n</span><span style="color: #BA2121">"</span><span style="color: #666666">.</span>join(<span style="color: #BA2121">f"</span><span style="color: #A45A77; font-weight: bold">{</span>sec<span style="color: #A45A77; font-weight: bold">}</span><span style="color: #BA2121">: </span><span style="color: #A45A77; font-weight: bold">{</span>txt<span style="color: #A45A77; font-weight: bold">}</span><span style="color: #BA2121">"</span> <span style="color: #008000; font-weight: bold">for</span> sec, txt <span style="color: #AA22FF; font-weight: bold">in</span> sections<span style="color: #666666">.</span>items())
    <span style="color: #008000; font-weight: bold">return</span> manual_text, file_map, evidence_map
</code></pre>
<h3 id="llm_fill_placeholders">llm_fill_placeholders(manual_text: str, code_snippets: dict[str, dict[str, str]], client: LLMClient, cache: ResponseCache, *, max_context_tokens: int=4096, chunk_token_budget: int | None=None) -&gt; str</h3>
<p>The function `llm_fill_placeholders` updates a manual text by replacing placeholders with relevant code snippets from a dictionary of code files. It processes each section of code snippets, summarizes them if they exceed the token budget, and uses an LLM client to generate updated manual content. The function maintains token usage within the model's context window by summarizing long snippets and returns the updated manual text after processing all sections.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">llm_fill_placeholders</span>(
    manual_text: <span style="color: #008000">str</span>,
    code_snippets: <span style="color: #008000">dict</span>[<span style="color: #008000">str</span>, <span style="color: #008000">dict</span>[<span style="color: #008000">str</span>, <span style="color: #008000">str</span>]],
    client: LLMClient,
    cache: ResponseCache,
    <span style="color: #666666">*</span>,
    max_context_tokens: <span style="color: #008000">int</span> <span style="color: #666666">=</span> <span style="color: #666666">4096</span>,
    chunk_token_budget: <span style="color: #008000">int</span> <span style="color: #666666">|</span> <span style="color: #008000; font-weight: bold">None</span> <span style="color: #666666">=</span> <span style="color: #008000; font-weight: bold">None</span>,
) <span style="color: #666666">-&gt;</span> <span style="color: #008000">str</span>:
<span style="color: #bbbbbb">    </span><span style="color: #BA2121; font-style: italic">"""Fill placeholder tokens in ``manual_text`` using ``code_snippets``.</span>

<span style="color: #BA2121; font-style: italic">    ``code_snippets`` maps section names to dictionaries of ``path -&gt; text``</span>
<span style="color: #BA2121; font-style: italic">    containing evidence for that section. A separate LLM call is made for each</span>
<span style="color: #BA2121; font-style: italic">    section to update the manual incrementally. Long snippets are summarized</span>
<span style="color: #BA2121; font-style: italic">    before being sent to the model so that prompts stay within the model's</span>
<span style="color: #BA2121; font-style: italic">    context window.</span>
<span style="color: #BA2121; font-style: italic">    """</span>

    tokenizer <span style="color: #666666">=</span> get_tokenizer()
    <span style="color: #008000; font-weight: bold">if</span> chunk_token_budget <span style="color: #AA22FF; font-weight: bold">is</span> <span style="color: #008000; font-weight: bold">None</span>:
        chunk_token_budget <span style="color: #666666">=</span> <span style="color: #008000">int</span>(max_context_tokens <span style="color: #666666">*</span> <span style="color: #666666">0.75</span>)

    <span style="color: #008000; font-weight: bold">for</span> section, files <span style="color: #AA22FF; font-weight: bold">in</span> code_snippets<span style="color: #666666">.</span>items():
        <span style="color: #008000; font-weight: bold">if</span> <span style="color: #AA22FF; font-weight: bold">not</span> files:
            <span style="color: #008000; font-weight: bold">continue</span>
        snippet_text <span style="color: #666666">=</span> <span style="color: #BA2121">"</span><span style="color: #AA5D1F; font-weight: bold">\n\n</span><span style="color: #BA2121">"</span><span style="color: #666666">.</span>join(
            <span style="color: #BA2121">f"# File: </span><span style="color: #A45A77; font-weight: bold">{</span>path<span style="color: #A45A77; font-weight: bold">}</span><span style="color: #AA5D1F; font-weight: bold">\n</span><span style="color: #A45A77; font-weight: bold">{</span>text<span style="color: #A45A77; font-weight: bold">}</span><span style="color: #BA2121">"</span> <span style="color: #008000; font-weight: bold">for</span> path, text <span style="color: #AA22FF; font-weight: bold">in</span> files<span style="color: #666666">.</span>items()
        )

        token_usage <span style="color: #666666">=</span> <span style="color: #008000">len</span>(tokenizer<span style="color: #666666">.</span>encode(manual_text)) <span style="color: #666666">+</span> <span style="color: #008000">len</span>(
            tokenizer<span style="color: #666666">.</span>encode(snippet_text)
        )
        <span style="color: #008000; font-weight: bold">if</span> token_usage <span style="color: #666666">&gt;</span> max_context_tokens:
            snippet_text <span style="color: #666666">=</span> summarize_chunked(
                client,
                cache,
                <span style="color: #BA2121">f"fill_manual:</span><span style="color: #A45A77; font-weight: bold">{</span>section<span style="color: #A45A77; font-weight: bold">}</span><span style="color: #BA2121">:snippet"</span>,
                snippet_text,
                <span style="color: #BA2121">"docstring"</span>,
                system_prompt<span style="color: #666666">=</span>FILL_SYSTEM_PROMPT,
                max_context_tokens<span style="color: #666666">=</span>max_context_tokens,
                chunk_token_budget<span style="color: #666666">=</span>chunk_token_budget,
            )

        prompt <span style="color: #666666">=</span> (
            <span style="color: #BA2121">f"Manual:</span><span style="color: #AA5D1F; font-weight: bold">\n</span><span style="color: #A45A77; font-weight: bold">{</span>manual_text<span style="color: #A45A77; font-weight: bold">}</span><span style="color: #AA5D1F; font-weight: bold">\n\n</span><span style="color: #BA2121">"</span>
            <span style="color: #BA2121">f"Section: </span><span style="color: #A45A77; font-weight: bold">{</span>section<span style="color: #A45A77; font-weight: bold">}</span><span style="color: #AA5D1F; font-weight: bold">\n</span><span style="color: #BA2121">"</span>
            <span style="color: #BA2121">f"Code Snippets:</span><span style="color: #AA5D1F; font-weight: bold">\n</span><span style="color: #A45A77; font-weight: bold">{</span>snippet_text<span style="color: #A45A77; font-weight: bold">}</span><span style="color: #AA5D1F; font-weight: bold">\n\n</span><span style="color: #BA2121">"</span>
            <span style="color: #BA2121">"Update the manual by replacing the placeholder for this section with the relevant information from the code snippets."</span>
        )

        manual_text <span style="color: #666666">=</span> summarize_chunked(
            client,
            cache,
            <span style="color: #BA2121">f"fill_manual:</span><span style="color: #A45A77; font-weight: bold">{</span>section<span style="color: #A45A77; font-weight: bold">}</span><span style="color: #BA2121">"</span>,
            prompt,
            <span style="color: #BA2121">"docstring"</span>,
            system_prompt<span style="color: #666666">=</span>FILL_SYSTEM_PROMPT,
            max_context_tokens<span style="color: #666666">=</span>max_context_tokens,
            chunk_token_budget<span style="color: #666666">=</span>chunk_token_budget,
        )

        logging<span style="color: #666666">.</span>info(
            <span style="color: #BA2121">"Filled </span><span style="color: #A45A77; font-weight: bold">%s</span><span style="color: #BA2121"> using code from: </span><span style="color: #A45A77; font-weight: bold">%s</span><span style="color: #BA2121">"</span>, section, <span style="color: #BA2121">", "</span><span style="color: #666666">.</span>join(files<span style="color: #666666">.</span>keys())
        )
    <span style="color: #008000; font-weight: bold">return</span> manual_text
</code></pre>
<h3 id="_edit_chunks_in_editor">_edit_chunks_in_editor(chunks: list[str]) -&gt; list[str]</h3>
<p>The function `_edit_chunks_in_editor` takes a list of strings (`chunks`) and opens them in a user's preferred text editor for modification. The chunks are joined with a separator line (`---`) and written to a temporary file. The user's editor is determined by environment variables `EDITOR` or `VISUAL`, defaulting to `vi` if neither is set. After the editor is closed, the modified content is read back from the temporary file, split by the separator, and returned as a list of non-empty, stripped strings. The temporary file is deleted after use.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">_edit_chunks_in_editor</span>(chunks: <span style="color: #008000">list</span>[<span style="color: #008000">str</span>]) <span style="color: #666666">-&gt;</span> <span style="color: #008000">list</span>[<span style="color: #008000">str</span>]:
<span style="color: #bbbbbb">    </span><span style="color: #BA2121; font-style: italic">"""Open ``chunks`` in user's editor for optional modification.</span>

<span style="color: #BA2121; font-style: italic">    Chunks are separated by lines containing ``---``. Returns the edited</span>
<span style="color: #BA2121; font-style: italic">    chunks after the editor is closed. Empty chunks are discarded.</span>
<span style="color: #BA2121; font-style: italic">    """</span>

    separator <span style="color: #666666">=</span> <span style="color: #BA2121">"</span><span style="color: #AA5D1F; font-weight: bold">\n\n</span><span style="color: #BA2121">---</span><span style="color: #AA5D1F; font-weight: bold">\n\n</span><span style="color: #BA2121">"</span>
    initial <span style="color: #666666">=</span> separator<span style="color: #666666">.</span>join(chunks)
    <span style="color: #008000; font-weight: bold">with</span> tempfile<span style="color: #666666">.</span>NamedTemporaryFile(<span style="color: #BA2121">"w+"</span>, suffix<span style="color: #666666">=</span><span style="color: #BA2121">".md"</span>, delete<span style="color: #666666">=</span><span style="color: #008000; font-weight: bold">False</span>) <span style="color: #008000; font-weight: bold">as</span> tmp:
        tmp<span style="color: #666666">.</span>write(initial)
        tmp<span style="color: #666666">.</span>flush()
        editor <span style="color: #666666">=</span> os<span style="color: #666666">.</span>environ<span style="color: #666666">.</span>get(<span style="color: #BA2121">"EDITOR"</span>) <span style="color: #AA22FF; font-weight: bold">or</span> os<span style="color: #666666">.</span>environ<span style="color: #666666">.</span>get(<span style="color: #BA2121">"VISUAL"</span>) <span style="color: #AA22FF; font-weight: bold">or</span> <span style="color: #BA2121">"vi"</span>
        subprocess<span style="color: #666666">.</span>call([editor, tmp<span style="color: #666666">.</span>name])
        tmp<span style="color: #666666">.</span>seek(<span style="color: #666666">0</span>)
        data <span style="color: #666666">=</span> tmp<span style="color: #666666">.</span>read()
    Path(tmp<span style="color: #666666">.</span>name)<span style="color: #666666">.</span>unlink(missing_ok<span style="color: #666666">=</span><span style="color: #008000; font-weight: bold">True</span>)
    parts <span style="color: #666666">=</span> re<span style="color: #666666">.</span>split(<span style="color: #BA2121">r"\n\s*---\s*\n"</span>, data)
    <span style="color: #008000; font-weight: bold">return</span> [p<span style="color: #666666">.</span>strip() <span style="color: #008000; font-weight: bold">for</span> p <span style="color: #AA22FF; font-weight: bold">in</span> parts <span style="color: #008000; font-weight: bold">if</span> p<span style="color: #666666">.</span>strip()]
</code></pre>
<h3 id="render_html">render_html(sections: Dict[str, str], title: str, evidence_map: dict[str, dict[str, object]] | None=None) -&gt; str</h3>
<p>The `render_html` function generates an HTML document from a dictionary of sections, each containing content and optional evidence snippets. It constructs a navigable HTML page with a title, a table of contents, and section headers with anchor links. For each section, if the content is empty or marked as "no information provided" and evidence is available, it displays the evidence snippets and associated source files. Otherwise, it renders the content using Markdown (if available) or escapes it as plain text. The function uses a helper `_slugify` to create URL-safe anchors for navigation and applies basic styling to the output. The resulting HTML includes structured sections, navigation, and formatting for both content and evidence.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">render_html</span>(
    sections: Dict[<span style="color: #008000">str</span>, <span style="color: #008000">str</span>],
    title: <span style="color: #008000">str</span>,
    evidence_map: <span style="color: #008000">dict</span>[<span style="color: #008000">str</span>, <span style="color: #008000">dict</span>[<span style="color: #008000">str</span>, <span style="color: #008000">object</span>]] <span style="color: #666666">|</span> <span style="color: #008000; font-weight: bold">None</span> <span style="color: #666666">=</span> <span style="color: #008000; font-weight: bold">None</span>,
) <span style="color: #666666">-&gt;</span> <span style="color: #008000">str</span>:
<span style="color: #bbbbbb">    </span><span style="color: #BA2121; font-style: italic">"""Return HTML for ``sections`` with ``title``.</span>

<span style="color: #BA2121; font-style: italic">    ``evidence_map`` contains supporting snippets for each section. When a</span>
<span style="color: #BA2121; font-style: italic">    section's content is empty or marked as lacking information, available</span>
<span style="color: #BA2121; font-style: italic">    evidence snippets are rendered instead so that the manual always reflects</span>
<span style="color: #BA2121; font-style: italic">    the extracted documentation.</span>
<span style="color: #BA2121; font-style: italic">    """</span>

    <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">_slugify</span>(text: <span style="color: #008000">str</span>) <span style="color: #666666">-&gt;</span> <span style="color: #008000">str</span>:
        slug <span style="color: #666666">=</span> re<span style="color: #666666">.</span>sub(<span style="color: #BA2121">r"[^a-z0-9]+"</span>, <span style="color: #BA2121">"-"</span>, text<span style="color: #666666">.</span>lower())
        <span style="color: #008000; font-weight: bold">return</span> slug<span style="color: #666666">.</span>strip(<span style="color: #BA2121">"-"</span>)

    nav_items: <span style="color: #008000">list</span>[<span style="color: #008000">str</span>] <span style="color: #666666">=</span> []
    body_parts: <span style="color: #008000">list</span>[<span style="color: #008000">str</span>] <span style="color: #666666">=</span> []

    <span style="color: #008000; font-weight: bold">for</span> sec_title, content <span style="color: #AA22FF; font-weight: bold">in</span> sections<span style="color: #666666">.</span>items():
        anchor <span style="color: #666666">=</span> _slugify(sec_title)
        nav_items<span style="color: #666666">.</span>append(
            <span style="color: #BA2121">f"&lt;li&gt;&lt;a href='#"</span> <span style="color: #666666">+</span> anchor <span style="color: #666666">+</span> <span style="color: #BA2121">f"'&gt;</span><span style="color: #A45A77; font-weight: bold">{</span>html<span style="color: #666666">.</span>escape(sec_title)<span style="color: #A45A77; font-weight: bold">}</span><span style="color: #BA2121">&lt;/a&gt;&lt;/li&gt;"</span>
        )

        evidence <span style="color: #666666">=</span> []
        <span style="color: #008000; font-weight: bold">if</span> evidence_map:
            evidence <span style="color: #666666">=</span> evidence_map<span style="color: #666666">.</span>get(sec_title, {})<span style="color: #666666">.</span>get(<span style="color: #BA2121">"evidence"</span>, [])
        text <span style="color: #666666">=</span> content<span style="color: #666666">.</span>strip()
        <span style="color: #008000; font-weight: bold">if</span> (<span style="color: #AA22FF; font-weight: bold">not</span> text <span style="color: #AA22FF; font-weight: bold">or</span> text<span style="color: #666666">.</span>lower() <span style="color: #666666">==</span> <span style="color: #BA2121">"no information provided."</span>) <span style="color: #AA22FF; font-weight: bold">and</span> evidence:
            snippets <span style="color: #666666">=</span> <span style="color: #BA2121">"&lt;br/&gt;"</span><span style="color: #666666">.</span>join(
                html<span style="color: #666666">.</span>escape(e<span style="color: #666666">.</span>get(<span style="color: #BA2121">"snippet"</span>, <span style="color: #BA2121">""</span>)) <span style="color: #008000; font-weight: bold">for</span> e <span style="color: #AA22FF; font-weight: bold">in</span> evidence <span style="color: #008000; font-weight: bold">if</span> e<span style="color: #666666">.</span>get(<span style="color: #BA2121">"snippet"</span>)
            )
            src_items <span style="color: #666666">=</span> [
                <span style="color: #BA2121">f"&lt;li&gt;</span><span style="color: #A45A77; font-weight: bold">{</span>html<span style="color: #666666">.</span>escape(e<span style="color: #666666">.</span>get(<span style="color: #BA2121">'file'</span>,<span style="color: #bbbbbb"> </span><span style="color: #BA2121">''</span>))<span style="color: #A45A77; font-weight: bold">}</span><span style="color: #BA2121">&lt;/li&gt;"</span>
                <span style="color: #008000; font-weight: bold">for</span> e <span style="color: #AA22FF; font-weight: bold">in</span> evidence
                <span style="color: #008000; font-weight: bold">if</span> e<span style="color: #666666">.</span>get(<span style="color: #BA2121">"file"</span>)
            ]
            sources_block <span style="color: #666666">=</span> (
                <span style="color: #BA2121">f"&lt;div class='sources'&gt;&lt;ul&gt;</span><span style="color: #A45A77; font-weight: bold">{</span><span style="color: #BA2121">''</span><span style="color: #666666">.</span>join(src_items)<span style="color: #A45A77; font-weight: bold">}</span><span style="color: #BA2121">&lt;/ul&gt;&lt;/div&gt;"</span>
                <span style="color: #008000; font-weight: bold">if</span> src_items
                <span style="color: #008000; font-weight: bold">else</span> <span style="color: #BA2121">""</span>
            )
            body_parts<span style="color: #666666">.</span>append(
                <span style="color: #BA2121">f"&lt;h2 id='</span><span style="color: #A45A77; font-weight: bold">{</span>anchor<span style="color: #A45A77; font-weight: bold">}</span><span style="color: #BA2121">'&gt;</span><span style="color: #A45A77; font-weight: bold">{</span>html<span style="color: #666666">.</span>escape(sec_title)<span style="color: #A45A77; font-weight: bold">}</span><span style="color: #BA2121">&lt;/h2&gt;&lt;p&gt;</span><span style="color: #A45A77; font-weight: bold">{</span>snippets<span style="color: #A45A77; font-weight: bold">}</span><span style="color: #BA2121">&lt;/p&gt;</span><span style="color: #A45A77; font-weight: bold">{</span>sources_block<span style="color: #A45A77; font-weight: bold">}</span><span style="color: #BA2121">"</span>
            )
        <span style="color: #008000; font-weight: bold">else</span>:
            <span style="color: #008000; font-weight: bold">if</span> <span style="color: #AA22FF; font-weight: bold">not</span> text:
                text <span style="color: #666666">=</span> <span style="color: #BA2121">"No information provided."</span>
            <span style="color: #008000; font-weight: bold">if</span> markdown <span style="color: #AA22FF; font-weight: bold">is</span> <span style="color: #AA22FF; font-weight: bold">not</span> <span style="color: #008000; font-weight: bold">None</span>:
                <span style="color: #008000; font-weight: bold">try</span>:
                    rendered <span style="color: #666666">=</span> markdown<span style="color: #666666">.</span>markdown(
                        text, extensions<span style="color: #666666">=</span>[<span style="color: #BA2121">"fenced_code"</span>, <span style="color: #BA2121">"tables"</span>]
                    )
                <span style="color: #008000; font-weight: bold">except</span> <span style="color: #CB3F38; font-weight: bold">Exception</span>:
                    rendered <span style="color: #666666">=</span> html<span style="color: #666666">.</span>escape(text)
            <span style="color: #008000; font-weight: bold">else</span>:  <span style="color: #3D7B7B; font-style: italic"># pragma: no cover - optional dependency missing</span>
                rendered <span style="color: #666666">=</span> html<span style="color: #666666">.</span>escape(text)
            body_parts<span style="color: #666666">.</span>append(
                <span style="color: #BA2121">f"&lt;h2 id='</span><span style="color: #A45A77; font-weight: bold">{</span>anchor<span style="color: #A45A77; font-weight: bold">}</span><span style="color: #BA2121">'&gt;</span><span style="color: #A45A77; font-weight: bold">{</span>html<span style="color: #666666">.</span>escape(sec_title)<span style="color: #A45A77; font-weight: bold">}</span><span style="color: #BA2121">&lt;/h2&gt;</span><span style="color: #A45A77; font-weight: bold">{</span>rendered<span style="color: #A45A77; font-weight: bold">}</span><span style="color: #BA2121">"</span>
            )

    parts <span style="color: #666666">=</span> [
        <span style="color: #BA2121">"&lt;html&gt;&lt;head&gt;&lt;meta charset='utf-8'&gt;"</span>,
        (
            <span style="color: #BA2121">"&lt;style&gt;body{font-family:Arial,sans-serif;margin:20px;}h2{color:#2c3e50;}"</span>
            <span style="color: #BA2121">".evidence{margin-left:1em;color:#555;font-size:0.9em;}"</span>
            <span style="color: #BA2121">".sources{margin-left:1em;font-size:0.9em;}"</span>
            <span style="color: #BA2121">".sources ul{margin:0;padding-left:1.2em;}&lt;/style&gt;"</span>
        ),
        <span style="color: #BA2121">"&lt;/head&gt;&lt;body&gt;"</span>,
        <span style="color: #BA2121">f"&lt;h1&gt;</span><span style="color: #A45A77; font-weight: bold">{</span>html<span style="color: #666666">.</span>escape(title)<span style="color: #A45A77; font-weight: bold">}</span><span style="color: #BA2121">&lt;/h1&gt;"</span>,
        <span style="color: #BA2121">"&lt;nav&gt;&lt;ul&gt;"</span>,
        <span style="color: #BA2121">""</span><span style="color: #666666">.</span>join(nav_items),
        <span style="color: #BA2121">"&lt;/ul&gt;&lt;/nav&gt;"</span>,
        <span style="color: #BA2121">""</span><span style="color: #666666">.</span>join(body_parts),
        <span style="color: #BA2121">"&lt;/body&gt;&lt;/html&gt;"</span>,
    ]
    <span style="color: #008000; font-weight: bold">return</span> <span style="color: #BA2121">"</span><span style="color: #AA5D1F; font-weight: bold">\n</span><span style="color: #BA2121">"</span><span style="color: #666666">.</span>join(parts)
</code></pre>
<details>
<summary>Subfunction: _slugify(text: str) -&gt; str</summary>
<h4 id="_slugify">_slugify(text: str) -&gt; str</h4>
<p>The function `_slugify` converts a given string into a URL-friendly slug format. It transforms the input text to lowercase, replaces all non-alphanumeric characters with hyphens, and removes any leading or trailing hyphens from the result.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">_slugify</span>(text: <span style="color: #008000">str</span>) <span style="color: #666666">-&gt;</span> <span style="color: #008000">str</span>:
        slug <span style="color: #666666">=</span> re<span style="color: #666666">.</span>sub(<span style="color: #BA2121">r"[^a-z0-9]+"</span>, <span style="color: #BA2121">"-"</span>, text<span style="color: #666666">.</span>lower())
        <span style="color: #008000; font-weight: bold">return</span> slug<span style="color: #666666">.</span>strip(<span style="color: #BA2121">"-"</span>)
</code></pre>
</details>
<h3 id="parse_manual">parse_manual(text: str, client: 'LLMClient | None'=None, infer_missing: bool=True) -&gt; Dict[str, str]</h3>
<p>The function `parse_manual` takes a text input and parses it into structured sections based on colon-separated headings. It splits the input text on lines containing a colon, extracting section names and their corresponding content. If `infer_missing` is enabled and required sections are missing, it uses an LLM client to generate inferred content for those sections. The function returns a dictionary mapping section names to their content, with inferred sections marked as "(inferred)". It handles multi-line content under a section heading and ensures all required sections are present in the output.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">parse_manual</span>(
    text: <span style="color: #008000">str</span>,
    client: <span style="color: #BA2121">"LLMClient | None"</span> <span style="color: #666666">=</span> <span style="color: #008000; font-weight: bold">None</span>,
    infer_missing: <span style="color: #008000">bool</span> <span style="color: #666666">=</span> <span style="color: #008000; font-weight: bold">True</span>,
) <span style="color: #666666">-&gt;</span> Dict[<span style="color: #008000">str</span>, <span style="color: #008000">str</span>]:
<span style="color: #bbbbbb">    </span><span style="color: #BA2121; font-style: italic">"""Parse ``text`` from the LLM into structured sections.</span>

<span style="color: #BA2121; font-style: italic">    The language model may return any set of headings. This parser splits the</span>
<span style="color: #BA2121; font-style: italic">    input on lines containing a colon (``Section: content``) and keeps the</span>
<span style="color: #BA2121; font-style: italic">    sections in the order they appear. When ``infer_missing`` is ``True``,</span>
<span style="color: #BA2121; font-style: italic">    absent required sections are inferred using the language model and marked</span>
<span style="color: #BA2121; font-style: italic">    as ``(inferred)``.</span>
<span style="color: #BA2121; font-style: italic">    """</span>

    sections: Dict[<span style="color: #008000">str</span>, <span style="color: #008000">str</span>] <span style="color: #666666">=</span> {}
    current: <span style="color: #008000">str</span> <span style="color: #666666">|</span> <span style="color: #008000; font-weight: bold">None</span> <span style="color: #666666">=</span> <span style="color: #008000; font-weight: bold">None</span>
    <span style="color: #008000; font-weight: bold">for</span> line <span style="color: #AA22FF; font-weight: bold">in</span> text<span style="color: #666666">.</span>splitlines():
        stripped <span style="color: #666666">=</span> line<span style="color: #666666">.</span>strip()
        <span style="color: #008000; font-weight: bold">if</span> <span style="color: #AA22FF; font-weight: bold">not</span> stripped:
            <span style="color: #008000; font-weight: bold">continue</span>
        match <span style="color: #666666">=</span> re<span style="color: #666666">.</span>match(<span style="color: #BA2121">r"^([A-Za-z &amp;]+):\s*(.*)$"</span>, stripped)
        <span style="color: #008000; font-weight: bold">if</span> match:
            current <span style="color: #666666">=</span> match<span style="color: #666666">.</span>group(<span style="color: #666666">1</span>)<span style="color: #666666">.</span>strip()
            sections[current] <span style="color: #666666">=</span> match<span style="color: #666666">.</span>group(<span style="color: #666666">2</span>)<span style="color: #666666">.</span>strip()
        <span style="color: #008000; font-weight: bold">elif</span> current:
            sections[current] <span style="color: #666666">+=</span> (<span style="color: #BA2121">"</span><span style="color: #AA5D1F; font-weight: bold">\n</span><span style="color: #BA2121">"</span> <span style="color: #008000; font-weight: bold">if</span> sections[current] <span style="color: #008000; font-weight: bold">else</span> <span style="color: #BA2121">""</span>) <span style="color: #666666">+</span> stripped

    missing <span style="color: #666666">=</span> [key <span style="color: #008000; font-weight: bold">for</span> key <span style="color: #AA22FF; font-weight: bold">in</span> REQUIRED_SECTIONS <span style="color: #008000; font-weight: bold">if</span> <span style="color: #AA22FF; font-weight: bold">not</span> sections<span style="color: #666666">.</span>get(key, <span style="color: #BA2121">""</span>)<span style="color: #666666">.</span>strip()]
    <span style="color: #008000; font-weight: bold">if</span> infer_missing <span style="color: #AA22FF; font-weight: bold">and</span> missing:
        <span style="color: #008000; font-weight: bold">if</span> client <span style="color: #AA22FF; font-weight: bold">is</span> <span style="color: #008000; font-weight: bold">None</span>:
            client <span style="color: #666666">=</span> LLMClient()
        <span style="color: #008000; font-weight: bold">for</span> key <span style="color: #AA22FF; font-weight: bold">in</span> missing:
            prompt <span style="color: #666666">=</span> (
                <span style="color: #BA2121">f"Based on the following manual draft, write a short '</span><span style="color: #A45A77; font-weight: bold">{</span>key<span style="color: #A45A77; font-weight: bold">}</span><span style="color: #BA2121">' section.</span><span style="color: #AA5D1F; font-weight: bold">\n\n</span><span style="color: #A45A77; font-weight: bold">{</span>text<span style="color: #A45A77; font-weight: bold">}</span><span style="color: #BA2121">"</span>
            )
            <span style="color: #008000; font-weight: bold">try</span>:
                guess <span style="color: #666666">=</span> client<span style="color: #666666">.</span>summarize(
                    prompt,
                    <span style="color: #BA2121">"docstring"</span>,
                    system_prompt<span style="color: #666666">=</span><span style="color: #BA2121">f"You fill in the '</span><span style="color: #A45A77; font-weight: bold">{</span>key<span style="color: #A45A77; font-weight: bold">}</span><span style="color: #BA2121">' section of a user manual."</span>,
                )
            <span style="color: #008000; font-weight: bold">except</span> <span style="color: #CB3F38; font-weight: bold">Exception</span>:  <span style="color: #3D7B7B; font-style: italic"># pragma: no cover - network issues</span>
                guess <span style="color: #666666">=</span> <span style="color: #BA2121">""</span>
            sections[key] <span style="color: #666666">=</span> (guess<span style="color: #666666">.</span>strip() <span style="color: #AA22FF; font-weight: bold">or</span> <span style="color: #BA2121">f"</span><span style="color: #A45A77; font-weight: bold">{</span>key<span style="color: #A45A77; font-weight: bold">}</span><span style="color: #BA2121"> details"</span>) <span style="color: #666666">+</span> <span style="color: #BA2121">" (inferred)"</span>

    <span style="color: #008000; font-weight: bold">return</span> sections
</code></pre>
<h3 id="validate_manual_references">validate_manual_references(sections: Dict[str, str], project_root: Path, evidence_map: dict[str, dict[str, object]] | None=None) -&gt; None</h3>
<p>The function `validate_manual_references` identifies and flags file references within sections of documentation that do not correspond to existing files in a project. It takes a dictionary of section titles and their text content, a project root path, and an optional evidence map for recording missing references.

Using a regular expression, it scans each section's text for substrings that resemble file paths or module names with specific extensions (e.g., `.py`, `.m`, `.md`). For each matched reference, it checks whether the reference exists as a file or filename within the project root. If a match is not found, the reference is annotated with `[missing]` in the section text.

If an `evidence_map` is provided, missing references are also recorded under a `missing_references` key for each section. The function modifies the input `sections` dictionary in place, updating the text content to include the `[missing]` annotations and optionally logging missing references in the evidence map.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">validate_manual_references</span>(
    sections: Dict[<span style="color: #008000">str</span>, <span style="color: #008000">str</span>],
    project_root: Path,
    evidence_map: <span style="color: #008000">dict</span>[<span style="color: #008000">str</span>, <span style="color: #008000">dict</span>[<span style="color: #008000">str</span>, <span style="color: #008000">object</span>]] <span style="color: #666666">|</span> <span style="color: #008000; font-weight: bold">None</span> <span style="color: #666666">=</span> <span style="color: #008000; font-weight: bold">None</span>,
) <span style="color: #666666">-&gt;</span> <span style="color: #008000; font-weight: bold">None</span>:
<span style="color: #bbbbbb">    </span><span style="color: #BA2121; font-style: italic">"""Flag references in ``sections`` that lack corresponding files.</span>

<span style="color: #BA2121; font-style: italic">    Each section's text is scanned for substrings that resemble file paths or</span>
<span style="color: #BA2121; font-style: italic">    module names (e.g., ``module.py`` or ``sub/dir/file.m``). If a referenced</span>
<span style="color: #BA2121; font-style: italic">    file cannot be found anywhere under ``project_root``, the reference is</span>
<span style="color: #BA2121; font-style: italic">    annotated with ``[missing]`` in the section text. When ``evidence_map`` is</span>
<span style="color: #BA2121; font-style: italic">    provided, missing references are also recorded under the corresponding</span>
<span style="color: #BA2121; font-style: italic">    section in a ``missing_references`` list.</span>

<span style="color: #BA2121; font-style: italic">    The ``sections`` mapping is modified in place.</span>
<span style="color: #BA2121; font-style: italic">    """</span>

    pattern <span style="color: #666666">=</span> re<span style="color: #666666">.</span>compile(
        <span style="color: #BA2121">r"\b[\w./-]+\.(?:py|m|md|rst|txt|json|yaml|yml|csv)\b"</span>
    )

    existing_paths <span style="color: #666666">=</span> {
        p<span style="color: #666666">.</span>relative_to(project_root)<span style="color: #666666">.</span>as_posix()
        <span style="color: #008000; font-weight: bold">for</span> p <span style="color: #AA22FF; font-weight: bold">in</span> project_root<span style="color: #666666">.</span>rglob(<span style="color: #BA2121">"*"</span>)
        <span style="color: #008000; font-weight: bold">if</span> p<span style="color: #666666">.</span>is_file()
    }
    existing_names <span style="color: #666666">=</span> {Path(p)<span style="color: #666666">.</span>name <span style="color: #008000; font-weight: bold">for</span> p <span style="color: #AA22FF; font-weight: bold">in</span> existing_paths}

    <span style="color: #008000; font-weight: bold">for</span> title, text <span style="color: #AA22FF; font-weight: bold">in</span> sections<span style="color: #666666">.</span>items():
        missing: <span style="color: #008000">list</span>[<span style="color: #008000">str</span>] <span style="color: #666666">=</span> []

        <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">repl</span>(match: re<span style="color: #666666">.</span>Match[<span style="color: #008000">str</span>]) <span style="color: #666666">-&gt;</span> <span style="color: #008000">str</span>:
            ref <span style="color: #666666">=</span> match<span style="color: #666666">.</span>group(<span style="color: #666666">0</span>)
            <span style="color: #008000; font-weight: bold">if</span> ref <span style="color: #AA22FF; font-weight: bold">in</span> existing_paths <span style="color: #AA22FF; font-weight: bold">or</span> ref <span style="color: #AA22FF; font-weight: bold">in</span> existing_names:
                <span style="color: #008000; font-weight: bold">return</span> ref
            missing<span style="color: #666666">.</span>append(ref)
            <span style="color: #008000; font-weight: bold">return</span> <span style="color: #BA2121">f"</span><span style="color: #A45A77; font-weight: bold">{</span>ref<span style="color: #A45A77; font-weight: bold">}</span><span style="color: #BA2121"> [missing]"</span>

        updated <span style="color: #666666">=</span> pattern<span style="color: #666666">.</span>sub(repl, text)
        sections[title] <span style="color: #666666">=</span> updated
        <span style="color: #008000; font-weight: bold">if</span> missing <span style="color: #AA22FF; font-weight: bold">and</span> evidence_map <span style="color: #AA22FF; font-weight: bold">is</span> <span style="color: #AA22FF; font-weight: bold">not</span> <span style="color: #008000; font-weight: bold">None</span>:
            evidence_map<span style="color: #666666">.</span>setdefault(title, {})<span style="color: #666666">.</span>setdefault(
                <span style="color: #BA2121">"missing_references"</span>, []
            )<span style="color: #666666">.</span>extend(missing)
</code></pre>
<h3 id="infer_sections">infer_sections(text: str) -&gt; Dict[str, str]</h3>
<p>The function `infer_sections` takes a string input and returns a dictionary of sections. If the input text is non-empty, it places the text under the "Overview" section and populates the remaining required sections with placeholder content labeled as "(inferred)". If the input text is empty, all required sections are assigned a default message indicating no information is provided. The function uses a predefined list `REQUIRED_SECTIONS` to determine which sections to include in the output dictionary.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">infer_sections</span>(text: <span style="color: #008000">str</span>) <span style="color: #666666">-&gt;</span> Dict[<span style="color: #008000">str</span>, <span style="color: #008000">str</span>]:
<span style="color: #bbbbbb">    </span><span style="color: #BA2121; font-style: italic">"""Infer manual sections heuristically from plain ``text``.</span>

<span style="color: #BA2121; font-style: italic">    This is a lightweight fallback used when the language model cannot provide</span>
<span style="color: #BA2121; font-style: italic">    a structured summary. When ``text`` is non-empty, the combined text is</span>
<span style="color: #BA2121; font-style: italic">    placed in the ``Overview`` section and placeholder content labelled</span>
<span style="color: #BA2121; font-style: italic">    ``(inferred)`` is generated for the remaining sections. If ``text`` is</span>
<span style="color: #BA2121; font-style: italic">    empty, a default message is used to indicate that no information exists.</span>
<span style="color: #BA2121; font-style: italic">    """</span>

    sections: Dict[<span style="color: #008000">str</span>, <span style="color: #008000">str</span>] <span style="color: #666666">=</span> {}
    text <span style="color: #666666">=</span> text<span style="color: #666666">.</span>strip()
    <span style="color: #008000; font-weight: bold">if</span> text:
        sections[<span style="color: #BA2121">"Overview"</span>] <span style="color: #666666">=</span> text
        <span style="color: #008000; font-weight: bold">for</span> key <span style="color: #AA22FF; font-weight: bold">in</span> REQUIRED_SECTIONS:
            sections<span style="color: #666666">.</span>setdefault(key, <span style="color: #BA2121">f"</span><span style="color: #A45A77; font-weight: bold">{</span>key<span style="color: #A45A77; font-weight: bold">}</span><span style="color: #BA2121"> details (inferred)"</span>)
    <span style="color: #008000; font-weight: bold">else</span>:
        <span style="color: #008000; font-weight: bold">for</span> key <span style="color: #AA22FF; font-weight: bold">in</span> REQUIRED_SECTIONS:
            sections[key] <span style="color: #666666">=</span> <span style="color: #BA2121">"No information provided."</span>
    <span style="color: #008000; font-weight: bold">return</span> sections
</code></pre>
<h3 id="write_pdf">write_pdf(html: str, path: Path) -&gt; bool</h3>
<p>The function `write_pdf` converts HTML content into a PDF file using the `reportlab` library. It takes an HTML string and a file path as inputs, and writes the text content of the HTML to the specified path as a PDF document. The function returns `True` if successful, or `False` if the required `canvas` module is not available. The text from the HTML is extracted using `BeautifulSoup`, split into lines, and written to the PDF using a `Canvas` object with a letter-sized page format.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">write_pdf</span>(html: <span style="color: #008000">str</span>, path: Path) <span style="color: #666666">-&gt;</span> <span style="color: #008000">bool</span>:
<span style="color: #bbbbbb">    </span><span style="color: #BA2121; font-style: italic">"""Write ``html`` to ``path`` as a PDF. Returns ``True`` on success."""</span>
    <span style="color: #008000; font-weight: bold">if</span> canvas <span style="color: #AA22FF; font-weight: bold">is</span> <span style="color: #008000; font-weight: bold">None</span>:  <span style="color: #3D7B7B; font-style: italic"># pragma: no cover - optional branch</span>
        <span style="color: #008000; font-weight: bold">return</span> <span style="color: #008000; font-weight: bold">False</span>
    text <span style="color: #666666">=</span> BeautifulSoup(html, <span style="color: #BA2121">"html.parser"</span>)<span style="color: #666666">.</span>get_text()<span style="color: #666666">.</span>splitlines()
    c <span style="color: #666666">=</span> canvas<span style="color: #666666">.</span>Canvas(<span style="color: #008000">str</span>(path), pagesize<span style="color: #666666">=</span>letter)
    textobject <span style="color: #666666">=</span> c<span style="color: #666666">.</span>beginText(<span style="color: #666666">40</span>, <span style="color: #666666">750</span>)
    <span style="color: #008000; font-weight: bold">for</span> line <span style="color: #AA22FF; font-weight: bold">in</span> text:
        textobject<span style="color: #666666">.</span>textLine(line)
    c<span style="color: #666666">.</span>drawText(textobject)
    c<span style="color: #666666">.</span>save()
    <span style="color: #008000; font-weight: bold">return</span> <span style="color: #008000; font-weight: bold">True</span>
</code></pre>
<h3 id="main">main(argv: list[str] | None=None) -&gt; int</h3>
<p>The `main` function serves as the primary entry point for the documentation generation tool. It accepts command-line arguments to configure the documentation process, including project path, output format (HTML or PDF), title, and code scanning behavior. The function initializes a configuration object based on parsed arguments and sets up the output directory.

It reads existing documentation files from the project, processes them using an LLM-based summarization pipeline, and handles missing sections by optionally scanning code if needed. The tool supports chunking strategies for large inputs and caches responses to avoid redundant processing. If LLM summarization fails, a fallback mechanism infers sections from combined text.

The generated content is rendered into HTML or PDF format, with options to insert a link into an existing `index.html`. Evidence maps are saved alongside the output, and the tool supports resumable runs through caching and progress tracking. The function returns an integer indicating success or failure of the operation.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">main</span>(argv: <span style="color: #008000">list</span>[<span style="color: #008000">str</span>] <span style="color: #666666">|</span> <span style="color: #008000; font-weight: bold">None</span> <span style="color: #666666">=</span> <span style="color: #008000; font-weight: bold">None</span>) <span style="color: #666666">-&gt;</span> <span style="color: #008000">int</span>:
    parser <span style="color: #666666">=</span> argparse<span style="color: #666666">.</span>ArgumentParser(description<span style="color: #666666">=</span><span style="color: #BA2121">"Summarise project documentation"</span>)
    parser<span style="color: #666666">.</span>add_argument(<span style="color: #BA2121">"--path"</span>, default<span style="color: #666666">=</span><span style="color: #BA2121">"."</span>, help<span style="color: #666666">=</span><span style="color: #BA2121">"target project directory"</span>)
    parser<span style="color: #666666">.</span>add_argument(
        <span style="color: #BA2121">"--output-format"</span>, choices<span style="color: #666666">=</span>[<span style="color: #BA2121">"html"</span>, <span style="color: #BA2121">"pdf"</span>], default<span style="color: #666666">=</span><span style="color: #BA2121">"html"</span>,
        help<span style="color: #666666">=</span><span style="color: #BA2121">"output format for the summary"</span>,
    )
    parser<span style="color: #666666">.</span>add_argument(<span style="color: #BA2121">"--output"</span>, help<span style="color: #666666">=</span><span style="color: #BA2121">"Destination directory for generated summary"</span>)
    parser<span style="color: #666666">.</span>add_argument(<span style="color: #BA2121">"--title"</span>, default<span style="color: #666666">=</span><span style="color: #BA2121">"User Manual"</span>, help<span style="color: #666666">=</span><span style="color: #BA2121">"Title for the generated manual"</span>)
    parser<span style="color: #666666">.</span>add_argument(
        <span style="color: #BA2121">"--insert-into-index"</span>,
        action<span style="color: #666666">=</span><span style="color: #BA2121">"store_true"</span>,
        help<span style="color: #666666">=</span><span style="color: #BA2121">"Insert link to the manual into index.html in the output directory"</span>,
    )
    parser<span style="color: #666666">.</span>add_argument(
        <span style="color: #BA2121">"--chunking"</span>,
        choices<span style="color: #666666">=</span>[<span style="color: #BA2121">"auto"</span>, <span style="color: #BA2121">"manual"</span>, <span style="color: #BA2121">"none"</span>],
        default<span style="color: #666666">=</span><span style="color: #BA2121">"auto"</span>,
        help<span style="color: #666666">=</span><span style="color: #BA2121">"Chunking mode: auto (default) chunks only when needed; manual always chunks; none disables chunking."</span>,
    )
    parser<span style="color: #666666">.</span>add_argument(
        <span style="color: #BA2121">"--scan-code-if-needed"</span>,
        action<span style="color: #666666">=</span><span style="color: #BA2121">"store_true"</span>,
        help<span style="color: #666666">=</span><span style="color: #BA2121">"Scan project code if manual sections are missing after doc pass"</span>,
    )
    parser<span style="color: #666666">.</span>add_argument(<span style="color: #BA2121">"--no-code"</span>, action<span style="color: #666666">=</span><span style="color: #BA2121">"store_true"</span>, help<span style="color: #666666">=</span><span style="color: #BA2121">"Do not scan project code"</span>)
    parser<span style="color: #666666">.</span>add_argument(<span style="color: #BA2121">"--force-code"</span>, action<span style="color: #666666">=</span><span style="color: #BA2121">"store_true"</span>, help<span style="color: #666666">=</span><span style="color: #BA2121">"Always scan project code"</span>)
    parser<span style="color: #666666">.</span>add_argument(<span style="color: #BA2121">"--max-code-files"</span>, <span style="color: #008000">type</span><span style="color: #666666">=</span><span style="color: #008000">int</span>, default<span style="color: #666666">=12</span>, help<span style="color: #666666">=</span><span style="color: #BA2121">"Maximum number of code files to scan"</span>)
    parser<span style="color: #666666">.</span>add_argument(
        <span style="color: #BA2121">"--code-time-budget-seconds"</span>,
        <span style="color: #008000">type</span><span style="color: #666666">=</span><span style="color: #008000">int</span>,
        default<span style="color: #666666">=20</span>,
        help<span style="color: #666666">=</span><span style="color: #BA2121">"Time budget in seconds for scanning code"</span>,
    )
    parser<span style="color: #666666">.</span>add_argument(
        <span style="color: #BA2121">"--max-bytes-per-file"</span>,
        <span style="color: #008000">type</span><span style="color: #666666">=</span><span style="color: #008000">int</span>,
        default<span style="color: #666666">=200_000</span>,
        help<span style="color: #666666">=</span><span style="color: #BA2121">"Maximum bytes to read from each code file"</span>,
    )
    args <span style="color: #666666">=</span> parser<span style="color: #666666">.</span>parse_args(argv)

    config <span style="color: #666666">=</span> Config(
        path<span style="color: #666666">=</span>Path(args<span style="color: #666666">.</span>path),
        output_format<span style="color: #666666">=</span>args<span style="color: #666666">.</span>output_format,
        output<span style="color: #666666">=</span>Path(args<span style="color: #666666">.</span>output) <span style="color: #008000; font-weight: bold">if</span> args<span style="color: #666666">.</span>output <span style="color: #008000; font-weight: bold">else</span> <span style="color: #008000; font-weight: bold">None</span>,
        title<span style="color: #666666">=</span>args<span style="color: #666666">.</span>title,
        insert_into_index<span style="color: #666666">=</span>args<span style="color: #666666">.</span>insert_into_index,
        chunking<span style="color: #666666">=</span>args<span style="color: #666666">.</span>chunking,
        scan_code_if_needed<span style="color: #666666">=</span>args<span style="color: #666666">.</span>scan_code_if_needed,
        no_code<span style="color: #666666">=</span>args<span style="color: #666666">.</span>no_code,
        force_code<span style="color: #666666">=</span>args<span style="color: #666666">.</span>force_code,
        max_code_files<span style="color: #666666">=</span>args<span style="color: #666666">.</span>max_code_files,
        code_time_budget_seconds<span style="color: #666666">=</span>args<span style="color: #666666">.</span>code_time_budget_seconds,
        max_bytes_per_file<span style="color: #666666">=</span>args<span style="color: #666666">.</span>max_bytes_per_file,
    )

    target <span style="color: #666666">=</span> config<span style="color: #666666">.</span>path
    docs_index <span style="color: #666666">=</span> target <span style="color: #666666">/</span> <span style="color: #BA2121">"docs"</span> <span style="color: #666666">/</span> <span style="color: #BA2121">"index.html"</span>
    <span style="color: #008000; font-weight: bold">if</span> config<span style="color: #666666">.</span>output:
        out_dir <span style="color: #666666">=</span> config<span style="color: #666666">.</span>output
    <span style="color: #008000; font-weight: bold">else</span>:
        out_dir <span style="color: #666666">=</span> docs_index<span style="color: #666666">.</span>parent <span style="color: #008000; font-weight: bold">if</span> docs_index<span style="color: #666666">.</span>exists() <span style="color: #008000; font-weight: bold">else</span> target
    out_dir<span style="color: #666666">.</span>mkdir(parents<span style="color: #666666">=</span><span style="color: #008000; font-weight: bold">True</span>, exist_ok<span style="color: #666666">=</span><span style="color: #008000; font-weight: bold">True</span>)
    files <span style="color: #666666">=</span> collect_docs(target)
    doc_texts <span style="color: #666666">=</span> {f: extract_text(f) <span style="color: #008000; font-weight: bold">for</span> f <span style="color: #AA22FF; font-weight: bold">in</span> tqdm(files, desc<span style="color: #666666">=</span><span style="color: #BA2121">"Reading docs"</span>)}
    texts <span style="color: #666666">=</span> <span style="color: #008000">list</span>(doc_texts<span style="color: #666666">.</span>values())
    logging<span style="color: #666666">.</span>basicConfig(
        level<span style="color: #666666">=</span>logging<span style="color: #666666">.</span>DEBUG <span style="color: #008000; font-weight: bold">if</span> config<span style="color: #666666">.</span>chunking <span style="color: #666666">!=</span> <span style="color: #BA2121">"none"</span> <span style="color: #008000; font-weight: bold">else</span> logging<span style="color: #666666">.</span>INFO
    )

    logging<span style="color: #666666">.</span>info(<span style="color: #BA2121">"DOC PASS started with </span><span style="color: #A45A77; font-weight: bold">%d</span><span style="color: #BA2121"> files"</span>, <span style="color: #008000">len</span>(files))
    logging<span style="color: #666666">.</span>info(<span style="color: #BA2121">"Files: </span><span style="color: #A45A77; font-weight: bold">%s</span><span style="color: #BA2121">"</span>, <span style="color: #BA2121">", "</span><span style="color: #666666">.</span>join(<span style="color: #008000">str</span>(f) <span style="color: #008000; font-weight: bold">for</span> f <span style="color: #AA22FF; font-weight: bold">in</span> files))

    client <span style="color: #666666">=</span> LLMClient()
    cache <span style="color: #666666">=</span> ResponseCache(<span style="color: #008000">str</span>(out_dir <span style="color: #666666">/</span> <span style="color: #BA2121">"cache.json"</span>))
    evidence_map: <span style="color: #008000">dict</span>[<span style="color: #008000">str</span>, <span style="color: #008000">dict</span>[<span style="color: #008000">str</span>, <span style="color: #008000">object</span>]] <span style="color: #666666">=</span> {}
    <span style="color: #008000; font-weight: bold">try</span>:
        ping <span style="color: #666666">=</span> <span style="color: #008000">getattr</span>(client, <span style="color: #BA2121">"ping"</span>, <span style="color: #008000; font-weight: bold">None</span>)
        <span style="color: #008000; font-weight: bold">if</span> callable(ping):
            ping()
        response, file_sections, evidence_map <span style="color: #666666">=</span> llm_generate_manual(
            doc_texts, client, cache, config<span style="color: #666666">.</span>chunking
        )
        <span style="color: #008000; font-weight: bold">for</span> f <span style="color: #AA22FF; font-weight: bold">in</span> files:
            sections <span style="color: #666666">=</span> <span style="color: #008000">sorted</span>(file_sections<span style="color: #666666">.</span>get(f, <span style="color: #008000">set</span>()))
            logging<span style="color: #666666">.</span>info(
                <span style="color: #BA2121">"</span><span style="color: #A45A77; font-weight: bold">%s</span><span style="color: #BA2121"> contributes to sections: </span><span style="color: #A45A77; font-weight: bold">%s</span><span style="color: #BA2121">"</span>,
                f,
                <span style="color: #BA2121">", "</span><span style="color: #666666">.</span>join(sections) <span style="color: #008000; font-weight: bold">if</span> sections <span style="color: #008000; font-weight: bold">else</span> <span style="color: #BA2121">"none"</span>,
            )
        missing <span style="color: #666666">=</span> detect_placeholders(response)
        <span style="color: #008000; font-weight: bold">if</span> missing:
            logging<span style="color: #666666">.</span>info(<span style="color: #BA2121">"Pass 1 missing sections: </span><span style="color: #A45A77; font-weight: bold">%s</span><span style="color: #BA2121">"</span>, <span style="color: #BA2121">", "</span><span style="color: #666666">.</span>join(missing))
        <span style="color: #008000; font-weight: bold">else</span>:
            logging<span style="color: #666666">.</span>info(<span style="color: #BA2121">"Pass 1 complete: no sections missing"</span>)

        <span style="color: #008000; font-weight: bold">if</span> config<span style="color: #666666">.</span>no_code:
            logging<span style="color: #666666">.</span>info(<span style="color: #BA2121">"Code scan skipped: --no-code specified"</span>)
            should_scan <span style="color: #666666">=</span> <span style="color: #008000; font-weight: bold">False</span>
        <span style="color: #008000; font-weight: bold">elif</span> config<span style="color: #666666">.</span>force_code:
            logging<span style="color: #666666">.</span>info(<span style="color: #BA2121">"Code scan triggered: --force-code enabled"</span>)
            should_scan <span style="color: #666666">=</span> <span style="color: #008000; font-weight: bold">True</span>
        <span style="color: #008000; font-weight: bold">elif</span> config<span style="color: #666666">.</span>scan_code_if_needed:
            <span style="color: #008000; font-weight: bold">if</span> missing:
                logging<span style="color: #666666">.</span>info(
                    <span style="color: #BA2121">"Code scan triggered: missing sections </span><span style="color: #A45A77; font-weight: bold">%s</span><span style="color: #BA2121">"</span>,
                    <span style="color: #BA2121">", "</span><span style="color: #666666">.</span>join(missing),
                )
                should_scan <span style="color: #666666">=</span> <span style="color: #008000; font-weight: bold">True</span>
            <span style="color: #008000; font-weight: bold">else</span>:
                logging<span style="color: #666666">.</span>info(<span style="color: #BA2121">"Code scan skipped: placeholders resolved"</span>)
                should_scan <span style="color: #666666">=</span> <span style="color: #008000; font-weight: bold">False</span>
        <span style="color: #008000; font-weight: bold">else</span>:
            logging<span style="color: #666666">.</span>info(<span style="color: #BA2121">"Code scan skipped: no scan flags provided"</span>)
            should_scan <span style="color: #666666">=</span> <span style="color: #008000; font-weight: bold">False</span>

        <span style="color: #008000; font-weight: bold">if</span> should_scan:
            code_context <span style="color: #666666">=</span> scan_code(
                target,
                missing,
                max_files<span style="color: #666666">=</span>config<span style="color: #666666">.</span>max_code_files,
                time_budget<span style="color: #666666">=</span>config<span style="color: #666666">.</span>code_time_budget_seconds,
                max_bytes_per_file<span style="color: #666666">=</span>config<span style="color: #666666">.</span>max_bytes_per_file,
            )
            <span style="color: #008000; font-weight: bold">if</span> code_context <span style="color: #AA22FF; font-weight: bold">and</span> missing:
                response <span style="color: #666666">=</span> llm_fill_placeholders(
                    response, code_context, client, cache
                )
                missing <span style="color: #666666">=</span> detect_placeholders(response)
        logging<span style="color: #666666">.</span>info(
            <span style="color: #BA2121">"Pass 2 complete. Unresolved placeholders: </span><span style="color: #A45A77; font-weight: bold">%s</span><span style="color: #BA2121">"</span>,
            <span style="color: #BA2121">", "</span><span style="color: #666666">.</span>join(missing) <span style="color: #008000; font-weight: bold">if</span> missing <span style="color: #008000; font-weight: bold">else</span> <span style="color: #BA2121">"none"</span>,
        )
        <span style="color: #008000; font-weight: bold">for</span> token <span style="color: #AA22FF; font-weight: bold">in</span> SECTION_PLACEHOLDERS<span style="color: #666666">.</span>values():
            response <span style="color: #666666">=</span> response<span style="color: #666666">.</span>replace(token, <span style="color: #BA2121">""</span>)
        sections <span style="color: #666666">=</span> parse_manual(response, infer_missing<span style="color: #666666">=</span><span style="color: #008000; font-weight: bold">False</span>)
        validate_manual_references(sections, target, evidence_map)
    <span style="color: #008000; font-weight: bold">except</span> <span style="color: #CB3F38; font-weight: bold">Exception</span> <span style="color: #008000; font-weight: bold">as</span> exc:  <span style="color: #3D7B7B; font-style: italic"># pragma: no cover - network or attribute failure</span>
        <span style="color: #008000">print</span>(
            <span style="color: #BA2121">f"[INFO] LLM summarization failed; using fallback: </span><span style="color: #A45A77; font-weight: bold">{</span>exc<span style="color: #A45A77; font-weight: bold">}</span><span style="color: #BA2121">"</span>,
            file<span style="color: #666666">=</span>sys<span style="color: #666666">.</span>stderr,
        )
        combined <span style="color: #666666">=</span> <span style="color: #BA2121">"</span><span style="color: #AA5D1F; font-weight: bold">\n</span><span style="color: #BA2121">"</span><span style="color: #666666">.</span>join(t <span style="color: #008000; font-weight: bold">for</span> t <span style="color: #AA22FF; font-weight: bold">in</span> texts <span style="color: #008000; font-weight: bold">if</span> t)
        sections <span style="color: #666666">=</span> infer_sections(combined)
        evidence_map <span style="color: #666666">=</span> {}
        validate_manual_references(sections, target, evidence_map)
    html <span style="color: #666666">=</span> render_html(sections, config<span style="color: #666666">.</span>title, evidence_map)

    base_name <span style="color: #666666">=</span> slugify(config<span style="color: #666666">.</span>title)
    out_file <span style="color: #666666">=</span> out_dir <span style="color: #666666">/</span> <span style="color: #BA2121">f"</span><span style="color: #A45A77; font-weight: bold">{</span>base_name<span style="color: #A45A77; font-weight: bold">}</span><span style="color: #BA2121">.</span><span style="color: #A45A77; font-weight: bold">{</span><span style="color: #BA2121">'html'</span><span style="color: #bbbbbb"> </span><span style="color: #008000; font-weight: bold">if</span><span style="color: #bbbbbb"> </span>config<span style="color: #666666">.</span>output_format<span style="color: #bbbbbb"> </span><span style="color: #666666">==</span><span style="color: #bbbbbb"> </span><span style="color: #BA2121">'html'</span><span style="color: #bbbbbb"> </span><span style="color: #008000; font-weight: bold">else</span><span style="color: #bbbbbb"> </span><span style="color: #BA2121">'pdf'</span><span style="color: #A45A77; font-weight: bold">}</span><span style="color: #BA2121">"</span>
    <span style="color: #008000; font-weight: bold">if</span> config<span style="color: #666666">.</span>output_format <span style="color: #666666">==</span> <span style="color: #BA2121">"html"</span>:
        out_file<span style="color: #666666">.</span>write_text(html, encoding<span style="color: #666666">=</span><span style="color: #BA2121">"utf-8"</span>)
    <span style="color: #008000; font-weight: bold">else</span>:
        success <span style="color: #666666">=</span> write_pdf(html, out_file)
        <span style="color: #008000; font-weight: bold">if</span> <span style="color: #AA22FF; font-weight: bold">not</span> success:
            <span style="color: #008000">print</span>(<span style="color: #BA2121">"PDF generation requires the reportlab package."</span>)
            <span style="color: #008000; font-weight: bold">return</span> <span style="color: #666666">1</span>

    <span style="color: #008000; font-weight: bold">if</span> config<span style="color: #666666">.</span>insert_into_index:
        <span style="color: #008000; font-weight: bold">if</span> docs_index<span style="color: #666666">.</span>exists() <span style="color: #AA22FF; font-weight: bold">and</span> <span style="color: #AA22FF; font-weight: bold">not</span> config<span style="color: #666666">.</span>output:
            index_file <span style="color: #666666">=</span> docs_index
            inject_user_manual(index_file, config<span style="color: #666666">.</span>title, out_file<span style="color: #666666">.</span>name)
        <span style="color: #008000; font-weight: bold">else</span>:
            index_file <span style="color: #666666">=</span> out_dir <span style="color: #666666">/</span> <span style="color: #BA2121">"index.html"</span>
            <span style="color: #008000; font-weight: bold">if</span> index_file<span style="color: #666666">.</span>exists():
                <span style="color: #008000; font-weight: bold">if</span> <span style="color: #AA22FF; font-weight: bold">not</span> docs_index<span style="color: #666666">.</span>exists() <span style="color: #AA22FF; font-weight: bold">and</span> <span style="color: #AA22FF; font-weight: bold">not</span> config<span style="color: #666666">.</span>output:
                    docs_dir <span style="color: #666666">=</span> target <span style="color: #666666">/</span> <span style="color: #BA2121">"docs"</span>
                    docs_dir<span style="color: #666666">.</span>mkdir(parents<span style="color: #666666">=</span><span style="color: #008000; font-weight: bold">True</span>, exist_ok<span style="color: #666666">=</span><span style="color: #008000; font-weight: bold">True</span>)
                    new_path <span style="color: #666666">=</span> docs_dir <span style="color: #666666">/</span> out_file<span style="color: #666666">.</span>name
                    shutil<span style="color: #666666">.</span>move(<span style="color: #008000">str</span>(out_file), new_path)
                    out_file <span style="color: #666666">=</span> new_path
                    rel <span style="color: #666666">=</span> os<span style="color: #666666">.</span>path<span style="color: #666666">.</span>relpath(out_file, index_file<span style="color: #666666">.</span>parent)
                <span style="color: #008000; font-weight: bold">else</span>:
                    rel <span style="color: #666666">=</span> out_file<span style="color: #666666">.</span>name
                inject_user_manual(index_file, config<span style="color: #666666">.</span>title, rel)

    evidence_path <span style="color: #666666">=</span> out_file<span style="color: #666666">.</span>with_name(<span style="color: #BA2121">f"</span><span style="color: #A45A77; font-weight: bold">{</span>out_file<span style="color: #666666">.</span>stem<span style="color: #A45A77; font-weight: bold">}</span><span style="color: #BA2121">_evidence.json"</span>)
    evidence_path<span style="color: #666666">.</span>write_text(
        json<span style="color: #666666">.</span>dumps(evidence_map, ensure_ascii<span style="color: #666666">=</span><span style="color: #008000; font-weight: bold">False</span>, indent<span style="color: #666666">=2</span>), encoding<span style="color: #666666">=</span><span style="color: #BA2121">"utf-8"</span>
    )

    <span style="color: #008000; font-weight: bold">return</span> <span style="color: #666666">0</span>
</code></pre>
</div>
    </main>
<script src="static/toggle.js"></script>
</body>
</html>
