<!-- Generated by DocGen-LM -->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>parser_python</title>
    <link rel="stylesheet" href="static/style.css">
</head>
<body>
    <button id="sidebar-toggle">Menu</button>
    <div class="sidebar">
        <h2>Navigation</h2>
        <ul><li><a href="index.html"><strong>üè† Project Overview</strong></a></li><li><a href="cache.html">cache</a></li><li><a href="chunk_utils.html">chunk_utils</a></li><li><a href="docgenerator.html">docgenerator</a></li><li><a href="explaincode.html">explaincode</a></li><li><a href="gui_wrapper.html">gui_wrapper</a></li><li><a href="html_writer.html">html_writer</a></li><li><a href="llm_client.html">llm_client</a></li><li><a href="manual_utils.html">manual_utils</a></li><li><a href="parser_cpp.html">parser_cpp</a></li><li><a href="parser_java.html">parser_java</a></li><li><a href="parser_matlab.html">parser_matlab</a></li><li><a href="parser_python.html">parser_python</a></li><li><a href="retrofit_sidebar.html">retrofit_sidebar</a></li><li><a href="reviewer.html">reviewer</a></li><li><a href="sanitize_docs.html">sanitize_docs</a></li><li><a href="scanner.html">scanner</a></li><li><a href="setup.html">setup</a></li><li><a href="summarize_utils.html">summarize_utils</a></li><li><details><summary>tests</summary><ul><li><a href="test_cache.html">test_cache</a></li><li><a href="test_chunk_utils.html">test_chunk_utils</a></li><li><a href="test_docgenerator.html">test_docgenerator</a></li><li><a href="test_docgenerator_subclasses.html">test_docgenerator_subclasses</a></li><li><a href="test_explaincode.html">test_explaincode</a></li><li><a href="test_html_writer.html">test_html_writer</a></li><li><a href="test_integration.html">test_integration</a></li><li><a href="test_llm_client.html">test_llm_client</a></li><li><a href="test_manual_utils.html">test_manual_utils</a></li><li><a href="test_parser_cpp.html">test_parser_cpp</a></li><li><a href="test_parser_java.html">test_parser_java</a></li><li><a href="test_parser_matlab.html">test_parser_matlab</a></li><li><a href="test_parser_python.html">test_parser_python</a></li><li><a href="test_resume_progress.html">test_resume_progress</a></li><li><a href="test_retrofit_sidebar.html">test_retrofit_sidebar</a></li><li><a href="test_reviewer.html">test_reviewer</a></li><li><a href="test_sanitize_docs.html">test_sanitize_docs</a></li><li><a href="test_scanner.html">test_scanner</a></li></ul></details></li></ul>
    </div>
    <div class="content">
        <h1>parser_python</h1>
        <p>Module defines a parser for Python files that extracts structured information using the `ast` module. It processes classes and functions, capturing their signatures, docstrings, and source code segments. The parser supports nested structures, including methods within classes and subfunctions within functions. It formats function arguments and handles default values, annotations, and keyword-only parameters. The main entry point is `parse_python_file`, which reads a file and returns a dictionary containing module-level information, classes, and functions. Helper functions format argument lists and function signatures, while recursive parsing handles nested definitions.</p>
<h2>Functions</h2>
<h3 id="_format_arg">_format_arg(arg: ast.arg) -&gt; str</h3>
<p>The function `_format_arg` takes an `ast.arg` object and returns a string representation of the argument name, optionally including its type annotation if present. If the argument has an annotation, it appends the annotation to the argument name in the format `arg_name: annotation`. If no annotation exists, it simply returns the argument name.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">_format_arg</span>(arg: ast<span style="color: #666666">.</span>arg) <span style="color: #666666">-&gt;</span> <span style="color: #008000">str</span>:
<span style="color: #bbbbbb">    </span><span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;Return ``arg`` formatted with its annotation if present.&quot;&quot;&quot;</span>
    text <span style="color: #666666">=</span> arg<span style="color: #666666">.</span>arg
    <span style="color: #008000; font-weight: bold">if</span> arg<span style="color: #666666">.</span>annotation <span style="color: #AA22FF; font-weight: bold">is</span> <span style="color: #AA22FF; font-weight: bold">not</span> <span style="color: #008000; font-weight: bold">None</span>:
        text <span style="color: #666666">+=</span> <span style="color: #BA2121">f&quot;: </span><span style="color: #A45A77; font-weight: bold">{</span>ast<span style="color: #666666">.</span>unparse(arg<span style="color: #666666">.</span>annotation)<span style="color: #A45A77; font-weight: bold">}</span><span style="color: #BA2121">&quot;</span>
    <span style="color: #008000; font-weight: bold">return</span> text
</code></pre>
<h3 id="_format_arguments">_format_arguments(args: ast.arguments) -&gt; str</h3>
<p>The function `_format_arguments` generates a string representation of Python function arguments defined in an abstract syntax tree (AST). It processes positional-only arguments, regular arguments, default values, *args, **kwargs, and keyword-only arguments, formatting them according to Python syntax. The function handles argument defaults by unwrapping them using `ast.unparse`, and ensures proper separation with commas. It also appends a forward slash `/` after positional-only arguments and a `*` before keyword-only arguments when needed. The result is a comma-separated string that reflects the signature of a Python function&#x27;s parameter list.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">_format_arguments</span>(args: ast<span style="color: #666666">.</span>arguments) <span style="color: #666666">-&gt;</span> <span style="color: #008000">str</span>:
<span style="color: #bbbbbb">    </span><span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;Return a string representation of ``args``.&quot;&quot;&quot;</span>

    parts: List[<span style="color: #008000">str</span>] <span style="color: #666666">=</span> []

    pos_only <span style="color: #666666">=</span> args<span style="color: #666666">.</span>posonlyargs
    defaults <span style="color: #666666">=</span> [<span style="color: #008000; font-weight: bold">None</span>] <span style="color: #666666">*</span> (<span style="color: #008000">len</span>(pos_only <span style="color: #666666">+</span> args<span style="color: #666666">.</span>args) <span style="color: #666666">-</span> <span style="color: #008000">len</span>(args<span style="color: #666666">.</span>defaults)) <span style="color: #666666">+</span> <span style="color: #008000">list</span>(args<span style="color: #666666">.</span>defaults)
    default_iter <span style="color: #666666">=</span> <span style="color: #008000">iter</span>(defaults)

    <span style="color: #3D7B7B; font-style: italic"># positional only</span>
    <span style="color: #008000; font-weight: bold">for</span> arg <span style="color: #AA22FF; font-weight: bold">in</span> pos_only:
        text <span style="color: #666666">=</span> _format_arg(arg)
        default <span style="color: #666666">=</span> <span style="color: #008000">next</span>(default_iter)
        <span style="color: #008000; font-weight: bold">if</span> default <span style="color: #AA22FF; font-weight: bold">is</span> <span style="color: #AA22FF; font-weight: bold">not</span> <span style="color: #008000; font-weight: bold">None</span>:
            text <span style="color: #666666">+=</span> <span style="color: #BA2121">f&quot;=</span><span style="color: #A45A77; font-weight: bold">{</span>ast<span style="color: #666666">.</span>unparse(default)<span style="color: #A45A77; font-weight: bold">}</span><span style="color: #BA2121">&quot;</span>
        parts<span style="color: #666666">.</span>append(text)
    <span style="color: #008000; font-weight: bold">if</span> pos_only:
        parts[<span style="color: #666666">-1</span>] <span style="color: #666666">+=</span> <span style="color: #BA2121">&quot;/&quot;</span>

    <span style="color: #3D7B7B; font-style: italic"># regular arguments</span>
    <span style="color: #008000; font-weight: bold">for</span> arg <span style="color: #AA22FF; font-weight: bold">in</span> args<span style="color: #666666">.</span>args:
        text <span style="color: #666666">=</span> _format_arg(arg)
        default <span style="color: #666666">=</span> <span style="color: #008000">next</span>(default_iter)
        <span style="color: #008000; font-weight: bold">if</span> default <span style="color: #AA22FF; font-weight: bold">is</span> <span style="color: #AA22FF; font-weight: bold">not</span> <span style="color: #008000; font-weight: bold">None</span>:
            text <span style="color: #666666">+=</span> <span style="color: #BA2121">f&quot;=</span><span style="color: #A45A77; font-weight: bold">{</span>ast<span style="color: #666666">.</span>unparse(default)<span style="color: #A45A77; font-weight: bold">}</span><span style="color: #BA2121">&quot;</span>
        parts<span style="color: #666666">.</span>append(text)

    <span style="color: #3D7B7B; font-style: italic"># var positional</span>
    <span style="color: #008000; font-weight: bold">if</span> args<span style="color: #666666">.</span>vararg:
        parts<span style="color: #666666">.</span>append(<span style="color: #BA2121">&quot;*&quot;</span> <span style="color: #666666">+</span> _format_arg(args<span style="color: #666666">.</span>vararg))
    <span style="color: #008000; font-weight: bold">elif</span> args<span style="color: #666666">.</span>kwonlyargs:
        parts<span style="color: #666666">.</span>append(<span style="color: #BA2121">&quot;*&quot;</span>)

    <span style="color: #3D7B7B; font-style: italic"># keyword only</span>
    <span style="color: #008000; font-weight: bold">for</span> arg, default <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">zip</span>(args<span style="color: #666666">.</span>kwonlyargs, args<span style="color: #666666">.</span>kw_defaults):
        text <span style="color: #666666">=</span> _format_arg(arg)
        <span style="color: #008000; font-weight: bold">if</span> default <span style="color: #AA22FF; font-weight: bold">is</span> <span style="color: #AA22FF; font-weight: bold">not</span> <span style="color: #008000; font-weight: bold">None</span>:
            text <span style="color: #666666">+=</span> <span style="color: #BA2121">f&quot;=</span><span style="color: #A45A77; font-weight: bold">{</span>ast<span style="color: #666666">.</span>unparse(default)<span style="color: #A45A77; font-weight: bold">}</span><span style="color: #BA2121">&quot;</span>
        parts<span style="color: #666666">.</span>append(text)

    <span style="color: #3D7B7B; font-style: italic"># var keyword</span>
    <span style="color: #008000; font-weight: bold">if</span> args<span style="color: #666666">.</span>kwarg:
        parts<span style="color: #666666">.</span>append(<span style="color: #BA2121">&quot;**&quot;</span> <span style="color: #666666">+</span> _format_arg(args<span style="color: #666666">.</span>kwarg))

    <span style="color: #008000; font-weight: bold">return</span> <span style="color: #BA2121">&quot;, &quot;</span><span style="color: #666666">.</span>join(parts)
</code></pre>
<h3 id="_format_signature">_format_signature(func: ast.FunctionDef | ast.AsyncFunctionDef) -&gt; str</h3>
<p>The function `_format_signature` generates a string representation of a function&#x27;s signature from an abstract syntax tree (AST) node. It takes a function definition node (`func`) of type `ast.FunctionDef` or `ast.AsyncFunctionDef` and returns a formatted string that includes the function name, its parameters, and optional return type annotation. The parameters are processed using a helper function `_format_arguments`, and if the function has a return type annotation, it is appended to the signature with an &quot; -&gt; &quot; prefix.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">_format_signature</span>(func: ast<span style="color: #666666">.</span>FunctionDef <span style="color: #666666">|</span> ast<span style="color: #666666">.</span>AsyncFunctionDef) <span style="color: #666666">-&gt;</span> <span style="color: #008000">str</span>:
<span style="color: #bbbbbb">    </span><span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;Return a string signature for ``func``.&quot;&quot;&quot;</span>

    params <span style="color: #666666">=</span> _format_arguments(func<span style="color: #666666">.</span>args)
    result <span style="color: #666666">=</span> <span style="color: #BA2121">f&quot;</span><span style="color: #A45A77; font-weight: bold">{</span>func<span style="color: #666666">.</span>name<span style="color: #A45A77; font-weight: bold">}</span><span style="color: #BA2121">(</span><span style="color: #A45A77; font-weight: bold">{</span>params<span style="color: #A45A77; font-weight: bold">}</span><span style="color: #BA2121">)&quot;</span>
    <span style="color: #008000; font-weight: bold">if</span> func<span style="color: #666666">.</span>returns <span style="color: #AA22FF; font-weight: bold">is</span> <span style="color: #AA22FF; font-weight: bold">not</span> <span style="color: #008000; font-weight: bold">None</span>:
        result <span style="color: #666666">+=</span> <span style="color: #BA2121">f&quot; -&gt; </span><span style="color: #A45A77; font-weight: bold">{</span>ast<span style="color: #666666">.</span>unparse(func<span style="color: #666666">.</span>returns)<span style="color: #A45A77; font-weight: bold">}</span><span style="color: #BA2121">&quot;</span>
    <span style="color: #008000; font-weight: bold">return</span> result
</code></pre>
<h3 id="_parse_classes">_parse_classes(nodes: List[ast.AST], source: str) -&gt; List[Dict[str, Any]]</h3>
<p>The function `_parse_classes` recursively extracts all `ClassDef` nodes from a list of AST nodes and returns a list of dictionaries containing parsed class information. It processes each node in the input list, and if the node is a class definition, it calls `parse_class` to parse the class. If the node is a function definition, it recursively parses the function&#x27;s body for nested class definitions. The function supports both synchronous and asynchronous function definitions.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">_parse_classes</span>(nodes: List[ast<span style="color: #666666">.</span>AST], source: <span style="color: #008000">str</span>) <span style="color: #666666">-&gt;</span> List[Dict[<span style="color: #008000">str</span>, Any]]:
<span style="color: #bbbbbb">    </span><span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;Recursively parse all ``ClassDef`` nodes within ``nodes``.&quot;&quot;&quot;</span>

    classes: List[Dict[<span style="color: #008000">str</span>, Any]] <span style="color: #666666">=</span> []
    <span style="color: #008000; font-weight: bold">for</span> item <span style="color: #AA22FF; font-weight: bold">in</span> nodes:
        <span style="color: #008000; font-weight: bold">if</span> <span style="color: #008000">isinstance</span>(item, ast<span style="color: #666666">.</span>ClassDef):
            classes<span style="color: #666666">.</span>append(parse_class(item, source))
        <span style="color: #008000; font-weight: bold">elif</span> <span style="color: #008000">isinstance</span>(item, (ast<span style="color: #666666">.</span>FunctionDef, ast<span style="color: #666666">.</span>AsyncFunctionDef)):
            classes<span style="color: #666666">.</span>extend(_parse_classes(item<span style="color: #666666">.</span>body, source))
    <span style="color: #008000; font-weight: bold">return</span> classes
</code></pre>
<h3 id="parse_classes">parse_classes(node: ast.AST, source: str) -&gt; List[Dict[str, Any]]</h3>
<p>The function `parse_classes` is a public wrapper that extracts class definitions from an abstract syntax tree (AST) node. It takes an AST node and the corresponding source code as input, retrieves the body of the node, and passes it to the internal `_parse_classes` function for processing. The result is a list of dictionaries containing information about the parsed classes.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">parse_classes</span>(node: ast<span style="color: #666666">.</span>AST, source: <span style="color: #008000">str</span>) <span style="color: #666666">-&gt;</span> List[Dict[<span style="color: #008000">str</span>, Any]]:
<span style="color: #bbbbbb">    </span><span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;Public wrapper for ``_parse_classes`` using ``node.body``.&quot;&quot;&quot;</span>

    <span style="color: #008000; font-weight: bold">return</span> _parse_classes(<span style="color: #008000">getattr</span>(node, <span style="color: #BA2121">&quot;body&quot;</span>, []), source)
</code></pre>
<h3 id="parse_function">parse_function(node: ast.FunctionDef | ast.AsyncFunctionDef, source: str) -&gt; Dict[str, Any]</h3>
<p>The function `parse_function` takes an AST node representing a function or asynchronous function and the source code as input, and returns a dictionary containing information about the function. The dictionary includes the function&#x27;s name, signature, return type, docstring, source code segment, and lists of nested functions and classes. It recursively processes the function body to identify and include any nested functions and classes.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">parse_function</span>(node: ast<span style="color: #666666">.</span>FunctionDef <span style="color: #666666">|</span> ast<span style="color: #666666">.</span>AsyncFunctionDef, source: <span style="color: #008000">str</span>) <span style="color: #666666">-&gt;</span> Dict[<span style="color: #008000">str</span>, Any]:
<span style="color: #bbbbbb">    </span><span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;Return a dictionary describing ``node`` and any nested definitions.&quot;&quot;&quot;</span>

    func_info: Dict[<span style="color: #008000">str</span>, Any] <span style="color: #666666">=</span> {
        <span style="color: #BA2121">&quot;name&quot;</span>: node<span style="color: #666666">.</span>name,
        <span style="color: #BA2121">&quot;signature&quot;</span>: _format_signature(node),
        <span style="color: #BA2121">&quot;returns&quot;</span>: ast<span style="color: #666666">.</span>unparse(node<span style="color: #666666">.</span>returns) <span style="color: #008000; font-weight: bold">if</span> node<span style="color: #666666">.</span>returns <span style="color: #008000; font-weight: bold">else</span> <span style="color: #008000; font-weight: bold">None</span>,
        <span style="color: #BA2121">&quot;docstring&quot;</span>: ast<span style="color: #666666">.</span>get_docstring(node),
        <span style="color: #BA2121">&quot;source&quot;</span>: ast<span style="color: #666666">.</span>get_source_segment(source, node),
        <span style="color: #BA2121">&quot;subfunctions&quot;</span>: [],
        <span style="color: #BA2121">&quot;subclasses&quot;</span>: [],
    }

    <span style="color: #008000; font-weight: bold">for</span> item <span style="color: #AA22FF; font-weight: bold">in</span> node<span style="color: #666666">.</span>body:
        <span style="color: #008000; font-weight: bold">if</span> <span style="color: #008000">isinstance</span>(item, (ast<span style="color: #666666">.</span>FunctionDef, ast<span style="color: #666666">.</span>AsyncFunctionDef)):
            func_info[<span style="color: #BA2121">&quot;subfunctions&quot;</span>]<span style="color: #666666">.</span>append(parse_function(item, source))

    func_info[<span style="color: #BA2121">&quot;subclasses&quot;</span>] <span style="color: #666666">=</span> _parse_classes(node<span style="color: #666666">.</span>body, source)

    <span style="color: #008000; font-weight: bold">return</span> func_info
</code></pre>
<h3 id="parse_class">parse_class(node: ast.ClassDef, source: str) -&gt; Dict[str, Any]</h3>
<p>The function `parse_class` takes an AST node representing a class and the source code as input, and returns a dictionary containing information about the class. The dictionary includes the class name, its docstring, a list of methods defined within the class (parsed using `parse_function`), a list of nested subclasses (parsed using `_parse_classes`), and the source code segment corresponding to the class definition. The function processes the body of the class node, identifying function definitions and subclass definitions, and organizes them into the returned dictionary structure.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">parse_class</span>(node: ast<span style="color: #666666">.</span>ClassDef, source: <span style="color: #008000">str</span>) <span style="color: #666666">-&gt;</span> Dict[<span style="color: #008000">str</span>, Any]:
<span style="color: #bbbbbb">    </span><span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;Return a dictionary describing ``node`` and any nested classes.&quot;&quot;&quot;</span>

    cls_info: Dict[<span style="color: #008000">str</span>, Any] <span style="color: #666666">=</span> {
        <span style="color: #BA2121">&quot;name&quot;</span>: node<span style="color: #666666">.</span>name,
        <span style="color: #BA2121">&quot;docstring&quot;</span>: ast<span style="color: #666666">.</span>get_docstring(node),
        <span style="color: #BA2121">&quot;methods&quot;</span>: [],
        <span style="color: #BA2121">&quot;subclasses&quot;</span>: [],
        <span style="color: #BA2121">&quot;source&quot;</span>: ast<span style="color: #666666">.</span>get_source_segment(source, node),
    }

    <span style="color: #008000; font-weight: bold">for</span> item <span style="color: #AA22FF; font-weight: bold">in</span> node<span style="color: #666666">.</span>body:
        <span style="color: #008000; font-weight: bold">if</span> <span style="color: #008000">isinstance</span>(item, (ast<span style="color: #666666">.</span>FunctionDef, ast<span style="color: #666666">.</span>AsyncFunctionDef)):
            cls_info[<span style="color: #BA2121">&quot;methods&quot;</span>]<span style="color: #666666">.</span>append(parse_function(item, source))

    cls_info[<span style="color: #BA2121">&quot;subclasses&quot;</span>] <span style="color: #666666">=</span> _parse_classes(node<span style="color: #666666">.</span>body, source)

    <span style="color: #008000; font-weight: bold">return</span> cls_info
</code></pre>
<h3 id="parse_python_file">parse_python_file(path: str) -&gt; Dict[str, Any]</h3>
<p>The function `parse_python_file` takes a file path as input and parses the Python source code into a structured dictionary. It reads the file content, uses the `ast` module to parse the code into an abstract syntax tree, and extracts the module&#x27;s docstring along with information about classes and functions defined at the top level of the module. For each class definition, it calls `parse_class` to extract details, and for each function or async function definition, it calls `parse_function`. The result is a dictionary containing the module docstring, a list of parsed classes, and a list of parsed functions.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">parse_python_file</span>(path: <span style="color: #008000">str</span>) <span style="color: #666666">-&gt;</span> Dict[<span style="color: #008000">str</span>, Any]:
<span style="color: #bbbbbb">    </span><span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;Parse a Python source file and return structured information.</span>

<span style="color: #BA2121; font-style: italic">    Parameters</span>
<span style="color: #BA2121; font-style: italic">    ----------</span>
<span style="color: #BA2121; font-style: italic">    path:</span>
<span style="color: #BA2121; font-style: italic">        File to parse.</span>

<span style="color: #BA2121; font-style: italic">    Returns</span>
<span style="color: #BA2121; font-style: italic">    -------</span>
<span style="color: #BA2121; font-style: italic">    dict</span>
<span style="color: #BA2121; font-style: italic">        Dictionary containing module docstring, classes, and functions.</span>
<span style="color: #BA2121; font-style: italic">    &quot;&quot;&quot;</span>

    source <span style="color: #666666">=</span> Path(path)<span style="color: #666666">.</span>read_text(encoding<span style="color: #666666">=</span><span style="color: #BA2121">&quot;utf-8&quot;</span>)
    module <span style="color: #666666">=</span> ast<span style="color: #666666">.</span>parse(source)

    parsed: Dict[<span style="color: #008000">str</span>, Any] <span style="color: #666666">=</span> {
        <span style="color: #BA2121">&quot;module_docstring&quot;</span>: ast<span style="color: #666666">.</span>get_docstring(module),
        <span style="color: #BA2121">&quot;classes&quot;</span>: [],
        <span style="color: #BA2121">&quot;functions&quot;</span>: [],
    }

    <span style="color: #008000; font-weight: bold">for</span> node <span style="color: #AA22FF; font-weight: bold">in</span> module<span style="color: #666666">.</span>body:
        <span style="color: #008000; font-weight: bold">if</span> <span style="color: #008000">isinstance</span>(node, ast<span style="color: #666666">.</span>ClassDef):
            parsed[<span style="color: #BA2121">&quot;classes&quot;</span>]<span style="color: #666666">.</span>append(parse_class(node, source))
        <span style="color: #008000; font-weight: bold">elif</span> <span style="color: #008000">isinstance</span>(node, (ast<span style="color: #666666">.</span>FunctionDef, ast<span style="color: #666666">.</span>AsyncFunctionDef)):
            parsed[<span style="color: #BA2121">&quot;functions&quot;</span>]<span style="color: #666666">.</span>append(parse_function(node, source))

    <span style="color: #008000; font-weight: bold">return</span> parsed
</code></pre>
    </div>
    <script src="static/toggle.js"></script>
</body>
</html>
