<!-- Generated by DocGen-LM -->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>reviewer</title>
    <link rel="stylesheet" href="static/style.css">
</head>
<body>
    <button id="sidebar-toggle">Menu</button>
    <div class="sidebar">
        <h2>Navigation</h2>
        <ul>
        <li><a href="index.html"><strong>üè† Project Overview</strong></a></li>
<li><a href="cache.html">cache</a></li>
<li><a href="chunk_utils.html">chunk_utils</a></li>
<li><a href="docgenerator.html">docgenerator</a></li>
<li><a href="explaincode.html">explaincode</a></li>
<li><a href="gui_wrapper.html">gui_wrapper</a></li>
<li><a href="html_writer.html">html_writer</a></li>
<li><a href="llm_client.html">llm_client</a></li>
<li><a href="manual_utils.html">manual_utils</a></li>
<li><a href="parser_cpp.html">parser_cpp</a></li>
<li><a href="parser_java.html">parser_java</a></li>
<li><a href="parser_matlab.html">parser_matlab</a></li>
<li><a href="parser_python.html">parser_python</a></li>
<li><a href="reviewer.html">reviewer</a></li>
<li><a href="scanner.html">scanner</a></li>
<li><a href="setup.html">setup</a></li>
<li><a href="summarize_utils.html">summarize_utils</a></li>
<li><a href="test_cache.html">test_cache</a></li>
<li><a href="test_chunk_utils.html">test_chunk_utils</a></li>
<li><a href="test_docgenerator.html">test_docgenerator</a></li>
<li><a href="test_docgenerator_subclasses.html">test_docgenerator_subclasses</a></li>
<li><a href="test_explaincode.html">test_explaincode</a></li>
<li><a href="test_html_writer.html">test_html_writer</a></li>
<li><a href="test_integration.html">test_integration</a></li>
<li><a href="test_llm_client.html">test_llm_client</a></li>
<li><a href="test_manual_utils.html">test_manual_utils</a></li>
<li><a href="test_parser_cpp.html">test_parser_cpp</a></li>
<li><a href="test_parser_java.html">test_parser_java</a></li>
<li><a href="test_parser_matlab.html">test_parser_matlab</a></li>
<li><a href="test_parser_python.html">test_parser_python</a></li>
<li><a href="test_reviewer.html">test_reviewer</a></li>
<li><a href="test_scanner.html">test_scanner</a></li>
        </ul>
    </div>
    <div class="content">
        <h1>reviewer</h1>
        <p>This module provides a tool to review HTML documentation generated by DocGen-LM. It checks for assistant-like phrases, contradictions, and hallucinations in the HTML content. The tool can also automatically fix some issues by sanitizing paragraphs using a `sanitize_summary` function from the `llm_client` library.</p>
<h2>Functions</h2>
<h3 id="_is_generated_html">_is_generated_html(text: str) -&gt; bool</h3>
<p>The function `_is_generated_html` checks whether a given string `text` appears to be output from DocGen-LM, a tool for generating static HTML documentation. It returns `True` if the text contains specific markers indicating it was generated by DocGen-LM: the phrase &quot;Generated by DocGen-LM&quot;, an `&lt;h1&gt;` heading with the title &quot;Project Documentation&quot;, and headings for classes and methods prefixed with `&lt;h2&gt;` and `&lt;h3&gt;`, respectively.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">_is_generated_html</span>(text: <span style="color: #008000">str</span>) <span style="color: #666666">-&gt;</span> <span style="color: #008000">bool</span>:
<span style="color: #bbbbbb">    </span><span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;Return True if *text* looks like DocGen-LM output.&quot;&quot;&quot;</span>
    <span style="color: #008000; font-weight: bold">if</span> <span style="color: #BA2121">&quot;Generated by DocGen-LM&quot;</span> <span style="color: #AA22FF; font-weight: bold">in</span> text:
        <span style="color: #008000; font-weight: bold">return</span> <span style="color: #008000; font-weight: bold">True</span>
    <span style="color: #008000; font-weight: bold">if</span> <span style="color: #BA2121">&quot;&lt;h1&gt;Project Documentation&lt;/h1&gt;&quot;</span> <span style="color: #AA22FF; font-weight: bold">in</span> text:
        <span style="color: #008000; font-weight: bold">return</span> <span style="color: #008000; font-weight: bold">True</span>
    <span style="color: #008000; font-weight: bold">if</span> re<span style="color: #666666">.</span>search(<span style="color: #BA2121">r&quot;&lt;h2[^&gt;]*&gt;Class:&quot;</span>, text):
        <span style="color: #008000; font-weight: bold">return</span> <span style="color: #008000; font-weight: bold">True</span>
    <span style="color: #008000; font-weight: bold">if</span> re<span style="color: #666666">.</span>search(<span style="color: #BA2121">r&quot;&lt;h3[^&gt;]*&gt;Method:&quot;</span>, text):
        <span style="color: #008000; font-weight: bold">return</span> <span style="color: #008000; font-weight: bold">True</span>
    <span style="color: #008000; font-weight: bold">return</span> <span style="color: #008000; font-weight: bold">False</span>
</code></pre>
<h3 id="_find_line_number">_find_line_number(html: str, phrase: str) -&gt; int</h3>
<p>The function `_find_line_number` searches for a specific phrase within an HTML string and returns the line number where the phrase is found. If the phrase is not found, it returns -1. The search is case-insensitive.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">_find_line_number</span>(html: <span style="color: #008000">str</span>, phrase: <span style="color: #008000">str</span>) <span style="color: #666666">-&gt;</span> <span style="color: #008000">int</span>:
    <span style="color: #008000; font-weight: bold">for</span> i, line <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">enumerate</span>(html<span style="color: #666666">.</span>splitlines(), <span style="color: #666666">1</span>):
        <span style="color: #008000; font-weight: bold">if</span> phrase<span style="color: #666666">.</span>lower() <span style="color: #AA22FF; font-weight: bold">in</span> line<span style="color: #666666">.</span>lower():
            <span style="color: #008000; font-weight: bold">return</span> i
    <span style="color: #008000; font-weight: bold">return</span> <span style="color: #666666">-1</span>
</code></pre>
<h3 id="_extract_tags">_extract_tags(html: str, tag: str) -&gt; List[str]</h3>
<p>The function `_extract_tags` is designed to extract all occurrences of a specified HTML tag and its content from a given HTML string. It uses the `re.findall` method with a regular expression pattern that matches the opening and closing tags along with their contents. The pattern is case-insensitive and allows for any characters (including newlines) within the tags, as indicated by the `re.DOTALL` flag. The function returns a list of strings, each representing the content inside an instance of the specified tag.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">_extract_tags</span>(html: <span style="color: #008000">str</span>, tag: <span style="color: #008000">str</span>) <span style="color: #666666">-&gt;</span> List[<span style="color: #008000">str</span>]:
    pattern <span style="color: #666666">=</span> <span style="color: #BA2121">rf&quot;&lt;</span><span style="color: #A45A77; font-weight: bold">{</span>tag<span style="color: #A45A77; font-weight: bold">}</span><span style="color: #BA2121">[^&gt;]*&gt;(.*?)&lt;/</span><span style="color: #A45A77; font-weight: bold">{</span>tag<span style="color: #A45A77; font-weight: bold">}</span><span style="color: #BA2121">&gt;&quot;</span>
    <span style="color: #008000; font-weight: bold">return</span> re<span style="color: #666666">.</span>findall(pattern, html, flags<span style="color: #666666">=</span>re<span style="color: #666666">.</span>DOTALL <span style="color: #666666">|</span> re<span style="color: #666666">.</span>IGNORECASE)
</code></pre>
<h3 id="_strip_html">_strip_html(text: str) -&gt; str</h3>
<p>The function `_strip_html` takes a string `text` as input and returns a new string with all HTML tags removed. It uses the `re.sub` function from the `re` module to substitute any sequence of characters that match the regular expression `&lt;[^&gt;]+&gt;` (which represents an HTML tag) with an empty string, effectively removing them from the input text.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">_strip_html</span>(text: <span style="color: #008000">str</span>) <span style="color: #666666">-&gt;</span> <span style="color: #008000">str</span>:
    <span style="color: #008000; font-weight: bold">return</span> re<span style="color: #666666">.</span>sub(<span style="color: #BA2121">r&quot;&lt;[^&gt;]+&gt;&quot;</span>, <span style="color: #BA2121">&quot;&quot;</span>, text)
</code></pre>
<h3 id="check_assistant_phrasing">check_assistant_phrasing(html: str) -&gt; List[str]</h3>
<p>The function `check_assistant_phrasing` analyzes an HTML string to identify and list occurrences of assistant-like phrases. It extracts paragraph tags from the HTML using `_extract_tags`, strips HTML from the text, converts it to lowercase for case-insensitive comparison, and checks if any predefined assistant phrases are present. If a phrase is found, it appends a formatted string with the phrase and its line number in the original HTML to a list of findings. The function returns this list of findings.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">check_assistant_phrasing</span>(html: <span style="color: #008000">str</span>) <span style="color: #666666">-&gt;</span> List[<span style="color: #008000">str</span>]:
<span style="color: #bbbbbb">    </span><span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;Return list of assistant-like phrases found.&quot;&quot;&quot;</span>
    findings: List[<span style="color: #008000">str</span>] <span style="color: #666666">=</span> []
    <span style="color: #008000; font-weight: bold">for</span> raw <span style="color: #AA22FF; font-weight: bold">in</span> _extract_tags(html, <span style="color: #BA2121">&quot;p&quot;</span>):
        text <span style="color: #666666">=</span> _strip_html(raw)<span style="color: #666666">.</span>strip()
        lower <span style="color: #666666">=</span> text<span style="color: #666666">.</span>lower()
        <span style="color: #008000; font-weight: bold">for</span> phrase <span style="color: #AA22FF; font-weight: bold">in</span> ASSISTANT_PHRASES:
            <span style="color: #008000; font-weight: bold">if</span> phrase <span style="color: #AA22FF; font-weight: bold">in</span> lower:
                line_no <span style="color: #666666">=</span> _find_line_number(html, text)
                findings<span style="color: #666666">.</span>append(<span style="color: #BA2121">f&#39;&quot;</span><span style="color: #A45A77; font-weight: bold">{</span>text<span style="color: #A45A77; font-weight: bold">}</span><span style="color: #BA2121">&quot; (line </span><span style="color: #A45A77; font-weight: bold">{</span>line_no<span style="color: #A45A77; font-weight: bold">}</span><span style="color: #BA2121">)&#39;</span>)
                <span style="color: #008000; font-weight: bold">break</span>
    <span style="color: #008000; font-weight: bold">return</span> findings
</code></pre>
<h3 id="check_contradictions">check_contradictions(html: str) -&gt; List[str]</h3>
<p>The `check_contradictions` function analyzes HTML documentation to identify contradictions between the text and the structure of the document. It returns a list of contradiction descriptions.

1. **Input**: The function takes a single argument, `html`, which is a string containing HTML content.
2. **Output**: It returns a list of strings, where each string describes a contradiction found in the HTML.
3. **Process**:
- Extracts all paragraph (`&lt;p&gt;`) tags from the HTML and converts their text to lowercase.
- Joins the first two paragraphs into a summary text.
- Extracts headers (`&lt;h3&gt;`) that start with &quot;Method:&quot; and those that do not, categorizing them as methods and functions, respectively.
- Extracts headers (`&lt;h2&gt;`) that start with &quot;Class:&quot;, categorizing them as classes.
- Checks for contradictions:
- If the summary text states &quot;no methods&quot; but methods are found, it adds a contradiction description to the list.
- If the summary text states &quot;no functions&quot; but functions are found, it adds a contradiction description to the list.
- If the summary text states &quot;no classes&quot; but classes are found, it adds a contradiction description to the list.
- Returns the list of contradictions.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">check_contradictions</span>(html: <span style="color: #008000">str</span>) <span style="color: #666666">-&gt;</span> List[<span style="color: #008000">str</span>]:
<span style="color: #bbbbbb">    </span><span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;Return list of contradiction descriptions.&quot;&quot;&quot;</span>
    findings: List[<span style="color: #008000">str</span>] <span style="color: #666666">=</span> []
    paragraphs <span style="color: #666666">=</span> [_strip_html(p)<span style="color: #666666">.</span>lower() <span style="color: #008000; font-weight: bold">for</span> p <span style="color: #AA22FF; font-weight: bold">in</span> _extract_tags(html, <span style="color: #BA2121">&quot;p&quot;</span>)]
    summary_text <span style="color: #666666">=</span> <span style="color: #BA2121">&quot; &quot;</span><span style="color: #666666">.</span>join(paragraphs[:<span style="color: #666666">2</span>])
    methods <span style="color: #666666">=</span> [h <span style="color: #008000; font-weight: bold">for</span> h <span style="color: #AA22FF; font-weight: bold">in</span> _extract_tags(html, <span style="color: #BA2121">&quot;h3&quot;</span>) <span style="color: #008000; font-weight: bold">if</span> h<span style="color: #666666">.</span>strip()<span style="color: #666666">.</span>startswith(<span style="color: #BA2121">&quot;Method:&quot;</span>)]
    functions <span style="color: #666666">=</span> [h <span style="color: #008000; font-weight: bold">for</span> h <span style="color: #AA22FF; font-weight: bold">in</span> _extract_tags(html, <span style="color: #BA2121">&quot;h3&quot;</span>) <span style="color: #008000; font-weight: bold">if</span> <span style="color: #AA22FF; font-weight: bold">not</span> h<span style="color: #666666">.</span>strip()<span style="color: #666666">.</span>startswith(<span style="color: #BA2121">&quot;Method:&quot;</span>)]
    classes <span style="color: #666666">=</span> [h <span style="color: #008000; font-weight: bold">for</span> h <span style="color: #AA22FF; font-weight: bold">in</span> _extract_tags(html, <span style="color: #BA2121">&quot;h2&quot;</span>) <span style="color: #008000; font-weight: bold">if</span> h<span style="color: #666666">.</span>strip()<span style="color: #666666">.</span>startswith(<span style="color: #BA2121">&quot;Class:&quot;</span>)]
    <span style="color: #008000; font-weight: bold">if</span> <span style="color: #BA2121">&quot;no methods&quot;</span> <span style="color: #AA22FF; font-weight: bold">in</span> summary_text <span style="color: #AA22FF; font-weight: bold">and</span> methods:
        findings<span style="color: #666666">.</span>append(<span style="color: #BA2121">f&quot;&#39;no methods&#39; stated but found </span><span style="color: #A45A77; font-weight: bold">{</span><span style="color: #008000">len</span>(methods)<span style="color: #A45A77; font-weight: bold">}</span><span style="color: #BA2121"> method headers&quot;</span>)
    <span style="color: #008000; font-weight: bold">if</span> <span style="color: #BA2121">&quot;no functions&quot;</span> <span style="color: #AA22FF; font-weight: bold">in</span> summary_text <span style="color: #AA22FF; font-weight: bold">and</span> functions:
        findings<span style="color: #666666">.</span>append(<span style="color: #BA2121">f&quot;&#39;no functions&#39; stated but found </span><span style="color: #A45A77; font-weight: bold">{</span><span style="color: #008000">len</span>(functions)<span style="color: #A45A77; font-weight: bold">}</span><span style="color: #BA2121"> function headers&quot;</span>)
    <span style="color: #008000; font-weight: bold">if</span> <span style="color: #BA2121">&quot;no classes&quot;</span> <span style="color: #AA22FF; font-weight: bold">in</span> summary_text <span style="color: #AA22FF; font-weight: bold">and</span> classes:
        findings<span style="color: #666666">.</span>append(<span style="color: #BA2121">f&quot;&#39;no classes&#39; stated but found </span><span style="color: #A45A77; font-weight: bold">{</span><span style="color: #008000">len</span>(classes)<span style="color: #A45A77; font-weight: bold">}</span><span style="color: #BA2121"> class headers&quot;</span>)
    <span style="color: #008000; font-weight: bold">return</span> findings
</code></pre>
<h3 id="check_hallucinations">check_hallucinations(html: str) -&gt; List[str]</h3>
<p>The function `check_hallucinations` analyzes an HTML string to detect the presence of hallucination phrases. It extracts all paragraph (`&lt;p&gt;`) tags from the HTML, strips out any HTML formatting, converts the text to lowercase, and checks for the presence of predefined hallucination terms. If a term is found, it is added to a list of findings, which is then returned.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">check_hallucinations</span>(html: <span style="color: #008000">str</span>) <span style="color: #666666">-&gt;</span> List[<span style="color: #008000">str</span>]:
<span style="color: #bbbbbb">    </span><span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;Return list of hallucination phrases detected.&quot;&quot;&quot;</span>
    findings: List[<span style="color: #008000">str</span>] <span style="color: #666666">=</span> []
    <span style="color: #008000; font-weight: bold">for</span> raw <span style="color: #AA22FF; font-weight: bold">in</span> _extract_tags(html, <span style="color: #BA2121">&quot;p&quot;</span>):
        text <span style="color: #666666">=</span> _strip_html(raw)<span style="color: #666666">.</span>lower()
        <span style="color: #008000; font-weight: bold">for</span> term <span style="color: #AA22FF; font-weight: bold">in</span> HALLUCINATION_TERMS:
            <span style="color: #008000; font-weight: bold">if</span> term <span style="color: #AA22FF; font-weight: bold">in</span> text:
                findings<span style="color: #666666">.</span>append(term)
    <span style="color: #008000; font-weight: bold">return</span> findings
</code></pre>
<h3 id="_sanitize_paragraphs">_sanitize_paragraphs(html: str) -&gt; str</h3>
<p>The function `_sanitize_paragraphs` processes HTML content to sanitize and standardize paragraph tags. It uses a regular expression to identify paragraphs within the HTML string. For each matched paragraph, it removes any unwanted characters or formatting from the content using the `sanitize_summary` function and then wraps the cleaned content back into a `&lt;p&gt;` tag. This ensures that all paragraphs in the HTML are properly formatted and free of extraneous elements.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">_sanitize_paragraphs</span>(html: <span style="color: #008000">str</span>) <span style="color: #666666">-&gt;</span> <span style="color: #008000">str</span>:
    <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">repl</span>(match):
        cleaned <span style="color: #666666">=</span> sanitize_summary(_strip_html(match<span style="color: #666666">.</span>group(<span style="color: #666666">1</span>)))
        <span style="color: #008000; font-weight: bold">return</span> <span style="color: #BA2121">f&quot;&lt;p&gt;</span><span style="color: #A45A77; font-weight: bold">{</span>cleaned<span style="color: #A45A77; font-weight: bold">}</span><span style="color: #BA2121">&lt;/p&gt;&quot;</span>

    <span style="color: #008000; font-weight: bold">return</span> re<span style="color: #666666">.</span>sub(<span style="color: #BA2121">r&quot;&lt;p&gt;(.*?)&lt;/p&gt;&quot;</span>, repl, html, flags<span style="color: #666666">=</span>re<span style="color: #666666">.</span>DOTALL <span style="color: #666666">|</span> re<span style="color: #666666">.</span>IGNORECASE)
</code></pre>
<details>
<summary>Subfunction: repl(match)</summary>
<h4 id="repl">repl(match)</h4>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">repl</span>(match):
        cleaned <span style="color: #666666">=</span> sanitize_summary(_strip_html(match<span style="color: #666666">.</span>group(<span style="color: #666666">1</span>)))
        <span style="color: #008000; font-weight: bold">return</span> <span style="color: #BA2121">f&quot;&lt;p&gt;</span><span style="color: #A45A77; font-weight: bold">{</span>cleaned<span style="color: #A45A77; font-weight: bold">}</span><span style="color: #BA2121">&lt;/p&gt;&quot;</span>
</code></pre>
</details>
<h3 id="_review_file">_review_file(path: Path, autofix: bool=False) -&gt; List[str]</h3>
<p>The function `_review_file` reads a file at the given `path`, checks for assistant phrasing, contradictions, and hallucinations in its HTML content, and optionally fixes any issues found. It returns a list of messages indicating any problems detected or actions taken. If `autofix` is enabled and issues are found, it sanitizes the HTML paragraphs and writes the changes back to the file.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">_review_file</span>(path: Path, autofix: <span style="color: #008000">bool</span> <span style="color: #666666">=</span> <span style="color: #008000; font-weight: bold">False</span>) <span style="color: #666666">-&gt;</span> List[<span style="color: #008000">str</span>]:
    html <span style="color: #666666">=</span> path<span style="color: #666666">.</span>read_text(encoding<span style="color: #666666">=</span><span style="color: #BA2121">&quot;utf-8&quot;</span>)
    <span style="color: #008000; font-weight: bold">if</span> <span style="color: #AA22FF; font-weight: bold">not</span> _is_generated_html(html):
        <span style="color: #008000; font-weight: bold">return</span> []
    results: List[<span style="color: #008000">str</span>] <span style="color: #666666">=</span> []
    <span style="color: #008000; font-weight: bold">for</span> snippet <span style="color: #AA22FF; font-weight: bold">in</span> check_assistant_phrasing(html):
        results<span style="color: #666666">.</span>append(<span style="color: #BA2121">f&quot;[ASSISTANT] </span><span style="color: #A45A77; font-weight: bold">{</span>path<span style="color: #666666">.</span>name<span style="color: #A45A77; font-weight: bold">}</span><span style="color: #BA2121">: </span><span style="color: #A45A77; font-weight: bold">{</span>snippet<span style="color: #A45A77; font-weight: bold">}</span><span style="color: #BA2121">&quot;</span>)
    <span style="color: #008000; font-weight: bold">for</span> desc <span style="color: #AA22FF; font-weight: bold">in</span> check_contradictions(html):
        results<span style="color: #666666">.</span>append(<span style="color: #BA2121">f&quot;[CONTRADICTION] </span><span style="color: #A45A77; font-weight: bold">{</span>path<span style="color: #666666">.</span>name<span style="color: #A45A77; font-weight: bold">}</span><span style="color: #BA2121">: </span><span style="color: #A45A77; font-weight: bold">{</span>desc<span style="color: #A45A77; font-weight: bold">}</span><span style="color: #BA2121">&quot;</span>)
    <span style="color: #008000; font-weight: bold">for</span> term <span style="color: #AA22FF; font-weight: bold">in</span> check_hallucinations(html):
        results<span style="color: #666666">.</span>append(<span style="color: #BA2121">f&quot;[HALLUCINATION] </span><span style="color: #A45A77; font-weight: bold">{</span>path<span style="color: #666666">.</span>name<span style="color: #A45A77; font-weight: bold">}</span><span style="color: #BA2121">: &#39;</span><span style="color: #A45A77; font-weight: bold">{</span>term<span style="color: #A45A77; font-weight: bold">}</span><span style="color: #BA2121">&#39; mentioned&quot;</span>)
    <span style="color: #008000; font-weight: bold">if</span> autofix <span style="color: #AA22FF; font-weight: bold">and</span> results:
        html <span style="color: #666666">=</span> _sanitize_paragraphs(html)
        path<span style="color: #666666">.</span>write_text(html, encoding<span style="color: #666666">=</span><span style="color: #BA2121">&quot;utf-8&quot;</span>)
    <span style="color: #008000; font-weight: bold">return</span> results
</code></pre>
<h3 id="review_directory">review_directory(directory: Path, autofix: bool=False) -&gt; None</h3>
<p>The function `review_directory` traverses a directory and its subdirectories, searching for files with the `.html` extension. For each HTML file found, it calls another function `_review_file` to analyze and process the content. If `autofix` is set to `True`, the function attempts to automatically fix any issues identified during the review. The results of the review are printed line by line. If an error occurs while reading a file, it prints an error message and continues with the next file.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">review_directory</span>(directory: Path, autofix: <span style="color: #008000">bool</span> <span style="color: #666666">=</span> <span style="color: #008000; font-weight: bold">False</span>) <span style="color: #666666">-&gt;</span> <span style="color: #008000; font-weight: bold">None</span>:
    <span style="color: #008000; font-weight: bold">for</span> file <span style="color: #AA22FF; font-weight: bold">in</span> directory<span style="color: #666666">.</span>rglob(<span style="color: #BA2121">&quot;*.html&quot;</span>):
        <span style="color: #008000; font-weight: bold">try</span>:
            results <span style="color: #666666">=</span> _review_file(file, autofix<span style="color: #666666">=</span>autofix)
        <span style="color: #008000; font-weight: bold">except</span> <span style="color: #CB3F38; font-weight: bold">Exception</span> <span style="color: #008000; font-weight: bold">as</span> exc:  <span style="color: #3D7B7B; font-style: italic"># pragma: no cover - unexpected parse failure</span>
            <span style="color: #008000">print</span>(<span style="color: #BA2121">f&quot;Error reading </span><span style="color: #A45A77; font-weight: bold">{</span>file<span style="color: #A45A77; font-weight: bold">}</span><span style="color: #BA2121">: </span><span style="color: #A45A77; font-weight: bold">{</span>exc<span style="color: #A45A77; font-weight: bold">}</span><span style="color: #BA2121">&quot;</span>)
            <span style="color: #008000; font-weight: bold">continue</span>
        <span style="color: #008000; font-weight: bold">for</span> line <span style="color: #AA22FF; font-weight: bold">in</span> results:
            <span style="color: #008000">print</span>(line)
</code></pre>
<h3 id="main">main(argv: Iterable[str] | None=None) -&gt; int</h3>
<p>The `main` function serves as the entry point for a script designed to review and optionally fix issues in generated HTML documentation. It accepts command-line arguments through `argv`, which defaults to `None`. The function uses Python&#x27;s `argparse` module to parse two arguments: `directory`, which specifies the path to the HTML output directory, and `--autofix`, a boolean flag indicating whether to automatically rewrite files to fix identified issues.

Upon parsing the arguments, the function calls another function named `review_directory` with the provided directory path and the autofix option. Finally, it returns an integer value of 0, typically used to indicate successful execution in command-line scripts.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">main</span>(argv: Iterable[<span style="color: #008000">str</span>] <span style="color: #666666">|</span> <span style="color: #008000; font-weight: bold">None</span> <span style="color: #666666">=</span> <span style="color: #008000; font-weight: bold">None</span>) <span style="color: #666666">-&gt;</span> <span style="color: #008000">int</span>:
    parser <span style="color: #666666">=</span> argparse<span style="color: #666666">.</span>ArgumentParser(description<span style="color: #666666">=</span><span style="color: #BA2121">&quot;Review generated HTML documentation&quot;</span>)
    parser<span style="color: #666666">.</span>add_argument(<span style="color: #BA2121">&quot;directory&quot;</span>, help<span style="color: #666666">=</span><span style="color: #BA2121">&quot;Path to the HTML output directory&quot;</span>)
    parser<span style="color: #666666">.</span>add_argument(<span style="color: #BA2121">&quot;--autofix&quot;</span>, action<span style="color: #666666">=</span><span style="color: #BA2121">&quot;store_true&quot;</span>, help<span style="color: #666666">=</span><span style="color: #BA2121">&quot;Rewrite files to fix issues&quot;</span>)
    args <span style="color: #666666">=</span> parser<span style="color: #666666">.</span>parse_args(<span style="color: #008000">list</span>(argv) <span style="color: #008000; font-weight: bold">if</span> argv <span style="color: #AA22FF; font-weight: bold">is</span> <span style="color: #AA22FF; font-weight: bold">not</span> <span style="color: #008000; font-weight: bold">None</span> <span style="color: #008000; font-weight: bold">else</span> <span style="color: #008000; font-weight: bold">None</span>)

    review_directory(Path(args<span style="color: #666666">.</span>directory), autofix<span style="color: #666666">=</span>args<span style="color: #666666">.</span>autofix)
    <span style="color: #008000; font-weight: bold">return</span> <span style="color: #666666">0</span>
</code></pre>
    </div>
    <script src="static/toggle.js"></script>
</body>
</html>
