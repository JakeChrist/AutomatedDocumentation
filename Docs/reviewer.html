<!-- Generated by DocGen-LM -->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>reviewer</title>
    <link rel="stylesheet" href="static/style.css">
</head>
<body>
    <div class="sidebar">
        <h2>Navigation</h2>
        <ul>
        <li><a href="index.html"><strong>üè† Project Overview</strong></a></li>
<li><a href="cache.html">cache</a></li>
<li><a href="docgenerator.html">docgenerator</a></li>
<li><a href="html_writer.html">html_writer</a></li>
<li><a href="llm_client.html">llm_client</a></li>
<li><a href="parser_matlab.html">parser_matlab</a></li>
<li><a href="parser_python.html">parser_python</a></li>
<li><a href="reviewer.html">reviewer</a></li>
<li><a href="scanner.html">scanner</a></li>
<li><a href="test_cache.html">test_cache</a></li>
<li><a href="test_docgenerator.html">test_docgenerator</a></li>
<li><a href="test_html_writer.html">test_html_writer</a></li>
<li><a href="test_integration.html">test_integration</a></li>
<li><a href="test_llm_client.html">test_llm_client</a></li>
<li><a href="test_parser_matlab.html">test_parser_matlab</a></li>
<li><a href="test_parser_python.html">test_parser_python</a></li>
<li><a href="test_reviewer.html">test_reviewer</a></li>
<li><a href="test_scanner.html">test_scanner</a></li>
        </ul>
    </div>
    <div class="content">
        <h1>reviewer</h1>
        <p>This module provides a tool for reviewing HTML documentation generated by DocGen-LM. It includes functions to check for assistant-like phrases, contradictions, and hallucinations in the documentation. The `review_directory` function processes all `.html` files in a specified directory, applying checks and optionally fixing issues based on the `autofix` flag. The `main` function sets up command-line arguments to specify the directory to review and whether to automatically fix detected issues.</p>
<h2>Functions</h2>
<h3 id="_is_generated_html">_is_generated_html(text: str) -&gt; bool</h3>
<p>The function `_is_generated_html` checks if a given string `text` appears to be output from the DocGen-LM documentation generator. It returns `True` if the text contains specific HTML tags that are characteristic of DocGen-LM&#x27;s generated documentation, such as an `&lt;h1&gt;` tag with the text &quot;Project Documentation&quot;, or `&lt;h2&gt;` and `&lt;h3&gt;` tags containing &quot;Class:&quot; and &quot;Method:&quot;, respectively.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">_is_generated_html</span>(text: <span style="color: #008000">str</span>) <span style="color: #666666">-&gt;</span> <span style="color: #008000">bool</span>:
<span style="color: #bbbbbb">    </span><span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;Return True if *text* looks like DocGen-LM output.&quot;&quot;&quot;</span>
    <span style="color: #008000; font-weight: bold">if</span> <span style="color: #BA2121">&quot;&lt;h1&gt;Project Documentation&lt;/h1&gt;&quot;</span> <span style="color: #AA22FF; font-weight: bold">in</span> text:
        <span style="color: #008000; font-weight: bold">return</span> <span style="color: #008000; font-weight: bold">True</span>
    <span style="color: #008000; font-weight: bold">if</span> re<span style="color: #666666">.</span>search(<span style="color: #BA2121">r&quot;&lt;h2[^&gt;]*&gt;Class:&quot;</span>, text):
        <span style="color: #008000; font-weight: bold">return</span> <span style="color: #008000; font-weight: bold">True</span>
    <span style="color: #008000; font-weight: bold">if</span> re<span style="color: #666666">.</span>search(<span style="color: #BA2121">r&quot;&lt;h3[^&gt;]*&gt;Method:&quot;</span>, text):
        <span style="color: #008000; font-weight: bold">return</span> <span style="color: #008000; font-weight: bold">True</span>
    <span style="color: #008000; font-weight: bold">return</span> <span style="color: #008000; font-weight: bold">False</span>
</code></pre>
<h3 id="_find_line_number">_find_line_number(html: str, phrase: str) -&gt; int</h3>
<p>This function `_find_line_number` searches for a specific phrase within an HTML string and returns the line number where the phrase is found. If the phrase is not present, it returns -1. The search is case-insensitive.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">_find_line_number</span>(html: <span style="color: #008000">str</span>, phrase: <span style="color: #008000">str</span>) <span style="color: #666666">-&gt;</span> <span style="color: #008000">int</span>:
    <span style="color: #008000; font-weight: bold">for</span> i, line <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">enumerate</span>(html<span style="color: #666666">.</span>splitlines(), <span style="color: #666666">1</span>):
        <span style="color: #008000; font-weight: bold">if</span> phrase<span style="color: #666666">.</span>lower() <span style="color: #AA22FF; font-weight: bold">in</span> line<span style="color: #666666">.</span>lower():
            <span style="color: #008000; font-weight: bold">return</span> i
    <span style="color: #008000; font-weight: bold">return</span> <span style="color: #666666">-1</span>
</code></pre>
<h3 id="check_assistant_phrasing">check_assistant_phrasing(soup: BeautifulSoup, html: str) -&gt; List[str]</h3>
<p>The function `check_assistant_phrasing` analyzes an HTML document using BeautifulSoup to identify paragraphs containing phrases that resemble assistant-like language. It returns a list of these phrases along with their line numbers in the original HTML source code. The function iterates over all paragraph elements, checks if any predefined assistant phrases are present in the text, and records the findings.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">check_assistant_phrasing</span>(soup: BeautifulSoup, html: <span style="color: #008000">str</span>) <span style="color: #666666">-&gt;</span> List[<span style="color: #008000">str</span>]:
<span style="color: #bbbbbb">    </span><span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;Return list of assistant-like phrases found.&quot;&quot;&quot;</span>
    findings: List[<span style="color: #008000">str</span>] <span style="color: #666666">=</span> []
    <span style="color: #008000; font-weight: bold">for</span> p <span style="color: #AA22FF; font-weight: bold">in</span> soup<span style="color: #666666">.</span>find_all(<span style="color: #BA2121">&quot;p&quot;</span>):
        text <span style="color: #666666">=</span> p<span style="color: #666666">.</span>get_text(strip<span style="color: #666666">=</span><span style="color: #008000; font-weight: bold">True</span>)
        lower <span style="color: #666666">=</span> text<span style="color: #666666">.</span>lower()
        <span style="color: #008000; font-weight: bold">for</span> phrase <span style="color: #AA22FF; font-weight: bold">in</span> ASSISTANT_PHRASES:
            <span style="color: #008000; font-weight: bold">if</span> phrase <span style="color: #AA22FF; font-weight: bold">in</span> lower:
                line_no <span style="color: #666666">=</span> _find_line_number(html, text)
                findings<span style="color: #666666">.</span>append(<span style="color: #BA2121">f&#39;&quot;</span><span style="color: #A45A77; font-weight: bold">{</span>text<span style="color: #A45A77; font-weight: bold">}</span><span style="color: #BA2121">&quot; (line </span><span style="color: #A45A77; font-weight: bold">{</span>line_no<span style="color: #A45A77; font-weight: bold">}</span><span style="color: #BA2121">)&#39;</span>)
                <span style="color: #008000; font-weight: bold">break</span>
    <span style="color: #008000; font-weight: bold">return</span> findings
</code></pre>
<h3 id="check_contradictions">check_contradictions(soup: BeautifulSoup) -&gt; List[str]</h3>
<p>This function `check_contradictions` analyzes the HTML content using BeautifulSoup to identify contradictions between the text summary and the actual structure of the code. It checks for discrepancies such as:

1. The presence of method headers when the summary states there are no methods.
2. The presence of function headers when the summary states there are no functions.
3. The presence of class headers when the summary states there are no classes.

The function returns a list of strings describing any contradictions found in the documentation.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">check_contradictions</span>(soup: BeautifulSoup) <span style="color: #666666">-&gt;</span> List[<span style="color: #008000">str</span>]:
<span style="color: #bbbbbb">    </span><span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;Return list of contradiction descriptions.&quot;&quot;&quot;</span>
    findings: List[<span style="color: #008000">str</span>] <span style="color: #666666">=</span> []
    summary_text <span style="color: #666666">=</span> <span style="color: #BA2121">&quot; &quot;</span><span style="color: #666666">.</span>join(p<span style="color: #666666">.</span>get_text(<span style="color: #BA2121">&quot; &quot;</span>, strip<span style="color: #666666">=</span><span style="color: #008000; font-weight: bold">True</span>)<span style="color: #666666">.</span>lower() <span style="color: #008000; font-weight: bold">for</span> p <span style="color: #AA22FF; font-weight: bold">in</span> soup<span style="color: #666666">.</span>find_all(<span style="color: #BA2121">&quot;p&quot;</span>)[:<span style="color: #666666">2</span>])
    methods <span style="color: #666666">=</span> soup<span style="color: #666666">.</span>find_all(
        <span style="color: #BA2121">&quot;h3&quot;</span>, string<span style="color: #666666">=</span><span style="color: #008000; font-weight: bold">lambda</span> s: <span style="color: #008000">isinstance</span>(s, <span style="color: #008000">str</span>) <span style="color: #AA22FF; font-weight: bold">and</span> s<span style="color: #666666">.</span>strip()<span style="color: #666666">.</span>startswith(<span style="color: #BA2121">&quot;Method:&quot;</span>)
    )
    functions <span style="color: #666666">=</span> [
        h
        <span style="color: #008000; font-weight: bold">for</span> h <span style="color: #AA22FF; font-weight: bold">in</span> soup<span style="color: #666666">.</span>find_all(<span style="color: #BA2121">&quot;h3&quot;</span>)
        <span style="color: #008000; font-weight: bold">if</span> <span style="color: #AA22FF; font-weight: bold">not</span> (<span style="color: #008000">isinstance</span>(h<span style="color: #666666">.</span>string, <span style="color: #008000">str</span>) <span style="color: #AA22FF; font-weight: bold">and</span> h<span style="color: #666666">.</span>string<span style="color: #666666">.</span>strip()<span style="color: #666666">.</span>startswith(<span style="color: #BA2121">&quot;Method:&quot;</span>))
    ]
    classes <span style="color: #666666">=</span> soup<span style="color: #666666">.</span>find_all(
        <span style="color: #BA2121">&quot;h2&quot;</span>, string<span style="color: #666666">=</span><span style="color: #008000; font-weight: bold">lambda</span> s: <span style="color: #008000">isinstance</span>(s, <span style="color: #008000">str</span>) <span style="color: #AA22FF; font-weight: bold">and</span> s<span style="color: #666666">.</span>strip()<span style="color: #666666">.</span>startswith(<span style="color: #BA2121">&quot;Class:&quot;</span>)
    )
    <span style="color: #008000; font-weight: bold">if</span> <span style="color: #BA2121">&quot;no methods&quot;</span> <span style="color: #AA22FF; font-weight: bold">in</span> summary_text <span style="color: #AA22FF; font-weight: bold">and</span> methods:
        findings<span style="color: #666666">.</span>append(<span style="color: #BA2121">f&quot;&#39;no methods&#39; stated but found </span><span style="color: #A45A77; font-weight: bold">{</span><span style="color: #008000">len</span>(methods)<span style="color: #A45A77; font-weight: bold">}</span><span style="color: #BA2121"> method headers&quot;</span>)
    <span style="color: #008000; font-weight: bold">if</span> <span style="color: #BA2121">&quot;no functions&quot;</span> <span style="color: #AA22FF; font-weight: bold">in</span> summary_text <span style="color: #AA22FF; font-weight: bold">and</span> functions:
        findings<span style="color: #666666">.</span>append(<span style="color: #BA2121">f&quot;&#39;no functions&#39; stated but found </span><span style="color: #A45A77; font-weight: bold">{</span><span style="color: #008000">len</span>(functions)<span style="color: #A45A77; font-weight: bold">}</span><span style="color: #BA2121"> function headers&quot;</span>)
    <span style="color: #008000; font-weight: bold">if</span> <span style="color: #BA2121">&quot;no classes&quot;</span> <span style="color: #AA22FF; font-weight: bold">in</span> summary_text <span style="color: #AA22FF; font-weight: bold">and</span> classes:
        findings<span style="color: #666666">.</span>append(<span style="color: #BA2121">f&quot;&#39;no classes&#39; stated but found </span><span style="color: #A45A77; font-weight: bold">{</span><span style="color: #008000">len</span>(classes)<span style="color: #A45A77; font-weight: bold">}</span><span style="color: #BA2121"> class headers&quot;</span>)
    <span style="color: #008000; font-weight: bold">return</span> findings
</code></pre>
<h3 id="check_hallucinations">check_hallucinations(soup: BeautifulSoup) -&gt; List[str]</h3>
<p>This function `check_hallucinations` takes a BeautifulSoup object as input and returns a list of phrases detected as hallucinations. It iterates through all paragraph elements (`&lt;p&gt;`) in the HTML content, extracts their text, converts it to lowercase for case-insensitive comparison, and checks if any predefined hallucination terms are present. If a hallucination term is found, it is added to the findings list.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">check_hallucinations</span>(soup: BeautifulSoup) <span style="color: #666666">-&gt;</span> List[<span style="color: #008000">str</span>]:
<span style="color: #bbbbbb">    </span><span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;Return list of hallucination phrases detected.&quot;&quot;&quot;</span>
    findings: List[<span style="color: #008000">str</span>] <span style="color: #666666">=</span> []
    <span style="color: #008000; font-weight: bold">for</span> p <span style="color: #AA22FF; font-weight: bold">in</span> soup<span style="color: #666666">.</span>find_all(<span style="color: #BA2121">&quot;p&quot;</span>):
        text <span style="color: #666666">=</span> p<span style="color: #666666">.</span>get_text(<span style="color: #BA2121">&quot; &quot;</span>, strip<span style="color: #666666">=</span><span style="color: #008000; font-weight: bold">True</span>)<span style="color: #666666">.</span>lower()
        <span style="color: #008000; font-weight: bold">for</span> term <span style="color: #AA22FF; font-weight: bold">in</span> HALLUCINATION_TERMS:
            <span style="color: #008000; font-weight: bold">if</span> term <span style="color: #AA22FF; font-weight: bold">in</span> text:
                findings<span style="color: #666666">.</span>append(term)
    <span style="color: #008000; font-weight: bold">return</span> findings
</code></pre>
<h3 id="_sanitize_paragraphs">_sanitize_paragraphs(soup: BeautifulSoup) -&gt; None</h3>
<p>The function `_sanitize_paragraphs` processes a `BeautifulSoup` object to clean up paragraph (`&lt;p&gt;`) elements. It iterates through all `&lt;p&gt;` tags in the provided HTML structure, extracts their text content, sanitizes it using the `sanitize_summary` function, and then updates the text of each `&lt;p&gt;` tag with the sanitized version.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">_sanitize_paragraphs</span>(soup: BeautifulSoup) <span style="color: #666666">-&gt;</span> <span style="color: #008000; font-weight: bold">None</span>:
    <span style="color: #008000; font-weight: bold">for</span> p <span style="color: #AA22FF; font-weight: bold">in</span> soup<span style="color: #666666">.</span>find_all(<span style="color: #BA2121">&quot;p&quot;</span>):
        cleaned <span style="color: #666666">=</span> sanitize_summary(p<span style="color: #666666">.</span>get_text())
        p<span style="color: #666666">.</span>string <span style="color: #666666">=</span> cleaned
</code></pre>
<h3 id="_review_file">_review_file(path: Path, autofix: bool=False) -&gt; List[str]</h3>
<p>The function `_review_file` takes a file path and an optional `autofix` flag as input. It reads the HTML content from the specified file, checks for assistant phrasing, contradictions, and hallucinations using predefined functions (`check_assistant_phrasing`, `check_contradictions`, `check_hallucinations`). If any issues are found, it appends a message to the results list indicating the type of issue (assistant phrasing, contradiction, or hallucination) along with the file name. If the `autofix` flag is set and there are issues, it sanitizes the paragraphs in the HTML content using `_sanitize_paragraphs` and writes the modified HTML back to the file. Finally, it returns a list of review results.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">_review_file</span>(path: Path, autofix: <span style="color: #008000">bool</span> <span style="color: #666666">=</span> <span style="color: #008000; font-weight: bold">False</span>) <span style="color: #666666">-&gt;</span> List[<span style="color: #008000">str</span>]:
    html <span style="color: #666666">=</span> path<span style="color: #666666">.</span>read_text(encoding<span style="color: #666666">=</span><span style="color: #BA2121">&quot;utf-8&quot;</span>)
    <span style="color: #008000; font-weight: bold">if</span> <span style="color: #AA22FF; font-weight: bold">not</span> _is_generated_html(html):
        <span style="color: #008000; font-weight: bold">return</span> []
    soup <span style="color: #666666">=</span> BeautifulSoup(html, <span style="color: #BA2121">&quot;html.parser&quot;</span>)
    results: List[<span style="color: #008000">str</span>] <span style="color: #666666">=</span> []
    <span style="color: #008000; font-weight: bold">for</span> snippet <span style="color: #AA22FF; font-weight: bold">in</span> check_assistant_phrasing(soup, html):
        results<span style="color: #666666">.</span>append(<span style="color: #BA2121">f&quot;[ASSISTANT] </span><span style="color: #A45A77; font-weight: bold">{</span>path<span style="color: #666666">.</span>name<span style="color: #A45A77; font-weight: bold">}</span><span style="color: #BA2121">: </span><span style="color: #A45A77; font-weight: bold">{</span>snippet<span style="color: #A45A77; font-weight: bold">}</span><span style="color: #BA2121">&quot;</span>)
    <span style="color: #008000; font-weight: bold">for</span> desc <span style="color: #AA22FF; font-weight: bold">in</span> check_contradictions(soup):
        results<span style="color: #666666">.</span>append(<span style="color: #BA2121">f&quot;[CONTRADICTION] </span><span style="color: #A45A77; font-weight: bold">{</span>path<span style="color: #666666">.</span>name<span style="color: #A45A77; font-weight: bold">}</span><span style="color: #BA2121">: </span><span style="color: #A45A77; font-weight: bold">{</span>desc<span style="color: #A45A77; font-weight: bold">}</span><span style="color: #BA2121">&quot;</span>)
    <span style="color: #008000; font-weight: bold">for</span> term <span style="color: #AA22FF; font-weight: bold">in</span> check_hallucinations(soup):
        results<span style="color: #666666">.</span>append(<span style="color: #BA2121">f&quot;[HALLUCINATION] </span><span style="color: #A45A77; font-weight: bold">{</span>path<span style="color: #666666">.</span>name<span style="color: #A45A77; font-weight: bold">}</span><span style="color: #BA2121">: &#39;</span><span style="color: #A45A77; font-weight: bold">{</span>term<span style="color: #A45A77; font-weight: bold">}</span><span style="color: #BA2121">&#39; mentioned&quot;</span>)
    <span style="color: #008000; font-weight: bold">if</span> autofix <span style="color: #AA22FF; font-weight: bold">and</span> results:
        _sanitize_paragraphs(soup)
        path<span style="color: #666666">.</span>write_text(<span style="color: #008000">str</span>(soup), encoding<span style="color: #666666">=</span><span style="color: #BA2121">&quot;utf-8&quot;</span>)
    <span style="color: #008000; font-weight: bold">return</span> results
</code></pre>
<h3 id="review_directory">review_directory(directory: Path, autofix: bool=False) -&gt; None</h3>
<p>The `review_directory` function iterates over all HTML files within a specified directory and its subdirectories using `rglob`. For each file, it calls `_review_file` with the file path and an optional `autofix` flag. If an exception occurs during the review process, it prints an error message and continues to the next file. The results from `_review_file` are printed line by line.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">review_directory</span>(directory: Path, autofix: <span style="color: #008000">bool</span> <span style="color: #666666">=</span> <span style="color: #008000; font-weight: bold">False</span>) <span style="color: #666666">-&gt;</span> <span style="color: #008000; font-weight: bold">None</span>:
    <span style="color: #008000; font-weight: bold">for</span> file <span style="color: #AA22FF; font-weight: bold">in</span> directory<span style="color: #666666">.</span>rglob(<span style="color: #BA2121">&quot;*.html&quot;</span>):
        <span style="color: #008000; font-weight: bold">try</span>:
            results <span style="color: #666666">=</span> _review_file(file, autofix<span style="color: #666666">=</span>autofix)
        <span style="color: #008000; font-weight: bold">except</span> <span style="color: #CB3F38; font-weight: bold">Exception</span> <span style="color: #008000; font-weight: bold">as</span> exc:  <span style="color: #3D7B7B; font-style: italic"># pragma: no cover - unexpected parse failure</span>
            <span style="color: #008000">print</span>(<span style="color: #BA2121">f&quot;Error reading </span><span style="color: #A45A77; font-weight: bold">{</span>file<span style="color: #A45A77; font-weight: bold">}</span><span style="color: #BA2121">: </span><span style="color: #A45A77; font-weight: bold">{</span>exc<span style="color: #A45A77; font-weight: bold">}</span><span style="color: #BA2121">&quot;</span>)
            <span style="color: #008000; font-weight: bold">continue</span>
        <span style="color: #008000; font-weight: bold">for</span> line <span style="color: #AA22FF; font-weight: bold">in</span> results:
            <span style="color: #008000">print</span>(line)
</code></pre>
<h3 id="main">main(argv: Iterable[str] | None=None) -&gt; int</h3>
<p>The `main` function serves as the entry point for reviewing generated HTML documentation. It accepts command-line arguments specifying the directory containing the HTML files and an optional flag to enable automatic fixes for issues in these files. The function uses the `argparse` module to parse these arguments and then calls the `review_directory` function with the provided directory path and autofix setting.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">main</span>(argv: Iterable[<span style="color: #008000">str</span>] <span style="color: #666666">|</span> <span style="color: #008000; font-weight: bold">None</span> <span style="color: #666666">=</span> <span style="color: #008000; font-weight: bold">None</span>) <span style="color: #666666">-&gt;</span> <span style="color: #008000">int</span>:
    parser <span style="color: #666666">=</span> argparse<span style="color: #666666">.</span>ArgumentParser(description<span style="color: #666666">=</span><span style="color: #BA2121">&quot;Review generated HTML documentation&quot;</span>)
    parser<span style="color: #666666">.</span>add_argument(<span style="color: #BA2121">&quot;directory&quot;</span>, help<span style="color: #666666">=</span><span style="color: #BA2121">&quot;Path to the HTML output directory&quot;</span>)
    parser<span style="color: #666666">.</span>add_argument(<span style="color: #BA2121">&quot;--autofix&quot;</span>, action<span style="color: #666666">=</span><span style="color: #BA2121">&quot;store_true&quot;</span>, help<span style="color: #666666">=</span><span style="color: #BA2121">&quot;Rewrite files to fix issues&quot;</span>)
    args <span style="color: #666666">=</span> parser<span style="color: #666666">.</span>parse_args(<span style="color: #008000">list</span>(argv) <span style="color: #008000; font-weight: bold">if</span> argv <span style="color: #AA22FF; font-weight: bold">is</span> <span style="color: #AA22FF; font-weight: bold">not</span> <span style="color: #008000; font-weight: bold">None</span> <span style="color: #008000; font-weight: bold">else</span> <span style="color: #008000; font-weight: bold">None</span>)

    review_directory(Path(args<span style="color: #666666">.</span>directory), autofix<span style="color: #666666">=</span>args<span style="color: #666666">.</span>autofix)
    <span style="color: #008000; font-weight: bold">return</span> <span style="color: #666666">0</span>
</code></pre>
    </div>
</body>
</html>
