<!-- Generated by DocGen-LM -->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>reviewer</title>
    <link rel="stylesheet" href="static/style.css">
</head>
<body>
    <button id="sidebar-toggle">Menu</button>
    <div class="sidebar">
        <h2>Navigation</h2>
        <ul><li><a href="index.html"><strong>üè† Project Overview</strong></a></li><li><a href="cache.html">cache</a></li><li><a href="chunk_utils.html">chunk_utils</a></li><li><a href="docgenerator.html">docgenerator</a></li><li><a href="explaincode.html">explaincode</a></li><li><a href="gui_wrapper.html">gui_wrapper</a></li><li><a href="html_writer.html">html_writer</a></li><li><a href="llm_client.html">llm_client</a></li><li><a href="manual_utils.html">manual_utils</a></li><li><a href="parser_cpp.html">parser_cpp</a></li><li><a href="parser_java.html">parser_java</a></li><li><a href="parser_matlab.html">parser_matlab</a></li><li><a href="parser_python.html">parser_python</a></li><li><a href="retrofit_sidebar.html">retrofit_sidebar</a></li><li><a href="reviewer.html">reviewer</a></li><li><a href="sanitize_docs.html">sanitize_docs</a></li><li><a href="scanner.html">scanner</a></li><li><a href="setup.html">setup</a></li><li><a href="summarize_utils.html">summarize_utils</a></li><li><details><summary>tests</summary><ul><li><a href="test_cache.html">test_cache</a></li><li><a href="test_chunk_utils.html">test_chunk_utils</a></li><li><a href="test_docgenerator.html">test_docgenerator</a></li><li><a href="test_docgenerator_subclasses.html">test_docgenerator_subclasses</a></li><li><a href="test_explaincode.html">test_explaincode</a></li><li><a href="test_html_writer.html">test_html_writer</a></li><li><a href="test_integration.html">test_integration</a></li><li><a href="test_llm_client.html">test_llm_client</a></li><li><a href="test_manual_utils.html">test_manual_utils</a></li><li><a href="test_parser_cpp.html">test_parser_cpp</a></li><li><a href="test_parser_java.html">test_parser_java</a></li><li><a href="test_parser_matlab.html">test_parser_matlab</a></li><li><a href="test_parser_python.html">test_parser_python</a></li><li><a href="test_resume_progress.html">test_resume_progress</a></li><li><a href="test_retrofit_sidebar.html">test_retrofit_sidebar</a></li><li><a href="test_reviewer.html">test_reviewer</a></li><li><a href="test_sanitize_docs.html">test_sanitize_docs</a></li><li><a href="test_scanner.html">test_scanner</a></li></ul></details></li></ul>
    </div>
    <div class="content">
        <h1>reviewer</h1>
        <p>Module defines a documentation reviewer for HTML output generated by DocGen-LM. It identifies assistant-like phrasing, contradictions between summary and detected elements, and hallucinated content. The tool processes HTML files in a directory, reporting issues found. An optional autofix mode rewrites files to sanitize paragraph content using an external client function. Command-line interface accepts a directory path and an autofix flag.</p>
<h2>Functions</h2>
<h3 id="_is_generated_html">_is_generated_html(text: str) -&gt; bool</h3>
<p>The function `_is_generated_html` determines whether a given HTML text appears to be output generated by DocGen-LM. It checks for the presence of specific markers within the text, including the string &quot;Generated by DocGen-LM&quot;, the heading &quot;Project Documentation&quot;, and patterns matching class and method headings with specific prefixes. The function returns `True` if any of these markers are found, indicating the text is likely generated documentation, and `False` otherwise.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">_is_generated_html</span>(text: <span style="color: #008000">str</span>) <span style="color: #666666">-&gt;</span> <span style="color: #008000">bool</span>:
<span style="color: #bbbbbb">    </span><span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;Return True if *text* looks like DocGen-LM output.&quot;&quot;&quot;</span>
    <span style="color: #008000; font-weight: bold">if</span> <span style="color: #BA2121">&quot;Generated by DocGen-LM&quot;</span> <span style="color: #AA22FF; font-weight: bold">in</span> text:
        <span style="color: #008000; font-weight: bold">return</span> <span style="color: #008000; font-weight: bold">True</span>
    <span style="color: #008000; font-weight: bold">if</span> <span style="color: #BA2121">&quot;&lt;h1&gt;Project Documentation&lt;/h1&gt;&quot;</span> <span style="color: #AA22FF; font-weight: bold">in</span> text:
        <span style="color: #008000; font-weight: bold">return</span> <span style="color: #008000; font-weight: bold">True</span>
    <span style="color: #008000; font-weight: bold">if</span> re<span style="color: #666666">.</span>search(<span style="color: #BA2121">r&quot;&lt;h2[^&gt;]*&gt;Class:&quot;</span>, text):
        <span style="color: #008000; font-weight: bold">return</span> <span style="color: #008000; font-weight: bold">True</span>
    <span style="color: #008000; font-weight: bold">if</span> re<span style="color: #666666">.</span>search(<span style="color: #BA2121">r&quot;&lt;h3[^&gt;]*&gt;Method:&quot;</span>, text):
        <span style="color: #008000; font-weight: bold">return</span> <span style="color: #008000; font-weight: bold">True</span>
    <span style="color: #008000; font-weight: bold">return</span> <span style="color: #008000; font-weight: bold">False</span>
</code></pre>
<h3 id="_find_line_number">_find_line_number(html: str, phrase: str) -&gt; int</h3>
<p>The function `_find_line_number` takes an HTML string and a search phrase as inputs. It iterates through each line of the HTML content, checking if the phrase (case-insensitively) is present in the line. If the phrase is found, it returns the line number (1-based indexing). If the phrase is not found after checking all lines, it returns -1.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">_find_line_number</span>(html: <span style="color: #008000">str</span>, phrase: <span style="color: #008000">str</span>) <span style="color: #666666">-&gt;</span> <span style="color: #008000">int</span>:
    <span style="color: #008000; font-weight: bold">for</span> i, line <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">enumerate</span>(html<span style="color: #666666">.</span>splitlines(), <span style="color: #666666">1</span>):
        <span style="color: #008000; font-weight: bold">if</span> phrase<span style="color: #666666">.</span>lower() <span style="color: #AA22FF; font-weight: bold">in</span> line<span style="color: #666666">.</span>lower():
            <span style="color: #008000; font-weight: bold">return</span> i
    <span style="color: #008000; font-weight: bold">return</span> <span style="color: #666666">-1</span>
</code></pre>
<h3 id="_extract_tags">_extract_tags(html: str, tag: str) -&gt; List[str]</h3>
<p>The function `_extract_tags` extracts all text content enclosed within specified HTML tags from a given HTML string. It uses a regular expression pattern to match the opening and closing tags, capturing the content between them. The extracted content is returned as a list of strings, with the search being case-insensitive and capable of matching across multiple lines.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">_extract_tags</span>(html: <span style="color: #008000">str</span>, tag: <span style="color: #008000">str</span>) <span style="color: #666666">-&gt;</span> List[<span style="color: #008000">str</span>]:
    pattern <span style="color: #666666">=</span> <span style="color: #BA2121">rf&quot;&lt;</span><span style="color: #A45A77; font-weight: bold">{</span>tag<span style="color: #A45A77; font-weight: bold">}</span><span style="color: #BA2121">[^&gt;]*&gt;(.*?)&lt;/</span><span style="color: #A45A77; font-weight: bold">{</span>tag<span style="color: #A45A77; font-weight: bold">}</span><span style="color: #BA2121">&gt;&quot;</span>
    <span style="color: #008000; font-weight: bold">return</span> re<span style="color: #666666">.</span>findall(pattern, html, flags<span style="color: #666666">=</span>re<span style="color: #666666">.</span>DOTALL <span style="color: #666666">|</span> re<span style="color: #666666">.</span>IGNORECASE)
</code></pre>
<h3 id="_strip_html">_strip_html(text: str) -&gt; str</h3>
<p>The function `_strip_html` takes a string input `text` and removes all HTML tags from it using a regular expression. It matches any character sequence that starts with `&lt;` and ends with `&gt;`, including nested tags, and replaces them with an empty string, effectively stripping all HTML formatting from the input text.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">_strip_html</span>(text: <span style="color: #008000">str</span>) <span style="color: #666666">-&gt;</span> <span style="color: #008000">str</span>:
    <span style="color: #008000; font-weight: bold">return</span> re<span style="color: #666666">.</span>sub(<span style="color: #BA2121">r&quot;&lt;[^&gt;]+&gt;&quot;</span>, <span style="color: #BA2121">&quot;&quot;</span>, text)
</code></pre>
<h3 id="check_assistant_phrasing">check_assistant_phrasing(html: str) -&gt; List[str]</h3>
<p>The function `check_assistant_phrasing` analyzes HTML content to identify paragraphs containing assistant-like phrases. It takes an HTML string as input and returns a list of strings, each representing a found phrase along with its line number in the HTML. The function extracts all paragraph elements from the HTML, strips their HTML tags to obtain plain text, converts the text to lowercase, and checks for the presence of predefined assistant phrases. When a match is found, it records the original text and its line number in the HTML document.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">check_assistant_phrasing</span>(html: <span style="color: #008000">str</span>) <span style="color: #666666">-&gt;</span> List[<span style="color: #008000">str</span>]:
<span style="color: #bbbbbb">    </span><span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;Return list of assistant-like phrases found.&quot;&quot;&quot;</span>
    findings: List[<span style="color: #008000">str</span>] <span style="color: #666666">=</span> []
    <span style="color: #008000; font-weight: bold">for</span> raw <span style="color: #AA22FF; font-weight: bold">in</span> _extract_tags(html, <span style="color: #BA2121">&quot;p&quot;</span>):
        text <span style="color: #666666">=</span> _strip_html(raw)<span style="color: #666666">.</span>strip()
        lower <span style="color: #666666">=</span> text<span style="color: #666666">.</span>lower()
        <span style="color: #008000; font-weight: bold">for</span> phrase <span style="color: #AA22FF; font-weight: bold">in</span> ASSISTANT_PHRASES:
            <span style="color: #008000; font-weight: bold">if</span> phrase <span style="color: #AA22FF; font-weight: bold">in</span> lower:
                line_no <span style="color: #666666">=</span> _find_line_number(html, text)
                findings<span style="color: #666666">.</span>append(<span style="color: #BA2121">f&#39;&quot;</span><span style="color: #A45A77; font-weight: bold">{</span>text<span style="color: #A45A77; font-weight: bold">}</span><span style="color: #BA2121">&quot; (line </span><span style="color: #A45A77; font-weight: bold">{</span>line_no<span style="color: #A45A77; font-weight: bold">}</span><span style="color: #BA2121">)&#39;</span>)
                <span style="color: #008000; font-weight: bold">break</span>
    <span style="color: #008000; font-weight: bold">return</span> findings
</code></pre>
<h3 id="check_contradictions">check_contradictions(html: str) -&gt; List[str]</h3>
<p>The function `check_contradictions` analyzes HTML content to identify contradictions between summarized text and the actual structure of code elements. It extracts paragraphs, headings (h2 and h3), and checks for inconsistencies such as stating &quot;no methods&quot; while finding method headers, or similar mismatches for functions and classes. The function returns a list of strings describing each identified contradiction.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">check_contradictions</span>(html: <span style="color: #008000">str</span>) <span style="color: #666666">-&gt;</span> List[<span style="color: #008000">str</span>]:
<span style="color: #bbbbbb">    </span><span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;Return list of contradiction descriptions.&quot;&quot;&quot;</span>
    findings: List[<span style="color: #008000">str</span>] <span style="color: #666666">=</span> []
    paragraphs <span style="color: #666666">=</span> [_strip_html(p)<span style="color: #666666">.</span>lower() <span style="color: #008000; font-weight: bold">for</span> p <span style="color: #AA22FF; font-weight: bold">in</span> _extract_tags(html, <span style="color: #BA2121">&quot;p&quot;</span>)]
    summary_text <span style="color: #666666">=</span> <span style="color: #BA2121">&quot; &quot;</span><span style="color: #666666">.</span>join(paragraphs[:<span style="color: #666666">2</span>])
    methods <span style="color: #666666">=</span> [h <span style="color: #008000; font-weight: bold">for</span> h <span style="color: #AA22FF; font-weight: bold">in</span> _extract_tags(html, <span style="color: #BA2121">&quot;h3&quot;</span>) <span style="color: #008000; font-weight: bold">if</span> h<span style="color: #666666">.</span>strip()<span style="color: #666666">.</span>startswith(<span style="color: #BA2121">&quot;Method:&quot;</span>)]
    functions <span style="color: #666666">=</span> [h <span style="color: #008000; font-weight: bold">for</span> h <span style="color: #AA22FF; font-weight: bold">in</span> _extract_tags(html, <span style="color: #BA2121">&quot;h3&quot;</span>) <span style="color: #008000; font-weight: bold">if</span> <span style="color: #AA22FF; font-weight: bold">not</span> h<span style="color: #666666">.</span>strip()<span style="color: #666666">.</span>startswith(<span style="color: #BA2121">&quot;Method:&quot;</span>)]
    classes <span style="color: #666666">=</span> [h <span style="color: #008000; font-weight: bold">for</span> h <span style="color: #AA22FF; font-weight: bold">in</span> _extract_tags(html, <span style="color: #BA2121">&quot;h2&quot;</span>) <span style="color: #008000; font-weight: bold">if</span> h<span style="color: #666666">.</span>strip()<span style="color: #666666">.</span>startswith(<span style="color: #BA2121">&quot;Class:&quot;</span>)]
    <span style="color: #008000; font-weight: bold">if</span> <span style="color: #BA2121">&quot;no methods&quot;</span> <span style="color: #AA22FF; font-weight: bold">in</span> summary_text <span style="color: #AA22FF; font-weight: bold">and</span> methods:
        findings<span style="color: #666666">.</span>append(<span style="color: #BA2121">f&quot;&#39;no methods&#39; stated but found </span><span style="color: #A45A77; font-weight: bold">{</span><span style="color: #008000">len</span>(methods)<span style="color: #A45A77; font-weight: bold">}</span><span style="color: #BA2121"> method headers&quot;</span>)
    <span style="color: #008000; font-weight: bold">if</span> <span style="color: #BA2121">&quot;no functions&quot;</span> <span style="color: #AA22FF; font-weight: bold">in</span> summary_text <span style="color: #AA22FF; font-weight: bold">and</span> functions:
        findings<span style="color: #666666">.</span>append(<span style="color: #BA2121">f&quot;&#39;no functions&#39; stated but found </span><span style="color: #A45A77; font-weight: bold">{</span><span style="color: #008000">len</span>(functions)<span style="color: #A45A77; font-weight: bold">}</span><span style="color: #BA2121"> function headers&quot;</span>)
    <span style="color: #008000; font-weight: bold">if</span> <span style="color: #BA2121">&quot;no classes&quot;</span> <span style="color: #AA22FF; font-weight: bold">in</span> summary_text <span style="color: #AA22FF; font-weight: bold">and</span> classes:
        findings<span style="color: #666666">.</span>append(<span style="color: #BA2121">f&quot;&#39;no classes&#39; stated but found </span><span style="color: #A45A77; font-weight: bold">{</span><span style="color: #008000">len</span>(classes)<span style="color: #A45A77; font-weight: bold">}</span><span style="color: #BA2121"> class headers&quot;</span>)
    <span style="color: #008000; font-weight: bold">return</span> findings
</code></pre>
<h3 id="check_hallucinations">check_hallucinations(html: str) -&gt; List[str]</h3>
<p>The function `check_hallucinations` takes an HTML string as input and returns a list of hallucination phrases detected within the text. It extracts all paragraph elements from the HTML, strips the HTML tags from each paragraph, converts the text to lowercase, and checks for the presence of predefined terms (stored in `HALLUCINATION_TERMS`). If any of these terms are found within the text of a paragraph, they are added to the list of findings, which is then returned.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">check_hallucinations</span>(html: <span style="color: #008000">str</span>) <span style="color: #666666">-&gt;</span> List[<span style="color: #008000">str</span>]:
<span style="color: #bbbbbb">    </span><span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;Return list of hallucination phrases detected.&quot;&quot;&quot;</span>
    findings: List[<span style="color: #008000">str</span>] <span style="color: #666666">=</span> []
    <span style="color: #008000; font-weight: bold">for</span> raw <span style="color: #AA22FF; font-weight: bold">in</span> _extract_tags(html, <span style="color: #BA2121">&quot;p&quot;</span>):
        text <span style="color: #666666">=</span> _strip_html(raw)<span style="color: #666666">.</span>lower()
        <span style="color: #008000; font-weight: bold">for</span> term <span style="color: #AA22FF; font-weight: bold">in</span> HALLUCINATION_TERMS:
            <span style="color: #008000; font-weight: bold">if</span> term <span style="color: #AA22FF; font-weight: bold">in</span> text:
                findings<span style="color: #666666">.</span>append(term)
    <span style="color: #008000; font-weight: bold">return</span> findings
</code></pre>
<h3 id="_sanitize_paragraphs">_sanitize_paragraphs(html: str) -&gt; str</h3>
<p>The function `_sanitize_paragraphs` processes an HTML string to sanitize the content within paragraph tags. It uses a regular expression to find all paragraph elements, extracts their inner content, applies sanitization and stripping operations to that content, and then reconstructs the paragraph with the cleaned content. The function preserves the paragraph structure while ensuring the text inside is properly sanitized.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">_sanitize_paragraphs</span>(html: <span style="color: #008000">str</span>) <span style="color: #666666">-&gt;</span> <span style="color: #008000">str</span>:
    <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">repl</span>(match):
        cleaned <span style="color: #666666">=</span> sanitize_summary(_strip_html(match<span style="color: #666666">.</span>group(<span style="color: #666666">1</span>)))
        <span style="color: #008000; font-weight: bold">return</span> <span style="color: #BA2121">f&quot;&lt;p&gt;</span><span style="color: #A45A77; font-weight: bold">{</span>cleaned<span style="color: #A45A77; font-weight: bold">}</span><span style="color: #BA2121">&lt;/p&gt;&quot;</span>

    <span style="color: #008000; font-weight: bold">return</span> re<span style="color: #666666">.</span>sub(<span style="color: #BA2121">r&quot;&lt;p&gt;(.*?)&lt;/p&gt;&quot;</span>, repl, html, flags<span style="color: #666666">=</span>re<span style="color: #666666">.</span>DOTALL <span style="color: #666666">|</span> re<span style="color: #666666">.</span>IGNORECASE)
</code></pre>
<details>
<summary>Subfunction: repl(match)</summary>
<h4 id="repl">repl(match)</h4>
<p>The function `repl` takes a regex match object as input, extracts the first captured group, sanitizes it by removing HTML tags using `_strip_html`, and wraps the resulting cleaned text in an HTML paragraph tag `&lt;p&gt;`. It returns this formatted string.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">repl</span>(match):
        cleaned <span style="color: #666666">=</span> sanitize_summary(_strip_html(match<span style="color: #666666">.</span>group(<span style="color: #666666">1</span>)))
        <span style="color: #008000; font-weight: bold">return</span> <span style="color: #BA2121">f&quot;&lt;p&gt;</span><span style="color: #A45A77; font-weight: bold">{</span>cleaned<span style="color: #A45A77; font-weight: bold">}</span><span style="color: #BA2121">&lt;/p&gt;&quot;</span>
</code></pre>
</details>
<h3 id="_review_file">_review_file(path: Path, autofix: bool=False) -&gt; List[str]</h3>
<p>The function `_review_file` takes a file path and an optional `autofix` flag, reads the file&#x27;s HTML content, and checks if it was generated by examining its content. If not, it returns an empty list. Otherwise, it performs three types of checks on the HTML: assistant phrasing, contradictions, and hallucinations. Each detected issue is recorded with a corresponding label and file name. If the `autofix` flag is enabled and issues are found, the function sanitizes paragraph formatting in the HTML and writes the updated content back to the file. The function returns a list of strings describing any detected issues.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">_review_file</span>(path: Path, autofix: <span style="color: #008000">bool</span> <span style="color: #666666">=</span> <span style="color: #008000; font-weight: bold">False</span>) <span style="color: #666666">-&gt;</span> List[<span style="color: #008000">str</span>]:
    html <span style="color: #666666">=</span> path<span style="color: #666666">.</span>read_text(encoding<span style="color: #666666">=</span><span style="color: #BA2121">&quot;utf-8&quot;</span>)
    <span style="color: #008000; font-weight: bold">if</span> <span style="color: #AA22FF; font-weight: bold">not</span> _is_generated_html(html):
        <span style="color: #008000; font-weight: bold">return</span> []
    results: List[<span style="color: #008000">str</span>] <span style="color: #666666">=</span> []
    <span style="color: #008000; font-weight: bold">for</span> snippet <span style="color: #AA22FF; font-weight: bold">in</span> check_assistant_phrasing(html):
        results<span style="color: #666666">.</span>append(<span style="color: #BA2121">f&quot;[ASSISTANT] </span><span style="color: #A45A77; font-weight: bold">{</span>path<span style="color: #666666">.</span>name<span style="color: #A45A77; font-weight: bold">}</span><span style="color: #BA2121">: </span><span style="color: #A45A77; font-weight: bold">{</span>snippet<span style="color: #A45A77; font-weight: bold">}</span><span style="color: #BA2121">&quot;</span>)
    <span style="color: #008000; font-weight: bold">for</span> desc <span style="color: #AA22FF; font-weight: bold">in</span> check_contradictions(html):
        results<span style="color: #666666">.</span>append(<span style="color: #BA2121">f&quot;[CONTRADICTION] </span><span style="color: #A45A77; font-weight: bold">{</span>path<span style="color: #666666">.</span>name<span style="color: #A45A77; font-weight: bold">}</span><span style="color: #BA2121">: </span><span style="color: #A45A77; font-weight: bold">{</span>desc<span style="color: #A45A77; font-weight: bold">}</span><span style="color: #BA2121">&quot;</span>)
    <span style="color: #008000; font-weight: bold">for</span> term <span style="color: #AA22FF; font-weight: bold">in</span> check_hallucinations(html):
        results<span style="color: #666666">.</span>append(<span style="color: #BA2121">f&quot;[HALLUCINATION] </span><span style="color: #A45A77; font-weight: bold">{</span>path<span style="color: #666666">.</span>name<span style="color: #A45A77; font-weight: bold">}</span><span style="color: #BA2121">: &#39;</span><span style="color: #A45A77; font-weight: bold">{</span>term<span style="color: #A45A77; font-weight: bold">}</span><span style="color: #BA2121">&#39; mentioned&quot;</span>)
    <span style="color: #008000; font-weight: bold">if</span> autofix <span style="color: #AA22FF; font-weight: bold">and</span> results:
        html <span style="color: #666666">=</span> _sanitize_paragraphs(html)
        path<span style="color: #666666">.</span>write_text(html, encoding<span style="color: #666666">=</span><span style="color: #BA2121">&quot;utf-8&quot;</span>)
    <span style="color: #008000; font-weight: bold">return</span> results
</code></pre>
<h3 id="review_directory">review_directory(directory: Path, autofix: bool=False) -&gt; None</h3>
<p>The function `review_directory` processes all HTML files within a specified directory and its subdirectories. For each HTML file, it calls an internal function `_review_file` to analyze the content, optionally applying automatic fixes if the `autofix` parameter is set to True. If an error occurs while processing a file, it prints an error message and continues with the next file. The results from each file review are printed line by line.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">review_directory</span>(directory: Path, autofix: <span style="color: #008000">bool</span> <span style="color: #666666">=</span> <span style="color: #008000; font-weight: bold">False</span>) <span style="color: #666666">-&gt;</span> <span style="color: #008000; font-weight: bold">None</span>:
    <span style="color: #008000; font-weight: bold">for</span> file <span style="color: #AA22FF; font-weight: bold">in</span> directory<span style="color: #666666">.</span>rglob(<span style="color: #BA2121">&quot;*.html&quot;</span>):
        <span style="color: #008000; font-weight: bold">try</span>:
            results <span style="color: #666666">=</span> _review_file(file, autofix<span style="color: #666666">=</span>autofix)
        <span style="color: #008000; font-weight: bold">except</span> <span style="color: #CB3F38; font-weight: bold">Exception</span> <span style="color: #008000; font-weight: bold">as</span> exc:  <span style="color: #3D7B7B; font-style: italic"># pragma: no cover - unexpected parse failure</span>
            <span style="color: #008000">print</span>(<span style="color: #BA2121">f&quot;Error reading </span><span style="color: #A45A77; font-weight: bold">{</span>file<span style="color: #A45A77; font-weight: bold">}</span><span style="color: #BA2121">: </span><span style="color: #A45A77; font-weight: bold">{</span>exc<span style="color: #A45A77; font-weight: bold">}</span><span style="color: #BA2121">&quot;</span>)
            <span style="color: #008000; font-weight: bold">continue</span>
        <span style="color: #008000; font-weight: bold">for</span> line <span style="color: #AA22FF; font-weight: bold">in</span> results:
            <span style="color: #008000">print</span>(line)
</code></pre>
<h3 id="main">main(argv: Iterable[str] | None=None) -&gt; int</h3>
<p>The `main` function serves as the entry point for reviewing generated HTML documentation. It accepts an optional iterable of command-line arguments and uses `argparse` to parse the directory path containing the HTML output and an optional `--autofix` flag. The function calls `review_directory` with the specified directory path and the autofix option, then returns an integer status code of 0 upon completion.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">main</span>(argv: Iterable[<span style="color: #008000">str</span>] <span style="color: #666666">|</span> <span style="color: #008000; font-weight: bold">None</span> <span style="color: #666666">=</span> <span style="color: #008000; font-weight: bold">None</span>) <span style="color: #666666">-&gt;</span> <span style="color: #008000">int</span>:
    parser <span style="color: #666666">=</span> argparse<span style="color: #666666">.</span>ArgumentParser(description<span style="color: #666666">=</span><span style="color: #BA2121">&quot;Review generated HTML documentation&quot;</span>)
    parser<span style="color: #666666">.</span>add_argument(<span style="color: #BA2121">&quot;directory&quot;</span>, help<span style="color: #666666">=</span><span style="color: #BA2121">&quot;Path to the HTML output directory&quot;</span>)
    parser<span style="color: #666666">.</span>add_argument(<span style="color: #BA2121">&quot;--autofix&quot;</span>, action<span style="color: #666666">=</span><span style="color: #BA2121">&quot;store_true&quot;</span>, help<span style="color: #666666">=</span><span style="color: #BA2121">&quot;Rewrite files to fix issues&quot;</span>)
    args <span style="color: #666666">=</span> parser<span style="color: #666666">.</span>parse_args(<span style="color: #008000">list</span>(argv) <span style="color: #008000; font-weight: bold">if</span> argv <span style="color: #AA22FF; font-weight: bold">is</span> <span style="color: #AA22FF; font-weight: bold">not</span> <span style="color: #008000; font-weight: bold">None</span> <span style="color: #008000; font-weight: bold">else</span> <span style="color: #008000; font-weight: bold">None</span>)

    review_directory(Path(args<span style="color: #666666">.</span>directory), autofix<span style="color: #666666">=</span>args<span style="color: #666666">.</span>autofix)
    <span style="color: #008000; font-weight: bold">return</span> <span style="color: #666666">0</span>
</code></pre>
    </div>
    <script src="static/toggle.js"></script>
</body>
</html>
