<!-- Generated by DocGen-LM -->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>Project Documentation</title>
    <link rel="stylesheet" href="static/style.css">
</head>
<body>
    <button id="sidebar-toggle">Menu</button>
    <div class="sidebar">
        <h2>Navigation</h2>
        <ul>
        <li><a href="cache.html">cache</a></li>
<li><a href="chunk_utils.html">chunk_utils</a></li>
<li><a href="docgenerator.html">docgenerator</a></li>
<li><a href="explaincode.html">explaincode</a></li>
<li><a href="gui_wrapper.html">gui_wrapper</a></li>
<li><a href="html_writer.html">html_writer</a></li>
<li><a href="llm_client.html">llm_client</a></li>
<li><a href="manual_utils.html">manual_utils</a></li>
<li><a href="parser_matlab.html">parser_matlab</a></li>
<li><a href="parser_python.html">parser_python</a></li>
<li><a href="reviewer.html">reviewer</a></li>
<li><a href="scanner.html">scanner</a></li>
<li><a href="setup.html">setup</a></li>
<li><a href="summarize_utils.html">summarize_utils</a></li>
<li><a href="test_cache.html">test_cache</a></li>
<li><a href="test_chunk_utils.html">test_chunk_utils</a></li>
<li><a href="test_docgenerator.html">test_docgenerator</a></li>
<li><a href="test_docgenerator_subclasses.html">test_docgenerator_subclasses</a></li>
<li><a href="test_explaincode.html">test_explaincode</a></li>
<li><a href="test_html_writer.html">test_html_writer</a></li>
<li><a href="test_integration.html">test_integration</a></li>
<li><a href="test_llm_client.html">test_llm_client</a></li>
<li><a href="test_manual_utils.html">test_manual_utils</a></li>
<li><a href="test_parser_matlab.html">test_parser_matlab</a></li>
<li><a href="test_parser_python.html">test_parser_python</a></li>
<li><a href="test_reviewer.html">test_reviewer</a></li>
<li><a href="test_scanner.html">test_scanner</a></li>
        </ul>
    </div>
    <div class="content">
        <h1>Project Documentation</h1>
        <p>DocGen-LM is a tool that generates static HTML documentation for Python and MATLAB projects by analyzing source files with a local LLM. It supports nested functions and subclasses, rendering complex structures as expandable sections in the output. The tool includes both CLI and GUI interfaces, allowing users to specify project directories, output paths, and LLM server details. Additionally, it provides a utility called `explaincode.py` for generating lightweight project summaries with options for PDF output and code scanning.
This project consists of multiple modules for generating documentation and analyzing code. The `cache.py` module provides a caching mechanism for responses. The `chunk_utils.py` module includes functions for chunking text into manageable parts. The `docgenerator.py` module handles the main logic for summarizing Python files, including parsing classes and functions, and generating summaries. The `explaincode.py` module focuses on collecting documentation from code, analyzing it, and injecting it into a user manual. The `gui_wrapper.py` module provides a graphical interface for running commands and displaying logs. The `html_writer.py` module generates HTML content from the collected data. The `llm_client.py` module interacts with a language model to generate summaries. The `manual_utils.py` module assists in parsing and summarizing user manuals. The `parser_matlab.py` and `parser_python.py` modules parse MATLAB and Python files, respectively. The `reviewer.py` module reviews the generated documentation for quality issues. The `scanner.py` module scans directories for source code files. The `summarize_utils.py` module provides utility functions for summarizing text. The project includes numerous test modules to ensure functionality across different aspects of the system.</p>
<hr/>
<h2>Modules</h2>
<ul style="list-style-type: none; padding-left: 0;">
<li style="margin-bottom: 1em;"><a href="cache.html">cache</a><br/><small>A simple on-disk cache for LLM responses. Implements methods to initialize the cache from a file, generate deterministic keys based on file paths and content, retrieve cached values by key, store new values with their keys, and persist the cache data to disk in JSON format.</small></li>
<li style="margin-bottom: 1em;"><a href="chunk_utils.html">chunk_utils</a><br/><small>This module provides utility functions for tokenization and text chunking. It includes:

1. `get_tokenizer()`: Returns a tokenizer object for estimating token counts, using the `tiktoken` library if available.
2. `_split_blocks(text: str) -&gt; List[str]`: Splits Markdown text into paragraphs, headings, and fenced code blocks.
3. `_split_long_block(block: str, tokenizer, chunk_size_tokens: int) -&gt; List[str]`: Fallback function to split long blocks by approximate character length if they exceed the specified token size.
4. `chunk_text(text: str, tokenizer, chunk_size_tokens: int) -&gt; List[str]`: Splits text into chunks roughly of the specified token size, honoring natural break points like blank lines and Markdown headings. If a block exceeds the token size, it falls back to splitting by character length.</small></li>
<li style="margin-bottom: 1em;"><a href="docgenerator.html">docgenerator</a><br/><small>This module provides a command-line interface for generating documentation using DocGen-LM. It scans a source tree for Python and MATLAB files, parses them, requests summaries from a running LLM, and writes HTML documentation. The script includes functions for cleaning the output directory, summarizing text chunks, handling module structure, and recursively summarizing classes and methods. This Python script generates HTML documentation using a local Large Language Model (LLM). It accepts command-line arguments to specify the source directory, output directory, and various options such as ignored paths, LLM URL, model name, and maximum context tokens. The script processes files in the source directory, parses them based on their extensions (Python or MATLAB), and generates summaries using the LLM. It handles exceptions for file encoding issues and syntax errors. The script also collects markdown documentation from README.md and any .md files within a &#x27;docs&#x27; subdirectory. After summarizing modules, classes, and functions, it writes HTML index and module pages to the output directory.</small></li>
<li style="margin-bottom: 1em;"><a href="explaincode.html">explaincode</a><br/><small>This module provides comprehensive functionality for generating project summaries from existing documentation and sample files. It includes classes, functions, and utilities for parsing configuration, collecting relevant files, slugifying text, inserting links into an index file, extracting text from various file types, detecting placeholders, mapping evidence to sections, ranking code files, and more. The module also defines functions to extract relevant code snippets from files, scan code for specific sections, generate a manual using an LLM, and fill placeholders in the manual with code snippets. It includes utilities for logging, time tracking, file size checks, and text extraction, designed to handle large numbers of files efficiently. Additionally, it provides functions to render HTML from structured sections of a manual, parse plain text into structured sections, validate references within sections, infer missing sections, and convert HTML to PDF. The module also interacts with an LLMClient for inferring missing sections based on provided text. Finally, the Python script defines a `main` function that sets up command-line arguments using the `argparse` module, processes these arguments to create a configuration object, collects document files, reads text from collected documents, initializes logging, generates an initial manual summary using an LLM client, detects missing sections, optionally scans project code to fill in missing sections, validates manual references and evidence map, renders the final HTML or PDF output based on the configured format, inserts a link to the generated manual into `index.html` if specified, saves the evidence map as a JSON file, and handles exceptions gracefully with fallbacks for LLM summarization failures.</small></li>
<li style="margin-bottom: 1em;"><a href="gui_wrapper.html">gui_wrapper</a><br/><small>A PyQt5 application for generating documentation and running ExplainCode. Features include:

- A dark-themed GUI with a header, project/output directory selectors, DocGen/ExplainCode options, and a log area.
- Drag-and-drop functionality for selecting directories/files in the GUI.
- Collapsible boxes to organize settings.
- Asynchronous command execution using `QThread` to handle long-running processes without blocking the main thread.
- Support for running DocGen and ExplainCode with customizable options.
- Logging of command output and process status.</small></li>
<li style="margin-bottom: 1em;"><a href="html_writer.html">html_writer</a><br/><small>This module provides HTML rendering utilities for generating documentation pages using simple template substitution. It includes functions for highlighting code snippets with Pygments and rendering HTML content based on templates. The module also defines functions to write index and module-specific documentation pages, handling project summaries, page links, and nested structures like classes and methods.</small></li>
<li style="margin-bottom: 1em;"><a href="llm_client.html">llm_client</a><br/><small>This module provides an interface to a local Large Language Model (LLM) backend called LMStudio. It includes:

- A `SYSTEM_PROMPT` for the documentation model.
- Common rules for prompt templates.
- A `README_PROMPT` for enriching project summaries from README files.
- A dictionary `PROMPT_TEMPLATES` containing different prompt templates for summarizing modules, classes, functions, READMEs, projects, docstrings, and user manuals.
- A `sanitize_summary` function to remove unwanted commentary from summaries.
- An `LLMClient` class that:
- Initializes with a base URL and model name.
- Includes a `ping` method to check if the API is reachable.
- Implements a `summarize` method to generate summaries using the LLM, handling retries on failures.</small></li>
<li style="margin-bottom: 1em;"><a href="manual_utils.html">manual_utils</a><br/><small>This module provides functions for splitting text into chunks and generating summaries using a language model. It includes utilities for token counting, text chunking, placeholder detection, and summarization with caching to improve performance. The module uses concurrent processing to handle large texts efficiently.</small></li>
<li style="margin-bottom: 1em;"><a href="parser_matlab.html">parser_matlab</a><br/><small>This module defines a function `parse_matlab_file` that takes the path to a MATLAB `.m` file and returns a dictionary containing the file&#x27;s header comments and any function declarations found. The function extracts leading comment lines as the file header and uses a regular expression to identify and parse function declarations, extracting their names and arguments.</small></li>
<li style="margin-bottom: 1em;"><a href="parser_python.html">parser_python</a><br/><small>This module provides a parser for Python files using the `ast` module. It extracts structured information according to the Software Requirements Specification (SRS). The parser can handle classes and functions, including their signatures, docstrings, and nested definitions. It also supports asynchronous functions and includes methods to parse entire Python source files into a structured dictionary format.</small></li>
<li style="margin-bottom: 1em;"><a href="reviewer.html">reviewer</a><br/><small>This module provides a tool for reviewing HTML documentation generated by DocGen-LM. It includes functions to check for assistant-like phrases, contradictions, and hallucinations in the HTML content. The `review_directory` function processes all `.html` files in a specified directory, applying checks and optionally fixing issues using an autofix feature. The main entry point is the `main` function, which parses command-line arguments to specify the directory to review and whether to enable autofix.</small></li>
<li style="margin-bottom: 1em;"><a href="scanner.html">scanner</a><br/><small>The module implements a function to recursively discover Python and Objective-C source files within a directory structure. It includes an internal helper function `_is_subpath` to check if one path is a subpath of another. The `scan_directory` function takes a base path and a list of ignore paths, then returns a sorted list of absolute paths to discovered source files, excluding those listed in the ignore list.</small></li>
<li style="margin-bottom: 1em;"><a href="setup.html">setup</a><br/><small>A Python script that uses `setuptools` to set up and configure a package. When executed, it runs the `setup()` function from `setuptools`, which typically handles tasks like installing dependencies, creating distribution packages, and managing project metadata.</small></li>
<li style="margin-bottom: 1em;"><a href="summarize_utils.html">summarize_utils</a><br/><small>This module provides functions for summarizing text using a language model client and caching responses. It includes:

1. `_summarize`: Summarizes text directly if it fits within the context token limit, otherwise returns cached summary.
2. `summarize_chunked`: Splits large texts into chunks to fit within context limits, summarizes each chunk, combines them, and caches the result.

The module uses a tokenizer for text processing, prompt templates, and system prompts. It handles exceptions during chunking and summarization processes, providing fallbacks and logging warnings.</small></li>
<li style="margin-bottom: 1em;"><a href="test_cache.html">test_cache</a><br/><small>The module defines two functions for testing a `ResponseCache` class. The first function, `test_cache_round_trip`, tests setting and retrieving a value from the cache. It creates a temporary file, initializes a `ResponseCache` instance with that file, sets a key-value pair in the cache, and then verifies that the value can be retrieved correctly.

The second function, `test_cache_get_missing`, tests retrieving a non-existent key from the cache. It initializes a `ResponseCache` instance with a new temporary file and attempts to retrieve a value for an unknown key, expecting `None` as the result.</small></li>
<li style="margin-bottom: 1em;"><a href="test_chunk_utils.html">test_chunk_utils</a><br/><small>The module contains tests for two functions: `get_tokenizer` and `chunk_text`. It verifies that the tokenizer encodes and decodes text correctly, reconstructs content when chunked, splits markdown headings appropriately, and preserves code blocks within chunks.</small></li>
<li style="margin-bottom: 1em;"><a href="test_docgenerator.html">test_docgenerator</a><br/><small>The module contains unit tests for a code documentation generator. It uses the `unittest.mock` library to patch dependencies and the `pathlib` library for file operations. The tests cover various scenarios such as skipping invalid Python files, generating summaries for classes and functions, handling non-UTF8 files, and ensuring project summaries are sanitized. Additionally, it includes tests for summarizing text in chunks, merging summaries recursively, and structuring chunkers to keep functions atomic or split large classes by methods.</small></li>
<li style="margin-bottom: 1em;"><a href="test_docgenerator_subclasses.html">test_docgenerator_subclasses</a><br/><small>This module defines a test function `test_subclass_docs_and_method_summary` that uses the `unittest.mock.patch` decorator to mock an `LLMClient` class from the `docgenerator` module. The test creates a temporary project directory with a Python file containing a nested class and method, then calls the `main` function from `docgenerator` with the path to the project directory and an output directory for documentation. It asserts that the return value of `main` is 0 and checks that the generated HTML documentation contains summaries for the subclass and method.</small></li>
<li style="margin-bottom: 1em;"><a href="test_explaincode.html">test_explaincode</a><br/><small>The module defines functions for creating documentation summaries, extracting text from files, rendering HTML, and handling various file formats. It includes a mock LLM client for summarization tasks, tests for different file types (Markdown, HTML, DOCX), and functionality to collect, map evidence, detect placeholders, parse manuals, validate references, infer sections, extract snippets, and scan code directories. The module also contains several test functions for a code documentation tool, covering aspects such as categorizing code snippets, filling placeholders using LLM responses, generating full documentation without scanning code, handling missing &quot;How to Run&quot; sections, skipping or forcing code fallback based on flags, customizing titles and filenames, inserting generated documentation into index files, and testing default and injected documentation into existing docs directories. Additionally, it includes tests for a summarization process, including chunking triggers, applying edit hooks, parallel summarization, hierarchical merge logging, cached chunks reuse, and avoiding LLM calls when chunking is set to none.</small></li>
<li style="margin-bottom: 1em;"><a href="test_html_writer.html">test_html_writer</a><br/><small>The module defines functions to generate HTML documentation for projects and modules. It includes:

- `write_index`: Generates an index page listing project summary, links to modules, and summaries of each module.
- `write_module_page`: Generates a detailed HTML page for a specific module, including its name, summary, classes, methods, and functions.
- `test_write_index`, `test_write_module_page`, `test_subfunction_rendering`, and `test_subclass_rendering`: Unit tests to verify the correctness of the above functions.</small></li>
<li style="margin-bottom: 1em;"><a href="test_integration.html">test_integration</a><br/><small>The module defines two tests for a documentation generator. The first test, `test_docgenerator_generates_html`, checks that the generator can process Python and MATLAB files in a project directory and produce HTML output with summaries. It uses a mock LLMClient to simulate API responses.

The second test, `test_static_copied_from_any_cwd`, ensures that static files like CSS are copied to the output directory regardless of the current working directory when running the generator.</small></li>
<li style="margin-bottom: 1em;"><a href="test_llm_client.html">test_llm_client</a><br/><small>The module defines a set of unit tests for an `LLMClient` class. The client interacts with a language model to generate summaries and sanitize text. The tests cover various scenarios, including successful pinging, handling exceptions during pinging, retrying summary generation, raising runtime errors, sanitizing text, and ensuring prompt templates vary by type (class, function, readme).</small></li>
<li style="margin-bottom: 1em;"><a href="test_manual_utils.html">test_manual_utils</a><br/><small>The module defines two functions: `_count` and `test_chunk_docs_respects_token_limit`, `test_find_placeholders`. The `_count` function calculates the number of tokens in a given text using a tokenizer from `manual_utils`. The `test_chunk_docs_respects_token_limit` function tests if documents are chunked correctly according to a token limit. The `test_find_placeholders` function checks if placeholders within a text are identified and returned as a set.</small></li>
<li style="margin-bottom: 1em;"><a href="test_parser_matlab.html">test_parser_matlab</a><br/><small>This module includes two test functions for parsing MATLAB files. The `test_parse_simple_matlab` function checks if the parser correctly extracts a header and a single function from a simple MATLAB file. The `test_parse_multiple_functions` function verifies that the parser can handle multiple functions in a single file, including their names and arguments.</small></li>
<li style="margin-bottom: 1em;"><a href="test_parser_python.html">test_parser_python</a><br/><small>This module contains tests for parsing Python files using the `parse_python_file` function from the `parser_python` module. It includes several test cases to verify the correctness of the parser, covering various scenarios such as simple modules, complex function signatures, nested structures, deeply nested classes, and classes inside methods. Each test case creates a temporary Python file with specific content, parses it using `parse_python_file`, and asserts that the parsed results match the expected structure and attributes of the code.</small></li>
<li style="margin-bottom: 1em;"><a href="test_reviewer.html">test_reviewer</a><br/><small>The module defines a test suite for a code review tool. It includes functions to create temporary module pages, and tests to detect issues such as assistant phrasing, contradictions, and hallucinations in the code documentation. The `test_autofix_removes_phrasing` function also checks if autofix functionality removes specified phrases from the generated HTML files.</small></li>
<li style="margin-bottom: 1em;"><a href="test_scanner.html">test_scanner</a><br/><small>The module defines a test suite for the `scan_directory` function from the `scanner` module. It includes three tests:

1. **test_scan_directory_ignore_folder**: Creates files and directories, including an &quot;ignore_me&quot; directory with a file inside it. Tests that the `scan_directory` function ignores the &quot;ignore_me&quot; directory when provided as an ignore list.

2. **test_scan_directory_mixed_file_types**: Creates files of various types (Python, M, TXT) in different directories. Tests that the `scan_directory` function returns only Python and M files, excluding TXT files and nested MD files.

3. **test_scan_directory_skips_git_folder**: Creates a file inside a `.git` directory. Tests that the `scan_directory` function skips any files within the `.git` directory from the results.</small></li>
</ul>
    </div>
    <script src="static/toggle.js"></script>
</body>
</html>
