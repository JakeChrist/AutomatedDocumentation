<!-- Generated by DocGen-LM -->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>chunk_utils</title>
    <link rel="stylesheet" href="static/style.css">
</head>
<body>
    <button id="sidebar-toggle">Menu</button>
    <div class="sidebar">
        <h2>Navigation</h2>
        <ul><li><a href="index.html"><strong>üè† Project Overview</strong></a></li><li><a href="cache.html">cache</a></li><li><a href="chunk_utils.html">chunk_utils</a></li><li><a href="docgenerator.html">docgenerator</a></li><li><a href="explaincode.html">explaincode</a></li><li><a href="gui_wrapper.html">gui_wrapper</a></li><li><a href="html_writer.html">html_writer</a></li><li><a href="llm_client.html">llm_client</a></li><li><a href="manual_utils.html">manual_utils</a></li><li><a href="parser_cpp.html">parser_cpp</a></li><li><a href="parser_java.html">parser_java</a></li><li><a href="parser_matlab.html">parser_matlab</a></li><li><a href="parser_python.html">parser_python</a></li><li><a href="retrofit_sidebar.html">retrofit_sidebar</a></li><li><a href="reviewer.html">reviewer</a></li><li><a href="sanitize_docs.html">sanitize_docs</a></li><li><a href="scanner.html">scanner</a></li><li><a href="setup.html">setup</a></li><li><a href="summarize_utils.html">summarize_utils</a></li><li><details><summary>tests</summary><ul><li><a href="test_cache.html">test_cache</a></li><li><a href="test_chunk_utils.html">test_chunk_utils</a></li><li><a href="test_docgenerator.html">test_docgenerator</a></li><li><a href="test_docgenerator_subclasses.html">test_docgenerator_subclasses</a></li><li><a href="test_explaincode.html">test_explaincode</a></li><li><a href="test_html_writer.html">test_html_writer</a></li><li><a href="test_integration.html">test_integration</a></li><li><a href="test_llm_client.html">test_llm_client</a></li><li><a href="test_manual_utils.html">test_manual_utils</a></li><li><a href="test_parser_cpp.html">test_parser_cpp</a></li><li><a href="test_parser_java.html">test_parser_java</a></li><li><a href="test_parser_matlab.html">test_parser_matlab</a></li><li><a href="test_parser_python.html">test_parser_python</a></li><li><a href="test_resume_progress.html">test_resume_progress</a></li><li><a href="test_retrofit_sidebar.html">test_retrofit_sidebar</a></li><li><a href="test_reviewer.html">test_reviewer</a></li><li><a href="test_sanitize_docs.html">test_sanitize_docs</a></li><li><a href="test_scanner.html">test_scanner</a></li></ul></details></li></ul>
    </div>
    <div class="content">
        <h1>chunk_utils</h1>
        <p>The module provides utilities for splitting text into chunks based on natural boundaries like blank lines, Markdown headings, and code fences. It includes functions to estimate token counts using the `tiktoken` library, with a fallback to a simple space-based tokenizer if `tiktoken` is unavailable. The main function `chunk_text` splits input text into segments approximately matching a specified token size, preserving structural elements of the text. When a single block exceeds the token limit, it falls back to character-based splitting to ensure all content is included. Helper functions manage the identification of text blocks and handle the fallback splitting logic for oversized sections.</p>
<h2>Functions</h2>
<h3 id="strip_fim_tokens">strip_fim_tokens(text: str) -&gt; str</h3>
<p>The function `strip_fim_tokens` removes FIM (Fill-In-Middle) special tokens from the input string `text`. It uses a regular expression `FIM_RE` to identify and substitute these tokens with empty strings, effectively stripping them from the text. The function returns the modified string with the tokens removed.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">strip_fim_tokens</span>(text: <span style="color: #008000">str</span>) <span style="color: #666666">-&gt;</span> <span style="color: #008000">str</span>:
<span style="color: #bbbbbb">    </span><span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;Return ``text`` with any FIM special tokens removed.&quot;&quot;&quot;</span>

    <span style="color: #008000; font-weight: bold">return</span> FIM_RE<span style="color: #666666">.</span>sub(<span style="color: #BA2121">&quot;&quot;</span>, text)
</code></pre>
<h3 id="get_tokenizer">get_tokenizer()</h3>
<p>The function `get_tokenizer()` returns a tokenizer object for estimating token counts. It attempts to use the `tiktoken` library to load the `cl100k_base` encoding, with fallback to `gpt-3.5-turbo` if the former fails. To prevent network-related warnings during encoding loading, it temporarily suppresses unraisable exception hooks. If `tiktoken` is unavailable or fails to load, it provides a simple fallback tokenizer that splits text into tokens by whitespace and joins them back with spaces. A warning message is printed to `stderr` if `tiktoken` is not available. The returned tokenizer supports `encode` and `decode` methods, with `encode` stripping FIM tokens before processing.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">get_tokenizer</span>():
<span style="color: #bbbbbb">    </span><span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;Return a tokenizer object used for estimating token counts.&quot;&quot;&quot;</span>

    <span style="color: #008000; font-weight: bold">if</span> tiktoken <span style="color: #AA22FF; font-weight: bold">is</span> <span style="color: #AA22FF; font-weight: bold">not</span> <span style="color: #008000; font-weight: bold">None</span>:  <span style="color: #3D7B7B; font-style: italic"># pragma: no cover - optional branch</span>
        enc <span style="color: #666666">=</span> <span style="color: #008000; font-weight: bold">None</span>
        <span style="color: #3D7B7B; font-style: italic"># ``tiktoken`` may attempt network access when loading encodings which</span>
        <span style="color: #3D7B7B; font-style: italic"># can trigger unraisable ``ProxyError`` warnings under pytest.  Temporarily</span>
        <span style="color: #3D7B7B; font-style: italic"># override the unraisable hook to swallow such errors.</span>
        old_hook <span style="color: #666666">=</span> <span style="color: #008000">getattr</span>(sys, <span style="color: #BA2121">&quot;unraisablehook&quot;</span>, <span style="color: #008000; font-weight: bold">None</span>)
        <span style="color: #008000; font-weight: bold">try</span>:
            <span style="color: #008000; font-weight: bold">if</span> old_hook <span style="color: #AA22FF; font-weight: bold">is</span> <span style="color: #AA22FF; font-weight: bold">not</span> <span style="color: #008000; font-weight: bold">None</span>:
                sys<span style="color: #666666">.</span>unraisablehook <span style="color: #666666">=</span> <span style="color: #008000; font-weight: bold">lambda</span> <span style="color: #666666">*</span>a, <span style="color: #666666">**</span>k: <span style="color: #008000; font-weight: bold">None</span>
            <span style="color: #008000; font-weight: bold">try</span>:
                enc <span style="color: #666666">=</span> tiktoken<span style="color: #666666">.</span>get_encoding(<span style="color: #BA2121">&quot;cl100k_base&quot;</span>)
            <span style="color: #008000; font-weight: bold">except</span> <span style="color: #CB3F38; font-weight: bold">Exception</span>:  <span style="color: #3D7B7B; font-style: italic"># pragma: no cover - fallback if model unknown or offline</span>
                <span style="color: #008000; font-weight: bold">try</span>:
                    enc <span style="color: #666666">=</span> tiktoken<span style="color: #666666">.</span>encoding_for_model(<span style="color: #BA2121">&quot;gpt-3.5-turbo&quot;</span>)
                <span style="color: #008000; font-weight: bold">except</span> <span style="color: #CB3F38; font-weight: bold">Exception</span>:
                    enc <span style="color: #666666">=</span> <span style="color: #008000; font-weight: bold">None</span>
        <span style="color: #008000; font-weight: bold">finally</span>:
            <span style="color: #008000; font-weight: bold">if</span> old_hook <span style="color: #AA22FF; font-weight: bold">is</span> <span style="color: #AA22FF; font-weight: bold">not</span> <span style="color: #008000; font-weight: bold">None</span>:
                sys<span style="color: #666666">.</span>unraisablehook <span style="color: #666666">=</span> old_hook

        <span style="color: #008000; font-weight: bold">if</span> enc <span style="color: #AA22FF; font-weight: bold">is</span> <span style="color: #AA22FF; font-weight: bold">not</span> <span style="color: #008000; font-weight: bold">None</span>:
            <span style="color: #008000; font-weight: bold">class</span> <span style="color: #0000FF; font-weight: bold">_EncodingWrapper</span>:
                <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">__init__</span>(<span style="color: #008000">self</span>, enc):
                    <span style="color: #008000">self</span><span style="color: #666666">.</span>_enc <span style="color: #666666">=</span> enc

                <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">encode</span>(<span style="color: #008000">self</span>, text: <span style="color: #008000">str</span>, <span style="color: #666666">**</span>kwargs):
                    text <span style="color: #666666">=</span> strip_fim_tokens(text)
                    kwargs<span style="color: #666666">.</span>setdefault(<span style="color: #BA2121">&quot;disallowed_special&quot;</span>, ())
                    <span style="color: #008000; font-weight: bold">return</span> <span style="color: #008000">self</span><span style="color: #666666">.</span>_enc<span style="color: #666666">.</span>encode(text, <span style="color: #666666">**</span>kwargs)

                <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">decode</span>(<span style="color: #008000">self</span>, tokens, <span style="color: #666666">**</span>kwargs):
                    <span style="color: #008000; font-weight: bold">return</span> <span style="color: #008000">self</span><span style="color: #666666">.</span>_enc<span style="color: #666666">.</span>decode(tokens, <span style="color: #666666">**</span>kwargs)

            <span style="color: #008000; font-weight: bold">return</span> _EncodingWrapper(enc)

    <span style="color: #008000">print</span>(
        <span style="color: #BA2121">&quot;[WARNING] tiktoken is not installed or could not be loaded; token counts will be approximate.&quot;</span>,
        file<span style="color: #666666">=</span>sys<span style="color: #666666">.</span>stderr,
    )

    <span style="color: #008000; font-weight: bold">class</span> <span style="color: #0000FF; font-weight: bold">_Simple</span>:
        <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">encode</span>(<span style="color: #008000">self</span>, text: <span style="color: #008000">str</span>):
            text <span style="color: #666666">=</span> strip_fim_tokens(text)
            <span style="color: #008000; font-weight: bold">return</span> text<span style="color: #666666">.</span>split()

        <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">decode</span>(<span style="color: #008000">self</span>, tokens):
            <span style="color: #008000; font-weight: bold">return</span> <span style="color: #BA2121">&quot; &quot;</span><span style="color: #666666">.</span>join(tokens)

    <span style="color: #008000; font-weight: bold">return</span> _Simple()
</code></pre>
<h3 id="_split_blocks">_split_blocks(text: str) -&gt; List[str]</h3>
<p>The function `_split_blocks` takes a Markdown-formatted text string and splits it into distinct blocks, separating paragraphs, headings, and code fences. It processes the input line by line, tracking whether it is inside a code block (indicated by triple backticks) and appending lines accordingly. When encountering a new heading (line starting with `#`) or an empty line, it finalizes the current block and starts a new one. The result is a list of strings, each representing a distinct block of content from the input text.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">_split_blocks</span>(text: <span style="color: #008000">str</span>) <span style="color: #666666">-&gt;</span> List[<span style="color: #008000">str</span>]:
<span style="color: #bbbbbb">    </span><span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;Return Markdown ``text`` separated into paragraphs, headings and fences.&quot;&quot;&quot;</span>

    blocks: List[<span style="color: #008000">str</span>] <span style="color: #666666">=</span> []
    lines <span style="color: #666666">=</span> text<span style="color: #666666">.</span>splitlines()
    current: List[<span style="color: #008000">str</span>] <span style="color: #666666">=</span> []
    in_code <span style="color: #666666">=</span> <span style="color: #008000; font-weight: bold">False</span>

    <span style="color: #008000; font-weight: bold">for</span> line <span style="color: #AA22FF; font-weight: bold">in</span> lines:
        <span style="color: #008000; font-weight: bold">if</span> line<span style="color: #666666">.</span>startswith(<span style="color: #BA2121">&quot;```&quot;</span>):
            <span style="color: #008000; font-weight: bold">if</span> in_code:  <span style="color: #3D7B7B; font-style: italic"># closing fence</span>
                current<span style="color: #666666">.</span>append(line)
                blocks<span style="color: #666666">.</span>append(<span style="color: #BA2121">&quot;</span><span style="color: #AA5D1F; font-weight: bold">\n</span><span style="color: #BA2121">&quot;</span><span style="color: #666666">.</span>join(current)<span style="color: #666666">.</span>strip())
                current <span style="color: #666666">=</span> []
                in_code <span style="color: #666666">=</span> <span style="color: #008000; font-weight: bold">False</span>
            <span style="color: #008000; font-weight: bold">else</span>:  <span style="color: #3D7B7B; font-style: italic"># opening fence</span>
                <span style="color: #008000; font-weight: bold">if</span> current:
                    blocks<span style="color: #666666">.</span>append(<span style="color: #BA2121">&quot;</span><span style="color: #AA5D1F; font-weight: bold">\n</span><span style="color: #BA2121">&quot;</span><span style="color: #666666">.</span>join(current)<span style="color: #666666">.</span>strip())
                    current <span style="color: #666666">=</span> []
                current<span style="color: #666666">.</span>append(line)
                in_code <span style="color: #666666">=</span> <span style="color: #008000; font-weight: bold">True</span>
            <span style="color: #008000; font-weight: bold">continue</span>

        <span style="color: #008000; font-weight: bold">if</span> in_code:
            current<span style="color: #666666">.</span>append(line)
            <span style="color: #008000; font-weight: bold">continue</span>

        <span style="color: #008000; font-weight: bold">if</span> line<span style="color: #666666">.</span>strip() <span style="color: #666666">==</span> <span style="color: #BA2121">&quot;&quot;</span>:
            <span style="color: #008000; font-weight: bold">if</span> current:
                blocks<span style="color: #666666">.</span>append(<span style="color: #BA2121">&quot;</span><span style="color: #AA5D1F; font-weight: bold">\n</span><span style="color: #BA2121">&quot;</span><span style="color: #666666">.</span>join(current)<span style="color: #666666">.</span>strip())
                current <span style="color: #666666">=</span> []
            <span style="color: #008000; font-weight: bold">continue</span>

        <span style="color: #008000; font-weight: bold">if</span> line<span style="color: #666666">.</span>lstrip()<span style="color: #666666">.</span>startswith(<span style="color: #BA2121">&quot;#&quot;</span>):
            <span style="color: #008000; font-weight: bold">if</span> current:
                blocks<span style="color: #666666">.</span>append(<span style="color: #BA2121">&quot;</span><span style="color: #AA5D1F; font-weight: bold">\n</span><span style="color: #BA2121">&quot;</span><span style="color: #666666">.</span>join(current)<span style="color: #666666">.</span>strip())
            blocks<span style="color: #666666">.</span>append(line<span style="color: #666666">.</span>strip())
            current <span style="color: #666666">=</span> []
            <span style="color: #008000; font-weight: bold">continue</span>

        current<span style="color: #666666">.</span>append(line)

    <span style="color: #008000; font-weight: bold">if</span> current:
        blocks<span style="color: #666666">.</span>append(<span style="color: #BA2121">&quot;</span><span style="color: #AA5D1F; font-weight: bold">\n</span><span style="color: #BA2121">&quot;</span><span style="color: #666666">.</span>join(current)<span style="color: #666666">.</span>strip())

    <span style="color: #008000; font-weight: bold">return</span> [b <span style="color: #008000; font-weight: bold">for</span> b <span style="color: #AA22FF; font-weight: bold">in</span> blocks <span style="color: #008000; font-weight: bold">if</span> b]
</code></pre>
<h3 id="_split_long_block">_split_long_block(block: str, tokenizer, chunk_size_tokens: int) -&gt; List[str]</h3>
<p>The function `_split_long_block` splits a text block into smaller chunks based on a token limit using a character-based approximation when the token count exceeds the specified chunk size. It encodes the input block using a provided tokenizer, calculates an average character length per token, determines the maximum number of characters per chunk, and then divides the block into segments of that size. If the block&#x27;s token count is less than or equal to the chunk size, it returns the block as a single-element list. The function handles edge cases where tokenization might result in zero-length averages by ensuring minimum values are used.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">_split_long_block</span>(block: <span style="color: #008000">str</span>, tokenizer, chunk_size_tokens: <span style="color: #008000">int</span>) <span style="color: #666666">-&gt;</span> List[<span style="color: #008000">str</span>]:
<span style="color: #bbbbbb">    </span><span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;Fallback splitter that uses a character based approximation.&quot;&quot;&quot;</span>

    tokens <span style="color: #666666">=</span> tokenizer<span style="color: #666666">.</span>encode(block)
    <span style="color: #008000; font-weight: bold">if</span> <span style="color: #008000">len</span>(tokens) <span style="color: #666666">&lt;=</span> chunk_size_tokens:
        <span style="color: #008000; font-weight: bold">return</span> [block]

    avg_chars <span style="color: #666666">=</span> <span style="color: #008000">max</span>(<span style="color: #008000">len</span>(block) <span style="color: #666666">//</span> <span style="color: #008000">len</span>(tokens), <span style="color: #666666">1</span>)
    max_chars <span style="color: #666666">=</span> <span style="color: #008000">max</span>(chunk_size_tokens <span style="color: #666666">*</span> avg_chars, <span style="color: #666666">1</span>)
    <span style="color: #008000; font-weight: bold">return</span> [block[i : i <span style="color: #666666">+</span> max_chars] <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(<span style="color: #666666">0</span>, <span style="color: #008000">len</span>(block), max_chars)]
</code></pre>
<h3 id="chunk_text">chunk_text(text: str, tokenizer, chunk_size_tokens: int) -&gt; List[str]</h3>
<p>The function `chunk_text` divides a given text into smaller segments, where each segment contains approximately a specified number of tokens. It processes the text by identifying natural breakpoints such as blank lines, Markdown headings, and code blocks to preserve structure. If a block exceeds the token limit, it is further split based on character length. The function utilizes a provided tokenizer to calculate token counts and returns a list of text chunks that adhere to the specified token size constraint.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">chunk_text</span>(text: <span style="color: #008000">str</span>, tokenizer, chunk_size_tokens: <span style="color: #008000">int</span>) <span style="color: #666666">-&gt;</span> List[<span style="color: #008000">str</span>]:
<span style="color: #bbbbbb">    </span><span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;Split ``text`` into chunks roughly ``chunk_size_tokens`` each.</span>

<span style="color: #BA2121; font-style: italic">    Natural break points such as blank lines, Markdown headings and fenced code</span>
<span style="color: #BA2121; font-style: italic">    blocks are honoured.  If a single block still exceeds ``chunk_size_tokens``</span>
<span style="color: #BA2121; font-style: italic">    the function falls back to splitting that block by approximate character</span>
<span style="color: #BA2121; font-style: italic">    length.</span>
<span style="color: #BA2121; font-style: italic">    &quot;&quot;&quot;</span>

    blocks <span style="color: #666666">=</span> _split_blocks(text)
    chunks: List[<span style="color: #008000">str</span>] <span style="color: #666666">=</span> []
    current: List[<span style="color: #008000">str</span>] <span style="color: #666666">=</span> []
    token_count <span style="color: #666666">=</span> <span style="color: #666666">0</span>

    <span style="color: #008000; font-weight: bold">for</span> block <span style="color: #AA22FF; font-weight: bold">in</span> blocks:
        block_tokens <span style="color: #666666">=</span> <span style="color: #008000">len</span>(tokenizer<span style="color: #666666">.</span>encode(block))
        <span style="color: #008000; font-weight: bold">if</span> token_count <span style="color: #666666">+</span> block_tokens <span style="color: #666666">&gt;</span> chunk_size_tokens <span style="color: #AA22FF; font-weight: bold">and</span> current:
            chunks<span style="color: #666666">.</span>append(<span style="color: #BA2121">&quot;</span><span style="color: #AA5D1F; font-weight: bold">\n\n</span><span style="color: #BA2121">&quot;</span><span style="color: #666666">.</span>join(current))
            current <span style="color: #666666">=</span> []
            token_count <span style="color: #666666">=</span> <span style="color: #666666">0</span>

        <span style="color: #008000; font-weight: bold">if</span> block_tokens <span style="color: #666666">&gt;</span> chunk_size_tokens:
            chunks<span style="color: #666666">.</span>extend(_split_long_block(block, tokenizer, chunk_size_tokens))
            <span style="color: #008000; font-weight: bold">continue</span>

        current<span style="color: #666666">.</span>append(block)
        token_count <span style="color: #666666">+=</span> block_tokens

    <span style="color: #008000; font-weight: bold">if</span> current:
        chunks<span style="color: #666666">.</span>append(<span style="color: #BA2121">&quot;</span><span style="color: #AA5D1F; font-weight: bold">\n\n</span><span style="color: #BA2121">&quot;</span><span style="color: #666666">.</span>join(current))

    <span style="color: #008000; font-weight: bold">return</span> chunks
</code></pre>
    </div>
    <script src="static/toggle.js"></script>
</body>
</html>
