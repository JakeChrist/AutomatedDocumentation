<!-- Generated by DocGen-LM -->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>test_docgenerator</title>
    <link rel="stylesheet" href="static/style.css">
</head>
<body>
    <button id="sidebar-toggle">Menu</button>
    <div class="sidebar">
        <h2>Navigation</h2>
        <ul>
        <li><a href="index.html"><strong>üè† Project Overview</strong></a></li>
<li><a href="cache.html">cache</a></li>
<li><a href="chunk_utils.html">chunk_utils</a></li>
<li><a href="docgenerator.html">docgenerator</a></li>
<li><a href="explaincode.html">explaincode</a></li>
<li><a href="gui_wrapper.html">gui_wrapper</a></li>
<li><a href="html_writer.html">html_writer</a></li>
<li><a href="llm_client.html">llm_client</a></li>
<li><a href="manual_utils.html">manual_utils</a></li>
<li><a href="parser_matlab.html">parser_matlab</a></li>
<li><a href="parser_python.html">parser_python</a></li>
<li><a href="reviewer.html">reviewer</a></li>
<li><a href="scanner.html">scanner</a></li>
<li><a href="setup.html">setup</a></li>
<li><a href="summarize_utils.html">summarize_utils</a></li>
<li><a href="test_cache.html">test_cache</a></li>
<li><a href="test_chunk_utils.html">test_chunk_utils</a></li>
<li><a href="test_docgenerator.html">test_docgenerator</a></li>
<li><a href="test_docgenerator_subclasses.html">test_docgenerator_subclasses</a></li>
<li><a href="test_explaincode.html">test_explaincode</a></li>
<li><a href="test_html_writer.html">test_html_writer</a></li>
<li><a href="test_integration.html">test_integration</a></li>
<li><a href="test_llm_client.html">test_llm_client</a></li>
<li><a href="test_manual_utils.html">test_manual_utils</a></li>
<li><a href="test_parser_matlab.html">test_parser_matlab</a></li>
<li><a href="test_parser_python.html">test_parser_python</a></li>
<li><a href="test_reviewer.html">test_reviewer</a></li>
<li><a href="test_scanner.html">test_scanner</a></li>
        </ul>
    </div>
    <div class="content">
        <h1>test_docgenerator</h1>
        <p>This module contains unit tests for a Python script that generates documentation from source code using an LLM (Large Language Model). The tests cover various scenarios, including:

1. Skipping invalid Python files.
2. Generating summaries for classes and functions.
3. Handling non-UTF8 encoded files.
4. Summarizing modules without docstrings.
5. Sanitizing project summaries.
6. Using README content as a summary.
7. Cleaning the output directory before generating new documentation.
8. Splitting long texts into chunks to fit within context token limits.
9. Recursively chunking text when prompt overhead exceeds available tokens.
10. Keeping functions atomic during structured chunking.
11. Splitting large classes by method during structured chunking.
12. Summarizing methods in subclasses.

The tests use the `unittest.mock` library to patch dependencies and verify that the main function (`docgenerator.main`) behaves as expected under different conditions.</p>
<h2>Functions</h2>
<h3 id="test_skips_invalid_python_file">test_skips_invalid_python_file(tmp_path: Path) -&gt; None</h3>
<p>The function `test_skips_invalid_python_file` is designed to test the behavior of a documentation generation tool when encountering an invalid Python file. It sets up a temporary project directory with a single Python file that contains invalid syntax due to a leading zero in an integer literal (`x = 08`). The function then calls the `main` function of the documentation generator, passing the path to the project directory and specifying an output directory for the generated documentation.

The test uses a mock object for the language model client (`LLMClient`) to simulate responses. It asserts that the main function returns successfully (exit code 0) and checks that only the index page is generated in the output directory, while no HTML file is created for the invalid Python file.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">test_skips_invalid_python_file</span>(tmp_path: Path) <span style="color: #666666">-&gt;</span> <span style="color: #008000; font-weight: bold">None</span>:
    project_dir <span style="color: #666666">=</span> tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;proj&quot;</span>
    project_dir<span style="color: #666666">.</span>mkdir()
    <span style="color: #3D7B7B; font-style: italic"># file with invalid syntax due to leading zero</span>
    (project_dir <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;bad.py&quot;</span>)<span style="color: #666666">.</span>write_text(<span style="color: #BA2121">&quot;x = 08</span><span style="color: #AA5D1F; font-weight: bold">\n</span><span style="color: #BA2121">&quot;</span>)

    output_dir <span style="color: #666666">=</span> tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;docs&quot;</span>

    <span style="color: #008000; font-weight: bold">with</span> patch(<span style="color: #BA2121">&quot;docgenerator.LLMClient&quot;</span>) <span style="color: #008000; font-weight: bold">as</span> MockClient:
        instance <span style="color: #666666">=</span> MockClient<span style="color: #666666">.</span>return_value
        instance<span style="color: #666666">.</span>ping<span style="color: #666666">.</span>return_value <span style="color: #666666">=</span> <span style="color: #008000; font-weight: bold">True</span>
        instance<span style="color: #666666">.</span>summarize<span style="color: #666666">.</span>return_value <span style="color: #666666">=</span> <span style="color: #BA2121">&quot;summary&quot;</span>
        ret <span style="color: #666666">=</span> main([<span style="color: #008000">str</span>(project_dir), <span style="color: #BA2121">&quot;--output&quot;</span>, <span style="color: #008000">str</span>(output_dir)])
        <span style="color: #008000; font-weight: bold">assert</span> ret <span style="color: #666666">==</span> <span style="color: #666666">0</span>

    <span style="color: #3D7B7B; font-style: italic"># only index page should be generated</span>
    <span style="color: #008000; font-weight: bold">assert</span> (output_dir <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;index.html&quot;</span>)<span style="color: #666666">.</span>exists()
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #AA22FF; font-weight: bold">not</span> (output_dir <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;bad.html&quot;</span>)<span style="color: #666666">.</span>exists()
</code></pre>
<h3 id="test_generates_class_and_function_summaries">test_generates_class_and_function_summaries(tmp_path: Path) -&gt; None</h3>
<p>This function `test_generates_class_and_function_summaries` is designed to test the generation of summaries for classes and functions within a Python project. It creates a temporary directory structure with a Python module containing a class and a function, then invokes the main documentation generation process using a mock language model client. The test asserts that the output HTML files contain the expected summaries for the class and function, as well as the module level summary.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">test_generates_class_and_function_summaries</span>(tmp_path: Path) <span style="color: #666666">-&gt;</span> <span style="color: #008000; font-weight: bold">None</span>:
    project_dir <span style="color: #666666">=</span> tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;proj&quot;</span>
    project_dir<span style="color: #666666">.</span>mkdir()
    (project_dir <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;mod.py&quot;</span>)<span style="color: #666666">.</span>write_text(
        <span style="color: #BA2121">&#39;class Foo:</span><span style="color: #AA5D1F; font-weight: bold">\n</span><span style="color: #BA2121">    &quot;&quot;&quot;Doc&quot;&quot;&quot;</span><span style="color: #AA5D1F; font-weight: bold">\n</span><span style="color: #BA2121">    pass</span><span style="color: #AA5D1F; font-weight: bold">\n\n</span><span style="color: #BA2121">&#39;</span> <span style="color: #BA2121">&quot;def bar():</span><span style="color: #AA5D1F; font-weight: bold">\n</span><span style="color: #BA2121">    return 1</span><span style="color: #AA5D1F; font-weight: bold">\n</span><span style="color: #BA2121">&quot;</span>
    )

    output_dir <span style="color: #666666">=</span> tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;docs&quot;</span>

    <span style="color: #008000; font-weight: bold">with</span> patch(<span style="color: #BA2121">&quot;docgenerator.LLMClient&quot;</span>) <span style="color: #008000; font-weight: bold">as</span> MockClient:
        instance <span style="color: #666666">=</span> MockClient<span style="color: #666666">.</span>return_value
        instance<span style="color: #666666">.</span>ping<span style="color: #666666">.</span>return_value <span style="color: #666666">=</span> <span style="color: #008000; font-weight: bold">True</span>
        instance<span style="color: #666666">.</span>summarize<span style="color: #666666">.</span>side_effect <span style="color: #666666">=</span> [
            <span style="color: #BA2121">&quot;module summary&quot;</span>,
            <span style="color: #BA2121">&quot;project summary&quot;</span>,
            <span style="color: #BA2121">&quot;class summary&quot;</span>,
            <span style="color: #BA2121">&quot;improved class doc&quot;</span>,
            <span style="color: #BA2121">&quot;function summary&quot;</span>,
            <span style="color: #BA2121">&quot;improved function doc&quot;</span>,
        ]
        ret <span style="color: #666666">=</span> main([<span style="color: #008000">str</span>(project_dir), <span style="color: #BA2121">&quot;--output&quot;</span>, <span style="color: #008000">str</span>(output_dir)])
        <span style="color: #008000; font-weight: bold">assert</span> ret <span style="color: #666666">==</span> <span style="color: #666666">0</span>

    html <span style="color: #666666">=</span> (output_dir <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;mod.html&quot;</span>)<span style="color: #666666">.</span>read_text(encoding<span style="color: #666666">=</span><span style="color: #BA2121">&quot;utf-8&quot;</span>)
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #BA2121">&quot;improved class doc&quot;</span> <span style="color: #AA22FF; font-weight: bold">in</span> html
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #BA2121">&quot;function summary&quot;</span> <span style="color: #AA22FF; font-weight: bold">in</span> html
    index_html <span style="color: #666666">=</span> (output_dir <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;index.html&quot;</span>)<span style="color: #666666">.</span>read_text(encoding<span style="color: #666666">=</span><span style="color: #BA2121">&quot;utf-8&quot;</span>)
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #BA2121">&quot;module summary&quot;</span> <span style="color: #AA22FF; font-weight: bold">in</span> index_html
</code></pre>
<h3 id="test_skips_non_utf8_file">test_skips_non_utf8_file(tmp_path: Path) -&gt; None</h3>
<p>The function `test_skips_non_utf8_file` tests the behavior of a documentation generation tool when encountering non-UTF-8 encoded files. It creates a temporary project directory with a file that contains non-UTF-8 bytes, mocks an LLM client to simulate successful responses, and then runs the main documentation generation function. The test asserts that the non-UTF-8 file is skipped during processing and that only valid UTF-8 files are included in the output directory.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">test_skips_non_utf8_file</span>(tmp_path: Path) <span style="color: #666666">-&gt;</span> <span style="color: #008000; font-weight: bold">None</span>:
    project_dir <span style="color: #666666">=</span> tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;proj&quot;</span>
    project_dir<span style="color: #666666">.</span>mkdir()
    (project_dir <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;bad.py&quot;</span>)<span style="color: #666666">.</span>write_bytes(<span style="color: #BA2121">b&quot;</span><span style="color: #AA5D1F; font-weight: bold">\xff\xfe\xfd</span><span style="color: #BA2121">&quot;</span>)

    output_dir <span style="color: #666666">=</span> tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;docs&quot;</span>

    <span style="color: #008000; font-weight: bold">with</span> patch(<span style="color: #BA2121">&quot;docgenerator.LLMClient&quot;</span>) <span style="color: #008000; font-weight: bold">as</span> MockClient:
        instance <span style="color: #666666">=</span> MockClient<span style="color: #666666">.</span>return_value
        instance<span style="color: #666666">.</span>ping<span style="color: #666666">.</span>return_value <span style="color: #666666">=</span> <span style="color: #008000; font-weight: bold">True</span>
        instance<span style="color: #666666">.</span>summarize<span style="color: #666666">.</span>return_value <span style="color: #666666">=</span> <span style="color: #BA2121">&quot;summary&quot;</span>
        ret <span style="color: #666666">=</span> main([<span style="color: #008000">str</span>(project_dir), <span style="color: #BA2121">&quot;--output&quot;</span>, <span style="color: #008000">str</span>(output_dir)])
        <span style="color: #008000; font-weight: bold">assert</span> ret <span style="color: #666666">==</span> <span style="color: #666666">0</span>

    <span style="color: #008000; font-weight: bold">assert</span> (output_dir <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;index.html&quot;</span>)<span style="color: #666666">.</span>exists()
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #AA22FF; font-weight: bold">not</span> (output_dir <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;bad.html&quot;</span>)<span style="color: #666666">.</span>exists()
</code></pre>
<h3 id="test_handles_class_without_docstring">test_handles_class_without_docstring(tmp_path: Path) -&gt; None</h3>
<p>The function `test_handles_class_without_docstring` is a unit test for a documentation generation tool. It checks if the tool correctly handles Python classes without docstrings by verifying that the generated HTML output includes a summary for the class.

Here&#x27;s a breakdown of what the function does:

1. **Setup**:
- Creates a temporary project directory (`tmp_path / &quot;proj&quot;`) and a module file (`mod.py`) within it.
- The module contains a simple Python class `Foo` without any docstring.

2. **Output Directory**:
- Specifies an output directory (`tmp_path / &quot;docs&quot;`).

3. **Mocking Language Model Client**:
- Uses the `patch` decorator to mock the `LLMClient` from the `docgenerator` module.
- Configures the mock client to return a successful ping and predefined summaries for different parts of the project.

4. **Running the Main Function**:
- Calls the `main` function with the path to the project directory and the output directory as arguments.
- Asserts that the main function returns 0, indicating success.

5. **Verification**:
- Reads the generated HTML file (`mod.html`) from the output directory.
- Asserts that the summary for the class `Foo` is present in the HTML content.

This test ensures that the documentation generation tool can handle Python classes without docstrings and correctly include summaries in the generated documentation.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">test_handles_class_without_docstring</span>(tmp_path: Path) <span style="color: #666666">-&gt;</span> <span style="color: #008000; font-weight: bold">None</span>:
    project_dir <span style="color: #666666">=</span> tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;proj&quot;</span>
    project_dir<span style="color: #666666">.</span>mkdir()
    (project_dir <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;mod.py&quot;</span>)<span style="color: #666666">.</span>write_text(<span style="color: #BA2121">&quot;class Foo:</span><span style="color: #AA5D1F; font-weight: bold">\n</span><span style="color: #BA2121">    pass</span><span style="color: #AA5D1F; font-weight: bold">\n</span><span style="color: #BA2121">&quot;</span>)

    output_dir <span style="color: #666666">=</span> tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;docs&quot;</span>

    <span style="color: #008000; font-weight: bold">with</span> patch(<span style="color: #BA2121">&quot;docgenerator.LLMClient&quot;</span>) <span style="color: #008000; font-weight: bold">as</span> MockClient:
        instance <span style="color: #666666">=</span> MockClient<span style="color: #666666">.</span>return_value
        instance<span style="color: #666666">.</span>ping<span style="color: #666666">.</span>return_value <span style="color: #666666">=</span> <span style="color: #008000; font-weight: bold">True</span>
        instance<span style="color: #666666">.</span>summarize<span style="color: #666666">.</span>side_effect <span style="color: #666666">=</span> [
            <span style="color: #BA2121">&quot;module summary&quot;</span>,
            <span style="color: #BA2121">&quot;project summary&quot;</span>,
            <span style="color: #BA2121">&quot;class summary&quot;</span>,
        ]
        ret <span style="color: #666666">=</span> main([<span style="color: #008000">str</span>(project_dir), <span style="color: #BA2121">&quot;--output&quot;</span>, <span style="color: #008000">str</span>(output_dir)])
        <span style="color: #008000; font-weight: bold">assert</span> ret <span style="color: #666666">==</span> <span style="color: #666666">0</span>

    html <span style="color: #666666">=</span> (output_dir <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;mod.html&quot;</span>)<span style="color: #666666">.</span>read_text(encoding<span style="color: #666666">=</span><span style="color: #BA2121">&quot;utf-8&quot;</span>)
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #BA2121">&quot;class summary&quot;</span> <span style="color: #AA22FF; font-weight: bold">in</span> html
</code></pre>
<h3 id="test_project_summary_is_sanitized">test_project_summary_is_sanitized(tmp_path: Path) -&gt; None</h3>
<p>This function, `test_project_summary_is_sanitized`, tests the process of generating a project summary using the DocGen-LM tool. It creates a temporary project directory with a Python module and an output directory for documentation. The function uses a mock language model client to simulate responses for summarizing modules, projects, functions, and improving function documentation. After running the main function with the specified project and output directories, it checks that the generated HTML file does not contain certain phrases (&quot;You can run this&quot; and &quot;It prints.&quot;) and that the language model was called with the correct arguments for summarizing a project.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">test_project_summary_is_sanitized</span>(tmp_path: Path) <span style="color: #666666">-&gt;</span> <span style="color: #008000; font-weight: bold">None</span>:
    project_dir <span style="color: #666666">=</span> tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;proj&quot;</span>
    project_dir<span style="color: #666666">.</span>mkdir()
    (project_dir <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;mod.py&quot;</span>)<span style="color: #666666">.</span>write_text(<span style="color: #BA2121">&quot;def foo():</span><span style="color: #AA5D1F; font-weight: bold">\n</span><span style="color: #BA2121">    pass</span><span style="color: #AA5D1F; font-weight: bold">\n</span><span style="color: #BA2121">&quot;</span>)

    output_dir <span style="color: #666666">=</span> tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;docs&quot;</span>

    <span style="color: #008000; font-weight: bold">with</span> patch(<span style="color: #BA2121">&quot;docgenerator.LLMClient&quot;</span>) <span style="color: #008000; font-weight: bold">as</span> MockClient:
        instance <span style="color: #666666">=</span> MockClient<span style="color: #666666">.</span>return_value
        instance<span style="color: #666666">.</span>ping<span style="color: #666666">.</span>return_value <span style="color: #666666">=</span> <span style="color: #008000; font-weight: bold">True</span>
        instance<span style="color: #666666">.</span>summarize<span style="color: #666666">.</span>side_effect <span style="color: #666666">=</span> [
            <span style="color: #BA2121">&quot;module summary&quot;</span>,
            <span style="color: #BA2121">&quot;project summary&quot;</span>,
            <span style="color: #BA2121">&quot;function summary&quot;</span>,
            <span style="color: #BA2121">&quot;improved function doc&quot;</span>,
        ]
        ret <span style="color: #666666">=</span> main([<span style="color: #008000">str</span>(project_dir), <span style="color: #BA2121">&quot;--output&quot;</span>, <span style="color: #008000">str</span>(output_dir)])
        <span style="color: #008000; font-weight: bold">assert</span> ret <span style="color: #666666">==</span> <span style="color: #666666">0</span>

    html <span style="color: #666666">=</span> (output_dir <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;index.html&quot;</span>)<span style="color: #666666">.</span>read_text(encoding<span style="color: #666666">=</span><span style="color: #BA2121">&quot;utf-8&quot;</span>)
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #BA2121">&quot;You can run this&quot;</span> <span style="color: #AA22FF; font-weight: bold">not</span> <span style="color: #AA22FF; font-weight: bold">in</span> html
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #BA2121">&quot;It prints.&quot;</span> <span style="color: #AA22FF; font-weight: bold">in</span> html
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #008000">any</span>(call<span style="color: #666666">.</span>args[<span style="color: #666666">1</span>] <span style="color: #666666">==</span> <span style="color: #BA2121">&quot;project&quot;</span> <span style="color: #008000; font-weight: bold">for</span> call <span style="color: #AA22FF; font-weight: bold">in</span> instance<span style="color: #666666">.</span>summarize<span style="color: #666666">.</span>call_args_list)
</code></pre>
<h3 id="test_readme_summary_used">test_readme_summary_used(tmp_path: Path) -&gt; None</h3>
<p>This function `test_readme_summary_used` is designed to test the functionality of a documentation generation tool, specifically focusing on how it handles README files. It creates a temporary project directory with a Python module and a README file, then simulates the execution of the main documentation generation script using a mock language model client.

The function sets up a mock environment where the language model client is configured to return a summary for any text input, specifically targeting the &quot;readme&quot; type. It then runs the main documentation generation function with the project directory and an output directory specified.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">test_readme_summary_used</span>(tmp_path: Path) <span style="color: #666666">-&gt;</span> <span style="color: #008000; font-weight: bold">None</span>:
    project_dir <span style="color: #666666">=</span> tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;proj&quot;</span>
    project_dir<span style="color: #666666">.</span>mkdir()
    (project_dir <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;mod.py&quot;</span>)<span style="color: #666666">.</span>write_text(<span style="color: #BA2121">&quot;def foo():</span><span style="color: #AA5D1F; font-weight: bold">\n</span><span style="color: #BA2121">    pass</span><span style="color: #AA5D1F; font-weight: bold">\n</span><span style="color: #BA2121">&quot;</span>)
    (project_dir <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;README.md&quot;</span>)<span style="color: #666666">.</span>write_text(<span style="color: #BA2121">&quot;Project docs&quot;</span>)

    output_dir <span style="color: #666666">=</span> tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;docs&quot;</span>

    <span style="color: #008000; font-weight: bold">with</span> patch(<span style="color: #BA2121">&quot;docgenerator.LLMClient&quot;</span>) <span style="color: #008000; font-weight: bold">as</span> MockClient:
        instance <span style="color: #666666">=</span> MockClient<span style="color: #666666">.</span>return_value
        instance<span style="color: #666666">.</span>ping<span style="color: #666666">.</span>return_value <span style="color: #666666">=</span> <span style="color: #008000; font-weight: bold">True</span>
        instance<span style="color: #666666">.</span>summarize<span style="color: #666666">.</span>side_effect <span style="color: #666666">=</span> <span style="color: #008000; font-weight: bold">lambda</span> text, pt, <span style="color: #666666">**</span>kwargs: <span style="color: #BA2121">f&quot;</span><span style="color: #A45A77; font-weight: bold">{</span>pt<span style="color: #A45A77; font-weight: bold">}</span><span style="color: #BA2121"> summary&quot;</span>
        ret <span style="color: #666666">=</span> main([<span style="color: #008000">str</span>(project_dir), <span style="color: #BA2121">&quot;--output&quot;</span>, <span style="color: #008000">str</span>(output_dir)])
        <span style="color: #008000; font-weight: bold">assert</span> ret <span style="color: #666666">==</span> <span style="color: #666666">0</span>

    html <span style="color: #666666">=</span> (output_dir <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;index.html&quot;</span>)<span style="color: #666666">.</span>read_text(encoding<span style="color: #666666">=</span><span style="color: #BA2121">&quot;utf-8&quot;</span>)
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #BA2121">&quot;readme summary&quot;</span> <span style="color: #AA22FF; font-weight: bold">in</span> html
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #008000">any</span>(call<span style="color: #666666">.</span>args[<span style="color: #666666">1</span>] <span style="color: #666666">==</span> <span style="color: #BA2121">&quot;readme&quot;</span> <span style="color: #008000; font-weight: bold">for</span> call <span style="color: #AA22FF; font-weight: bold">in</span> instance<span style="color: #666666">.</span>summarize<span style="color: #666666">.</span>call_args_list)
</code></pre>
<h3 id="test_clean_output_dir">test_clean_output_dir(tmp_path: Path) -&gt; None</h3>
<p>The function `test_clean_output_dir` is designed to test the behavior of a hypothetical `clean_output_dir` function from the `docgenerator` module. It creates a temporary directory structure with files and subdirectories, simulating an output directory for documentation generation. The function then calls `clean_output_dir` on this temporary path.

The purpose of `test_clean_output_dir` is to ensure that `clean_output_dir` correctly removes files that are considered &quot;generated&quot; by the tool (in this case, files containing a specific comment) while preserving other files. After calling `clean_output_dir`, it asserts that the generated file has been deleted (`generated.exists()` returns `False`), but the custom and asset files still exist (`custom.exists()` and `asset.exists()` return `True`). This test helps verify that the function behaves as expected in managing the output directory for documentation generation.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">test_clean_output_dir</span>(tmp_path: Path) <span style="color: #666666">-&gt;</span> <span style="color: #008000; font-weight: bold">None</span>:
    out <span style="color: #666666">=</span> tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;docs&quot;</span>
    out<span style="color: #666666">.</span>mkdir()
    generated <span style="color: #666666">=</span> out <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;old.html&quot;</span>
    generated<span style="color: #666666">.</span>write_text(<span style="color: #BA2121">&quot;&lt;!-- Generated by DocGen-LM --&gt;</span><span style="color: #AA5D1F; font-weight: bold">\n</span><span style="color: #BA2121">&lt;html&gt;&lt;/html&gt;&quot;</span>, encoding<span style="color: #666666">=</span><span style="color: #BA2121">&quot;utf-8&quot;</span>)
    custom <span style="color: #666666">=</span> out <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;custom.html&quot;</span>
    custom<span style="color: #666666">.</span>write_text(<span style="color: #BA2121">&quot;&lt;html&gt;&lt;/html&gt;&quot;</span>, encoding<span style="color: #666666">=</span><span style="color: #BA2121">&quot;utf-8&quot;</span>)
    asset <span style="color: #666666">=</span> out <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;style.css&quot;</span>
    asset<span style="color: #666666">.</span>write_text(<span style="color: #BA2121">&quot;body </span><span style="color: #A45A77; font-weight: bold">{}</span><span style="color: #BA2121">&quot;</span>, encoding<span style="color: #666666">=</span><span style="color: #BA2121">&quot;utf-8&quot;</span>)

    <span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">docgenerator</span> <span style="color: #008000; font-weight: bold">import</span> clean_output_dir

    clean_output_dir(<span style="color: #008000">str</span>(out))

    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #AA22FF; font-weight: bold">not</span> generated<span style="color: #666666">.</span>exists()
    <span style="color: #008000; font-weight: bold">assert</span> custom<span style="color: #666666">.</span>exists()
    <span style="color: #008000; font-weight: bold">assert</span> asset<span style="color: #666666">.</span>exists()
</code></pre>
<h3 id="test_summarize_chunked_splits_long_text">test_summarize_chunked_splits_long_text(tmp_path: Path) -&gt; None</h3>
<p>The function `test_summarize_chunked_splits_long_text` tests the `summarize_chunked` function by mocking its behavior to return a summary. It uses a tokenizer, a cache, and patches the `_summarize` method to ensure it is called multiple times during the execution of the test. The test checks if the `_summarize` method is called more than once, indicating that the long text has been successfully chunked and summarized.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">test_summarize_chunked_splits_long_text</span>(tmp_path: Path) <span style="color: #666666">-&gt;</span> <span style="color: #008000; font-weight: bold">None</span>:
    <span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">cache</span> <span style="color: #008000; font-weight: bold">import</span> ResponseCache
    <span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">chunk_utils</span> <span style="color: #008000; font-weight: bold">import</span> get_tokenizer
    <span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">summarize_utils</span> <span style="color: #008000; font-weight: bold">import</span> summarize_chunked

    tokenizer <span style="color: #666666">=</span> get_tokenizer()
    text <span style="color: #666666">=</span> <span style="color: #BA2121">&quot;word &quot;</span> <span style="color: #666666">*</span> <span style="color: #666666">50</span>
    cache <span style="color: #666666">=</span> ResponseCache(<span style="color: #008000">str</span>(tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;cache.json&quot;</span>))

    <span style="color: #008000; font-weight: bold">with</span> patch(<span style="color: #BA2121">&quot;summarize_utils._summarize&quot;</span>, return_value<span style="color: #666666">=</span><span style="color: #BA2121">&quot;summary&quot;</span>) <span style="color: #008000; font-weight: bold">as</span> mock_sum:
        summarize_chunked(
            client<span style="color: #666666">=</span><span style="color: #008000">object</span>(),
            cache<span style="color: #666666">=</span>cache,
            key_prefix<span style="color: #666666">=</span><span style="color: #BA2121">&quot;k&quot;</span>,
            text<span style="color: #666666">=</span>text,
            prompt_type<span style="color: #666666">=</span><span style="color: #BA2121">&quot;module&quot;</span>,
            max_context_tokens<span style="color: #666666">=10</span>,
            chunk_token_budget<span style="color: #666666">=5</span>,
        )
        <span style="color: #008000; font-weight: bold">assert</span> mock_sum<span style="color: #666666">.</span>call_count <span style="color: #666666">&gt;</span> <span style="color: #666666">1</span>
</code></pre>
<h3 id="test_chunking_accounts_for_prompt_overhead">test_chunking_accounts_for_prompt_overhead(tmp_path: Path) -&gt; None</h3>
<p>This function tests the `summarize_chunked` utility by simulating a scenario where the system is prompted to summarize text. It uses a mock object for summarization and calculates the token overhead for the system prompt and template. The function asserts that the summarization method was called more than once, indicating that the text was chunked appropriately to account for the prompt overhead.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">test_chunking_accounts_for_prompt_overhead</span>(tmp_path: Path) <span style="color: #666666">-&gt;</span> <span style="color: #008000; font-weight: bold">None</span>:
    <span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">cache</span> <span style="color: #008000; font-weight: bold">import</span> ResponseCache
    <span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">chunk_utils</span> <span style="color: #008000; font-weight: bold">import</span> get_tokenizer
    <span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">summarize_utils</span> <span style="color: #008000; font-weight: bold">import</span> summarize_chunked
    <span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">llm_client</span> <span style="color: #008000; font-weight: bold">import</span> SYSTEM_PROMPT, PROMPT_TEMPLATES

    tokenizer <span style="color: #666666">=</span> get_tokenizer()
    text <span style="color: #666666">=</span> <span style="color: #BA2121">&quot;word &quot;</span> <span style="color: #666666">*</span> <span style="color: #666666">15</span>
    cache <span style="color: #666666">=</span> ResponseCache(<span style="color: #008000">str</span>(tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;cache.json&quot;</span>))
    template <span style="color: #666666">=</span> PROMPT_TEMPLATES[<span style="color: #BA2121">&quot;module&quot;</span>]
    overhead <span style="color: #666666">=</span> <span style="color: #008000">len</span>(tokenizer<span style="color: #666666">.</span>encode(SYSTEM_PROMPT)) <span style="color: #666666">+</span> <span style="color: #008000">len</span>(tokenizer<span style="color: #666666">.</span>encode(template<span style="color: #666666">.</span>format(text<span style="color: #666666">=</span><span style="color: #BA2121">&quot;&quot;</span>)))
    max_context_tokens <span style="color: #666666">=</span> overhead <span style="color: #666666">+</span> <span style="color: #666666">10</span>

    <span style="color: #008000; font-weight: bold">with</span> patch(<span style="color: #BA2121">&quot;summarize_utils._summarize&quot;</span>, return_value<span style="color: #666666">=</span><span style="color: #BA2121">&quot;summary&quot;</span>) <span style="color: #008000; font-weight: bold">as</span> mock_sum:
        summarize_chunked(
            client<span style="color: #666666">=</span><span style="color: #008000">object</span>(),
            cache<span style="color: #666666">=</span>cache,
            key_prefix<span style="color: #666666">=</span><span style="color: #BA2121">&quot;k&quot;</span>,
            text<span style="color: #666666">=</span>text,
            prompt_type<span style="color: #666666">=</span><span style="color: #BA2121">&quot;module&quot;</span>,
            max_context_tokens<span style="color: #666666">=</span>max_context_tokens,
            chunk_token_budget<span style="color: #666666">=100</span>,
        )
        <span style="color: #008000; font-weight: bold">assert</span> mock_sum<span style="color: #666666">.</span>call_count <span style="color: #666666">&gt;</span> <span style="color: #666666">1</span>
</code></pre>
<h3 id="test_merge_recurses_when_prompt_too_long">test_merge_recurses_when_prompt_too_long(tmp_path: Path) -&gt; None</h3>
<p>This function `test_merge_recurses_when_prompt_too_long` tests the behavior of merging and recursing during documentation generation when the prompt exceeds a certain length. It uses mocks to simulate the summarization process, ensuring that the system handles long prompts by breaking them into smaller chunks and recursively processing each chunk. The test checks if the merging logic is invoked multiple times for docstring prompts, indicating successful handling of large input sizes.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">test_merge_recurses_when_prompt_too_long</span>(tmp_path: Path) <span style="color: #666666">-&gt;</span> <span style="color: #008000; font-weight: bold">None</span>:
    <span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">cache</span> <span style="color: #008000; font-weight: bold">import</span> ResponseCache
    <span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">chunk_utils</span> <span style="color: #008000; font-weight: bold">import</span> get_tokenizer
    <span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">summarize_utils</span> <span style="color: #008000; font-weight: bold">import</span> summarize_chunked
    <span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">llm_client</span> <span style="color: #008000; font-weight: bold">import</span> SYSTEM_PROMPT, PROMPT_TEMPLATES

    tokenizer <span style="color: #666666">=</span> get_tokenizer()
    text <span style="color: #666666">=</span> <span style="color: #BA2121">&quot;word &quot;</span> <span style="color: #666666">*</span> <span style="color: #666666">200</span>
    cache <span style="color: #666666">=</span> ResponseCache(<span style="color: #008000">str</span>(tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;cache.json&quot;</span>))
    template <span style="color: #666666">=</span> PROMPT_TEMPLATES[<span style="color: #BA2121">&quot;module&quot;</span>]
    overhead <span style="color: #666666">=</span> <span style="color: #008000">len</span>(tokenizer<span style="color: #666666">.</span>encode(SYSTEM_PROMPT)) <span style="color: #666666">+</span> <span style="color: #008000">len</span>(
        tokenizer<span style="color: #666666">.</span>encode(template<span style="color: #666666">.</span>format(text<span style="color: #666666">=</span><span style="color: #BA2121">&quot;&quot;</span>))
    )
    max_context_tokens <span style="color: #666666">=</span> overhead <span style="color: #666666">+</span> <span style="color: #666666">50</span>

    <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">fake_sum</span>(client, cache_obj, key, text_arg, prompt_type, <span style="color: #666666">*</span>, system_prompt<span style="color: #666666">=</span><span style="color: #BA2121">&quot;&quot;</span>):
        template <span style="color: #666666">=</span> PROMPT_TEMPLATES<span style="color: #666666">.</span>get(prompt_type, PROMPT_TEMPLATES[<span style="color: #BA2121">&quot;module&quot;</span>])
        overhead <span style="color: #666666">=</span> <span style="color: #008000">len</span>(tokenizer<span style="color: #666666">.</span>encode(SYSTEM_PROMPT)) <span style="color: #666666">+</span> <span style="color: #008000">len</span>(
            tokenizer<span style="color: #666666">.</span>encode(template<span style="color: #666666">.</span>format(text<span style="color: #666666">=</span><span style="color: #BA2121">&quot;&quot;</span>))
        )
        available <span style="color: #666666">=</span> max_context_tokens <span style="color: #666666">-</span> overhead
        <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #008000">len</span>(tokenizer<span style="color: #666666">.</span>encode(text_arg)) <span style="color: #666666">&lt;=</span> available
        <span style="color: #008000; font-weight: bold">if</span> prompt_type <span style="color: #666666">==</span> <span style="color: #BA2121">&quot;module&quot;</span>:
            <span style="color: #008000; font-weight: bold">return</span> <span style="color: #BA2121">&quot;summary &quot;</span> <span style="color: #666666">*</span> <span style="color: #666666">30</span>
        <span style="color: #008000; font-weight: bold">return</span> <span style="color: #BA2121">&quot;short&quot;</span>

    <span style="color: #008000; font-weight: bold">with</span> patch(<span style="color: #BA2121">&quot;summarize_utils._summarize&quot;</span>, side_effect<span style="color: #666666">=</span>fake_sum) <span style="color: #008000; font-weight: bold">as</span> mock_sum:
        summarize_chunked(
            client<span style="color: #666666">=</span><span style="color: #008000">object</span>(),
            cache<span style="color: #666666">=</span>cache,
            key_prefix<span style="color: #666666">=</span><span style="color: #BA2121">&quot;k&quot;</span>,
            text<span style="color: #666666">=</span>text,
            prompt_type<span style="color: #666666">=</span><span style="color: #BA2121">&quot;module&quot;</span>,
            max_context_tokens<span style="color: #666666">=</span>max_context_tokens,
            chunk_token_budget<span style="color: #666666">=10</span>,
        )
        merge_calls <span style="color: #666666">=</span> [c <span style="color: #008000; font-weight: bold">for</span> c <span style="color: #AA22FF; font-weight: bold">in</span> mock_sum<span style="color: #666666">.</span>call_args_list <span style="color: #008000; font-weight: bold">if</span> c<span style="color: #666666">.</span>args[<span style="color: #666666">4</span>] <span style="color: #666666">==</span> <span style="color: #BA2121">&quot;docstring&quot;</span>]
        <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #008000">len</span>(merge_calls) <span style="color: #666666">&gt;</span> <span style="color: #666666">1</span>
</code></pre>
<details>
<summary>Subfunction: fake_sum(client, cache_obj, key, text_arg, prompt_type, *, system_prompt=&#x27;&#x27;)</summary>
<h4 id="fake_sum">fake_sum(client, cache_obj, key, text_arg, prompt_type, *, system_prompt=&#x27;&#x27;)</h4>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">fake_sum</span>(client, cache_obj, key, text_arg, prompt_type, <span style="color: #666666">*</span>, system_prompt<span style="color: #666666">=</span><span style="color: #BA2121">&quot;&quot;</span>):
        template <span style="color: #666666">=</span> PROMPT_TEMPLATES<span style="color: #666666">.</span>get(prompt_type, PROMPT_TEMPLATES[<span style="color: #BA2121">&quot;module&quot;</span>])
        overhead <span style="color: #666666">=</span> <span style="color: #008000">len</span>(tokenizer<span style="color: #666666">.</span>encode(SYSTEM_PROMPT)) <span style="color: #666666">+</span> <span style="color: #008000">len</span>(
            tokenizer<span style="color: #666666">.</span>encode(template<span style="color: #666666">.</span>format(text<span style="color: #666666">=</span><span style="color: #BA2121">&quot;&quot;</span>))
        )
        available <span style="color: #666666">=</span> max_context_tokens <span style="color: #666666">-</span> overhead
        <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #008000">len</span>(tokenizer<span style="color: #666666">.</span>encode(text_arg)) <span style="color: #666666">&lt;=</span> available
        <span style="color: #008000; font-weight: bold">if</span> prompt_type <span style="color: #666666">==</span> <span style="color: #BA2121">&quot;module&quot;</span>:
            <span style="color: #008000; font-weight: bold">return</span> <span style="color: #BA2121">&quot;summary &quot;</span> <span style="color: #666666">*</span> <span style="color: #666666">30</span>
        <span style="color: #008000; font-weight: bold">return</span> <span style="color: #BA2121">&quot;short&quot;</span>
</code></pre>
</details>
<h3 id="test_single_long_partial_is_recursively_chunked">test_single_long_partial_is_recursively_chunked(tmp_path: Path) -&gt; None</h3>
<p>The function `test_single_long_partial_is_recursively_chunked` tests the recursive chunking of a long text into smaller parts suitable for summarization. It uses a mock function to simulate the behavior of the actual summarization process, ensuring that the text is split correctly based on token budget and prompt type. The test checks if the number of calls made with the &quot;docstring&quot; prompt type is greater than one, indicating successful recursive chunking.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">test_single_long_partial_is_recursively_chunked</span>(tmp_path: Path) <span style="color: #666666">-&gt;</span> <span style="color: #008000; font-weight: bold">None</span>:
    <span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">cache</span> <span style="color: #008000; font-weight: bold">import</span> ResponseCache
    <span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">chunk_utils</span> <span style="color: #008000; font-weight: bold">import</span> get_tokenizer
    <span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">summarize_utils</span> <span style="color: #008000; font-weight: bold">import</span> summarize_chunked
    <span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">llm_client</span> <span style="color: #008000; font-weight: bold">import</span> SYSTEM_PROMPT, PROMPT_TEMPLATES

    tokenizer <span style="color: #666666">=</span> get_tokenizer()
    text <span style="color: #666666">=</span> <span style="color: #BA2121">&quot;word &quot;</span> <span style="color: #666666">*</span> <span style="color: #666666">200</span>
    cache <span style="color: #666666">=</span> ResponseCache(<span style="color: #008000">str</span>(tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;cache.json&quot;</span>))
    template <span style="color: #666666">=</span> PROMPT_TEMPLATES[<span style="color: #BA2121">&quot;module&quot;</span>]
    overhead <span style="color: #666666">=</span> <span style="color: #008000">len</span>(tokenizer<span style="color: #666666">.</span>encode(SYSTEM_PROMPT)) <span style="color: #666666">+</span> <span style="color: #008000">len</span>(tokenizer<span style="color: #666666">.</span>encode(template<span style="color: #666666">.</span>format(text<span style="color: #666666">=</span><span style="color: #BA2121">&quot;&quot;</span>)))
    max_context_tokens <span style="color: #666666">=</span> overhead <span style="color: #666666">+</span> <span style="color: #666666">50</span>

    <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">fake_sum</span>(client, cache_obj, key, text_arg, prompt_type, <span style="color: #666666">*</span>, system_prompt<span style="color: #666666">=</span><span style="color: #BA2121">&quot;&quot;</span>):
        template <span style="color: #666666">=</span> PROMPT_TEMPLATES<span style="color: #666666">.</span>get(prompt_type, PROMPT_TEMPLATES[<span style="color: #BA2121">&quot;module&quot;</span>])
        overhead_local <span style="color: #666666">=</span> <span style="color: #008000">len</span>(tokenizer<span style="color: #666666">.</span>encode(SYSTEM_PROMPT)) <span style="color: #666666">+</span> <span style="color: #008000">len</span>(
            tokenizer<span style="color: #666666">.</span>encode(template<span style="color: #666666">.</span>format(text<span style="color: #666666">=</span><span style="color: #BA2121">&quot;&quot;</span>))
        )
        available <span style="color: #666666">=</span> max_context_tokens <span style="color: #666666">-</span> overhead_local
        <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #008000">len</span>(tokenizer<span style="color: #666666">.</span>encode(text_arg)) <span style="color: #666666">&lt;=</span> available
        <span style="color: #008000; font-weight: bold">if</span> prompt_type <span style="color: #666666">==</span> <span style="color: #BA2121">&quot;module&quot;</span>:
            <span style="color: #008000; font-weight: bold">return</span> <span style="color: #BA2121">&quot;long &quot;</span> <span style="color: #666666">*</span> <span style="color: #666666">200</span>
        <span style="color: #008000; font-weight: bold">return</span> <span style="color: #BA2121">&quot;short&quot;</span>

    <span style="color: #008000; font-weight: bold">with</span> patch(<span style="color: #BA2121">&quot;summarize_utils._summarize&quot;</span>, side_effect<span style="color: #666666">=</span>fake_sum) <span style="color: #008000; font-weight: bold">as</span> mock_sum:
        summarize_chunked(
            client<span style="color: #666666">=</span><span style="color: #008000">object</span>(),
            cache<span style="color: #666666">=</span>cache,
            key_prefix<span style="color: #666666">=</span><span style="color: #BA2121">&quot;k&quot;</span>,
            text<span style="color: #666666">=</span>text,
            prompt_type<span style="color: #666666">=</span><span style="color: #BA2121">&quot;module&quot;</span>,
            max_context_tokens<span style="color: #666666">=</span>max_context_tokens,
            chunk_token_budget<span style="color: #666666">=10</span>,
        )
        doc_calls <span style="color: #666666">=</span> [c <span style="color: #008000; font-weight: bold">for</span> c <span style="color: #AA22FF; font-weight: bold">in</span> mock_sum<span style="color: #666666">.</span>call_args_list <span style="color: #008000; font-weight: bold">if</span> c<span style="color: #666666">.</span>args[<span style="color: #666666">4</span>] <span style="color: #666666">==</span> <span style="color: #BA2121">&quot;docstring&quot;</span>]
        <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #008000">len</span>(doc_calls) <span style="color: #666666">&gt;</span> <span style="color: #666666">1</span>
</code></pre>
<details>
<summary>Subfunction: fake_sum(client, cache_obj, key, text_arg, prompt_type, *, system_prompt=&#x27;&#x27;)</summary>
<h4 id="fake_sum">fake_sum(client, cache_obj, key, text_arg, prompt_type, *, system_prompt=&#x27;&#x27;)</h4>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">fake_sum</span>(client, cache_obj, key, text_arg, prompt_type, <span style="color: #666666">*</span>, system_prompt<span style="color: #666666">=</span><span style="color: #BA2121">&quot;&quot;</span>):
        template <span style="color: #666666">=</span> PROMPT_TEMPLATES<span style="color: #666666">.</span>get(prompt_type, PROMPT_TEMPLATES[<span style="color: #BA2121">&quot;module&quot;</span>])
        overhead_local <span style="color: #666666">=</span> <span style="color: #008000">len</span>(tokenizer<span style="color: #666666">.</span>encode(SYSTEM_PROMPT)) <span style="color: #666666">+</span> <span style="color: #008000">len</span>(
            tokenizer<span style="color: #666666">.</span>encode(template<span style="color: #666666">.</span>format(text<span style="color: #666666">=</span><span style="color: #BA2121">&quot;&quot;</span>))
        )
        available <span style="color: #666666">=</span> max_context_tokens <span style="color: #666666">-</span> overhead_local
        <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #008000">len</span>(tokenizer<span style="color: #666666">.</span>encode(text_arg)) <span style="color: #666666">&lt;=</span> available
        <span style="color: #008000; font-weight: bold">if</span> prompt_type <span style="color: #666666">==</span> <span style="color: #BA2121">&quot;module&quot;</span>:
            <span style="color: #008000; font-weight: bold">return</span> <span style="color: #BA2121">&quot;long &quot;</span> <span style="color: #666666">*</span> <span style="color: #666666">200</span>
        <span style="color: #008000; font-weight: bold">return</span> <span style="color: #BA2121">&quot;short&quot;</span>
</code></pre>
</details>
<h3 id="test_structured_chunker_keeps_functions_atomic">test_structured_chunker_keeps_functions_atomic(tmp_path: Path) -&gt; None</h3>
<p>This function, `test_structured_chunker_keeps_functions_atomic`, tests the functionality of a structured chunker that processes Python functions. It ensures that each function is treated as an atomic unit during chunking. The test involves creating a temporary file with two functions, parsing it using a Python parser, and then simulating the chunking process with a mock summarization function. The assertions verify that the chunking results in separate chunks for each function, maintaining their atomicity.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">test_structured_chunker_keeps_functions_atomic</span>(tmp_path: Path) <span style="color: #666666">-&gt;</span> <span style="color: #008000; font-weight: bold">None</span>:
    <span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">cache</span> <span style="color: #008000; font-weight: bold">import</span> ResponseCache
    <span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">parser_python</span> <span style="color: #008000; font-weight: bold">import</span> parse_python_file
    <span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">chunk_utils</span> <span style="color: #008000; font-weight: bold">import</span> get_tokenizer
    <span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">docgenerator</span> <span style="color: #008000; font-weight: bold">import</span> _summarize_module_chunked
    <span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">llm_client</span> <span style="color: #008000; font-weight: bold">import</span> SYSTEM_PROMPT, PROMPT_TEMPLATES

    src <span style="color: #666666">=</span> (
        <span style="color: #BA2121">&quot;def f1():</span><span style="color: #AA5D1F; font-weight: bold">\n</span><span style="color: #BA2121">&quot;</span>
        <span style="color: #BA2121">&quot;    x = 1</span><span style="color: #AA5D1F; font-weight: bold">\n</span><span style="color: #BA2121">&quot;</span>
        <span style="color: #666666">+</span> <span style="color: #BA2121">&quot;    x += 1</span><span style="color: #AA5D1F; font-weight: bold">\n</span><span style="color: #BA2121">&quot;</span> <span style="color: #666666">*</span> <span style="color: #666666">5</span>
        <span style="color: #666666">+</span> <span style="color: #BA2121">&quot;    return x</span><span style="color: #AA5D1F; font-weight: bold">\n\n</span><span style="color: #BA2121">&quot;</span>
        <span style="color: #BA2121">&quot;def f2():</span><span style="color: #AA5D1F; font-weight: bold">\n</span><span style="color: #BA2121">&quot;</span>
        <span style="color: #BA2121">&quot;    y = 1</span><span style="color: #AA5D1F; font-weight: bold">\n</span><span style="color: #BA2121">&quot;</span>
        <span style="color: #666666">+</span> <span style="color: #BA2121">&quot;    y += 1</span><span style="color: #AA5D1F; font-weight: bold">\n</span><span style="color: #BA2121">&quot;</span> <span style="color: #666666">*</span> <span style="color: #666666">5</span>
        <span style="color: #666666">+</span> <span style="color: #BA2121">&quot;    return y</span><span style="color: #AA5D1F; font-weight: bold">\n</span><span style="color: #BA2121">&quot;</span>
    )
    file <span style="color: #666666">=</span> tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;m.py&quot;</span>
    file<span style="color: #666666">.</span>write_text(src)
    parsed <span style="color: #666666">=</span> parse_python_file(<span style="color: #008000">str</span>(file))

    tokenizer <span style="color: #666666">=</span> get_tokenizer()
    cache <span style="color: #666666">=</span> ResponseCache(<span style="color: #008000">str</span>(tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;cache.json&quot;</span>))

    <span style="color: #008000; font-weight: bold">with</span> patch(<span style="color: #BA2121">&quot;docgenerator._summarize&quot;</span>, return_value<span style="color: #666666">=</span><span style="color: #BA2121">&quot;sum&quot;</span>) <span style="color: #008000; font-weight: bold">as</span> mock_sum:
        flen <span style="color: #666666">=</span> <span style="color: #008000">len</span>(tokenizer<span style="color: #666666">.</span>encode(parsed[<span style="color: #BA2121">&quot;functions&quot;</span>][<span style="color: #666666">0</span>][<span style="color: #BA2121">&quot;source&quot;</span>]))
        budget <span style="color: #666666">=</span> flen <span style="color: #666666">+</span> <span style="color: #666666">5</span>
        overhead <span style="color: #666666">=</span> <span style="color: #008000">len</span>(tokenizer<span style="color: #666666">.</span>encode(SYSTEM_PROMPT)) <span style="color: #666666">+</span> <span style="color: #008000">len</span>(tokenizer<span style="color: #666666">.</span>encode(PROMPT_TEMPLATES[<span style="color: #BA2121">&quot;module&quot;</span>]<span style="color: #666666">.</span>format(text<span style="color: #666666">=</span><span style="color: #BA2121">&quot;&quot;</span>)))
        _summarize_module_chunked(
            client<span style="color: #666666">=</span><span style="color: #008000">object</span>(),
            cache<span style="color: #666666">=</span>cache,
            key_prefix<span style="color: #666666">=</span><span style="color: #BA2121">&quot;k&quot;</span>,
            module_text<span style="color: #666666">=</span>src,
            module<span style="color: #666666">=</span>parsed,
            tokenizer<span style="color: #666666">=</span>tokenizer,
            max_context_tokens<span style="color: #666666">=</span>overhead <span style="color: #666666">+</span> budget,
            chunk_token_budget<span style="color: #666666">=</span>budget,
        )

        chunks <span style="color: #666666">=</span> [c<span style="color: #666666">.</span>args[<span style="color: #666666">3</span>] <span style="color: #008000; font-weight: bold">for</span> c <span style="color: #AA22FF; font-weight: bold">in</span> mock_sum<span style="color: #666666">.</span>call_args_list <span style="color: #008000; font-weight: bold">if</span> c<span style="color: #666666">.</span>args[<span style="color: #666666">4</span>] <span style="color: #666666">==</span> <span style="color: #BA2121">&quot;module&quot;</span>]
        <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #008000">len</span>(chunks) <span style="color: #666666">==</span> <span style="color: #666666">2</span>
        func_sources <span style="color: #666666">=</span> {f[<span style="color: #BA2121">&quot;source&quot;</span>] <span style="color: #008000; font-weight: bold">for</span> f <span style="color: #AA22FF; font-weight: bold">in</span> parsed[<span style="color: #BA2121">&quot;functions&quot;</span>]}
        <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #008000">set</span>(chunks) <span style="color: #666666">==</span> func_sources
</code></pre>
<h3 id="test_structured_chunker_splits_large_class_by_method">test_structured_chunker_splits_large_class_by_method(tmp_path: Path) -&gt; None</h3>
<p>This function tests the `test_structured_chunker_splits_large_class_by_method` function. It creates a Python class with two methods, writes it to a temporary file, and parses it using the `parse_python_file` function from the `parser_python` module. The function then uses a tokenizer and a response cache to simulate summarizing the class methods. It asserts that the number of chunks generated matches the number of methods in the class and that each chunk corresponds to one of the method sources.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">test_structured_chunker_splits_large_class_by_method</span>(tmp_path: Path) <span style="color: #666666">-&gt;</span> <span style="color: #008000; font-weight: bold">None</span>:
    <span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">cache</span> <span style="color: #008000; font-weight: bold">import</span> ResponseCache
    <span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">parser_python</span> <span style="color: #008000; font-weight: bold">import</span> parse_python_file
    <span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">chunk_utils</span> <span style="color: #008000; font-weight: bold">import</span> get_tokenizer
    <span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">docgenerator</span> <span style="color: #008000; font-weight: bold">import</span> _summarize_module_chunked
    <span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">llm_client</span> <span style="color: #008000; font-weight: bold">import</span> SYSTEM_PROMPT, PROMPT_TEMPLATES

    class_src <span style="color: #666666">=</span> (
        <span style="color: #BA2121">&quot;class Foo:</span><span style="color: #AA5D1F; font-weight: bold">\n</span><span style="color: #BA2121">&quot;</span>
        <span style="color: #BA2121">&quot;    def a(self):</span><span style="color: #AA5D1F; font-weight: bold">\n</span><span style="color: #BA2121">&quot;</span>
        <span style="color: #666666">+</span> <span style="color: #BA2121">&quot;        x = 1</span><span style="color: #AA5D1F; font-weight: bold">\n</span><span style="color: #BA2121">&quot;</span>
        <span style="color: #666666">+</span> <span style="color: #BA2121">&quot;        x += 1</span><span style="color: #AA5D1F; font-weight: bold">\n</span><span style="color: #BA2121">&quot;</span> <span style="color: #666666">*</span> <span style="color: #666666">5</span>
        <span style="color: #666666">+</span> <span style="color: #BA2121">&quot;        return x</span><span style="color: #AA5D1F; font-weight: bold">\n\n</span><span style="color: #BA2121">&quot;</span>
        <span style="color: #BA2121">&quot;    def b(self):</span><span style="color: #AA5D1F; font-weight: bold">\n</span><span style="color: #BA2121">&quot;</span>
        <span style="color: #666666">+</span> <span style="color: #BA2121">&quot;        y = 1</span><span style="color: #AA5D1F; font-weight: bold">\n</span><span style="color: #BA2121">&quot;</span>
        <span style="color: #666666">+</span> <span style="color: #BA2121">&quot;        y += 1</span><span style="color: #AA5D1F; font-weight: bold">\n</span><span style="color: #BA2121">&quot;</span> <span style="color: #666666">*</span> <span style="color: #666666">5</span>
        <span style="color: #666666">+</span> <span style="color: #BA2121">&quot;        return y</span><span style="color: #AA5D1F; font-weight: bold">\n</span><span style="color: #BA2121">&quot;</span>
    )
    file <span style="color: #666666">=</span> tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;m.py&quot;</span>
    file<span style="color: #666666">.</span>write_text(class_src)
    parsed <span style="color: #666666">=</span> parse_python_file(<span style="color: #008000">str</span>(file))

    tokenizer <span style="color: #666666">=</span> get_tokenizer()
    cache <span style="color: #666666">=</span> ResponseCache(<span style="color: #008000">str</span>(tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;cache.json&quot;</span>))

    <span style="color: #008000; font-weight: bold">with</span> patch(<span style="color: #BA2121">&quot;docgenerator._summarize&quot;</span>, return_value<span style="color: #666666">=</span><span style="color: #BA2121">&quot;sum&quot;</span>) <span style="color: #008000; font-weight: bold">as</span> mock_sum:
        mlen <span style="color: #666666">=</span> <span style="color: #008000">len</span>(tokenizer<span style="color: #666666">.</span>encode(parsed[<span style="color: #BA2121">&quot;classes&quot;</span>][<span style="color: #666666">0</span>][<span style="color: #BA2121">&quot;methods&quot;</span>][<span style="color: #666666">0</span>][<span style="color: #BA2121">&quot;source&quot;</span>]))
        budget <span style="color: #666666">=</span> mlen <span style="color: #666666">+</span> <span style="color: #666666">5</span>
        overhead <span style="color: #666666">=</span> <span style="color: #008000">len</span>(tokenizer<span style="color: #666666">.</span>encode(SYSTEM_PROMPT)) <span style="color: #666666">+</span> <span style="color: #008000">len</span>(tokenizer<span style="color: #666666">.</span>encode(PROMPT_TEMPLATES[<span style="color: #BA2121">&quot;module&quot;</span>]<span style="color: #666666">.</span>format(text<span style="color: #666666">=</span><span style="color: #BA2121">&quot;&quot;</span>)))
        _summarize_module_chunked(
            client<span style="color: #666666">=</span><span style="color: #008000">object</span>(),
            cache<span style="color: #666666">=</span>cache,
            key_prefix<span style="color: #666666">=</span><span style="color: #BA2121">&quot;k&quot;</span>,
            module_text<span style="color: #666666">=</span>class_src,
            module<span style="color: #666666">=</span>parsed,
            tokenizer<span style="color: #666666">=</span>tokenizer,
            max_context_tokens<span style="color: #666666">=</span>overhead <span style="color: #666666">+</span> budget,
            chunk_token_budget<span style="color: #666666">=</span>budget,
        )

        chunks <span style="color: #666666">=</span> [c<span style="color: #666666">.</span>args[<span style="color: #666666">3</span>] <span style="color: #008000; font-weight: bold">for</span> c <span style="color: #AA22FF; font-weight: bold">in</span> mock_sum<span style="color: #666666">.</span>call_args_list <span style="color: #008000; font-weight: bold">if</span> c<span style="color: #666666">.</span>args[<span style="color: #666666">4</span>] <span style="color: #666666">==</span> <span style="color: #BA2121">&quot;module&quot;</span>]
        methods <span style="color: #666666">=</span> parsed[<span style="color: #BA2121">&quot;classes&quot;</span>][<span style="color: #666666">0</span>][<span style="color: #BA2121">&quot;methods&quot;</span>]
        method_sources <span style="color: #666666">=</span> {m[<span style="color: #BA2121">&quot;source&quot;</span>] <span style="color: #008000; font-weight: bold">for</span> m <span style="color: #AA22FF; font-weight: bold">in</span> methods}
        <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #008000">len</span>(chunks) <span style="color: #666666">==</span> <span style="color: #008000">len</span>(methods)
        <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #008000">set</span>(chunks) <span style="color: #666666">==</span> method_sources
</code></pre>
<h3 id="test_subclass_methods_are_summarized">test_subclass_methods_are_summarized(tmp_path: Path) -&gt; None</h3>
<p>The function `test_subclass_methods_are_summarized` is designed to test the documentation generation process, specifically focusing on subclass methods. It creates a temporary project directory with a nested class structure and uses mocks to simulate interactions with an LLM client and summarization functions. The function asserts that the method of a subclass is included in the calls made to the chunked summarization function during the documentation generation process.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">test_subclass_methods_are_summarized</span>(tmp_path: Path) <span style="color: #666666">-&gt;</span> <span style="color: #008000; font-weight: bold">None</span>:
    project_dir <span style="color: #666666">=</span> tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;proj&quot;</span>
    project_dir<span style="color: #666666">.</span>mkdir()
    (project_dir <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;mod.py&quot;</span>)<span style="color: #666666">.</span>write_text(
        <span style="color: #BA2121">&quot;class A:</span><span style="color: #AA5D1F; font-weight: bold">\n</span><span style="color: #BA2121">    class B:</span><span style="color: #AA5D1F; font-weight: bold">\n</span><span style="color: #BA2121">        def m(self):</span><span style="color: #AA5D1F; font-weight: bold">\n</span><span style="color: #BA2121">            pass</span><span style="color: #AA5D1F; font-weight: bold">\n</span><span style="color: #BA2121">&quot;</span>
    )

    output_dir <span style="color: #666666">=</span> tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;docs&quot;</span>

    <span style="color: #008000; font-weight: bold">with</span> patch(<span style="color: #BA2121">&quot;docgenerator.LLMClient&quot;</span>) <span style="color: #008000; font-weight: bold">as</span> MockClient, patch(
        <span style="color: #BA2121">&quot;docgenerator._summarize&quot;</span>,
        return_value<span style="color: #666666">=</span><span style="color: #BA2121">&quot;summary&quot;</span>,
    ), patch(
        <span style="color: #BA2121">&quot;docgenerator._summarize_chunked&quot;</span>,
        return_value<span style="color: #666666">=</span><span style="color: #BA2121">&quot;summary&quot;</span>,
    ) <span style="color: #008000; font-weight: bold">as</span> mock_chunk:
        instance <span style="color: #666666">=</span> MockClient<span style="color: #666666">.</span>return_value
        instance<span style="color: #666666">.</span>ping<span style="color: #666666">.</span>return_value <span style="color: #666666">=</span> <span style="color: #008000; font-weight: bold">True</span>
        ret <span style="color: #666666">=</span> main([<span style="color: #008000">str</span>(project_dir), <span style="color: #BA2121">&quot;--output&quot;</span>, <span style="color: #008000">str</span>(output_dir)])
        <span style="color: #008000; font-weight: bold">assert</span> ret <span style="color: #666666">==</span> <span style="color: #666666">0</span>

    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #008000">any</span>(<span style="color: #BA2121">&quot;B:m&quot;</span> <span style="color: #AA22FF; font-weight: bold">in</span> call<span style="color: #666666">.</span>args[<span style="color: #666666">2</span>] <span style="color: #008000; font-weight: bold">for</span> call <span style="color: #AA22FF; font-weight: bold">in</span> mock_chunk<span style="color: #666666">.</span>call_args_list)
</code></pre>
    </div>
    <script src="static/toggle.js"></script>
</body>
</html>
