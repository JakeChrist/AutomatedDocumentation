<!-- Generated by DocGen-LM -->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>test_docgenerator</title>
    <link rel="stylesheet" href="static/style.css">
</head>
<body>
    <button id="sidebar-toggle">Menu</button>
    <div class="sidebar">
        <h2>Navigation</h2>
        <ul>
        <li><a href="index.html"><strong>üè† Project Overview</strong></a></li>
<li><a href="cache.html">cache</a></li>
<li><a href="chunk_utils.html">chunk_utils</a></li>
<li><a href="docgenerator.html">docgenerator</a></li>
<li><a href="explaincode.html">explaincode</a></li>
<li><a href="gui_wrapper.html">gui_wrapper</a></li>
<li><a href="html_writer.html">html_writer</a></li>
<li><a href="llm_client.html">llm_client</a></li>
<li><a href="manual_utils.html">manual_utils</a></li>
<li><a href="parser_cpp.html">parser_cpp</a></li>
<li><a href="parser_java.html">parser_java</a></li>
<li><a href="parser_matlab.html">parser_matlab</a></li>
<li><a href="parser_python.html">parser_python</a></li>
<li><a href="reviewer.html">reviewer</a></li>
<li><a href="scanner.html">scanner</a></li>
<li><a href="setup.html">setup</a></li>
<li><a href="summarize_utils.html">summarize_utils</a></li>
<li><a href="test_cache.html">test_cache</a></li>
<li><a href="test_chunk_utils.html">test_chunk_utils</a></li>
<li><a href="test_docgenerator.html">test_docgenerator</a></li>
<li><a href="test_docgenerator_subclasses.html">test_docgenerator_subclasses</a></li>
<li><a href="test_explaincode.html">test_explaincode</a></li>
<li><a href="test_html_writer.html">test_html_writer</a></li>
<li><a href="test_integration.html">test_integration</a></li>
<li><a href="test_llm_client.html">test_llm_client</a></li>
<li><a href="test_manual_utils.html">test_manual_utils</a></li>
<li><a href="test_parser_cpp.html">test_parser_cpp</a></li>
<li><a href="test_parser_java.html">test_parser_java</a></li>
<li><a href="test_parser_matlab.html">test_parser_matlab</a></li>
<li><a href="test_parser_python.html">test_parser_python</a></li>
<li><a href="test_reviewer.html">test_reviewer</a></li>
<li><a href="test_scanner.html">test_scanner</a></li>
        </ul>
    </div>
    <div class="content">
        <h1>test_docgenerator</h1>
        <p>The module contains unit tests for a code documentation generator. It uses the `unittest.mock` library to patch dependencies and test various scenarios, such as handling invalid Python files, generating summaries for classes and functions, skipping non-UTF8 files, and processing different programming languages like C++, Java, and Python. The tests ensure that the generator correctly identifies and processes different types of code elements while skipping or sanitizing problematic files.</p>
<h2>Functions</h2>
<h3 id="test_skips_invalid_python_file">test_skips_invalid_python_file(tmp_path: Path) -&gt; None</h3>
<p>The function `test_skips_invalid_python_file` tests the behavior of a documentation generation tool when encountering an invalid Python file. It creates a temporary project directory with an invalid Python file (`bad.py`) that contains a syntax error due to a leading zero in a numeric literal. The function then runs the main documentation generation command, mocking an LLM client to return a summary for valid files and asserting that the process completes successfully (return code 0). After execution, it verifies that only the index page is generated in the output directory, while the invalid file&#x27;s documentation is not created.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">test_skips_invalid_python_file</span>(tmp_path: Path) <span style="color: #666666">-&gt;</span> <span style="color: #008000; font-weight: bold">None</span>:
    project_dir <span style="color: #666666">=</span> tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;proj&quot;</span>
    project_dir<span style="color: #666666">.</span>mkdir()
    <span style="color: #3D7B7B; font-style: italic"># file with invalid syntax due to leading zero</span>
    (project_dir <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;bad.py&quot;</span>)<span style="color: #666666">.</span>write_text(<span style="color: #BA2121">&quot;x = 08</span><span style="color: #AA5D1F; font-weight: bold">\n</span><span style="color: #BA2121">&quot;</span>)

    output_dir <span style="color: #666666">=</span> tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;docs&quot;</span>

    <span style="color: #008000; font-weight: bold">with</span> patch(<span style="color: #BA2121">&quot;docgenerator.LLMClient&quot;</span>) <span style="color: #008000; font-weight: bold">as</span> MockClient:
        instance <span style="color: #666666">=</span> MockClient<span style="color: #666666">.</span>return_value
        instance<span style="color: #666666">.</span>ping<span style="color: #666666">.</span>return_value <span style="color: #666666">=</span> <span style="color: #008000; font-weight: bold">True</span>
        instance<span style="color: #666666">.</span>summarize<span style="color: #666666">.</span>return_value <span style="color: #666666">=</span> <span style="color: #BA2121">&quot;summary&quot;</span>
        ret <span style="color: #666666">=</span> main([<span style="color: #008000">str</span>(project_dir), <span style="color: #BA2121">&quot;--output&quot;</span>, <span style="color: #008000">str</span>(output_dir)])
        <span style="color: #008000; font-weight: bold">assert</span> ret <span style="color: #666666">==</span> <span style="color: #666666">0</span>

    <span style="color: #3D7B7B; font-style: italic"># only index page should be generated</span>
    <span style="color: #008000; font-weight: bold">assert</span> (output_dir <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;index.html&quot;</span>)<span style="color: #666666">.</span>exists()
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #AA22FF; font-weight: bold">not</span> (output_dir <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;bad.html&quot;</span>)<span style="color: #666666">.</span>exists()
</code></pre>
<h3 id="test_generates_class_and_function_summaries">test_generates_class_and_function_summaries(tmp_path: Path) -&gt; None</h3>
<p>This function `test_generates_class_and_function_summaries` tests the generation of class and function summaries using a mock LLM client. It creates a temporary project directory with a Python module containing a class and a function, then invokes the main function with specified output directory. The mock client is configured to return predefined summaries for different components. After running the main function, it asserts that the correct summaries are generated and written to HTML files in the output directory.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">test_generates_class_and_function_summaries</span>(tmp_path: Path) <span style="color: #666666">-&gt;</span> <span style="color: #008000; font-weight: bold">None</span>:
    project_dir <span style="color: #666666">=</span> tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;proj&quot;</span>
    project_dir<span style="color: #666666">.</span>mkdir()
    (project_dir <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;mod.py&quot;</span>)<span style="color: #666666">.</span>write_text(
        <span style="color: #BA2121">&#39;class Foo:</span><span style="color: #AA5D1F; font-weight: bold">\n</span><span style="color: #BA2121">    &quot;&quot;&quot;Doc&quot;&quot;&quot;</span><span style="color: #AA5D1F; font-weight: bold">\n</span><span style="color: #BA2121">    pass</span><span style="color: #AA5D1F; font-weight: bold">\n\n</span><span style="color: #BA2121">&#39;</span> <span style="color: #BA2121">&quot;def bar():</span><span style="color: #AA5D1F; font-weight: bold">\n</span><span style="color: #BA2121">    return 1</span><span style="color: #AA5D1F; font-weight: bold">\n</span><span style="color: #BA2121">&quot;</span>
    )

    output_dir <span style="color: #666666">=</span> tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;docs&quot;</span>

    <span style="color: #008000; font-weight: bold">with</span> patch(<span style="color: #BA2121">&quot;docgenerator.LLMClient&quot;</span>) <span style="color: #008000; font-weight: bold">as</span> MockClient:
        instance <span style="color: #666666">=</span> MockClient<span style="color: #666666">.</span>return_value
        instance<span style="color: #666666">.</span>ping<span style="color: #666666">.</span>return_value <span style="color: #666666">=</span> <span style="color: #008000; font-weight: bold">True</span>
        instance<span style="color: #666666">.</span>summarize<span style="color: #666666">.</span>side_effect <span style="color: #666666">=</span> [
            <span style="color: #BA2121">&quot;module summary&quot;</span>,
            <span style="color: #BA2121">&quot;project summary&quot;</span>,
            <span style="color: #BA2121">&quot;class summary&quot;</span>,
            <span style="color: #BA2121">&quot;improved class doc&quot;</span>,
            <span style="color: #BA2121">&quot;function summary&quot;</span>,
            <span style="color: #BA2121">&quot;improved function doc&quot;</span>,
        ]
        ret <span style="color: #666666">=</span> main([<span style="color: #008000">str</span>(project_dir), <span style="color: #BA2121">&quot;--output&quot;</span>, <span style="color: #008000">str</span>(output_dir)])
        <span style="color: #008000; font-weight: bold">assert</span> ret <span style="color: #666666">==</span> <span style="color: #666666">0</span>

    html <span style="color: #666666">=</span> (output_dir <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;mod.html&quot;</span>)<span style="color: #666666">.</span>read_text(encoding<span style="color: #666666">=</span><span style="color: #BA2121">&quot;utf-8&quot;</span>)
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #BA2121">&quot;improved class doc&quot;</span> <span style="color: #AA22FF; font-weight: bold">in</span> html
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #BA2121">&quot;function summary&quot;</span> <span style="color: #AA22FF; font-weight: bold">in</span> html
    index_html <span style="color: #666666">=</span> (output_dir <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;index.html&quot;</span>)<span style="color: #666666">.</span>read_text(encoding<span style="color: #666666">=</span><span style="color: #BA2121">&quot;utf-8&quot;</span>)
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #BA2121">&quot;module summary&quot;</span> <span style="color: #AA22FF; font-weight: bold">in</span> index_html
</code></pre>
<h3 id="test_skips_non_utf8_file">test_skips_non_utf8_file(tmp_path: Path) -&gt; None</h3>
<p>The function `test_skips_non_utf8_file` tests the behavior of a documentation generation tool when encountering non-UTF-8 encoded files. It creates a temporary project directory with a file that contains non-UTF-8 bytes, then runs the main function of the documentation generator with this project directory and an output directory specified. The test uses a mock LLM client to simulate successful ping and summary responses. After running the main function, it asserts that the tool skips generating documentation for the non-UTF-8 file and successfully generates documentation for other files in the project, creating an `index.html` file but not a `bad.html` file.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">test_skips_non_utf8_file</span>(tmp_path: Path) <span style="color: #666666">-&gt;</span> <span style="color: #008000; font-weight: bold">None</span>:
    project_dir <span style="color: #666666">=</span> tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;proj&quot;</span>
    project_dir<span style="color: #666666">.</span>mkdir()
    (project_dir <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;bad.py&quot;</span>)<span style="color: #666666">.</span>write_bytes(<span style="color: #BA2121">b&quot;</span><span style="color: #AA5D1F; font-weight: bold">\xff\xfe\xfd</span><span style="color: #BA2121">&quot;</span>)

    output_dir <span style="color: #666666">=</span> tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;docs&quot;</span>

    <span style="color: #008000; font-weight: bold">with</span> patch(<span style="color: #BA2121">&quot;docgenerator.LLMClient&quot;</span>) <span style="color: #008000; font-weight: bold">as</span> MockClient:
        instance <span style="color: #666666">=</span> MockClient<span style="color: #666666">.</span>return_value
        instance<span style="color: #666666">.</span>ping<span style="color: #666666">.</span>return_value <span style="color: #666666">=</span> <span style="color: #008000; font-weight: bold">True</span>
        instance<span style="color: #666666">.</span>summarize<span style="color: #666666">.</span>return_value <span style="color: #666666">=</span> <span style="color: #BA2121">&quot;summary&quot;</span>
        ret <span style="color: #666666">=</span> main([<span style="color: #008000">str</span>(project_dir), <span style="color: #BA2121">&quot;--output&quot;</span>, <span style="color: #008000">str</span>(output_dir)])
        <span style="color: #008000; font-weight: bold">assert</span> ret <span style="color: #666666">==</span> <span style="color: #666666">0</span>

    <span style="color: #008000; font-weight: bold">assert</span> (output_dir <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;index.html&quot;</span>)<span style="color: #666666">.</span>exists()
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #AA22FF; font-weight: bold">not</span> (output_dir <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;bad.html&quot;</span>)<span style="color: #666666">.</span>exists()
</code></pre>
<h3 id="test_handles_class_without_docstring">test_handles_class_without_docstring(tmp_path: Path) -&gt; None</h3>
<p>The function `test_handles_class_without_docstring` tests the handling of a Python class without a docstring by creating a temporary project directory, writing a Python file with an empty class definition, and then running the main function with the project directory as input. It uses a mock LLMClient to simulate responses for summarizing the module, project, and class. The test asserts that the return value of the main function is 0 and that the generated HTML file contains the class summary.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">test_handles_class_without_docstring</span>(tmp_path: Path) <span style="color: #666666">-&gt;</span> <span style="color: #008000; font-weight: bold">None</span>:
    project_dir <span style="color: #666666">=</span> tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;proj&quot;</span>
    project_dir<span style="color: #666666">.</span>mkdir()
    (project_dir <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;mod.py&quot;</span>)<span style="color: #666666">.</span>write_text(<span style="color: #BA2121">&quot;class Foo:</span><span style="color: #AA5D1F; font-weight: bold">\n</span><span style="color: #BA2121">    pass</span><span style="color: #AA5D1F; font-weight: bold">\n</span><span style="color: #BA2121">&quot;</span>)

    output_dir <span style="color: #666666">=</span> tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;docs&quot;</span>

    <span style="color: #008000; font-weight: bold">with</span> patch(<span style="color: #BA2121">&quot;docgenerator.LLMClient&quot;</span>) <span style="color: #008000; font-weight: bold">as</span> MockClient:
        instance <span style="color: #666666">=</span> MockClient<span style="color: #666666">.</span>return_value
        instance<span style="color: #666666">.</span>ping<span style="color: #666666">.</span>return_value <span style="color: #666666">=</span> <span style="color: #008000; font-weight: bold">True</span>
        instance<span style="color: #666666">.</span>summarize<span style="color: #666666">.</span>side_effect <span style="color: #666666">=</span> [
            <span style="color: #BA2121">&quot;module summary&quot;</span>,
            <span style="color: #BA2121">&quot;project summary&quot;</span>,
            <span style="color: #BA2121">&quot;class summary&quot;</span>,
        ]
        ret <span style="color: #666666">=</span> main([<span style="color: #008000">str</span>(project_dir), <span style="color: #BA2121">&quot;--output&quot;</span>, <span style="color: #008000">str</span>(output_dir)])
        <span style="color: #008000; font-weight: bold">assert</span> ret <span style="color: #666666">==</span> <span style="color: #666666">0</span>

    html <span style="color: #666666">=</span> (output_dir <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;mod.html&quot;</span>)<span style="color: #666666">.</span>read_text(encoding<span style="color: #666666">=</span><span style="color: #BA2121">&quot;utf-8&quot;</span>)
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #BA2121">&quot;class summary&quot;</span> <span style="color: #AA22FF; font-weight: bold">in</span> html
</code></pre>
<h3 id="test_project_summary_is_sanitized">test_project_summary_is_sanitized(tmp_path: Path) -&gt; None</h3>
<p>The function `test_project_summary_is_sanitized` is a unit test that verifies the sanitization of project summaries generated by the DocGen-LM tool. It creates a temporary project directory with a Python module, invokes the main function with this project directory and an output directory, and asserts that the generated HTML does not contain certain unwanted strings while ensuring that the LLMClient&#x27;s `summarize` method is called appropriately for different entities in the project (module, project, function).</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">test_project_summary_is_sanitized</span>(tmp_path: Path) <span style="color: #666666">-&gt;</span> <span style="color: #008000; font-weight: bold">None</span>:
    project_dir <span style="color: #666666">=</span> tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;proj&quot;</span>
    project_dir<span style="color: #666666">.</span>mkdir()
    (project_dir <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;mod.py&quot;</span>)<span style="color: #666666">.</span>write_text(<span style="color: #BA2121">&quot;def foo():</span><span style="color: #AA5D1F; font-weight: bold">\n</span><span style="color: #BA2121">    pass</span><span style="color: #AA5D1F; font-weight: bold">\n</span><span style="color: #BA2121">&quot;</span>)

    output_dir <span style="color: #666666">=</span> tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;docs&quot;</span>

    <span style="color: #008000; font-weight: bold">with</span> patch(<span style="color: #BA2121">&quot;docgenerator.LLMClient&quot;</span>) <span style="color: #008000; font-weight: bold">as</span> MockClient:
        instance <span style="color: #666666">=</span> MockClient<span style="color: #666666">.</span>return_value
        instance<span style="color: #666666">.</span>ping<span style="color: #666666">.</span>return_value <span style="color: #666666">=</span> <span style="color: #008000; font-weight: bold">True</span>
        instance<span style="color: #666666">.</span>summarize<span style="color: #666666">.</span>side_effect <span style="color: #666666">=</span> [
            <span style="color: #BA2121">&quot;module summary&quot;</span>,
            <span style="color: #BA2121">&quot;project summary&quot;</span>,
            <span style="color: #BA2121">&quot;function summary&quot;</span>,
            <span style="color: #BA2121">&quot;improved function doc&quot;</span>,
        ]
        ret <span style="color: #666666">=</span> main([<span style="color: #008000">str</span>(project_dir), <span style="color: #BA2121">&quot;--output&quot;</span>, <span style="color: #008000">str</span>(output_dir)])
        <span style="color: #008000; font-weight: bold">assert</span> ret <span style="color: #666666">==</span> <span style="color: #666666">0</span>

    html <span style="color: #666666">=</span> (output_dir <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;index.html&quot;</span>)<span style="color: #666666">.</span>read_text(encoding<span style="color: #666666">=</span><span style="color: #BA2121">&quot;utf-8&quot;</span>)
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #BA2121">&quot;You can run this&quot;</span> <span style="color: #AA22FF; font-weight: bold">not</span> <span style="color: #AA22FF; font-weight: bold">in</span> html
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #BA2121">&quot;It prints.&quot;</span> <span style="color: #AA22FF; font-weight: bold">in</span> html
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #008000">any</span>(call<span style="color: #666666">.</span>args[<span style="color: #666666">1</span>] <span style="color: #666666">==</span> <span style="color: #BA2121">&quot;project&quot;</span> <span style="color: #008000; font-weight: bold">for</span> call <span style="color: #AA22FF; font-weight: bold">in</span> instance<span style="color: #666666">.</span>summarize<span style="color: #666666">.</span>call_args_list)
</code></pre>
<h3 id="test_readme_summary_used">test_readme_summary_used(tmp_path: Path) -&gt; None</h3>
<p>The function `test_readme_summary_used` tests the generation of documentation for a project that includes a README file. It creates a temporary project directory with a Python module and a README file, then uses a mock LLM client to simulate summarization of the README content. The function asserts that the main command returns 0 (indicating success) and checks if the generated HTML output contains a summary of the README.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">test_readme_summary_used</span>(tmp_path: Path) <span style="color: #666666">-&gt;</span> <span style="color: #008000; font-weight: bold">None</span>:
    project_dir <span style="color: #666666">=</span> tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;proj&quot;</span>
    project_dir<span style="color: #666666">.</span>mkdir()
    (project_dir <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;mod.py&quot;</span>)<span style="color: #666666">.</span>write_text(<span style="color: #BA2121">&quot;def foo():</span><span style="color: #AA5D1F; font-weight: bold">\n</span><span style="color: #BA2121">    pass</span><span style="color: #AA5D1F; font-weight: bold">\n</span><span style="color: #BA2121">&quot;</span>)
    (project_dir <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;README.md&quot;</span>)<span style="color: #666666">.</span>write_text(<span style="color: #BA2121">&quot;Project docs&quot;</span>)

    output_dir <span style="color: #666666">=</span> tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;docs&quot;</span>

    <span style="color: #008000; font-weight: bold">with</span> patch(<span style="color: #BA2121">&quot;docgenerator.LLMClient&quot;</span>) <span style="color: #008000; font-weight: bold">as</span> MockClient:
        instance <span style="color: #666666">=</span> MockClient<span style="color: #666666">.</span>return_value
        instance<span style="color: #666666">.</span>ping<span style="color: #666666">.</span>return_value <span style="color: #666666">=</span> <span style="color: #008000; font-weight: bold">True</span>
        instance<span style="color: #666666">.</span>summarize<span style="color: #666666">.</span>side_effect <span style="color: #666666">=</span> <span style="color: #008000; font-weight: bold">lambda</span> text, pt, <span style="color: #666666">**</span>kwargs: <span style="color: #BA2121">f&quot;</span><span style="color: #A45A77; font-weight: bold">{</span>pt<span style="color: #A45A77; font-weight: bold">}</span><span style="color: #BA2121"> summary&quot;</span>
        ret <span style="color: #666666">=</span> main([<span style="color: #008000">str</span>(project_dir), <span style="color: #BA2121">&quot;--output&quot;</span>, <span style="color: #008000">str</span>(output_dir)])
        <span style="color: #008000; font-weight: bold">assert</span> ret <span style="color: #666666">==</span> <span style="color: #666666">0</span>

    html <span style="color: #666666">=</span> (output_dir <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;index.html&quot;</span>)<span style="color: #666666">.</span>read_text(encoding<span style="color: #666666">=</span><span style="color: #BA2121">&quot;utf-8&quot;</span>)
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #BA2121">&quot;readme summary&quot;</span> <span style="color: #AA22FF; font-weight: bold">in</span> html
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #008000">any</span>(call<span style="color: #666666">.</span>args[<span style="color: #666666">1</span>] <span style="color: #666666">==</span> <span style="color: #BA2121">&quot;readme&quot;</span> <span style="color: #008000; font-weight: bold">for</span> call <span style="color: #AA22FF; font-weight: bold">in</span> instance<span style="color: #666666">.</span>summarize<span style="color: #666666">.</span>call_args_list)
</code></pre>
<h3 id="test_clean_output_dir">test_clean_output_dir(tmp_path: Path) -&gt; None</h3>
<p>The function `test_clean_output_dir` tests the `clean_output_dir` function from the `docgenerator` module. It creates a temporary directory, generates an HTML file with a specific comment, and another HTML file without any comment. A CSS file is also created. The `clean_output_dir` function is then called with the path to the temporary directory as an argument. After the function call, it asserts that the generated HTML file no longer exists, while the custom HTML file and the CSS file still exist.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">test_clean_output_dir</span>(tmp_path: Path) <span style="color: #666666">-&gt;</span> <span style="color: #008000; font-weight: bold">None</span>:
    out <span style="color: #666666">=</span> tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;docs&quot;</span>
    out<span style="color: #666666">.</span>mkdir()
    generated <span style="color: #666666">=</span> out <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;old.html&quot;</span>
    generated<span style="color: #666666">.</span>write_text(<span style="color: #BA2121">&quot;&lt;!-- Generated by DocGen-LM --&gt;</span><span style="color: #AA5D1F; font-weight: bold">\n</span><span style="color: #BA2121">&lt;html&gt;&lt;/html&gt;&quot;</span>, encoding<span style="color: #666666">=</span><span style="color: #BA2121">&quot;utf-8&quot;</span>)
    custom <span style="color: #666666">=</span> out <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;custom.html&quot;</span>
    custom<span style="color: #666666">.</span>write_text(<span style="color: #BA2121">&quot;&lt;html&gt;&lt;/html&gt;&quot;</span>, encoding<span style="color: #666666">=</span><span style="color: #BA2121">&quot;utf-8&quot;</span>)
    asset <span style="color: #666666">=</span> out <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;style.css&quot;</span>
    asset<span style="color: #666666">.</span>write_text(<span style="color: #BA2121">&quot;body </span><span style="color: #A45A77; font-weight: bold">{}</span><span style="color: #BA2121">&quot;</span>, encoding<span style="color: #666666">=</span><span style="color: #BA2121">&quot;utf-8&quot;</span>)

    <span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">docgenerator</span> <span style="color: #008000; font-weight: bold">import</span> clean_output_dir

    clean_output_dir(<span style="color: #008000">str</span>(out))

    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #AA22FF; font-weight: bold">not</span> generated<span style="color: #666666">.</span>exists()
    <span style="color: #008000; font-weight: bold">assert</span> custom<span style="color: #666666">.</span>exists()
    <span style="color: #008000; font-weight: bold">assert</span> asset<span style="color: #666666">.</span>exists()
</code></pre>
<h3 id="test_summarize_chunked_splits_long_text">test_summarize_chunked_splits_long_text(tmp_path: Path) -&gt; None</h3>
<p>This function tests the `summarize_chunked` utility by mocking the `_summarize` method to return a fixed summary. It uses a tokenizer, a cache, and a temporary path for caching responses. The test ensures that the `summarize_chunked` function is called multiple times when processing a long text, demonstrating its ability to handle chunking based on token limits.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">test_summarize_chunked_splits_long_text</span>(tmp_path: Path) <span style="color: #666666">-&gt;</span> <span style="color: #008000; font-weight: bold">None</span>:
    <span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">cache</span> <span style="color: #008000; font-weight: bold">import</span> ResponseCache
    <span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">chunk_utils</span> <span style="color: #008000; font-weight: bold">import</span> get_tokenizer
    <span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">summarize_utils</span> <span style="color: #008000; font-weight: bold">import</span> summarize_chunked

    tokenizer <span style="color: #666666">=</span> get_tokenizer()
    text <span style="color: #666666">=</span> <span style="color: #BA2121">&quot;word &quot;</span> <span style="color: #666666">*</span> <span style="color: #666666">50</span>
    cache <span style="color: #666666">=</span> ResponseCache(<span style="color: #008000">str</span>(tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;cache.json&quot;</span>))

    <span style="color: #008000; font-weight: bold">with</span> patch(<span style="color: #BA2121">&quot;summarize_utils._summarize&quot;</span>, return_value<span style="color: #666666">=</span><span style="color: #BA2121">&quot;summary&quot;</span>) <span style="color: #008000; font-weight: bold">as</span> mock_sum:
        summarize_chunked(
            client<span style="color: #666666">=</span><span style="color: #008000">object</span>(),
            cache<span style="color: #666666">=</span>cache,
            key_prefix<span style="color: #666666">=</span><span style="color: #BA2121">&quot;k&quot;</span>,
            text<span style="color: #666666">=</span>text,
            prompt_type<span style="color: #666666">=</span><span style="color: #BA2121">&quot;module&quot;</span>,
            max_context_tokens<span style="color: #666666">=10</span>,
            chunk_token_budget<span style="color: #666666">=5</span>,
        )
        <span style="color: #008000; font-weight: bold">assert</span> mock_sum<span style="color: #666666">.</span>call_count <span style="color: #666666">&gt;</span> <span style="color: #666666">1</span>
</code></pre>
<h3 id="test_chunking_accounts_for_prompt_overhead">test_chunking_accounts_for_prompt_overhead(tmp_path: Path) -&gt; None</h3>
<p>The function `test_chunking_accounts_for_prompt_overhead` tests the chunking functionality of code summaries by ensuring that the system prompt and template overhead is accounted for when determining the maximum context tokens. It uses a mock to verify that the `_summarize` function is called more than once, indicating that the text has been successfully chunked.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">test_chunking_accounts_for_prompt_overhead</span>(tmp_path: Path) <span style="color: #666666">-&gt;</span> <span style="color: #008000; font-weight: bold">None</span>:
    <span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">cache</span> <span style="color: #008000; font-weight: bold">import</span> ResponseCache
    <span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">chunk_utils</span> <span style="color: #008000; font-weight: bold">import</span> get_tokenizer
    <span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">summarize_utils</span> <span style="color: #008000; font-weight: bold">import</span> summarize_chunked
    <span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">llm_client</span> <span style="color: #008000; font-weight: bold">import</span> SYSTEM_PROMPT, PROMPT_TEMPLATES

    tokenizer <span style="color: #666666">=</span> get_tokenizer()
    text <span style="color: #666666">=</span> <span style="color: #BA2121">&quot;word &quot;</span> <span style="color: #666666">*</span> <span style="color: #666666">15</span>
    cache <span style="color: #666666">=</span> ResponseCache(<span style="color: #008000">str</span>(tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;cache.json&quot;</span>))
    template <span style="color: #666666">=</span> PROMPT_TEMPLATES[<span style="color: #BA2121">&quot;module&quot;</span>]
    overhead <span style="color: #666666">=</span> <span style="color: #008000">len</span>(tokenizer<span style="color: #666666">.</span>encode(SYSTEM_PROMPT)) <span style="color: #666666">+</span> <span style="color: #008000">len</span>(tokenizer<span style="color: #666666">.</span>encode(template<span style="color: #666666">.</span>format(text<span style="color: #666666">=</span><span style="color: #BA2121">&quot;&quot;</span>)))
    max_context_tokens <span style="color: #666666">=</span> overhead <span style="color: #666666">+</span> <span style="color: #666666">10</span>

    <span style="color: #008000; font-weight: bold">with</span> patch(<span style="color: #BA2121">&quot;summarize_utils._summarize&quot;</span>, return_value<span style="color: #666666">=</span><span style="color: #BA2121">&quot;summary&quot;</span>) <span style="color: #008000; font-weight: bold">as</span> mock_sum:
        summarize_chunked(
            client<span style="color: #666666">=</span><span style="color: #008000">object</span>(),
            cache<span style="color: #666666">=</span>cache,
            key_prefix<span style="color: #666666">=</span><span style="color: #BA2121">&quot;k&quot;</span>,
            text<span style="color: #666666">=</span>text,
            prompt_type<span style="color: #666666">=</span><span style="color: #BA2121">&quot;module&quot;</span>,
            max_context_tokens<span style="color: #666666">=</span>max_context_tokens,
            chunk_token_budget<span style="color: #666666">=100</span>,
        )
        <span style="color: #008000; font-weight: bold">assert</span> mock_sum<span style="color: #666666">.</span>call_count <span style="color: #666666">&gt;</span> <span style="color: #666666">1</span>
</code></pre>
<h3 id="test_merge_recurses_when_prompt_too_long">test_merge_recurses_when_prompt_too_long(tmp_path: Path) -&gt; None</h3>
<p>The function `test_merge_recurses_when_prompt_too_long` tests the behavior of merging recursive summaries when the prompt exceeds a certain length. It uses a fake summarization function to simulate responses and asserts that the merge calls are made multiple times for docstrings. The test ensures that the system can handle long prompts by recursively breaking them down into manageable chunks.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">test_merge_recurses_when_prompt_too_long</span>(tmp_path: Path) <span style="color: #666666">-&gt;</span> <span style="color: #008000; font-weight: bold">None</span>:
    <span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">cache</span> <span style="color: #008000; font-weight: bold">import</span> ResponseCache
    <span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">chunk_utils</span> <span style="color: #008000; font-weight: bold">import</span> get_tokenizer
    <span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">summarize_utils</span> <span style="color: #008000; font-weight: bold">import</span> summarize_chunked
    <span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">llm_client</span> <span style="color: #008000; font-weight: bold">import</span> SYSTEM_PROMPT, PROMPT_TEMPLATES

    tokenizer <span style="color: #666666">=</span> get_tokenizer()
    text <span style="color: #666666">=</span> <span style="color: #BA2121">&quot;word &quot;</span> <span style="color: #666666">*</span> <span style="color: #666666">200</span>
    cache <span style="color: #666666">=</span> ResponseCache(<span style="color: #008000">str</span>(tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;cache.json&quot;</span>))
    template <span style="color: #666666">=</span> PROMPT_TEMPLATES[<span style="color: #BA2121">&quot;module&quot;</span>]
    overhead <span style="color: #666666">=</span> <span style="color: #008000">len</span>(tokenizer<span style="color: #666666">.</span>encode(SYSTEM_PROMPT)) <span style="color: #666666">+</span> <span style="color: #008000">len</span>(
        tokenizer<span style="color: #666666">.</span>encode(template<span style="color: #666666">.</span>format(text<span style="color: #666666">=</span><span style="color: #BA2121">&quot;&quot;</span>))
    )
    max_context_tokens <span style="color: #666666">=</span> overhead <span style="color: #666666">+</span> <span style="color: #666666">50</span>

    <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">fake_sum</span>(client, cache_obj, key, text_arg, prompt_type, <span style="color: #666666">*</span>, system_prompt<span style="color: #666666">=</span><span style="color: #BA2121">&quot;&quot;</span>):
        template <span style="color: #666666">=</span> PROMPT_TEMPLATES<span style="color: #666666">.</span>get(prompt_type, PROMPT_TEMPLATES[<span style="color: #BA2121">&quot;module&quot;</span>])
        overhead <span style="color: #666666">=</span> <span style="color: #008000">len</span>(tokenizer<span style="color: #666666">.</span>encode(SYSTEM_PROMPT)) <span style="color: #666666">+</span> <span style="color: #008000">len</span>(
            tokenizer<span style="color: #666666">.</span>encode(template<span style="color: #666666">.</span>format(text<span style="color: #666666">=</span><span style="color: #BA2121">&quot;&quot;</span>))
        )
        available <span style="color: #666666">=</span> max_context_tokens <span style="color: #666666">-</span> overhead
        <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #008000">len</span>(tokenizer<span style="color: #666666">.</span>encode(text_arg)) <span style="color: #666666">&lt;=</span> available
        <span style="color: #008000; font-weight: bold">if</span> prompt_type <span style="color: #666666">==</span> <span style="color: #BA2121">&quot;module&quot;</span>:
            <span style="color: #008000; font-weight: bold">return</span> <span style="color: #BA2121">&quot;summary &quot;</span> <span style="color: #666666">*</span> <span style="color: #666666">30</span>
        <span style="color: #008000; font-weight: bold">return</span> <span style="color: #BA2121">&quot;short&quot;</span>

    <span style="color: #008000; font-weight: bold">with</span> patch(<span style="color: #BA2121">&quot;summarize_utils._summarize&quot;</span>, side_effect<span style="color: #666666">=</span>fake_sum) <span style="color: #008000; font-weight: bold">as</span> mock_sum:
        summarize_chunked(
            client<span style="color: #666666">=</span><span style="color: #008000">object</span>(),
            cache<span style="color: #666666">=</span>cache,
            key_prefix<span style="color: #666666">=</span><span style="color: #BA2121">&quot;k&quot;</span>,
            text<span style="color: #666666">=</span>text,
            prompt_type<span style="color: #666666">=</span><span style="color: #BA2121">&quot;module&quot;</span>,
            max_context_tokens<span style="color: #666666">=</span>max_context_tokens,
            chunk_token_budget<span style="color: #666666">=10</span>,
        )
        merge_calls <span style="color: #666666">=</span> [c <span style="color: #008000; font-weight: bold">for</span> c <span style="color: #AA22FF; font-weight: bold">in</span> mock_sum<span style="color: #666666">.</span>call_args_list <span style="color: #008000; font-weight: bold">if</span> c<span style="color: #666666">.</span>args[<span style="color: #666666">4</span>] <span style="color: #666666">==</span> <span style="color: #BA2121">&quot;docstring&quot;</span>]
        <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #008000">len</span>(merge_calls) <span style="color: #666666">&gt;</span> <span style="color: #666666">1</span>
</code></pre>
<details>
<summary>Subfunction: fake_sum(client, cache_obj, key, text_arg, prompt_type, *, system_prompt=&#x27;&#x27;)</summary>
<h4 id="fake_sum">fake_sum(client, cache_obj, key, text_arg, prompt_type, *, system_prompt=&#x27;&#x27;)</h4>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">fake_sum</span>(client, cache_obj, key, text_arg, prompt_type, <span style="color: #666666">*</span>, system_prompt<span style="color: #666666">=</span><span style="color: #BA2121">&quot;&quot;</span>):
        template <span style="color: #666666">=</span> PROMPT_TEMPLATES<span style="color: #666666">.</span>get(prompt_type, PROMPT_TEMPLATES[<span style="color: #BA2121">&quot;module&quot;</span>])
        overhead <span style="color: #666666">=</span> <span style="color: #008000">len</span>(tokenizer<span style="color: #666666">.</span>encode(SYSTEM_PROMPT)) <span style="color: #666666">+</span> <span style="color: #008000">len</span>(
            tokenizer<span style="color: #666666">.</span>encode(template<span style="color: #666666">.</span>format(text<span style="color: #666666">=</span><span style="color: #BA2121">&quot;&quot;</span>))
        )
        available <span style="color: #666666">=</span> max_context_tokens <span style="color: #666666">-</span> overhead
        <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #008000">len</span>(tokenizer<span style="color: #666666">.</span>encode(text_arg)) <span style="color: #666666">&lt;=</span> available
        <span style="color: #008000; font-weight: bold">if</span> prompt_type <span style="color: #666666">==</span> <span style="color: #BA2121">&quot;module&quot;</span>:
            <span style="color: #008000; font-weight: bold">return</span> <span style="color: #BA2121">&quot;summary &quot;</span> <span style="color: #666666">*</span> <span style="color: #666666">30</span>
        <span style="color: #008000; font-weight: bold">return</span> <span style="color: #BA2121">&quot;short&quot;</span>
</code></pre>
</details>
<h3 id="test_single_long_partial_is_recursively_chunked">test_single_long_partial_is_recursively_chunked(tmp_path: Path) -&gt; None</h3>
<p>This function tests the recursive chunking of a single long partial text using a local language model (LLM). It sets up a fake summarization function to simulate responses from the LLM and then calls `summarize_chunked` with specific parameters. The test asserts that the number of calls made to the fake summarization function for docstring prompts is greater than one, indicating successful recursive chunking.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">test_single_long_partial_is_recursively_chunked</span>(tmp_path: Path) <span style="color: #666666">-&gt;</span> <span style="color: #008000; font-weight: bold">None</span>:
    <span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">cache</span> <span style="color: #008000; font-weight: bold">import</span> ResponseCache
    <span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">chunk_utils</span> <span style="color: #008000; font-weight: bold">import</span> get_tokenizer
    <span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">summarize_utils</span> <span style="color: #008000; font-weight: bold">import</span> summarize_chunked
    <span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">llm_client</span> <span style="color: #008000; font-weight: bold">import</span> SYSTEM_PROMPT, PROMPT_TEMPLATES

    tokenizer <span style="color: #666666">=</span> get_tokenizer()
    text <span style="color: #666666">=</span> <span style="color: #BA2121">&quot;word &quot;</span> <span style="color: #666666">*</span> <span style="color: #666666">200</span>
    cache <span style="color: #666666">=</span> ResponseCache(<span style="color: #008000">str</span>(tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;cache.json&quot;</span>))
    template <span style="color: #666666">=</span> PROMPT_TEMPLATES[<span style="color: #BA2121">&quot;module&quot;</span>]
    overhead <span style="color: #666666">=</span> <span style="color: #008000">len</span>(tokenizer<span style="color: #666666">.</span>encode(SYSTEM_PROMPT)) <span style="color: #666666">+</span> <span style="color: #008000">len</span>(tokenizer<span style="color: #666666">.</span>encode(template<span style="color: #666666">.</span>format(text<span style="color: #666666">=</span><span style="color: #BA2121">&quot;&quot;</span>)))
    max_context_tokens <span style="color: #666666">=</span> overhead <span style="color: #666666">+</span> <span style="color: #666666">50</span>

    <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">fake_sum</span>(client, cache_obj, key, text_arg, prompt_type, <span style="color: #666666">*</span>, system_prompt<span style="color: #666666">=</span><span style="color: #BA2121">&quot;&quot;</span>):
        template <span style="color: #666666">=</span> PROMPT_TEMPLATES<span style="color: #666666">.</span>get(prompt_type, PROMPT_TEMPLATES[<span style="color: #BA2121">&quot;module&quot;</span>])
        overhead_local <span style="color: #666666">=</span> <span style="color: #008000">len</span>(tokenizer<span style="color: #666666">.</span>encode(SYSTEM_PROMPT)) <span style="color: #666666">+</span> <span style="color: #008000">len</span>(
            tokenizer<span style="color: #666666">.</span>encode(template<span style="color: #666666">.</span>format(text<span style="color: #666666">=</span><span style="color: #BA2121">&quot;&quot;</span>))
        )
        available <span style="color: #666666">=</span> max_context_tokens <span style="color: #666666">-</span> overhead_local
        <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #008000">len</span>(tokenizer<span style="color: #666666">.</span>encode(text_arg)) <span style="color: #666666">&lt;=</span> available
        <span style="color: #008000; font-weight: bold">if</span> prompt_type <span style="color: #666666">==</span> <span style="color: #BA2121">&quot;module&quot;</span>:
            <span style="color: #008000; font-weight: bold">return</span> <span style="color: #BA2121">&quot;long &quot;</span> <span style="color: #666666">*</span> <span style="color: #666666">200</span>
        <span style="color: #008000; font-weight: bold">return</span> <span style="color: #BA2121">&quot;short&quot;</span>

    <span style="color: #008000; font-weight: bold">with</span> patch(<span style="color: #BA2121">&quot;summarize_utils._summarize&quot;</span>, side_effect<span style="color: #666666">=</span>fake_sum) <span style="color: #008000; font-weight: bold">as</span> mock_sum:
        summarize_chunked(
            client<span style="color: #666666">=</span><span style="color: #008000">object</span>(),
            cache<span style="color: #666666">=</span>cache,
            key_prefix<span style="color: #666666">=</span><span style="color: #BA2121">&quot;k&quot;</span>,
            text<span style="color: #666666">=</span>text,
            prompt_type<span style="color: #666666">=</span><span style="color: #BA2121">&quot;module&quot;</span>,
            max_context_tokens<span style="color: #666666">=</span>max_context_tokens,
            chunk_token_budget<span style="color: #666666">=10</span>,
        )
        doc_calls <span style="color: #666666">=</span> [c <span style="color: #008000; font-weight: bold">for</span> c <span style="color: #AA22FF; font-weight: bold">in</span> mock_sum<span style="color: #666666">.</span>call_args_list <span style="color: #008000; font-weight: bold">if</span> c<span style="color: #666666">.</span>args[<span style="color: #666666">4</span>] <span style="color: #666666">==</span> <span style="color: #BA2121">&quot;docstring&quot;</span>]
        <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #008000">len</span>(doc_calls) <span style="color: #666666">&gt;</span> <span style="color: #666666">1</span>
</code></pre>
<details>
<summary>Subfunction: fake_sum(client, cache_obj, key, text_arg, prompt_type, *, system_prompt=&#x27;&#x27;)</summary>
<h4 id="fake_sum">fake_sum(client, cache_obj, key, text_arg, prompt_type, *, system_prompt=&#x27;&#x27;)</h4>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">fake_sum</span>(client, cache_obj, key, text_arg, prompt_type, <span style="color: #666666">*</span>, system_prompt<span style="color: #666666">=</span><span style="color: #BA2121">&quot;&quot;</span>):
        template <span style="color: #666666">=</span> PROMPT_TEMPLATES<span style="color: #666666">.</span>get(prompt_type, PROMPT_TEMPLATES[<span style="color: #BA2121">&quot;module&quot;</span>])
        overhead_local <span style="color: #666666">=</span> <span style="color: #008000">len</span>(tokenizer<span style="color: #666666">.</span>encode(SYSTEM_PROMPT)) <span style="color: #666666">+</span> <span style="color: #008000">len</span>(
            tokenizer<span style="color: #666666">.</span>encode(template<span style="color: #666666">.</span>format(text<span style="color: #666666">=</span><span style="color: #BA2121">&quot;&quot;</span>))
        )
        available <span style="color: #666666">=</span> max_context_tokens <span style="color: #666666">-</span> overhead_local
        <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #008000">len</span>(tokenizer<span style="color: #666666">.</span>encode(text_arg)) <span style="color: #666666">&lt;=</span> available
        <span style="color: #008000; font-weight: bold">if</span> prompt_type <span style="color: #666666">==</span> <span style="color: #BA2121">&quot;module&quot;</span>:
            <span style="color: #008000; font-weight: bold">return</span> <span style="color: #BA2121">&quot;long &quot;</span> <span style="color: #666666">*</span> <span style="color: #666666">200</span>
        <span style="color: #008000; font-weight: bold">return</span> <span style="color: #BA2121">&quot;short&quot;</span>
</code></pre>
</details>
<h3 id="test_structured_chunker_keeps_functions_atomic">test_structured_chunker_keeps_functions_atomic(tmp_path: Path) -&gt; None</h3>
<p>This function tests the `test_structured_chunker_keeps_functions_atomic` method, which ensures that functions are kept atomic during chunking. It uses a temporary path to create a Python file with two functions, parses it using the `parse_python_file` function from the `parser_python` module, and then chunks the text using the `_summarize_module_chunked` function from the `docgenerator` module. The test asserts that the number of chunks is equal to the number of functions and that each chunk contains a unique function source code.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">test_structured_chunker_keeps_functions_atomic</span>(tmp_path: Path) <span style="color: #666666">-&gt;</span> <span style="color: #008000; font-weight: bold">None</span>:
    <span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">cache</span> <span style="color: #008000; font-weight: bold">import</span> ResponseCache
    <span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">parser_python</span> <span style="color: #008000; font-weight: bold">import</span> parse_python_file
    <span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">chunk_utils</span> <span style="color: #008000; font-weight: bold">import</span> get_tokenizer
    <span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">docgenerator</span> <span style="color: #008000; font-weight: bold">import</span> _summarize_module_chunked
    <span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">llm_client</span> <span style="color: #008000; font-weight: bold">import</span> SYSTEM_PROMPT, PROMPT_TEMPLATES

    src <span style="color: #666666">=</span> (
        <span style="color: #BA2121">&quot;def f1():</span><span style="color: #AA5D1F; font-weight: bold">\n</span><span style="color: #BA2121">&quot;</span>
        <span style="color: #BA2121">&quot;    x = 1</span><span style="color: #AA5D1F; font-weight: bold">\n</span><span style="color: #BA2121">&quot;</span>
        <span style="color: #666666">+</span> <span style="color: #BA2121">&quot;    x += 1</span><span style="color: #AA5D1F; font-weight: bold">\n</span><span style="color: #BA2121">&quot;</span> <span style="color: #666666">*</span> <span style="color: #666666">5</span>
        <span style="color: #666666">+</span> <span style="color: #BA2121">&quot;    return x</span><span style="color: #AA5D1F; font-weight: bold">\n\n</span><span style="color: #BA2121">&quot;</span>
        <span style="color: #BA2121">&quot;def f2():</span><span style="color: #AA5D1F; font-weight: bold">\n</span><span style="color: #BA2121">&quot;</span>
        <span style="color: #BA2121">&quot;    y = 1</span><span style="color: #AA5D1F; font-weight: bold">\n</span><span style="color: #BA2121">&quot;</span>
        <span style="color: #666666">+</span> <span style="color: #BA2121">&quot;    y += 1</span><span style="color: #AA5D1F; font-weight: bold">\n</span><span style="color: #BA2121">&quot;</span> <span style="color: #666666">*</span> <span style="color: #666666">5</span>
        <span style="color: #666666">+</span> <span style="color: #BA2121">&quot;    return y</span><span style="color: #AA5D1F; font-weight: bold">\n</span><span style="color: #BA2121">&quot;</span>
    )
    file <span style="color: #666666">=</span> tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;m.py&quot;</span>
    file<span style="color: #666666">.</span>write_text(src)
    parsed <span style="color: #666666">=</span> parse_python_file(<span style="color: #008000">str</span>(file))

    tokenizer <span style="color: #666666">=</span> get_tokenizer()
    cache <span style="color: #666666">=</span> ResponseCache(<span style="color: #008000">str</span>(tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;cache.json&quot;</span>))

    <span style="color: #008000; font-weight: bold">with</span> patch(<span style="color: #BA2121">&quot;docgenerator._summarize&quot;</span>, return_value<span style="color: #666666">=</span><span style="color: #BA2121">&quot;sum&quot;</span>) <span style="color: #008000; font-weight: bold">as</span> mock_sum:
        flen <span style="color: #666666">=</span> <span style="color: #008000">len</span>(tokenizer<span style="color: #666666">.</span>encode(parsed[<span style="color: #BA2121">&quot;functions&quot;</span>][<span style="color: #666666">0</span>][<span style="color: #BA2121">&quot;source&quot;</span>]))
        budget <span style="color: #666666">=</span> flen <span style="color: #666666">+</span> <span style="color: #666666">5</span>
        overhead <span style="color: #666666">=</span> <span style="color: #008000">len</span>(tokenizer<span style="color: #666666">.</span>encode(SYSTEM_PROMPT)) <span style="color: #666666">+</span> <span style="color: #008000">len</span>(tokenizer<span style="color: #666666">.</span>encode(PROMPT_TEMPLATES[<span style="color: #BA2121">&quot;module&quot;</span>]<span style="color: #666666">.</span>format(text<span style="color: #666666">=</span><span style="color: #BA2121">&quot;&quot;</span>)))
        _summarize_module_chunked(
            client<span style="color: #666666">=</span><span style="color: #008000">object</span>(),
            cache<span style="color: #666666">=</span>cache,
            key_prefix<span style="color: #666666">=</span><span style="color: #BA2121">&quot;k&quot;</span>,
            module_text<span style="color: #666666">=</span>src,
            module<span style="color: #666666">=</span>parsed,
            tokenizer<span style="color: #666666">=</span>tokenizer,
            max_context_tokens<span style="color: #666666">=</span>overhead <span style="color: #666666">+</span> budget,
            chunk_token_budget<span style="color: #666666">=</span>budget,
        )

        chunks <span style="color: #666666">=</span> [c<span style="color: #666666">.</span>args[<span style="color: #666666">3</span>] <span style="color: #008000; font-weight: bold">for</span> c <span style="color: #AA22FF; font-weight: bold">in</span> mock_sum<span style="color: #666666">.</span>call_args_list <span style="color: #008000; font-weight: bold">if</span> c<span style="color: #666666">.</span>args[<span style="color: #666666">4</span>] <span style="color: #666666">==</span> <span style="color: #BA2121">&quot;module&quot;</span>]
        <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #008000">len</span>(chunks) <span style="color: #666666">==</span> <span style="color: #666666">2</span>
        func_sources <span style="color: #666666">=</span> {f[<span style="color: #BA2121">&quot;source&quot;</span>] <span style="color: #008000; font-weight: bold">for</span> f <span style="color: #AA22FF; font-weight: bold">in</span> parsed[<span style="color: #BA2121">&quot;functions&quot;</span>]}
        <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #008000">set</span>(chunks) <span style="color: #666666">==</span> func_sources
</code></pre>
<h3 id="test_structured_chunker_splits_large_class_by_method">test_structured_chunker_splits_large_class_by_method(tmp_path: Path) -&gt; None</h3>
<p>This function tests the `test_structured_chunker_splits_large_class_by_method` from a project that generates and summarizes documentation from source code. It uses a temporary path to create a Python file with a class containing two methods. The function parses this file, sets up a tokenizer and cache, and then simulates calling `_summarize_module_chunked` with a mock client. It asserts that the number of chunks created matches the number of methods in the class and that each chunk corresponds to one method&#x27;s source code.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">test_structured_chunker_splits_large_class_by_method</span>(tmp_path: Path) <span style="color: #666666">-&gt;</span> <span style="color: #008000; font-weight: bold">None</span>:
    <span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">cache</span> <span style="color: #008000; font-weight: bold">import</span> ResponseCache
    <span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">parser_python</span> <span style="color: #008000; font-weight: bold">import</span> parse_python_file
    <span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">chunk_utils</span> <span style="color: #008000; font-weight: bold">import</span> get_tokenizer
    <span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">docgenerator</span> <span style="color: #008000; font-weight: bold">import</span> _summarize_module_chunked
    <span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">llm_client</span> <span style="color: #008000; font-weight: bold">import</span> SYSTEM_PROMPT, PROMPT_TEMPLATES

    class_src <span style="color: #666666">=</span> (
        <span style="color: #BA2121">&quot;class Foo:</span><span style="color: #AA5D1F; font-weight: bold">\n</span><span style="color: #BA2121">&quot;</span>
        <span style="color: #BA2121">&quot;    def a(self):</span><span style="color: #AA5D1F; font-weight: bold">\n</span><span style="color: #BA2121">&quot;</span>
        <span style="color: #666666">+</span> <span style="color: #BA2121">&quot;        x = 1</span><span style="color: #AA5D1F; font-weight: bold">\n</span><span style="color: #BA2121">&quot;</span>
        <span style="color: #666666">+</span> <span style="color: #BA2121">&quot;        x += 1</span><span style="color: #AA5D1F; font-weight: bold">\n</span><span style="color: #BA2121">&quot;</span> <span style="color: #666666">*</span> <span style="color: #666666">5</span>
        <span style="color: #666666">+</span> <span style="color: #BA2121">&quot;        return x</span><span style="color: #AA5D1F; font-weight: bold">\n\n</span><span style="color: #BA2121">&quot;</span>
        <span style="color: #BA2121">&quot;    def b(self):</span><span style="color: #AA5D1F; font-weight: bold">\n</span><span style="color: #BA2121">&quot;</span>
        <span style="color: #666666">+</span> <span style="color: #BA2121">&quot;        y = 1</span><span style="color: #AA5D1F; font-weight: bold">\n</span><span style="color: #BA2121">&quot;</span>
        <span style="color: #666666">+</span> <span style="color: #BA2121">&quot;        y += 1</span><span style="color: #AA5D1F; font-weight: bold">\n</span><span style="color: #BA2121">&quot;</span> <span style="color: #666666">*</span> <span style="color: #666666">5</span>
        <span style="color: #666666">+</span> <span style="color: #BA2121">&quot;        return y</span><span style="color: #AA5D1F; font-weight: bold">\n</span><span style="color: #BA2121">&quot;</span>
    )
    file <span style="color: #666666">=</span> tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;m.py&quot;</span>
    file<span style="color: #666666">.</span>write_text(class_src)
    parsed <span style="color: #666666">=</span> parse_python_file(<span style="color: #008000">str</span>(file))

    tokenizer <span style="color: #666666">=</span> get_tokenizer()
    cache <span style="color: #666666">=</span> ResponseCache(<span style="color: #008000">str</span>(tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;cache.json&quot;</span>))

    <span style="color: #008000; font-weight: bold">with</span> patch(<span style="color: #BA2121">&quot;docgenerator._summarize&quot;</span>, return_value<span style="color: #666666">=</span><span style="color: #BA2121">&quot;sum&quot;</span>) <span style="color: #008000; font-weight: bold">as</span> mock_sum:
        mlen <span style="color: #666666">=</span> <span style="color: #008000">len</span>(tokenizer<span style="color: #666666">.</span>encode(parsed[<span style="color: #BA2121">&quot;classes&quot;</span>][<span style="color: #666666">0</span>][<span style="color: #BA2121">&quot;methods&quot;</span>][<span style="color: #666666">0</span>][<span style="color: #BA2121">&quot;source&quot;</span>]))
        budget <span style="color: #666666">=</span> mlen <span style="color: #666666">+</span> <span style="color: #666666">5</span>
        overhead <span style="color: #666666">=</span> <span style="color: #008000">len</span>(tokenizer<span style="color: #666666">.</span>encode(SYSTEM_PROMPT)) <span style="color: #666666">+</span> <span style="color: #008000">len</span>(tokenizer<span style="color: #666666">.</span>encode(PROMPT_TEMPLATES[<span style="color: #BA2121">&quot;module&quot;</span>]<span style="color: #666666">.</span>format(text<span style="color: #666666">=</span><span style="color: #BA2121">&quot;&quot;</span>)))
        _summarize_module_chunked(
            client<span style="color: #666666">=</span><span style="color: #008000">object</span>(),
            cache<span style="color: #666666">=</span>cache,
            key_prefix<span style="color: #666666">=</span><span style="color: #BA2121">&quot;k&quot;</span>,
            module_text<span style="color: #666666">=</span>class_src,
            module<span style="color: #666666">=</span>parsed,
            tokenizer<span style="color: #666666">=</span>tokenizer,
            max_context_tokens<span style="color: #666666">=</span>overhead <span style="color: #666666">+</span> budget,
            chunk_token_budget<span style="color: #666666">=</span>budget,
        )

        chunks <span style="color: #666666">=</span> [c<span style="color: #666666">.</span>args[<span style="color: #666666">3</span>] <span style="color: #008000; font-weight: bold">for</span> c <span style="color: #AA22FF; font-weight: bold">in</span> mock_sum<span style="color: #666666">.</span>call_args_list <span style="color: #008000; font-weight: bold">if</span> c<span style="color: #666666">.</span>args[<span style="color: #666666">4</span>] <span style="color: #666666">==</span> <span style="color: #BA2121">&quot;module&quot;</span>]
        methods <span style="color: #666666">=</span> parsed[<span style="color: #BA2121">&quot;classes&quot;</span>][<span style="color: #666666">0</span>][<span style="color: #BA2121">&quot;methods&quot;</span>]
        method_sources <span style="color: #666666">=</span> {m[<span style="color: #BA2121">&quot;source&quot;</span>] <span style="color: #008000; font-weight: bold">for</span> m <span style="color: #AA22FF; font-weight: bold">in</span> methods}
        <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #008000">len</span>(chunks) <span style="color: #666666">==</span> <span style="color: #008000">len</span>(methods)
        <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #008000">set</span>(chunks) <span style="color: #666666">==</span> method_sources
</code></pre>
<h3 id="test_subclass_methods_are_summarized">test_subclass_methods_are_summarized(tmp_path: Path) -&gt; None</h3>
<p>This function tests that subclass methods are summarized correctly. It creates a temporary project directory with a nested class structure and a method within the subclass. The function then patches the LLMClient to simulate successful pinging and returns predefined summaries for summarization functions. Finally, it asserts that the method name &quot;B:m&quot; is called during the chunked summarization process.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">test_subclass_methods_are_summarized</span>(tmp_path: Path) <span style="color: #666666">-&gt;</span> <span style="color: #008000; font-weight: bold">None</span>:
    project_dir <span style="color: #666666">=</span> tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;proj&quot;</span>
    project_dir<span style="color: #666666">.</span>mkdir()
    (project_dir <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;mod.py&quot;</span>)<span style="color: #666666">.</span>write_text(
        <span style="color: #BA2121">&quot;class A:</span><span style="color: #AA5D1F; font-weight: bold">\n</span><span style="color: #BA2121">    class B:</span><span style="color: #AA5D1F; font-weight: bold">\n</span><span style="color: #BA2121">        def m(self):</span><span style="color: #AA5D1F; font-weight: bold">\n</span><span style="color: #BA2121">            pass</span><span style="color: #AA5D1F; font-weight: bold">\n</span><span style="color: #BA2121">&quot;</span>
    )

    output_dir <span style="color: #666666">=</span> tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;docs&quot;</span>

    <span style="color: #008000; font-weight: bold">with</span> patch(<span style="color: #BA2121">&quot;docgenerator.LLMClient&quot;</span>) <span style="color: #008000; font-weight: bold">as</span> MockClient, patch(
        <span style="color: #BA2121">&quot;docgenerator._summarize&quot;</span>,
        return_value<span style="color: #666666">=</span><span style="color: #BA2121">&quot;summary&quot;</span>,
    ), patch(
        <span style="color: #BA2121">&quot;docgenerator._summarize_chunked&quot;</span>,
        return_value<span style="color: #666666">=</span><span style="color: #BA2121">&quot;summary&quot;</span>,
    ) <span style="color: #008000; font-weight: bold">as</span> mock_chunk:
        instance <span style="color: #666666">=</span> MockClient<span style="color: #666666">.</span>return_value
        instance<span style="color: #666666">.</span>ping<span style="color: #666666">.</span>return_value <span style="color: #666666">=</span> <span style="color: #008000; font-weight: bold">True</span>
        ret <span style="color: #666666">=</span> main([<span style="color: #008000">str</span>(project_dir), <span style="color: #BA2121">&quot;--output&quot;</span>, <span style="color: #008000">str</span>(output_dir)])
        <span style="color: #008000; font-weight: bold">assert</span> ret <span style="color: #666666">==</span> <span style="color: #666666">0</span>

    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #008000">any</span>(<span style="color: #BA2121">&quot;B:m&quot;</span> <span style="color: #AA22FF; font-weight: bold">in</span> call<span style="color: #666666">.</span>args[<span style="color: #666666">2</span>] <span style="color: #008000; font-weight: bold">for</span> call <span style="color: #AA22FF; font-weight: bold">in</span> mock_chunk<span style="color: #666666">.</span>call_args_list)
</code></pre>
<h3 id="test_processes_cpp_file">test_processes_cpp_file(tmp_path: Path) -&gt; None</h3>
<p>The function `test_processes_cpp_file` is designed to test the processing of a C++ file using the DocGen-LM project. It creates a temporary directory, simulates the presence of a C++ source file within it, and sets up mock objects for parsing the file and interacting with an LLM client. The function then calls the `main` function with the specified project directory and output location, asserting that the return value is 0 (indicating success) and that the mock parse function was called exactly once. Finally, it checks that an HTML file has been created in the output directory.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">test_processes_cpp_file</span>(tmp_path: Path) <span style="color: #666666">-&gt;</span> <span style="color: #008000; font-weight: bold">None</span>:
    project_dir <span style="color: #666666">=</span> tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;proj&quot;</span>
    project_dir<span style="color: #666666">.</span>mkdir()
    (project_dir <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;mod.cpp&quot;</span>)<span style="color: #666666">.</span>write_text(<span style="color: #BA2121">&quot;int add(int a, int b) { return a + b; }</span><span style="color: #AA5D1F; font-weight: bold">\n</span><span style="color: #BA2121">&quot;</span>)

    output_dir <span style="color: #666666">=</span> tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;docs&quot;</span>

    parsed <span style="color: #666666">=</span> {
        <span style="color: #BA2121">&quot;module_docstring&quot;</span>: <span style="color: #BA2121">&quot;&quot;</span>,
        <span style="color: #BA2121">&quot;classes&quot;</span>: [
            {
                <span style="color: #BA2121">&quot;name&quot;</span>: <span style="color: #BA2121">&quot;Foo&quot;</span>,
                <span style="color: #BA2121">&quot;docstring&quot;</span>: <span style="color: #BA2121">&quot;&quot;</span>,
                <span style="color: #BA2121">&quot;methods&quot;</span>: [],
                <span style="color: #BA2121">&quot;variables&quot;</span>: [{<span style="color: #BA2121">&quot;name&quot;</span>: <span style="color: #BA2121">&quot;x&quot;</span>, <span style="color: #BA2121">&quot;docstring&quot;</span>: <span style="color: #BA2121">&quot;&quot;</span>, <span style="color: #BA2121">&quot;source&quot;</span>: <span style="color: #BA2121">&quot;int x;&quot;</span>}],
                <span style="color: #BA2121">&quot;source&quot;</span>: <span style="color: #BA2121">&quot;class Foo { int x; };&quot;</span>,
            }
        ],
        <span style="color: #BA2121">&quot;functions&quot;</span>: [],
    }

    <span style="color: #008000; font-weight: bold">with</span> patch(<span style="color: #BA2121">&quot;docgenerator.parse_cpp_file&quot;</span>, return_value<span style="color: #666666">=</span>parsed) <span style="color: #008000; font-weight: bold">as</span> mock_parse, patch(
        <span style="color: #BA2121">&quot;docgenerator.LLMClient&quot;</span>
    ) <span style="color: #008000; font-weight: bold">as</span> MockClient:
        instance <span style="color: #666666">=</span> MockClient<span style="color: #666666">.</span>return_value
        instance<span style="color: #666666">.</span>ping<span style="color: #666666">.</span>return_value <span style="color: #666666">=</span> <span style="color: #008000; font-weight: bold">True</span>
        instance<span style="color: #666666">.</span>summarize<span style="color: #666666">.</span>return_value <span style="color: #666666">=</span> <span style="color: #BA2121">&quot;summary&quot;</span>
        ret <span style="color: #666666">=</span> main([<span style="color: #008000">str</span>(project_dir), <span style="color: #BA2121">&quot;--output&quot;</span>, <span style="color: #008000">str</span>(output_dir)])
        <span style="color: #008000; font-weight: bold">assert</span> ret <span style="color: #666666">==</span> <span style="color: #666666">0</span>
        mock_parse<span style="color: #666666">.</span>assert_called_once()

    <span style="color: #008000; font-weight: bold">assert</span> (output_dir <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;mod.html&quot;</span>)<span style="color: #666666">.</span>exists()
</code></pre>
<h3 id="test_processes_java_file">test_processes_java_file(tmp_path: Path) -&gt; None</h3>
<p>This function `test_processes_java_file` tests the process of generating documentation for a Java file using the DocGen-LM tool. It sets up a temporary project directory with a single Java file named `Mod.java`. The function then mocks the parsing and LLM summarization processes, asserting that the `main` function returns 0 upon successful execution. Finally, it checks if the output HTML file for the Java class exists in the specified output directory.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">test_processes_java_file</span>(tmp_path: Path) <span style="color: #666666">-&gt;</span> <span style="color: #008000; font-weight: bold">None</span>:
    project_dir <span style="color: #666666">=</span> tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;proj&quot;</span>
    project_dir<span style="color: #666666">.</span>mkdir()
    (project_dir <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;Mod.java&quot;</span>)<span style="color: #666666">.</span>write_text(
        <span style="color: #BA2121">&quot;public class Foo { public int x; public void bar() </span><span style="color: #A45A77; font-weight: bold">{}</span><span style="color: #BA2121"> }</span><span style="color: #AA5D1F; font-weight: bold">\n</span><span style="color: #BA2121">&quot;</span>
    )

    output_dir <span style="color: #666666">=</span> tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;docs&quot;</span>

    parsed <span style="color: #666666">=</span> {
        <span style="color: #BA2121">&quot;module_docstring&quot;</span>: <span style="color: #BA2121">&quot;&quot;</span>,
        <span style="color: #BA2121">&quot;classes&quot;</span>: [
            {
                <span style="color: #BA2121">&quot;name&quot;</span>: <span style="color: #BA2121">&quot;Foo&quot;</span>,
                <span style="color: #BA2121">&quot;docstring&quot;</span>: <span style="color: #BA2121">&quot;&quot;</span>,
                <span style="color: #BA2121">&quot;methods&quot;</span>: [],
                <span style="color: #BA2121">&quot;variables&quot;</span>: [{<span style="color: #BA2121">&quot;name&quot;</span>: <span style="color: #BA2121">&quot;x&quot;</span>, <span style="color: #BA2121">&quot;docstring&quot;</span>: <span style="color: #BA2121">&quot;&quot;</span>, <span style="color: #BA2121">&quot;source&quot;</span>: <span style="color: #BA2121">&quot;public int x;&quot;</span>}],
                <span style="color: #BA2121">&quot;source&quot;</span>: <span style="color: #BA2121">&quot;public class Foo { public int x; }&quot;</span>,
            }
        ],
        <span style="color: #BA2121">&quot;functions&quot;</span>: [],
    }

    <span style="color: #008000; font-weight: bold">with</span> patch(<span style="color: #BA2121">&quot;docgenerator.parse_java_file&quot;</span>, return_value<span style="color: #666666">=</span>parsed) <span style="color: #008000; font-weight: bold">as</span> mock_parse, patch(
        <span style="color: #BA2121">&quot;docgenerator.LLMClient&quot;</span>
    ) <span style="color: #008000; font-weight: bold">as</span> MockClient:
        instance <span style="color: #666666">=</span> MockClient<span style="color: #666666">.</span>return_value
        instance<span style="color: #666666">.</span>ping<span style="color: #666666">.</span>return_value <span style="color: #666666">=</span> <span style="color: #008000; font-weight: bold">True</span>
        instance<span style="color: #666666">.</span>summarize<span style="color: #666666">.</span>return_value <span style="color: #666666">=</span> <span style="color: #BA2121">&quot;summary&quot;</span>
        ret <span style="color: #666666">=</span> main([<span style="color: #008000">str</span>(project_dir), <span style="color: #BA2121">&quot;--output&quot;</span>, <span style="color: #008000">str</span>(output_dir)])
        <span style="color: #008000; font-weight: bold">assert</span> ret <span style="color: #666666">==</span> <span style="color: #666666">0</span>
        mock_parse<span style="color: #666666">.</span>assert_called_once()

    <span style="color: #008000; font-weight: bold">assert</span> (output_dir <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;Mod.html&quot;</span>)<span style="color: #666666">.</span>exists()
</code></pre>
    </div>
    <script src="static/toggle.js"></script>
</body>
</html>
