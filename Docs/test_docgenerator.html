<!-- Generated by DocGen-LM -->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>test_docgenerator</title>
    <link rel="stylesheet" href="static/style.css">
</head>
<body>
    <button id="sidebar-toggle">Menu</button>
    <div class="sidebar">
        <h2>Navigation</h2>
        <ul><li><a href="index.html"><strong>üè† Project Overview</strong></a></li><li><a href="cache.html">cache</a></li><li><a href="chunk_utils.html">chunk_utils</a></li><li><a href="docgenerator.html">docgenerator</a></li><li><a href="explaincode.html">explaincode</a></li><li><a href="gui_wrapper.html">gui_wrapper</a></li><li><a href="html_writer.html">html_writer</a></li><li><a href="llm_client.html">llm_client</a></li><li><a href="manual_utils.html">manual_utils</a></li><li><a href="parser_cpp.html">parser_cpp</a></li><li><a href="parser_java.html">parser_java</a></li><li><a href="parser_matlab.html">parser_matlab</a></li><li><a href="parser_python.html">parser_python</a></li><li><a href="retrofit_sidebar.html">retrofit_sidebar</a></li><li><a href="reviewer.html">reviewer</a></li><li><a href="sanitize_docs.html">sanitize_docs</a></li><li><a href="scanner.html">scanner</a></li><li><a href="setup.html">setup</a></li><li><a href="summarize_utils.html">summarize_utils</a></li><li><details><summary>tests</summary><ul><li><a href="test_cache.html">test_cache</a></li><li><a href="test_chunk_utils.html">test_chunk_utils</a></li><li><a href="test_docgenerator.html">test_docgenerator</a></li><li><a href="test_docgenerator_subclasses.html">test_docgenerator_subclasses</a></li><li><a href="test_explaincode.html">test_explaincode</a></li><li><a href="test_html_writer.html">test_html_writer</a></li><li><a href="test_integration.html">test_integration</a></li><li><a href="test_llm_client.html">test_llm_client</a></li><li><a href="test_manual_utils.html">test_manual_utils</a></li><li><a href="test_parser_cpp.html">test_parser_cpp</a></li><li><a href="test_parser_java.html">test_parser_java</a></li><li><a href="test_parser_matlab.html">test_parser_matlab</a></li><li><a href="test_parser_python.html">test_parser_python</a></li><li><a href="test_resume_progress.html">test_resume_progress</a></li><li><a href="test_retrofit_sidebar.html">test_retrofit_sidebar</a></li><li><a href="test_reviewer.html">test_reviewer</a></li><li><a href="test_sanitize_docs.html">test_sanitize_docs</a></li><li><a href="test_scanner.html">test_scanner</a></li></ul></details></li></ul>
    </div>
    <div class="content">
        <h1>test_docgenerator</h1>
        <p>Module defines test cases for a documentation generator tool. Tests cover handling of invalid Python files, generation of class and function summaries, skipping non-UTF8 files, sanitization of project summaries, use of README content, cleaning output directories, chunked text summarization, prompt overhead handling during chunking, recursive merging of long texts, atomic function chunking, splitting large classes by methods, subclass method processing, and support for C++ and Java file types. Tests utilize mocking of LLMClient and related functions to isolate functionality and verify correct behavior under various conditions.</p>
<h2>Functions</h2>
<h3 id="test_skips_invalid_python_file">test_skips_invalid_python_file(tmp_path: Path) -&gt; None</h3>
<p>This function tests the handling of a Python file with invalid syntax during documentation generation. It creates a temporary project directory containing a file with a syntax error (leading zero in integer literal), then invokes the main documentation generation function with mocked LLM client responses. The test verifies that the process completes successfully (return code 0) and that only the index page is generated, while the invalid file&#x27;s documentation page is skipped.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">test_skips_invalid_python_file</span>(tmp_path: Path) <span style="color: #666666">-&gt;</span> <span style="color: #008000; font-weight: bold">None</span>:
    project_dir <span style="color: #666666">=</span> tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;proj&quot;</span>
    project_dir<span style="color: #666666">.</span>mkdir()
    <span style="color: #3D7B7B; font-style: italic"># file with invalid syntax due to leading zero</span>
    (project_dir <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;bad.py&quot;</span>)<span style="color: #666666">.</span>write_text(<span style="color: #BA2121">&quot;x = 08</span><span style="color: #AA5D1F; font-weight: bold">\n</span><span style="color: #BA2121">&quot;</span>)

    output_dir <span style="color: #666666">=</span> tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;docs&quot;</span>

    <span style="color: #008000; font-weight: bold">with</span> patch(<span style="color: #BA2121">&quot;docgenerator.LLMClient&quot;</span>) <span style="color: #008000; font-weight: bold">as</span> MockClient:
        instance <span style="color: #666666">=</span> MockClient<span style="color: #666666">.</span>return_value
        instance<span style="color: #666666">.</span>ping<span style="color: #666666">.</span>return_value <span style="color: #666666">=</span> <span style="color: #008000; font-weight: bold">True</span>
        instance<span style="color: #666666">.</span>summarize<span style="color: #666666">.</span>return_value <span style="color: #666666">=</span> <span style="color: #BA2121">&quot;summary&quot;</span>
        ret <span style="color: #666666">=</span> main([<span style="color: #008000">str</span>(project_dir), <span style="color: #BA2121">&quot;--output&quot;</span>, <span style="color: #008000">str</span>(output_dir)])
        <span style="color: #008000; font-weight: bold">assert</span> ret <span style="color: #666666">==</span> <span style="color: #666666">0</span>

    <span style="color: #3D7B7B; font-style: italic"># only index page should be generated</span>
    <span style="color: #008000; font-weight: bold">assert</span> (output_dir <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;index.html&quot;</span>)<span style="color: #666666">.</span>exists()
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #AA22FF; font-weight: bold">not</span> (output_dir <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;bad.html&quot;</span>)<span style="color: #666666">.</span>exists()
</code></pre>
<h3 id="test_generates_class_and_function_summaries">test_generates_class_and_function_summaries(tmp_path: Path) -&gt; None</h3>
<p>This function tests the generation of class and function summaries within a Python project documentation process. It creates a temporary project directory with a Python module containing a class and a function, then invokes the main documentation generation function with mocked LLM responses. The test verifies that the generated HTML output includes expected summary text for the class and function, as well as a module summary in the index page. The function asserts successful execution (return code 0) and checks that specific summary content appears in the generated documentation files.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">test_generates_class_and_function_summaries</span>(tmp_path: Path) <span style="color: #666666">-&gt;</span> <span style="color: #008000; font-weight: bold">None</span>:
    project_dir <span style="color: #666666">=</span> tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;proj&quot;</span>
    project_dir<span style="color: #666666">.</span>mkdir()
    (project_dir <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;mod.py&quot;</span>)<span style="color: #666666">.</span>write_text(
        <span style="color: #BA2121">&#39;class Foo:</span><span style="color: #AA5D1F; font-weight: bold">\n</span><span style="color: #BA2121">    &quot;&quot;&quot;Doc&quot;&quot;&quot;</span><span style="color: #AA5D1F; font-weight: bold">\n</span><span style="color: #BA2121">    pass</span><span style="color: #AA5D1F; font-weight: bold">\n\n</span><span style="color: #BA2121">&#39;</span> <span style="color: #BA2121">&quot;def bar():</span><span style="color: #AA5D1F; font-weight: bold">\n</span><span style="color: #BA2121">    return 1</span><span style="color: #AA5D1F; font-weight: bold">\n</span><span style="color: #BA2121">&quot;</span>
    )

    output_dir <span style="color: #666666">=</span> tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;docs&quot;</span>

    <span style="color: #008000; font-weight: bold">with</span> patch(<span style="color: #BA2121">&quot;docgenerator.LLMClient&quot;</span>) <span style="color: #008000; font-weight: bold">as</span> MockClient:
        instance <span style="color: #666666">=</span> MockClient<span style="color: #666666">.</span>return_value
        instance<span style="color: #666666">.</span>ping<span style="color: #666666">.</span>return_value <span style="color: #666666">=</span> <span style="color: #008000; font-weight: bold">True</span>
        instance<span style="color: #666666">.</span>summarize<span style="color: #666666">.</span>side_effect <span style="color: #666666">=</span> [
            <span style="color: #BA2121">&quot;module summary&quot;</span>,
            <span style="color: #BA2121">&quot;project summary&quot;</span>,
            <span style="color: #BA2121">&quot;class summary&quot;</span>,
            <span style="color: #BA2121">&quot;improved class doc&quot;</span>,
            <span style="color: #BA2121">&quot;function summary&quot;</span>,
            <span style="color: #BA2121">&quot;improved function doc&quot;</span>,
        ]
        ret <span style="color: #666666">=</span> main([<span style="color: #008000">str</span>(project_dir), <span style="color: #BA2121">&quot;--output&quot;</span>, <span style="color: #008000">str</span>(output_dir)])
        <span style="color: #008000; font-weight: bold">assert</span> ret <span style="color: #666666">==</span> <span style="color: #666666">0</span>

    html <span style="color: #666666">=</span> (output_dir <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;mod.html&quot;</span>)<span style="color: #666666">.</span>read_text(encoding<span style="color: #666666">=</span><span style="color: #BA2121">&quot;utf-8&quot;</span>)
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #BA2121">&quot;improved class doc&quot;</span> <span style="color: #AA22FF; font-weight: bold">in</span> html
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #BA2121">&quot;function summary&quot;</span> <span style="color: #AA22FF; font-weight: bold">in</span> html
    index_html <span style="color: #666666">=</span> (output_dir <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;index.html&quot;</span>)<span style="color: #666666">.</span>read_text(encoding<span style="color: #666666">=</span><span style="color: #BA2121">&quot;utf-8&quot;</span>)
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #BA2121">&quot;module summary&quot;</span> <span style="color: #AA22FF; font-weight: bold">in</span> index_html
</code></pre>
<h3 id="test_skips_non_utf8_file">test_skips_non_utf8_file(tmp_path: Path) -&gt; None</h3>
<p>This function tests that the documentation generator correctly skips files that are not UTF-8 encoded. It creates a temporary project directory with a non-UTF-8 file (`bad.py`) and runs the main documentation generation process. The test verifies that the process completes successfully (return code 0) and that the output directory contains an `index.html` file but does not contain a `bad.html` file for the invalid UTF-8 file. The test mocks the LLM client to simulate successful communication with the language model.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">test_skips_non_utf8_file</span>(tmp_path: Path) <span style="color: #666666">-&gt;</span> <span style="color: #008000; font-weight: bold">None</span>:
    project_dir <span style="color: #666666">=</span> tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;proj&quot;</span>
    project_dir<span style="color: #666666">.</span>mkdir()
    (project_dir <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;bad.py&quot;</span>)<span style="color: #666666">.</span>write_bytes(<span style="color: #BA2121">b&quot;</span><span style="color: #AA5D1F; font-weight: bold">\xff\xfe\xfd</span><span style="color: #BA2121">&quot;</span>)

    output_dir <span style="color: #666666">=</span> tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;docs&quot;</span>

    <span style="color: #008000; font-weight: bold">with</span> patch(<span style="color: #BA2121">&quot;docgenerator.LLMClient&quot;</span>) <span style="color: #008000; font-weight: bold">as</span> MockClient:
        instance <span style="color: #666666">=</span> MockClient<span style="color: #666666">.</span>return_value
        instance<span style="color: #666666">.</span>ping<span style="color: #666666">.</span>return_value <span style="color: #666666">=</span> <span style="color: #008000; font-weight: bold">True</span>
        instance<span style="color: #666666">.</span>summarize<span style="color: #666666">.</span>return_value <span style="color: #666666">=</span> <span style="color: #BA2121">&quot;summary&quot;</span>
        ret <span style="color: #666666">=</span> main([<span style="color: #008000">str</span>(project_dir), <span style="color: #BA2121">&quot;--output&quot;</span>, <span style="color: #008000">str</span>(output_dir)])
        <span style="color: #008000; font-weight: bold">assert</span> ret <span style="color: #666666">==</span> <span style="color: #666666">0</span>

    <span style="color: #008000; font-weight: bold">assert</span> (output_dir <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;index.html&quot;</span>)<span style="color: #666666">.</span>exists()
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #AA22FF; font-weight: bold">not</span> (output_dir <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;bad.html&quot;</span>)<span style="color: #666666">.</span>exists()
</code></pre>
<h3 id="test_handles_class_without_docstring">test_handles_class_without_docstring(tmp_path: Path) -&gt; None</h3>
<p>This function tests the handling of a class without a docstring during documentation generation. It creates a temporary project directory with a Python module containing a class named `Foo` that has no docstring. The test then invokes the main documentation generation function, simulating LLM responses for module, project, and class summaries. It verifies that the generated HTML output includes the class summary and that the main function returns successfully (exit code 0). The test uses mocking to simulate the LLM client behavior and ensures proper integration of the documentation generation process with the LLM-based summarization.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">test_handles_class_without_docstring</span>(tmp_path: Path) <span style="color: #666666">-&gt;</span> <span style="color: #008000; font-weight: bold">None</span>:
    project_dir <span style="color: #666666">=</span> tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;proj&quot;</span>
    project_dir<span style="color: #666666">.</span>mkdir()
    (project_dir <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;mod.py&quot;</span>)<span style="color: #666666">.</span>write_text(<span style="color: #BA2121">&quot;class Foo:</span><span style="color: #AA5D1F; font-weight: bold">\n</span><span style="color: #BA2121">    pass</span><span style="color: #AA5D1F; font-weight: bold">\n</span><span style="color: #BA2121">&quot;</span>)

    output_dir <span style="color: #666666">=</span> tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;docs&quot;</span>

    <span style="color: #008000; font-weight: bold">with</span> patch(<span style="color: #BA2121">&quot;docgenerator.LLMClient&quot;</span>) <span style="color: #008000; font-weight: bold">as</span> MockClient:
        instance <span style="color: #666666">=</span> MockClient<span style="color: #666666">.</span>return_value
        instance<span style="color: #666666">.</span>ping<span style="color: #666666">.</span>return_value <span style="color: #666666">=</span> <span style="color: #008000; font-weight: bold">True</span>
        instance<span style="color: #666666">.</span>summarize<span style="color: #666666">.</span>side_effect <span style="color: #666666">=</span> [
            <span style="color: #BA2121">&quot;module summary&quot;</span>,
            <span style="color: #BA2121">&quot;project summary&quot;</span>,
            <span style="color: #BA2121">&quot;class summary&quot;</span>,
        ]
        ret <span style="color: #666666">=</span> main([<span style="color: #008000">str</span>(project_dir), <span style="color: #BA2121">&quot;--output&quot;</span>, <span style="color: #008000">str</span>(output_dir)])
        <span style="color: #008000; font-weight: bold">assert</span> ret <span style="color: #666666">==</span> <span style="color: #666666">0</span>

    html <span style="color: #666666">=</span> (output_dir <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;mod.html&quot;</span>)<span style="color: #666666">.</span>read_text(encoding<span style="color: #666666">=</span><span style="color: #BA2121">&quot;utf-8&quot;</span>)
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #BA2121">&quot;class summary&quot;</span> <span style="color: #AA22FF; font-weight: bold">in</span> html
</code></pre>
<h3 id="test_project_summary_is_sanitized">test_project_summary_is_sanitized(tmp_path: Path) -&gt; None</h3>
<p>This function tests that the project summary generated by the documentation generator is properly sanitized. It creates a temporary project directory with a Python module containing a function, then runs the main documentation generation process with a mocked LLM client. The test verifies that the resulting HTML output does not contain certain unsanitized strings (like &quot;You can run this&quot;) and instead contains expected sanitized content (like &quot;It prints.&quot;), while also confirming that the LLM was called to summarize the project. The function ensures that the documentation generation process properly sanitizes output content before rendering it in the final HTML documentation.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">test_project_summary_is_sanitized</span>(tmp_path: Path) <span style="color: #666666">-&gt;</span> <span style="color: #008000; font-weight: bold">None</span>:
    project_dir <span style="color: #666666">=</span> tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;proj&quot;</span>
    project_dir<span style="color: #666666">.</span>mkdir()
    (project_dir <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;mod.py&quot;</span>)<span style="color: #666666">.</span>write_text(<span style="color: #BA2121">&quot;def foo():</span><span style="color: #AA5D1F; font-weight: bold">\n</span><span style="color: #BA2121">    pass</span><span style="color: #AA5D1F; font-weight: bold">\n</span><span style="color: #BA2121">&quot;</span>)

    output_dir <span style="color: #666666">=</span> tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;docs&quot;</span>

    <span style="color: #008000; font-weight: bold">with</span> patch(<span style="color: #BA2121">&quot;docgenerator.LLMClient&quot;</span>) <span style="color: #008000; font-weight: bold">as</span> MockClient:
        instance <span style="color: #666666">=</span> MockClient<span style="color: #666666">.</span>return_value
        instance<span style="color: #666666">.</span>ping<span style="color: #666666">.</span>return_value <span style="color: #666666">=</span> <span style="color: #008000; font-weight: bold">True</span>
        instance<span style="color: #666666">.</span>summarize<span style="color: #666666">.</span>side_effect <span style="color: #666666">=</span> [
            <span style="color: #BA2121">&quot;module summary&quot;</span>,
            <span style="color: #BA2121">&quot;project summary&quot;</span>,
            <span style="color: #BA2121">&quot;function summary&quot;</span>,
            <span style="color: #BA2121">&quot;improved function doc&quot;</span>,
        ]
        ret <span style="color: #666666">=</span> main([<span style="color: #008000">str</span>(project_dir), <span style="color: #BA2121">&quot;--output&quot;</span>, <span style="color: #008000">str</span>(output_dir)])
        <span style="color: #008000; font-weight: bold">assert</span> ret <span style="color: #666666">==</span> <span style="color: #666666">0</span>

    html <span style="color: #666666">=</span> (output_dir <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;index.html&quot;</span>)<span style="color: #666666">.</span>read_text(encoding<span style="color: #666666">=</span><span style="color: #BA2121">&quot;utf-8&quot;</span>)
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #BA2121">&quot;You can run this&quot;</span> <span style="color: #AA22FF; font-weight: bold">not</span> <span style="color: #AA22FF; font-weight: bold">in</span> html
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #BA2121">&quot;It prints.&quot;</span> <span style="color: #AA22FF; font-weight: bold">in</span> html
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #008000">any</span>(call<span style="color: #666666">.</span>args[<span style="color: #666666">1</span>] <span style="color: #666666">==</span> <span style="color: #BA2121">&quot;project&quot;</span> <span style="color: #008000; font-weight: bold">for</span> call <span style="color: #AA22FF; font-weight: bold">in</span> instance<span style="color: #666666">.</span>summarize<span style="color: #666666">.</span>call_args_list)
</code></pre>
<h3 id="test_readme_summary_used">test_readme_summary_used(tmp_path: Path) -&gt; None</h3>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">test_readme_summary_used</span>(tmp_path: Path) <span style="color: #666666">-&gt;</span> <span style="color: #008000; font-weight: bold">None</span>:
    project_dir <span style="color: #666666">=</span> tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;proj&quot;</span>
    project_dir<span style="color: #666666">.</span>mkdir()
    (project_dir <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;mod.py&quot;</span>)<span style="color: #666666">.</span>write_text(<span style="color: #BA2121">&quot;def foo():</span><span style="color: #AA5D1F; font-weight: bold">\n</span><span style="color: #BA2121">    pass</span><span style="color: #AA5D1F; font-weight: bold">\n</span><span style="color: #BA2121">&quot;</span>)
    (project_dir <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;README.md&quot;</span>)<span style="color: #666666">.</span>write_text(<span style="color: #BA2121">&quot;Project docs&quot;</span>)

    output_dir <span style="color: #666666">=</span> tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;docs&quot;</span>

    <span style="color: #008000; font-weight: bold">with</span> patch(<span style="color: #BA2121">&quot;docgenerator.LLMClient&quot;</span>) <span style="color: #008000; font-weight: bold">as</span> MockClient:
        instance <span style="color: #666666">=</span> MockClient<span style="color: #666666">.</span>return_value
        instance<span style="color: #666666">.</span>ping<span style="color: #666666">.</span>return_value <span style="color: #666666">=</span> <span style="color: #008000; font-weight: bold">True</span>
        instance<span style="color: #666666">.</span>summarize<span style="color: #666666">.</span>side_effect <span style="color: #666666">=</span> <span style="color: #008000; font-weight: bold">lambda</span> text, pt, <span style="color: #666666">**</span>kwargs: <span style="color: #BA2121">f&quot;</span><span style="color: #A45A77; font-weight: bold">{</span>pt<span style="color: #A45A77; font-weight: bold">}</span><span style="color: #BA2121"> summary&quot;</span>
        ret <span style="color: #666666">=</span> main([<span style="color: #008000">str</span>(project_dir), <span style="color: #BA2121">&quot;--output&quot;</span>, <span style="color: #008000">str</span>(output_dir)])
        <span style="color: #008000; font-weight: bold">assert</span> ret <span style="color: #666666">==</span> <span style="color: #666666">0</span>

    html <span style="color: #666666">=</span> (output_dir <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;index.html&quot;</span>)<span style="color: #666666">.</span>read_text(encoding<span style="color: #666666">=</span><span style="color: #BA2121">&quot;utf-8&quot;</span>)
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #BA2121">&quot;readme summary&quot;</span> <span style="color: #AA22FF; font-weight: bold">in</span> html
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #008000">any</span>(call<span style="color: #666666">.</span>args[<span style="color: #666666">1</span>] <span style="color: #666666">==</span> <span style="color: #BA2121">&quot;readme&quot;</span> <span style="color: #008000; font-weight: bold">for</span> call <span style="color: #AA22FF; font-weight: bold">in</span> instance<span style="color: #666666">.</span>summarize<span style="color: #666666">.</span>call_args_list)
</code></pre>
<h3 id="test_clean_output_dir">test_clean_output_dir(tmp_path: Path) -&gt; None</h3>
<p>The function `test_clean_output_dir` tests the `clean_output_dir` function from the `docgenerator` module. It creates a temporary directory structure with an output folder containing files generated by DocGen-LM (marked with a specific comment) and other custom files. The test verifies that `clean_output_dir` removes only the files generated by DocGen-LM while preserving custom files and assets. The assertion confirms that the generated file is deleted, while the custom HTML and CSS files remain in the output directory.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">test_clean_output_dir</span>(tmp_path: Path) <span style="color: #666666">-&gt;</span> <span style="color: #008000; font-weight: bold">None</span>:
    out <span style="color: #666666">=</span> tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;docs&quot;</span>
    out<span style="color: #666666">.</span>mkdir()
    generated <span style="color: #666666">=</span> out <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;old.html&quot;</span>
    generated<span style="color: #666666">.</span>write_text(<span style="color: #BA2121">&quot;&lt;!-- Generated by DocGen-LM --&gt;</span><span style="color: #AA5D1F; font-weight: bold">\n</span><span style="color: #BA2121">&lt;html&gt;&lt;/html&gt;&quot;</span>, encoding<span style="color: #666666">=</span><span style="color: #BA2121">&quot;utf-8&quot;</span>)
    custom <span style="color: #666666">=</span> out <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;custom.html&quot;</span>
    custom<span style="color: #666666">.</span>write_text(<span style="color: #BA2121">&quot;&lt;html&gt;&lt;/html&gt;&quot;</span>, encoding<span style="color: #666666">=</span><span style="color: #BA2121">&quot;utf-8&quot;</span>)
    asset <span style="color: #666666">=</span> out <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;style.css&quot;</span>
    asset<span style="color: #666666">.</span>write_text(<span style="color: #BA2121">&quot;body </span><span style="color: #A45A77; font-weight: bold">{}</span><span style="color: #BA2121">&quot;</span>, encoding<span style="color: #666666">=</span><span style="color: #BA2121">&quot;utf-8&quot;</span>)

    <span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">docgenerator</span> <span style="color: #008000; font-weight: bold">import</span> clean_output_dir

    clean_output_dir(<span style="color: #008000">str</span>(out))

    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #AA22FF; font-weight: bold">not</span> generated<span style="color: #666666">.</span>exists()
    <span style="color: #008000; font-weight: bold">assert</span> custom<span style="color: #666666">.</span>exists()
    <span style="color: #008000; font-weight: bold">assert</span> asset<span style="color: #666666">.</span>exists()
</code></pre>
<h3 id="test_summarize_chunked_splits_long_text">test_summarize_chunked_splits_long_text(tmp_path: Path) -&gt; None</h3>
<p>The function `test_summarize_chunked_splits_long_text` tests the behavior of the `summarize_chunked` utility when processing a long text input. It verifies that the text is properly split into chunks and that the summarization process is invoked multiple times, indicating chunking. The test uses a mocked summary function to ensure that the chunking logic is exercised without making actual LLM calls. It sets up a tokenizer, creates a long text string, initializes a response cache, and then calls `summarize_chunked` with specific parameters including a small token budget to force chunking. The assertion confirms that the mock summarization function was called more than once, demonstrating that the input text was split into multiple chunks for processing.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">test_summarize_chunked_splits_long_text</span>(tmp_path: Path) <span style="color: #666666">-&gt;</span> <span style="color: #008000; font-weight: bold">None</span>:
    <span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">cache</span> <span style="color: #008000; font-weight: bold">import</span> ResponseCache
    <span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">chunk_utils</span> <span style="color: #008000; font-weight: bold">import</span> get_tokenizer
    <span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">summarize_utils</span> <span style="color: #008000; font-weight: bold">import</span> summarize_chunked

    tokenizer <span style="color: #666666">=</span> get_tokenizer()
    text <span style="color: #666666">=</span> <span style="color: #BA2121">&quot;word &quot;</span> <span style="color: #666666">*</span> <span style="color: #666666">50</span>
    cache <span style="color: #666666">=</span> ResponseCache(<span style="color: #008000">str</span>(tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;cache.json&quot;</span>))

    <span style="color: #008000; font-weight: bold">with</span> patch(<span style="color: #BA2121">&quot;summarize_utils._summarize&quot;</span>, return_value<span style="color: #666666">=</span><span style="color: #BA2121">&quot;summary&quot;</span>) <span style="color: #008000; font-weight: bold">as</span> mock_sum:
        summarize_chunked(
            client<span style="color: #666666">=</span><span style="color: #008000">object</span>(),
            cache<span style="color: #666666">=</span>cache,
            key_prefix<span style="color: #666666">=</span><span style="color: #BA2121">&quot;k&quot;</span>,
            text<span style="color: #666666">=</span>text,
            prompt_type<span style="color: #666666">=</span><span style="color: #BA2121">&quot;module&quot;</span>,
            max_context_tokens<span style="color: #666666">=10</span>,
            chunk_token_budget<span style="color: #666666">=5</span>,
        )
        <span style="color: #008000; font-weight: bold">assert</span> mock_sum<span style="color: #666666">.</span>call_count <span style="color: #666666">&gt;</span> <span style="color: #666666">1</span>
</code></pre>
<h3 id="test_chunking_accounts_for_prompt_overhead">test_chunking_accounts_for_prompt_overhead(tmp_path: Path) -&gt; None</h3>
<p>The function `test_chunking_accounts_for_prompt_overhead` tests that text chunking in the `summarize_chunked` utility accounts for prompt overhead when determining chunk sizes. It sets up a tokenizer, creates a sample text, and configures a cache. Using a mocked summary function, it verifies that the text is split into multiple chunks by checking that the mock is called more than once, ensuring that the prompt overhead is properly considered in the token budget calculation.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">test_chunking_accounts_for_prompt_overhead</span>(tmp_path: Path) <span style="color: #666666">-&gt;</span> <span style="color: #008000; font-weight: bold">None</span>:
    <span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">cache</span> <span style="color: #008000; font-weight: bold">import</span> ResponseCache
    <span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">chunk_utils</span> <span style="color: #008000; font-weight: bold">import</span> get_tokenizer
    <span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">summarize_utils</span> <span style="color: #008000; font-weight: bold">import</span> summarize_chunked
    <span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">llm_client</span> <span style="color: #008000; font-weight: bold">import</span> SYSTEM_PROMPT, PROMPT_TEMPLATES

    tokenizer <span style="color: #666666">=</span> get_tokenizer()
    text <span style="color: #666666">=</span> <span style="color: #BA2121">&quot;word &quot;</span> <span style="color: #666666">*</span> <span style="color: #666666">15</span>
    cache <span style="color: #666666">=</span> ResponseCache(<span style="color: #008000">str</span>(tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;cache.json&quot;</span>))
    template <span style="color: #666666">=</span> PROMPT_TEMPLATES[<span style="color: #BA2121">&quot;module&quot;</span>]
    overhead <span style="color: #666666">=</span> <span style="color: #008000">len</span>(tokenizer<span style="color: #666666">.</span>encode(SYSTEM_PROMPT)) <span style="color: #666666">+</span> <span style="color: #008000">len</span>(tokenizer<span style="color: #666666">.</span>encode(template<span style="color: #666666">.</span>format(text<span style="color: #666666">=</span><span style="color: #BA2121">&quot;&quot;</span>)))
    max_context_tokens <span style="color: #666666">=</span> overhead <span style="color: #666666">+</span> <span style="color: #666666">10</span>

    <span style="color: #008000; font-weight: bold">with</span> patch(<span style="color: #BA2121">&quot;summarize_utils._summarize&quot;</span>, return_value<span style="color: #666666">=</span><span style="color: #BA2121">&quot;summary&quot;</span>) <span style="color: #008000; font-weight: bold">as</span> mock_sum:
        summarize_chunked(
            client<span style="color: #666666">=</span><span style="color: #008000">object</span>(),
            cache<span style="color: #666666">=</span>cache,
            key_prefix<span style="color: #666666">=</span><span style="color: #BA2121">&quot;k&quot;</span>,
            text<span style="color: #666666">=</span>text,
            prompt_type<span style="color: #666666">=</span><span style="color: #BA2121">&quot;module&quot;</span>,
            max_context_tokens<span style="color: #666666">=</span>max_context_tokens,
            chunk_token_budget<span style="color: #666666">=100</span>,
        )
        <span style="color: #008000; font-weight: bold">assert</span> mock_sum<span style="color: #666666">.</span>call_count <span style="color: #666666">&gt;</span> <span style="color: #666666">1</span>
</code></pre>
<h3 id="test_merge_recurses_when_prompt_too_long">test_merge_recurses_when_prompt_too_long(tmp_path: Path) -&gt; None</h3>
<p>This function tests the recursive merging behavior of the `summarize_chunked` function when the prompt exceeds the maximum context length. It sets up a mocked environment with a fake summarization function that enforces token limits, then verifies that multiple merge operations are performed by checking the number of calls made to the summarization function with the &quot;docstring&quot; prompt type. The test ensures that chunking and recursive merging occur correctly when the input text is long enough to require multiple processing steps.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">test_merge_recurses_when_prompt_too_long</span>(tmp_path: Path) <span style="color: #666666">-&gt;</span> <span style="color: #008000; font-weight: bold">None</span>:
    <span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">cache</span> <span style="color: #008000; font-weight: bold">import</span> ResponseCache
    <span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">chunk_utils</span> <span style="color: #008000; font-weight: bold">import</span> get_tokenizer
    <span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">summarize_utils</span> <span style="color: #008000; font-weight: bold">import</span> summarize_chunked
    <span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">llm_client</span> <span style="color: #008000; font-weight: bold">import</span> SYSTEM_PROMPT, PROMPT_TEMPLATES

    tokenizer <span style="color: #666666">=</span> get_tokenizer()
    text <span style="color: #666666">=</span> <span style="color: #BA2121">&quot;word &quot;</span> <span style="color: #666666">*</span> <span style="color: #666666">200</span>
    cache <span style="color: #666666">=</span> ResponseCache(<span style="color: #008000">str</span>(tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;cache.json&quot;</span>))
    template <span style="color: #666666">=</span> PROMPT_TEMPLATES[<span style="color: #BA2121">&quot;module&quot;</span>]
    overhead <span style="color: #666666">=</span> <span style="color: #008000">len</span>(tokenizer<span style="color: #666666">.</span>encode(SYSTEM_PROMPT)) <span style="color: #666666">+</span> <span style="color: #008000">len</span>(
        tokenizer<span style="color: #666666">.</span>encode(template<span style="color: #666666">.</span>format(text<span style="color: #666666">=</span><span style="color: #BA2121">&quot;&quot;</span>))
    )
    max_context_tokens <span style="color: #666666">=</span> overhead <span style="color: #666666">+</span> <span style="color: #666666">50</span>

    <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">fake_sum</span>(client, cache_obj, key, text_arg, prompt_type, <span style="color: #666666">*</span>, system_prompt<span style="color: #666666">=</span><span style="color: #BA2121">&quot;&quot;</span>):
        template <span style="color: #666666">=</span> PROMPT_TEMPLATES<span style="color: #666666">.</span>get(prompt_type, PROMPT_TEMPLATES[<span style="color: #BA2121">&quot;module&quot;</span>])
        overhead <span style="color: #666666">=</span> <span style="color: #008000">len</span>(tokenizer<span style="color: #666666">.</span>encode(SYSTEM_PROMPT)) <span style="color: #666666">+</span> <span style="color: #008000">len</span>(
            tokenizer<span style="color: #666666">.</span>encode(template<span style="color: #666666">.</span>format(text<span style="color: #666666">=</span><span style="color: #BA2121">&quot;&quot;</span>))
        )
        available <span style="color: #666666">=</span> max_context_tokens <span style="color: #666666">-</span> overhead
        <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #008000">len</span>(tokenizer<span style="color: #666666">.</span>encode(text_arg)) <span style="color: #666666">&lt;=</span> available
        <span style="color: #008000; font-weight: bold">if</span> prompt_type <span style="color: #666666">==</span> <span style="color: #BA2121">&quot;module&quot;</span>:
            <span style="color: #008000; font-weight: bold">return</span> <span style="color: #BA2121">&quot;summary &quot;</span> <span style="color: #666666">*</span> <span style="color: #666666">30</span>
        <span style="color: #008000; font-weight: bold">return</span> <span style="color: #BA2121">&quot;short&quot;</span>

    <span style="color: #008000; font-weight: bold">with</span> patch(<span style="color: #BA2121">&quot;summarize_utils._summarize&quot;</span>, side_effect<span style="color: #666666">=</span>fake_sum) <span style="color: #008000; font-weight: bold">as</span> mock_sum:
        summarize_chunked(
            client<span style="color: #666666">=</span><span style="color: #008000">object</span>(),
            cache<span style="color: #666666">=</span>cache,
            key_prefix<span style="color: #666666">=</span><span style="color: #BA2121">&quot;k&quot;</span>,
            text<span style="color: #666666">=</span>text,
            prompt_type<span style="color: #666666">=</span><span style="color: #BA2121">&quot;module&quot;</span>,
            max_context_tokens<span style="color: #666666">=</span>max_context_tokens,
            chunk_token_budget<span style="color: #666666">=10</span>,
        )
        merge_calls <span style="color: #666666">=</span> [c <span style="color: #008000; font-weight: bold">for</span> c <span style="color: #AA22FF; font-weight: bold">in</span> mock_sum<span style="color: #666666">.</span>call_args_list <span style="color: #008000; font-weight: bold">if</span> c<span style="color: #666666">.</span>args[<span style="color: #666666">4</span>] <span style="color: #666666">==</span> <span style="color: #BA2121">&quot;docstring&quot;</span>]
        <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #008000">len</span>(merge_calls) <span style="color: #666666">&gt;</span> <span style="color: #666666">1</span>
</code></pre>
<details>
<summary>Subfunction: fake_sum(client, cache_obj, key, text_arg, prompt_type, *, system_prompt=&#x27;&#x27;)</summary>
<h4 id="fake_sum">fake_sum(client, cache_obj, key, text_arg, prompt_type, *, system_prompt=&#x27;&#x27;)</h4>
<p>The function `fake_sum` generates a fake summary for a given text argument based on the specified prompt type. It retrieves a prompt template from `PROMPT_TEMPLATES` using the `prompt_type`, calculates the token overhead of the system prompt and template, and determines the available tokens for the input text. It asserts that the input text fits within the available token limit. If the prompt type is &quot;module&quot;, it returns a repeated string of &quot;summary &quot;. Otherwise, it returns the string &quot;short&quot;. The function appears to be a placeholder or mock implementation for testing purposes.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">fake_sum</span>(client, cache_obj, key, text_arg, prompt_type, <span style="color: #666666">*</span>, system_prompt<span style="color: #666666">=</span><span style="color: #BA2121">&quot;&quot;</span>):
        template <span style="color: #666666">=</span> PROMPT_TEMPLATES<span style="color: #666666">.</span>get(prompt_type, PROMPT_TEMPLATES[<span style="color: #BA2121">&quot;module&quot;</span>])
        overhead <span style="color: #666666">=</span> <span style="color: #008000">len</span>(tokenizer<span style="color: #666666">.</span>encode(SYSTEM_PROMPT)) <span style="color: #666666">+</span> <span style="color: #008000">len</span>(
            tokenizer<span style="color: #666666">.</span>encode(template<span style="color: #666666">.</span>format(text<span style="color: #666666">=</span><span style="color: #BA2121">&quot;&quot;</span>))
        )
        available <span style="color: #666666">=</span> max_context_tokens <span style="color: #666666">-</span> overhead
        <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #008000">len</span>(tokenizer<span style="color: #666666">.</span>encode(text_arg)) <span style="color: #666666">&lt;=</span> available
        <span style="color: #008000; font-weight: bold">if</span> prompt_type <span style="color: #666666">==</span> <span style="color: #BA2121">&quot;module&quot;</span>:
            <span style="color: #008000; font-weight: bold">return</span> <span style="color: #BA2121">&quot;summary &quot;</span> <span style="color: #666666">*</span> <span style="color: #666666">30</span>
        <span style="color: #008000; font-weight: bold">return</span> <span style="color: #BA2121">&quot;short&quot;</span>
</code></pre>
</details>
<h3 id="test_single_long_partial_is_recursively_chunked">test_single_long_partial_is_recursively_chunked(tmp_path: Path) -&gt; None</h3>
<p>This function tests that a long text input is recursively chunked during the summarization process when the token limit is exceeded. It sets up a mock environment with a fake summarization function that enforces token limits, then calls `summarize_chunked` with a text that exceeds the context size. The test verifies that the `docstring` prompt type is used in multiple calls to the mock summarizer, indicating recursive chunking occurred.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">test_single_long_partial_is_recursively_chunked</span>(tmp_path: Path) <span style="color: #666666">-&gt;</span> <span style="color: #008000; font-weight: bold">None</span>:
    <span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">cache</span> <span style="color: #008000; font-weight: bold">import</span> ResponseCache
    <span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">chunk_utils</span> <span style="color: #008000; font-weight: bold">import</span> get_tokenizer
    <span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">summarize_utils</span> <span style="color: #008000; font-weight: bold">import</span> summarize_chunked
    <span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">llm_client</span> <span style="color: #008000; font-weight: bold">import</span> SYSTEM_PROMPT, PROMPT_TEMPLATES

    tokenizer <span style="color: #666666">=</span> get_tokenizer()
    text <span style="color: #666666">=</span> <span style="color: #BA2121">&quot;word &quot;</span> <span style="color: #666666">*</span> <span style="color: #666666">200</span>
    cache <span style="color: #666666">=</span> ResponseCache(<span style="color: #008000">str</span>(tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;cache.json&quot;</span>))
    template <span style="color: #666666">=</span> PROMPT_TEMPLATES[<span style="color: #BA2121">&quot;module&quot;</span>]
    overhead <span style="color: #666666">=</span> <span style="color: #008000">len</span>(tokenizer<span style="color: #666666">.</span>encode(SYSTEM_PROMPT)) <span style="color: #666666">+</span> <span style="color: #008000">len</span>(tokenizer<span style="color: #666666">.</span>encode(template<span style="color: #666666">.</span>format(text<span style="color: #666666">=</span><span style="color: #BA2121">&quot;&quot;</span>)))
    max_context_tokens <span style="color: #666666">=</span> overhead <span style="color: #666666">+</span> <span style="color: #666666">50</span>

    <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">fake_sum</span>(client, cache_obj, key, text_arg, prompt_type, <span style="color: #666666">*</span>, system_prompt<span style="color: #666666">=</span><span style="color: #BA2121">&quot;&quot;</span>):
        template <span style="color: #666666">=</span> PROMPT_TEMPLATES<span style="color: #666666">.</span>get(prompt_type, PROMPT_TEMPLATES[<span style="color: #BA2121">&quot;module&quot;</span>])
        overhead_local <span style="color: #666666">=</span> <span style="color: #008000">len</span>(tokenizer<span style="color: #666666">.</span>encode(SYSTEM_PROMPT)) <span style="color: #666666">+</span> <span style="color: #008000">len</span>(
            tokenizer<span style="color: #666666">.</span>encode(template<span style="color: #666666">.</span>format(text<span style="color: #666666">=</span><span style="color: #BA2121">&quot;&quot;</span>))
        )
        available <span style="color: #666666">=</span> max_context_tokens <span style="color: #666666">-</span> overhead_local
        <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #008000">len</span>(tokenizer<span style="color: #666666">.</span>encode(text_arg)) <span style="color: #666666">&lt;=</span> available
        <span style="color: #008000; font-weight: bold">if</span> prompt_type <span style="color: #666666">==</span> <span style="color: #BA2121">&quot;module&quot;</span>:
            <span style="color: #008000; font-weight: bold">return</span> <span style="color: #BA2121">&quot;long &quot;</span> <span style="color: #666666">*</span> <span style="color: #666666">200</span>
        <span style="color: #008000; font-weight: bold">return</span> <span style="color: #BA2121">&quot;short&quot;</span>

    <span style="color: #008000; font-weight: bold">with</span> patch(<span style="color: #BA2121">&quot;summarize_utils._summarize&quot;</span>, side_effect<span style="color: #666666">=</span>fake_sum) <span style="color: #008000; font-weight: bold">as</span> mock_sum:
        summarize_chunked(
            client<span style="color: #666666">=</span><span style="color: #008000">object</span>(),
            cache<span style="color: #666666">=</span>cache,
            key_prefix<span style="color: #666666">=</span><span style="color: #BA2121">&quot;k&quot;</span>,
            text<span style="color: #666666">=</span>text,
            prompt_type<span style="color: #666666">=</span><span style="color: #BA2121">&quot;module&quot;</span>,
            max_context_tokens<span style="color: #666666">=</span>max_context_tokens,
            chunk_token_budget<span style="color: #666666">=10</span>,
        )
        doc_calls <span style="color: #666666">=</span> [c <span style="color: #008000; font-weight: bold">for</span> c <span style="color: #AA22FF; font-weight: bold">in</span> mock_sum<span style="color: #666666">.</span>call_args_list <span style="color: #008000; font-weight: bold">if</span> c<span style="color: #666666">.</span>args[<span style="color: #666666">4</span>] <span style="color: #666666">==</span> <span style="color: #BA2121">&quot;docstring&quot;</span>]
        <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #008000">len</span>(doc_calls) <span style="color: #666666">&gt;</span> <span style="color: #666666">1</span>
</code></pre>
<details>
<summary>Subfunction: fake_sum(client, cache_obj, key, text_arg, prompt_type, *, system_prompt=&#x27;&#x27;)</summary>
<h4 id="fake_sum">fake_sum(client, cache_obj, key, text_arg, prompt_type, *, system_prompt=&#x27;&#x27;)</h4>
<p>The function `fake_sum` is designed to generate a fake summary for a given text argument based on the specified prompt type. It retrieves a template from `PROMPT_TEMPLATES` corresponding to the provided `prompt_type`, defaulting to the &quot;module&quot; template if the type is not found. The function calculates the number of available tokens by subtracting the token count of the system prompt and the template from the maximum context tokens. It asserts that the input text argument fits within the available token limit. If the prompt type is &quot;module&quot;, it returns a long fake summary consisting of repeated &quot;long &quot; strings. For all other prompt types, it returns a short fake summary consisting of the string &quot;short&quot;. The function uses a tokenizer to encode prompts and text for token count calculations.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">fake_sum</span>(client, cache_obj, key, text_arg, prompt_type, <span style="color: #666666">*</span>, system_prompt<span style="color: #666666">=</span><span style="color: #BA2121">&quot;&quot;</span>):
        template <span style="color: #666666">=</span> PROMPT_TEMPLATES<span style="color: #666666">.</span>get(prompt_type, PROMPT_TEMPLATES[<span style="color: #BA2121">&quot;module&quot;</span>])
        overhead_local <span style="color: #666666">=</span> <span style="color: #008000">len</span>(tokenizer<span style="color: #666666">.</span>encode(SYSTEM_PROMPT)) <span style="color: #666666">+</span> <span style="color: #008000">len</span>(
            tokenizer<span style="color: #666666">.</span>encode(template<span style="color: #666666">.</span>format(text<span style="color: #666666">=</span><span style="color: #BA2121">&quot;&quot;</span>))
        )
        available <span style="color: #666666">=</span> max_context_tokens <span style="color: #666666">-</span> overhead_local
        <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #008000">len</span>(tokenizer<span style="color: #666666">.</span>encode(text_arg)) <span style="color: #666666">&lt;=</span> available
        <span style="color: #008000; font-weight: bold">if</span> prompt_type <span style="color: #666666">==</span> <span style="color: #BA2121">&quot;module&quot;</span>:
            <span style="color: #008000; font-weight: bold">return</span> <span style="color: #BA2121">&quot;long &quot;</span> <span style="color: #666666">*</span> <span style="color: #666666">200</span>
        <span style="color: #008000; font-weight: bold">return</span> <span style="color: #BA2121">&quot;short&quot;</span>
</code></pre>
</details>
<h3 id="test_structured_chunker_keeps_functions_atomic">test_structured_chunker_keeps_functions_atomic(tmp_path: Path) -&gt; None</h3>
<p>This function tests that the structured chunker maintains atomicity of functions when processing Python source code. It creates a temporary Python file containing two functions, parses the file, and then uses a mocked summarization function to verify that each function is processed as a separate chunk. The test ensures that the `_summarize_module_chunked` function correctly separates and processes individual functions without merging their content, by checking that the number of chunks matches the number of functions and that each chunk corresponds to the source of a function.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">test_structured_chunker_keeps_functions_atomic</span>(tmp_path: Path) <span style="color: #666666">-&gt;</span> <span style="color: #008000; font-weight: bold">None</span>:
    <span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">cache</span> <span style="color: #008000; font-weight: bold">import</span> ResponseCache
    <span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">parser_python</span> <span style="color: #008000; font-weight: bold">import</span> parse_python_file
    <span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">chunk_utils</span> <span style="color: #008000; font-weight: bold">import</span> get_tokenizer
    <span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">docgenerator</span> <span style="color: #008000; font-weight: bold">import</span> _summarize_module_chunked
    <span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">llm_client</span> <span style="color: #008000; font-weight: bold">import</span> SYSTEM_PROMPT, PROMPT_TEMPLATES

    src <span style="color: #666666">=</span> (
        <span style="color: #BA2121">&quot;def f1():</span><span style="color: #AA5D1F; font-weight: bold">\n</span><span style="color: #BA2121">&quot;</span>
        <span style="color: #BA2121">&quot;    x = 1</span><span style="color: #AA5D1F; font-weight: bold">\n</span><span style="color: #BA2121">&quot;</span>
        <span style="color: #666666">+</span> <span style="color: #BA2121">&quot;    x += 1</span><span style="color: #AA5D1F; font-weight: bold">\n</span><span style="color: #BA2121">&quot;</span> <span style="color: #666666">*</span> <span style="color: #666666">5</span>
        <span style="color: #666666">+</span> <span style="color: #BA2121">&quot;    return x</span><span style="color: #AA5D1F; font-weight: bold">\n\n</span><span style="color: #BA2121">&quot;</span>
        <span style="color: #BA2121">&quot;def f2():</span><span style="color: #AA5D1F; font-weight: bold">\n</span><span style="color: #BA2121">&quot;</span>
        <span style="color: #BA2121">&quot;    y = 1</span><span style="color: #AA5D1F; font-weight: bold">\n</span><span style="color: #BA2121">&quot;</span>
        <span style="color: #666666">+</span> <span style="color: #BA2121">&quot;    y += 1</span><span style="color: #AA5D1F; font-weight: bold">\n</span><span style="color: #BA2121">&quot;</span> <span style="color: #666666">*</span> <span style="color: #666666">5</span>
        <span style="color: #666666">+</span> <span style="color: #BA2121">&quot;    return y</span><span style="color: #AA5D1F; font-weight: bold">\n</span><span style="color: #BA2121">&quot;</span>
    )
    file <span style="color: #666666">=</span> tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;m.py&quot;</span>
    file<span style="color: #666666">.</span>write_text(src)
    parsed <span style="color: #666666">=</span> parse_python_file(<span style="color: #008000">str</span>(file))

    tokenizer <span style="color: #666666">=</span> get_tokenizer()
    cache <span style="color: #666666">=</span> ResponseCache(<span style="color: #008000">str</span>(tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;cache.json&quot;</span>))

    <span style="color: #008000; font-weight: bold">with</span> patch(<span style="color: #BA2121">&quot;docgenerator._summarize&quot;</span>, return_value<span style="color: #666666">=</span><span style="color: #BA2121">&quot;sum&quot;</span>) <span style="color: #008000; font-weight: bold">as</span> mock_sum:
        flen <span style="color: #666666">=</span> <span style="color: #008000">len</span>(tokenizer<span style="color: #666666">.</span>encode(parsed[<span style="color: #BA2121">&quot;functions&quot;</span>][<span style="color: #666666">0</span>][<span style="color: #BA2121">&quot;source&quot;</span>]))
        budget <span style="color: #666666">=</span> flen <span style="color: #666666">+</span> <span style="color: #666666">5</span>
        overhead <span style="color: #666666">=</span> <span style="color: #008000">len</span>(tokenizer<span style="color: #666666">.</span>encode(SYSTEM_PROMPT)) <span style="color: #666666">+</span> <span style="color: #008000">len</span>(tokenizer<span style="color: #666666">.</span>encode(PROMPT_TEMPLATES[<span style="color: #BA2121">&quot;module&quot;</span>]<span style="color: #666666">.</span>format(text<span style="color: #666666">=</span><span style="color: #BA2121">&quot;&quot;</span>)))
        _summarize_module_chunked(
            client<span style="color: #666666">=</span><span style="color: #008000">object</span>(),
            cache<span style="color: #666666">=</span>cache,
            key_prefix<span style="color: #666666">=</span><span style="color: #BA2121">&quot;k&quot;</span>,
            module_text<span style="color: #666666">=</span>src,
            module<span style="color: #666666">=</span>parsed,
            tokenizer<span style="color: #666666">=</span>tokenizer,
            max_context_tokens<span style="color: #666666">=</span>overhead <span style="color: #666666">+</span> budget,
            chunk_token_budget<span style="color: #666666">=</span>budget,
        )

        chunks <span style="color: #666666">=</span> [c<span style="color: #666666">.</span>args[<span style="color: #666666">3</span>] <span style="color: #008000; font-weight: bold">for</span> c <span style="color: #AA22FF; font-weight: bold">in</span> mock_sum<span style="color: #666666">.</span>call_args_list <span style="color: #008000; font-weight: bold">if</span> c<span style="color: #666666">.</span>args[<span style="color: #666666">4</span>] <span style="color: #666666">==</span> <span style="color: #BA2121">&quot;module&quot;</span>]
        <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #008000">len</span>(chunks) <span style="color: #666666">==</span> <span style="color: #666666">2</span>
        func_sources <span style="color: #666666">=</span> {f[<span style="color: #BA2121">&quot;source&quot;</span>] <span style="color: #008000; font-weight: bold">for</span> f <span style="color: #AA22FF; font-weight: bold">in</span> parsed[<span style="color: #BA2121">&quot;functions&quot;</span>]}
        <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #008000">set</span>(chunks) <span style="color: #666666">==</span> func_sources
</code></pre>
<h3 id="test_structured_chunker_splits_large_class_by_method">test_structured_chunker_splits_large_class_by_method(tmp_path: Path) -&gt; None</h3>
<p>This function tests the behavior of `_summarize_module_chunked` when processing a Python class that exceeds the token budget for summarization. It creates a temporary Python file containing a class with two methods, parses the file, and then invokes the chunked summarization function with a limited token budget. The test verifies that the class is split into individual method chunks and that each method&#x27;s source code is passed to the summarization function exactly once. The test uses a mocked version of `_summarize` to capture the arguments passed to it and ensures that the number of chunks matches the number of methods and that the content of the chunks corresponds to the methods&#x27; source code.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">test_structured_chunker_splits_large_class_by_method</span>(tmp_path: Path) <span style="color: #666666">-&gt;</span> <span style="color: #008000; font-weight: bold">None</span>:
    <span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">cache</span> <span style="color: #008000; font-weight: bold">import</span> ResponseCache
    <span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">parser_python</span> <span style="color: #008000; font-weight: bold">import</span> parse_python_file
    <span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">chunk_utils</span> <span style="color: #008000; font-weight: bold">import</span> get_tokenizer
    <span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">docgenerator</span> <span style="color: #008000; font-weight: bold">import</span> _summarize_module_chunked
    <span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">llm_client</span> <span style="color: #008000; font-weight: bold">import</span> SYSTEM_PROMPT, PROMPT_TEMPLATES

    class_src <span style="color: #666666">=</span> (
        <span style="color: #BA2121">&quot;class Foo:</span><span style="color: #AA5D1F; font-weight: bold">\n</span><span style="color: #BA2121">&quot;</span>
        <span style="color: #BA2121">&quot;    def a(self):</span><span style="color: #AA5D1F; font-weight: bold">\n</span><span style="color: #BA2121">&quot;</span>
        <span style="color: #666666">+</span> <span style="color: #BA2121">&quot;        x = 1</span><span style="color: #AA5D1F; font-weight: bold">\n</span><span style="color: #BA2121">&quot;</span>
        <span style="color: #666666">+</span> <span style="color: #BA2121">&quot;        x += 1</span><span style="color: #AA5D1F; font-weight: bold">\n</span><span style="color: #BA2121">&quot;</span> <span style="color: #666666">*</span> <span style="color: #666666">5</span>
        <span style="color: #666666">+</span> <span style="color: #BA2121">&quot;        return x</span><span style="color: #AA5D1F; font-weight: bold">\n\n</span><span style="color: #BA2121">&quot;</span>
        <span style="color: #BA2121">&quot;    def b(self):</span><span style="color: #AA5D1F; font-weight: bold">\n</span><span style="color: #BA2121">&quot;</span>
        <span style="color: #666666">+</span> <span style="color: #BA2121">&quot;        y = 1</span><span style="color: #AA5D1F; font-weight: bold">\n</span><span style="color: #BA2121">&quot;</span>
        <span style="color: #666666">+</span> <span style="color: #BA2121">&quot;        y += 1</span><span style="color: #AA5D1F; font-weight: bold">\n</span><span style="color: #BA2121">&quot;</span> <span style="color: #666666">*</span> <span style="color: #666666">5</span>
        <span style="color: #666666">+</span> <span style="color: #BA2121">&quot;        return y</span><span style="color: #AA5D1F; font-weight: bold">\n</span><span style="color: #BA2121">&quot;</span>
    )
    file <span style="color: #666666">=</span> tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;m.py&quot;</span>
    file<span style="color: #666666">.</span>write_text(class_src)
    parsed <span style="color: #666666">=</span> parse_python_file(<span style="color: #008000">str</span>(file))

    tokenizer <span style="color: #666666">=</span> get_tokenizer()
    cache <span style="color: #666666">=</span> ResponseCache(<span style="color: #008000">str</span>(tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;cache.json&quot;</span>))

    <span style="color: #008000; font-weight: bold">with</span> patch(<span style="color: #BA2121">&quot;docgenerator._summarize&quot;</span>, return_value<span style="color: #666666">=</span><span style="color: #BA2121">&quot;sum&quot;</span>) <span style="color: #008000; font-weight: bold">as</span> mock_sum:
        mlen <span style="color: #666666">=</span> <span style="color: #008000">len</span>(tokenizer<span style="color: #666666">.</span>encode(parsed[<span style="color: #BA2121">&quot;classes&quot;</span>][<span style="color: #666666">0</span>][<span style="color: #BA2121">&quot;methods&quot;</span>][<span style="color: #666666">0</span>][<span style="color: #BA2121">&quot;source&quot;</span>]))
        budget <span style="color: #666666">=</span> mlen <span style="color: #666666">+</span> <span style="color: #666666">5</span>
        overhead <span style="color: #666666">=</span> <span style="color: #008000">len</span>(tokenizer<span style="color: #666666">.</span>encode(SYSTEM_PROMPT)) <span style="color: #666666">+</span> <span style="color: #008000">len</span>(tokenizer<span style="color: #666666">.</span>encode(PROMPT_TEMPLATES[<span style="color: #BA2121">&quot;module&quot;</span>]<span style="color: #666666">.</span>format(text<span style="color: #666666">=</span><span style="color: #BA2121">&quot;&quot;</span>)))
        _summarize_module_chunked(
            client<span style="color: #666666">=</span><span style="color: #008000">object</span>(),
            cache<span style="color: #666666">=</span>cache,
            key_prefix<span style="color: #666666">=</span><span style="color: #BA2121">&quot;k&quot;</span>,
            module_text<span style="color: #666666">=</span>class_src,
            module<span style="color: #666666">=</span>parsed,
            tokenizer<span style="color: #666666">=</span>tokenizer,
            max_context_tokens<span style="color: #666666">=</span>overhead <span style="color: #666666">+</span> budget,
            chunk_token_budget<span style="color: #666666">=</span>budget,
        )

        chunks <span style="color: #666666">=</span> [c<span style="color: #666666">.</span>args[<span style="color: #666666">3</span>] <span style="color: #008000; font-weight: bold">for</span> c <span style="color: #AA22FF; font-weight: bold">in</span> mock_sum<span style="color: #666666">.</span>call_args_list <span style="color: #008000; font-weight: bold">if</span> c<span style="color: #666666">.</span>args[<span style="color: #666666">4</span>] <span style="color: #666666">==</span> <span style="color: #BA2121">&quot;module&quot;</span>]
        methods <span style="color: #666666">=</span> parsed[<span style="color: #BA2121">&quot;classes&quot;</span>][<span style="color: #666666">0</span>][<span style="color: #BA2121">&quot;methods&quot;</span>]
        method_sources <span style="color: #666666">=</span> {m[<span style="color: #BA2121">&quot;source&quot;</span>] <span style="color: #008000; font-weight: bold">for</span> m <span style="color: #AA22FF; font-weight: bold">in</span> methods}
        <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #008000">len</span>(chunks) <span style="color: #666666">==</span> <span style="color: #008000">len</span>(methods)
        <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #008000">set</span>(chunks) <span style="color: #666666">==</span> method_sources
</code></pre>
<h3 id="test_subclass_methods_are_summarized">test_subclass_methods_are_summarized(tmp_path: Path) -&gt; None</h3>
<p>This function tests that methods within nested subclasses are properly summarized during the documentation generation process. It creates a temporary Python project structure with a class `A` containing a nested class `B` with a method `m`. The test mocks the LLM client and summarization functions to simulate documentation generation, then verifies that the method `B:m` is included in the arguments of a call to `_summarize_chunked`, ensuring that nested subclass methods are processed for documentation.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">test_subclass_methods_are_summarized</span>(tmp_path: Path) <span style="color: #666666">-&gt;</span> <span style="color: #008000; font-weight: bold">None</span>:
    project_dir <span style="color: #666666">=</span> tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;proj&quot;</span>
    project_dir<span style="color: #666666">.</span>mkdir()
    (project_dir <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;mod.py&quot;</span>)<span style="color: #666666">.</span>write_text(
        <span style="color: #BA2121">&quot;class A:</span><span style="color: #AA5D1F; font-weight: bold">\n</span><span style="color: #BA2121">    class B:</span><span style="color: #AA5D1F; font-weight: bold">\n</span><span style="color: #BA2121">        def m(self):</span><span style="color: #AA5D1F; font-weight: bold">\n</span><span style="color: #BA2121">            pass</span><span style="color: #AA5D1F; font-weight: bold">\n</span><span style="color: #BA2121">&quot;</span>
    )

    output_dir <span style="color: #666666">=</span> tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;docs&quot;</span>

    <span style="color: #008000; font-weight: bold">with</span> patch(<span style="color: #BA2121">&quot;docgenerator.LLMClient&quot;</span>) <span style="color: #008000; font-weight: bold">as</span> MockClient, patch(
        <span style="color: #BA2121">&quot;docgenerator._summarize&quot;</span>,
        return_value<span style="color: #666666">=</span><span style="color: #BA2121">&quot;summary&quot;</span>,
    ), patch(
        <span style="color: #BA2121">&quot;docgenerator._summarize_chunked&quot;</span>,
        return_value<span style="color: #666666">=</span><span style="color: #BA2121">&quot;summary&quot;</span>,
    ) <span style="color: #008000; font-weight: bold">as</span> mock_chunk:
        instance <span style="color: #666666">=</span> MockClient<span style="color: #666666">.</span>return_value
        instance<span style="color: #666666">.</span>ping<span style="color: #666666">.</span>return_value <span style="color: #666666">=</span> <span style="color: #008000; font-weight: bold">True</span>
        ret <span style="color: #666666">=</span> main([<span style="color: #008000">str</span>(project_dir), <span style="color: #BA2121">&quot;--output&quot;</span>, <span style="color: #008000">str</span>(output_dir)])
        <span style="color: #008000; font-weight: bold">assert</span> ret <span style="color: #666666">==</span> <span style="color: #666666">0</span>

    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #008000">any</span>(<span style="color: #BA2121">&quot;B:m&quot;</span> <span style="color: #AA22FF; font-weight: bold">in</span> call<span style="color: #666666">.</span>args[<span style="color: #666666">2</span>] <span style="color: #008000; font-weight: bold">for</span> call <span style="color: #AA22FF; font-weight: bold">in</span> mock_chunk<span style="color: #666666">.</span>call_args_list)
</code></pre>
<h3 id="test_processes_cpp_file">test_processes_cpp_file(tmp_path: Path) -&gt; None</h3>
<p>This function tests the processing of a C++ file by mocking the parsing and LLM client components. It creates a temporary project directory with a C++ source file, sets up expected parsed output for a class containing a variable, and mocks the `parse_cpp_file` function and `LLMClient` to simulate successful documentation generation. The test verifies that the main function executes without error, the parser is called once, and the resulting HTML documentation file is created in the specified output directory.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">test_processes_cpp_file</span>(tmp_path: Path) <span style="color: #666666">-&gt;</span> <span style="color: #008000; font-weight: bold">None</span>:
    project_dir <span style="color: #666666">=</span> tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;proj&quot;</span>
    project_dir<span style="color: #666666">.</span>mkdir()
    (project_dir <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;mod.cpp&quot;</span>)<span style="color: #666666">.</span>write_text(<span style="color: #BA2121">&quot;int add(int a, int b) { return a + b; }</span><span style="color: #AA5D1F; font-weight: bold">\n</span><span style="color: #BA2121">&quot;</span>)

    output_dir <span style="color: #666666">=</span> tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;docs&quot;</span>

    parsed <span style="color: #666666">=</span> {
        <span style="color: #BA2121">&quot;module_docstring&quot;</span>: <span style="color: #BA2121">&quot;&quot;</span>,
        <span style="color: #BA2121">&quot;classes&quot;</span>: [
            {
                <span style="color: #BA2121">&quot;name&quot;</span>: <span style="color: #BA2121">&quot;Foo&quot;</span>,
                <span style="color: #BA2121">&quot;docstring&quot;</span>: <span style="color: #BA2121">&quot;&quot;</span>,
                <span style="color: #BA2121">&quot;methods&quot;</span>: [],
                <span style="color: #BA2121">&quot;variables&quot;</span>: [{<span style="color: #BA2121">&quot;name&quot;</span>: <span style="color: #BA2121">&quot;x&quot;</span>, <span style="color: #BA2121">&quot;docstring&quot;</span>: <span style="color: #BA2121">&quot;&quot;</span>, <span style="color: #BA2121">&quot;source&quot;</span>: <span style="color: #BA2121">&quot;int x;&quot;</span>}],
                <span style="color: #BA2121">&quot;source&quot;</span>: <span style="color: #BA2121">&quot;class Foo { int x; };&quot;</span>,
            }
        ],
        <span style="color: #BA2121">&quot;functions&quot;</span>: [],
    }

    <span style="color: #008000; font-weight: bold">with</span> patch(<span style="color: #BA2121">&quot;docgenerator.parse_cpp_file&quot;</span>, return_value<span style="color: #666666">=</span>parsed) <span style="color: #008000; font-weight: bold">as</span> mock_parse, patch(
        <span style="color: #BA2121">&quot;docgenerator.LLMClient&quot;</span>
    ) <span style="color: #008000; font-weight: bold">as</span> MockClient:
        instance <span style="color: #666666">=</span> MockClient<span style="color: #666666">.</span>return_value
        instance<span style="color: #666666">.</span>ping<span style="color: #666666">.</span>return_value <span style="color: #666666">=</span> <span style="color: #008000; font-weight: bold">True</span>
        instance<span style="color: #666666">.</span>summarize<span style="color: #666666">.</span>return_value <span style="color: #666666">=</span> <span style="color: #BA2121">&quot;summary&quot;</span>
        ret <span style="color: #666666">=</span> main([<span style="color: #008000">str</span>(project_dir), <span style="color: #BA2121">&quot;--output&quot;</span>, <span style="color: #008000">str</span>(output_dir)])
        <span style="color: #008000; font-weight: bold">assert</span> ret <span style="color: #666666">==</span> <span style="color: #666666">0</span>
        mock_parse<span style="color: #666666">.</span>assert_called_once()

    <span style="color: #008000; font-weight: bold">assert</span> (output_dir <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;mod.html&quot;</span>)<span style="color: #666666">.</span>exists()
</code></pre>
<h3 id="test_processes_java_file">test_processes_java_file(tmp_path: Path) -&gt; None</h3>
<p>The function `test_processes_java_file` tests the processing of a Java source file by the documentation generator. It creates a temporary project directory with a simple Java class `Foo` containing a public variable and method. The test mocks the `parse_java_file` function to return a predefined parsed structure and mocks the `LLMClient` to simulate successful communication and summarization. It then calls the main function with the project and output directories as arguments, asserting that the main function returns zero (indicating success), the parser is called once, and the resulting HTML documentation file (`Mod.html`) is created in the output directory.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">test_processes_java_file</span>(tmp_path: Path) <span style="color: #666666">-&gt;</span> <span style="color: #008000; font-weight: bold">None</span>:
    project_dir <span style="color: #666666">=</span> tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;proj&quot;</span>
    project_dir<span style="color: #666666">.</span>mkdir()
    (project_dir <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;Mod.java&quot;</span>)<span style="color: #666666">.</span>write_text(
        <span style="color: #BA2121">&quot;public class Foo { public int x; public void bar() </span><span style="color: #A45A77; font-weight: bold">{}</span><span style="color: #BA2121"> }</span><span style="color: #AA5D1F; font-weight: bold">\n</span><span style="color: #BA2121">&quot;</span>
    )

    output_dir <span style="color: #666666">=</span> tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;docs&quot;</span>

    parsed <span style="color: #666666">=</span> {
        <span style="color: #BA2121">&quot;module_docstring&quot;</span>: <span style="color: #BA2121">&quot;&quot;</span>,
        <span style="color: #BA2121">&quot;classes&quot;</span>: [
            {
                <span style="color: #BA2121">&quot;name&quot;</span>: <span style="color: #BA2121">&quot;Foo&quot;</span>,
                <span style="color: #BA2121">&quot;docstring&quot;</span>: <span style="color: #BA2121">&quot;&quot;</span>,
                <span style="color: #BA2121">&quot;methods&quot;</span>: [],
                <span style="color: #BA2121">&quot;variables&quot;</span>: [{<span style="color: #BA2121">&quot;name&quot;</span>: <span style="color: #BA2121">&quot;x&quot;</span>, <span style="color: #BA2121">&quot;docstring&quot;</span>: <span style="color: #BA2121">&quot;&quot;</span>, <span style="color: #BA2121">&quot;source&quot;</span>: <span style="color: #BA2121">&quot;public int x;&quot;</span>}],
                <span style="color: #BA2121">&quot;source&quot;</span>: <span style="color: #BA2121">&quot;public class Foo { public int x; }&quot;</span>,
            }
        ],
        <span style="color: #BA2121">&quot;functions&quot;</span>: [],
    }

    <span style="color: #008000; font-weight: bold">with</span> patch(<span style="color: #BA2121">&quot;docgenerator.parse_java_file&quot;</span>, return_value<span style="color: #666666">=</span>parsed) <span style="color: #008000; font-weight: bold">as</span> mock_parse, patch(
        <span style="color: #BA2121">&quot;docgenerator.LLMClient&quot;</span>
    ) <span style="color: #008000; font-weight: bold">as</span> MockClient:
        instance <span style="color: #666666">=</span> MockClient<span style="color: #666666">.</span>return_value
        instance<span style="color: #666666">.</span>ping<span style="color: #666666">.</span>return_value <span style="color: #666666">=</span> <span style="color: #008000; font-weight: bold">True</span>
        instance<span style="color: #666666">.</span>summarize<span style="color: #666666">.</span>return_value <span style="color: #666666">=</span> <span style="color: #BA2121">&quot;summary&quot;</span>
        ret <span style="color: #666666">=</span> main([<span style="color: #008000">str</span>(project_dir), <span style="color: #BA2121">&quot;--output&quot;</span>, <span style="color: #008000">str</span>(output_dir)])
        <span style="color: #008000; font-weight: bold">assert</span> ret <span style="color: #666666">==</span> <span style="color: #666666">0</span>
        mock_parse<span style="color: #666666">.</span>assert_called_once()

    <span style="color: #008000; font-weight: bold">assert</span> (output_dir <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;Mod.html&quot;</span>)<span style="color: #666666">.</span>exists()
</code></pre>
    </div>
    <script src="static/toggle.js"></script>
</body>
</html>
