<!-- Generated by DocGen-LM -->
<!DOCTYPE html>

<html lang="en">
<head>
<meta charset="utf-8"/><meta content="width=device-width, initial-scale=1" name="viewport"/>
<title>test_docgenerator</title>
<link href="static/style.css" rel="stylesheet"/>
</head>
<body><a class="skip-link" href="#main-content">Skip to main content</a><header class="topbar"><button aria-label="Toggle navigation menu" id="sidebar-toggle">Menu</button><span class="topbar-title">test_docgenerator</span></header>
<nav aria-label="Documentation navigation" class="sidebar">
<h2>Navigation</h2>
<ul><li><a href="index.html"><strong>üè† Project Overview</strong></a></li><li><a href="cache.html">cache</a></li><li><a href="chunk_utils.html">chunk_utils</a></li><li><a href="docgenerator.html">docgenerator</a></li><li><a href="explaincode.html">explaincode</a></li><li><a href="gui_wrapper.html">gui_wrapper</a></li><li><a href="html_writer.html">html_writer</a></li><li><a href="llm_client.html">llm_client</a></li><li><a href="manual_utils.html">manual_utils</a></li><li><a href="parser_cpp.html">parser_cpp</a></li><li><a href="parser_java.html">parser_java</a></li><li><a href="parser_matlab.html">parser_matlab</a></li><li><a href="parser_python.html">parser_python</a></li><li><a href="retrofit_sidebar.html">retrofit_sidebar</a></li><li><a href="reviewer.html">reviewer</a></li><li><a href="sanitize_docs.html">sanitize_docs</a></li><li><a href="scanner.html">scanner</a></li><li><a href="setup.html">setup</a></li><li><a href="summarize_utils.html">summarize_utils</a></li><li><details><summary>tests</summary><ul><li><a href="test_cache.html">test_cache</a></li><li><a href="test_chunk_utils.html">test_chunk_utils</a></li><li><a href="test_docgenerator.html">test_docgenerator</a></li><li><a href="test_docgenerator_subclasses.html">test_docgenerator_subclasses</a></li><li><a href="test_explaincode.html">test_explaincode</a></li><li><a href="test_html_writer.html">test_html_writer</a></li><li><a href="test_integration.html">test_integration</a></li><li><a href="test_llm_client.html">test_llm_client</a></li><li><a href="test_manual_utils.html">test_manual_utils</a></li><li><a href="test_parser_cpp.html">test_parser_cpp</a></li><li><a href="test_parser_java.html">test_parser_java</a></li><li><a href="test_parser_matlab.html">test_parser_matlab</a></li><li><a href="test_parser_python.html">test_parser_python</a></li><li><a href="test_resume_progress.html">test_resume_progress</a></li><li><a href="test_retrofit_sidebar.html">test_retrofit_sidebar</a></li><li><a href="test_reviewer.html">test_reviewer</a></li><li><a href="test_sanitize_docs.html">test_sanitize_docs</a></li><li><a href="test_scanner.html">test_scanner</a></li></ul></details></li></ul>
</nav>
<main class="content" id="main-content" role="main">
<h1>test_docgenerator</h1>
<p>Module defines test cases for a documentation generator tool. Tests cover handling of invalid Python syntax, generation of class and function summaries, skipping non-UTF8 files, sanitization of project summaries, use of README content, cleaning output directories, chunked text summarization with token budgeting, recursive merging of long texts, structured chunking for functions and classes, subclass method processing, and support for C++ and Java file types. Tests utilize mocking of LLMClient and related functions to isolate functionality and verify correct behavior under various conditions.</p>
<h2>Functions</h2>
<h3 id="test_skips_invalid_python_file">test_skips_invalid_python_file(tmp_path: Path) -&gt; None</h3>
<p>The function `test_skips_invalid_python_file` tests the behavior of the documentation generator when encountering a Python file with invalid syntax. It creates a temporary project directory containing a file (`bad.py`) with invalid Python syntax (a leading zero in an integer literal). The test runs the main documentation generation process, mocking the LLM client to simulate successful communication and summarization. After execution, it verifies that only the index page is generated in the output directory, confirming that invalid Python files are skipped during processing.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">test_skips_invalid_python_file</span>(tmp_path: Path) <span style="color: #666666">-&gt;</span> <span style="color: #008000; font-weight: bold">None</span>:
    project_dir <span style="color: #666666">=</span> tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">"proj"</span>
    project_dir<span style="color: #666666">.</span>mkdir()
    <span style="color: #3D7B7B; font-style: italic"># file with invalid syntax due to leading zero</span>
    (project_dir <span style="color: #666666">/</span> <span style="color: #BA2121">"bad.py"</span>)<span style="color: #666666">.</span>write_text(<span style="color: #BA2121">"x = 08</span><span style="color: #AA5D1F; font-weight: bold">\n</span><span style="color: #BA2121">"</span>)

    output_dir <span style="color: #666666">=</span> tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">"docs"</span>

    <span style="color: #008000; font-weight: bold">with</span> patch(<span style="color: #BA2121">"docgenerator.LLMClient"</span>) <span style="color: #008000; font-weight: bold">as</span> MockClient:
        instance <span style="color: #666666">=</span> MockClient<span style="color: #666666">.</span>return_value
        instance<span style="color: #666666">.</span>ping<span style="color: #666666">.</span>return_value <span style="color: #666666">=</span> <span style="color: #008000; font-weight: bold">True</span>
        instance<span style="color: #666666">.</span>summarize<span style="color: #666666">.</span>return_value <span style="color: #666666">=</span> <span style="color: #BA2121">"summary"</span>
        ret <span style="color: #666666">=</span> main([<span style="color: #008000">str</span>(project_dir), <span style="color: #BA2121">"--output"</span>, <span style="color: #008000">str</span>(output_dir)])
        <span style="color: #008000; font-weight: bold">assert</span> ret <span style="color: #666666">==</span> <span style="color: #666666">0</span>

    <span style="color: #3D7B7B; font-style: italic"># only index page should be generated</span>
    <span style="color: #008000; font-weight: bold">assert</span> (output_dir <span style="color: #666666">/</span> <span style="color: #BA2121">"index.html"</span>)<span style="color: #666666">.</span>exists()
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #AA22FF; font-weight: bold">not</span> (output_dir <span style="color: #666666">/</span> <span style="color: #BA2121">"bad.html"</span>)<span style="color: #666666">.</span>exists()
</code></pre>
<h3 id="test_generates_class_and_function_summaries">test_generates_class_and_function_summaries(tmp_path: Path) -&gt; None</h3>
<p>This function tests the generation of class and function summaries by a documentation generator. It creates a temporary project directory with a Python module containing a class and a function, then invokes the main documentation generation process with a mocked LLM client. The test verifies that the generated HTML output includes expected summary text for the class and function, as well as a module summary in the index page. The mocked client simulates LLM responses for various summarization tasks including module, project, class, and function summaries. The test ensures that the documentation generator correctly processes the source code and incorporates LLM-generated summaries into the output HTML files.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">test_generates_class_and_function_summaries</span>(tmp_path: Path) <span style="color: #666666">-&gt;</span> <span style="color: #008000; font-weight: bold">None</span>:
    project_dir <span style="color: #666666">=</span> tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">"proj"</span>
    project_dir<span style="color: #666666">.</span>mkdir()
    (project_dir <span style="color: #666666">/</span> <span style="color: #BA2121">"mod.py"</span>)<span style="color: #666666">.</span>write_text(
        <span style="color: #BA2121">'class Foo:</span><span style="color: #AA5D1F; font-weight: bold">\n</span><span style="color: #BA2121">    """Doc"""</span><span style="color: #AA5D1F; font-weight: bold">\n</span><span style="color: #BA2121">    pass</span><span style="color: #AA5D1F; font-weight: bold">\n\n</span><span style="color: #BA2121">'</span> <span style="color: #BA2121">"def bar():</span><span style="color: #AA5D1F; font-weight: bold">\n</span><span style="color: #BA2121">    return 1</span><span style="color: #AA5D1F; font-weight: bold">\n</span><span style="color: #BA2121">"</span>
    )

    output_dir <span style="color: #666666">=</span> tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">"docs"</span>

    <span style="color: #008000; font-weight: bold">with</span> patch(<span style="color: #BA2121">"docgenerator.LLMClient"</span>) <span style="color: #008000; font-weight: bold">as</span> MockClient:
        instance <span style="color: #666666">=</span> MockClient<span style="color: #666666">.</span>return_value
        instance<span style="color: #666666">.</span>ping<span style="color: #666666">.</span>return_value <span style="color: #666666">=</span> <span style="color: #008000; font-weight: bold">True</span>
        instance<span style="color: #666666">.</span>summarize<span style="color: #666666">.</span>side_effect <span style="color: #666666">=</span> [
            <span style="color: #BA2121">"module summary"</span>,
            <span style="color: #BA2121">"project summary"</span>,
            <span style="color: #BA2121">"class summary"</span>,
            <span style="color: #BA2121">"improved class doc"</span>,
            <span style="color: #BA2121">"function summary"</span>,
            <span style="color: #BA2121">"improved function doc"</span>,
        ]
        ret <span style="color: #666666">=</span> main([<span style="color: #008000">str</span>(project_dir), <span style="color: #BA2121">"--output"</span>, <span style="color: #008000">str</span>(output_dir)])
        <span style="color: #008000; font-weight: bold">assert</span> ret <span style="color: #666666">==</span> <span style="color: #666666">0</span>

    html <span style="color: #666666">=</span> (output_dir <span style="color: #666666">/</span> <span style="color: #BA2121">"mod.html"</span>)<span style="color: #666666">.</span>read_text(encoding<span style="color: #666666">=</span><span style="color: #BA2121">"utf-8"</span>)
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #BA2121">"improved class doc"</span> <span style="color: #AA22FF; font-weight: bold">in</span> html
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #BA2121">"function summary"</span> <span style="color: #AA22FF; font-weight: bold">in</span> html
    index_html <span style="color: #666666">=</span> (output_dir <span style="color: #666666">/</span> <span style="color: #BA2121">"index.html"</span>)<span style="color: #666666">.</span>read_text(encoding<span style="color: #666666">=</span><span style="color: #BA2121">"utf-8"</span>)
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #BA2121">"module summary"</span> <span style="color: #AA22FF; font-weight: bold">in</span> index_html
</code></pre>
<h3 id="test_skips_non_utf8_file">test_skips_non_utf8_file(tmp_path: Path) -&gt; None</h3>
<p>The function `test_skips_non_utf8_file` tests the handling of non-UTF-8 files during documentation generation. It creates a temporary project directory with a file containing non-UTF-8 bytes, then runs the main documentation generation process. The test verifies that the process completes successfully (return code 0) and that the output directory contains an index.html file while skipping the invalid file (no bad.html is created). The test mocks the LLM client to simulate successful communication and summarization.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">test_skips_non_utf8_file</span>(tmp_path: Path) <span style="color: #666666">-&gt;</span> <span style="color: #008000; font-weight: bold">None</span>:
    project_dir <span style="color: #666666">=</span> tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">"proj"</span>
    project_dir<span style="color: #666666">.</span>mkdir()
    (project_dir <span style="color: #666666">/</span> <span style="color: #BA2121">"bad.py"</span>)<span style="color: #666666">.</span>write_bytes(<span style="color: #BA2121">b"</span><span style="color: #AA5D1F; font-weight: bold">\xff\xfe\xfd</span><span style="color: #BA2121">"</span>)

    output_dir <span style="color: #666666">=</span> tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">"docs"</span>

    <span style="color: #008000; font-weight: bold">with</span> patch(<span style="color: #BA2121">"docgenerator.LLMClient"</span>) <span style="color: #008000; font-weight: bold">as</span> MockClient:
        instance <span style="color: #666666">=</span> MockClient<span style="color: #666666">.</span>return_value
        instance<span style="color: #666666">.</span>ping<span style="color: #666666">.</span>return_value <span style="color: #666666">=</span> <span style="color: #008000; font-weight: bold">True</span>
        instance<span style="color: #666666">.</span>summarize<span style="color: #666666">.</span>return_value <span style="color: #666666">=</span> <span style="color: #BA2121">"summary"</span>
        ret <span style="color: #666666">=</span> main([<span style="color: #008000">str</span>(project_dir), <span style="color: #BA2121">"--output"</span>, <span style="color: #008000">str</span>(output_dir)])
        <span style="color: #008000; font-weight: bold">assert</span> ret <span style="color: #666666">==</span> <span style="color: #666666">0</span>

    <span style="color: #008000; font-weight: bold">assert</span> (output_dir <span style="color: #666666">/</span> <span style="color: #BA2121">"index.html"</span>)<span style="color: #666666">.</span>exists()
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #AA22FF; font-weight: bold">not</span> (output_dir <span style="color: #666666">/</span> <span style="color: #BA2121">"bad.html"</span>)<span style="color: #666666">.</span>exists()
</code></pre>
<h3 id="test_handles_class_without_docstring">test_handles_class_without_docstring(tmp_path: Path) -&gt; None</h3>
<p>The function `test_handles_class_without_docstring` tests the handling of a class without a docstring during documentation generation. It creates a temporary project directory with a Python module containing a class named `Foo` that has no docstring. The test then runs the main documentation generation process, mocking the LLM client to simulate responses for module, project, and class summaries. After execution, it verifies that the generated HTML output includes the class summary text. The test ensures that the documentation generator correctly processes classes regardless of whether they have docstrings.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">test_handles_class_without_docstring</span>(tmp_path: Path) <span style="color: #666666">-&gt;</span> <span style="color: #008000; font-weight: bold">None</span>:
    project_dir <span style="color: #666666">=</span> tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">"proj"</span>
    project_dir<span style="color: #666666">.</span>mkdir()
    (project_dir <span style="color: #666666">/</span> <span style="color: #BA2121">"mod.py"</span>)<span style="color: #666666">.</span>write_text(<span style="color: #BA2121">"class Foo:</span><span style="color: #AA5D1F; font-weight: bold">\n</span><span style="color: #BA2121">    pass</span><span style="color: #AA5D1F; font-weight: bold">\n</span><span style="color: #BA2121">"</span>)

    output_dir <span style="color: #666666">=</span> tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">"docs"</span>

    <span style="color: #008000; font-weight: bold">with</span> patch(<span style="color: #BA2121">"docgenerator.LLMClient"</span>) <span style="color: #008000; font-weight: bold">as</span> MockClient:
        instance <span style="color: #666666">=</span> MockClient<span style="color: #666666">.</span>return_value
        instance<span style="color: #666666">.</span>ping<span style="color: #666666">.</span>return_value <span style="color: #666666">=</span> <span style="color: #008000; font-weight: bold">True</span>
        instance<span style="color: #666666">.</span>summarize<span style="color: #666666">.</span>side_effect <span style="color: #666666">=</span> [
            <span style="color: #BA2121">"module summary"</span>,
            <span style="color: #BA2121">"project summary"</span>,
            <span style="color: #BA2121">"class summary"</span>,
        ]
        ret <span style="color: #666666">=</span> main([<span style="color: #008000">str</span>(project_dir), <span style="color: #BA2121">"--output"</span>, <span style="color: #008000">str</span>(output_dir)])
        <span style="color: #008000; font-weight: bold">assert</span> ret <span style="color: #666666">==</span> <span style="color: #666666">0</span>

    html <span style="color: #666666">=</span> (output_dir <span style="color: #666666">/</span> <span style="color: #BA2121">"mod.html"</span>)<span style="color: #666666">.</span>read_text(encoding<span style="color: #666666">=</span><span style="color: #BA2121">"utf-8"</span>)
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #BA2121">"class summary"</span> <span style="color: #AA22FF; font-weight: bold">in</span> html
</code></pre>
<h3 id="test_project_summary_is_sanitized">test_project_summary_is_sanitized(tmp_path: Path) -&gt; None</h3>
<p>The function `test_project_summary_is_sanitized` verifies that the project summary generated by the documentation generator is sanitized of specific phrases. It creates a temporary project directory with a Python module, configures a mocked LLM client to return predefined summaries, and executes the main documentation generation process. The test confirms that the resulting HTML output does not contain the phrase "You can run this" while ensuring "It prints." is present. It also checks that the LLM client's `summarize` method was called with "project" as an argument during the process.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">test_project_summary_is_sanitized</span>(tmp_path: Path) <span style="color: #666666">-&gt;</span> <span style="color: #008000; font-weight: bold">None</span>:
    project_dir <span style="color: #666666">=</span> tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">"proj"</span>
    project_dir<span style="color: #666666">.</span>mkdir()
    (project_dir <span style="color: #666666">/</span> <span style="color: #BA2121">"mod.py"</span>)<span style="color: #666666">.</span>write_text(<span style="color: #BA2121">"def foo():</span><span style="color: #AA5D1F; font-weight: bold">\n</span><span style="color: #BA2121">    pass</span><span style="color: #AA5D1F; font-weight: bold">\n</span><span style="color: #BA2121">"</span>)

    output_dir <span style="color: #666666">=</span> tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">"docs"</span>

    <span style="color: #008000; font-weight: bold">with</span> patch(<span style="color: #BA2121">"docgenerator.LLMClient"</span>) <span style="color: #008000; font-weight: bold">as</span> MockClient:
        instance <span style="color: #666666">=</span> MockClient<span style="color: #666666">.</span>return_value
        instance<span style="color: #666666">.</span>ping<span style="color: #666666">.</span>return_value <span style="color: #666666">=</span> <span style="color: #008000; font-weight: bold">True</span>
        instance<span style="color: #666666">.</span>summarize<span style="color: #666666">.</span>side_effect <span style="color: #666666">=</span> [
            <span style="color: #BA2121">"module summary"</span>,
            <span style="color: #BA2121">"project summary"</span>,
            <span style="color: #BA2121">"function summary"</span>,
            <span style="color: #BA2121">"improved function doc"</span>,
        ]
        ret <span style="color: #666666">=</span> main([<span style="color: #008000">str</span>(project_dir), <span style="color: #BA2121">"--output"</span>, <span style="color: #008000">str</span>(output_dir)])
        <span style="color: #008000; font-weight: bold">assert</span> ret <span style="color: #666666">==</span> <span style="color: #666666">0</span>

    html <span style="color: #666666">=</span> (output_dir <span style="color: #666666">/</span> <span style="color: #BA2121">"index.html"</span>)<span style="color: #666666">.</span>read_text(encoding<span style="color: #666666">=</span><span style="color: #BA2121">"utf-8"</span>)
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #BA2121">"You can run this"</span> <span style="color: #AA22FF; font-weight: bold">not</span> <span style="color: #AA22FF; font-weight: bold">in</span> html
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #BA2121">"It prints."</span> <span style="color: #AA22FF; font-weight: bold">in</span> html
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #008000">any</span>(call<span style="color: #666666">.</span>args[<span style="color: #666666">1</span>] <span style="color: #666666">==</span> <span style="color: #BA2121">"project"</span> <span style="color: #008000; font-weight: bold">for</span> call <span style="color: #AA22FF; font-weight: bold">in</span> instance<span style="color: #666666">.</span>summarize<span style="color: #666666">.</span>call_args_list)
</code></pre>
<h3 id="test_readme_summary_used">test_readme_summary_used(tmp_path: Path) -&gt; None</h3>
<p>This function tests the generation of a README summary using a mocked LLM client. It creates a temporary project directory with a Python module and a README file, then invokes the main documentation generation function with specified input and output paths. The test verifies that the generated HTML output contains the expected summary text and that the LLM client's summarize method was called with the correct prompt type ("readme"). The test uses mocking to simulate LLM behavior and ensures the integration of README content into the documentation output.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">test_readme_summary_used</span>(tmp_path: Path) <span style="color: #666666">-&gt;</span> <span style="color: #008000; font-weight: bold">None</span>:
    project_dir <span style="color: #666666">=</span> tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">"proj"</span>
    project_dir<span style="color: #666666">.</span>mkdir()
    (project_dir <span style="color: #666666">/</span> <span style="color: #BA2121">"mod.py"</span>)<span style="color: #666666">.</span>write_text(<span style="color: #BA2121">"def foo():</span><span style="color: #AA5D1F; font-weight: bold">\n</span><span style="color: #BA2121">    pass</span><span style="color: #AA5D1F; font-weight: bold">\n</span><span style="color: #BA2121">"</span>)
    (project_dir <span style="color: #666666">/</span> <span style="color: #BA2121">"README.md"</span>)<span style="color: #666666">.</span>write_text(<span style="color: #BA2121">"Project docs"</span>)

    output_dir <span style="color: #666666">=</span> tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">"docs"</span>

    <span style="color: #008000; font-weight: bold">with</span> patch(<span style="color: #BA2121">"docgenerator.LLMClient"</span>) <span style="color: #008000; font-weight: bold">as</span> MockClient:
        instance <span style="color: #666666">=</span> MockClient<span style="color: #666666">.</span>return_value
        instance<span style="color: #666666">.</span>ping<span style="color: #666666">.</span>return_value <span style="color: #666666">=</span> <span style="color: #008000; font-weight: bold">True</span>
        instance<span style="color: #666666">.</span>summarize<span style="color: #666666">.</span>side_effect <span style="color: #666666">=</span> <span style="color: #008000; font-weight: bold">lambda</span> text, pt, <span style="color: #666666">**</span>kwargs: <span style="color: #BA2121">f"</span><span style="color: #A45A77; font-weight: bold">{</span>pt<span style="color: #A45A77; font-weight: bold">}</span><span style="color: #BA2121"> summary"</span>
        ret <span style="color: #666666">=</span> main([<span style="color: #008000">str</span>(project_dir), <span style="color: #BA2121">"--output"</span>, <span style="color: #008000">str</span>(output_dir)])
        <span style="color: #008000; font-weight: bold">assert</span> ret <span style="color: #666666">==</span> <span style="color: #666666">0</span>

    html <span style="color: #666666">=</span> (output_dir <span style="color: #666666">/</span> <span style="color: #BA2121">"index.html"</span>)<span style="color: #666666">.</span>read_text(encoding<span style="color: #666666">=</span><span style="color: #BA2121">"utf-8"</span>)
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #BA2121">"readme summary"</span> <span style="color: #AA22FF; font-weight: bold">in</span> html
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #008000">any</span>(call<span style="color: #666666">.</span>args[<span style="color: #666666">1</span>] <span style="color: #666666">==</span> <span style="color: #BA2121">"readme"</span> <span style="color: #008000; font-weight: bold">for</span> call <span style="color: #AA22FF; font-weight: bold">in</span> instance<span style="color: #666666">.</span>summarize<span style="color: #666666">.</span>call_args_list)
</code></pre>
<h3 id="test_clean_output_dir">test_clean_output_dir(tmp_path: Path) -&gt; None</h3>
<p>The function `test_clean_output_dir` tests the `clean_output_dir` function from the `docgenerator` module. It creates a temporary output directory with subdirectories and files, including an HTML file marked as generated by DocGen-LM, a custom HTML file, and a CSS asset file. After calling `clean_output_dir` on the output directory path, it verifies that the generated HTML file is removed while the custom HTML file and the CSS asset file remain intact.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">test_clean_output_dir</span>(tmp_path: Path) <span style="color: #666666">-&gt;</span> <span style="color: #008000; font-weight: bold">None</span>:
    out <span style="color: #666666">=</span> tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">"docs"</span>
    out<span style="color: #666666">.</span>mkdir()
    generated <span style="color: #666666">=</span> out <span style="color: #666666">/</span> <span style="color: #BA2121">"old.html"</span>
    generated<span style="color: #666666">.</span>write_text(<span style="color: #BA2121">"&lt;!-- Generated by DocGen-LM --&gt;</span><span style="color: #AA5D1F; font-weight: bold">\n</span><span style="color: #BA2121">&lt;html&gt;&lt;/html&gt;"</span>, encoding<span style="color: #666666">=</span><span style="color: #BA2121">"utf-8"</span>)
    custom <span style="color: #666666">=</span> out <span style="color: #666666">/</span> <span style="color: #BA2121">"custom.html"</span>
    custom<span style="color: #666666">.</span>write_text(<span style="color: #BA2121">"&lt;html&gt;&lt;/html&gt;"</span>, encoding<span style="color: #666666">=</span><span style="color: #BA2121">"utf-8"</span>)
    asset <span style="color: #666666">=</span> out <span style="color: #666666">/</span> <span style="color: #BA2121">"style.css"</span>
    asset<span style="color: #666666">.</span>write_text(<span style="color: #BA2121">"body </span><span style="color: #A45A77; font-weight: bold">{}</span><span style="color: #BA2121">"</span>, encoding<span style="color: #666666">=</span><span style="color: #BA2121">"utf-8"</span>)

    <span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">docgenerator</span> <span style="color: #008000; font-weight: bold">import</span> clean_output_dir

    clean_output_dir(<span style="color: #008000">str</span>(out))

    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #AA22FF; font-weight: bold">not</span> generated<span style="color: #666666">.</span>exists()
    <span style="color: #008000; font-weight: bold">assert</span> custom<span style="color: #666666">.</span>exists()
    <span style="color: #008000; font-weight: bold">assert</span> asset<span style="color: #666666">.</span>exists()
</code></pre>
<h3 id="test_summarize_chunked_splits_long_text">test_summarize_chunked_splits_long_text(tmp_path: Path) -&gt; None</h3>
<p>The function `test_summarize_chunked_splits_long_text` tests the behavior of the `summarize_chunked` utility by verifying that a long text input is split into multiple chunks during summarization. It creates a tokenizer and a cache, then patches the internal `_summarize` function to return a fixed summary. The test calls `summarize_chunked` with a text string consisting of 50 repeated words, a small context size, and a limited chunk budget. It asserts that the mocked `_summarize` function is called more than once, confirming that the input text was divided into multiple chunks for processing.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">test_summarize_chunked_splits_long_text</span>(tmp_path: Path) <span style="color: #666666">-&gt;</span> <span style="color: #008000; font-weight: bold">None</span>:
    <span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">cache</span> <span style="color: #008000; font-weight: bold">import</span> ResponseCache
    <span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">chunk_utils</span> <span style="color: #008000; font-weight: bold">import</span> get_tokenizer
    <span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">summarize_utils</span> <span style="color: #008000; font-weight: bold">import</span> summarize_chunked

    tokenizer <span style="color: #666666">=</span> get_tokenizer()
    text <span style="color: #666666">=</span> <span style="color: #BA2121">"word "</span> <span style="color: #666666">*</span> <span style="color: #666666">50</span>
    cache <span style="color: #666666">=</span> ResponseCache(<span style="color: #008000">str</span>(tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">"cache.json"</span>))

    <span style="color: #008000; font-weight: bold">with</span> patch(<span style="color: #BA2121">"summarize_utils._summarize"</span>, return_value<span style="color: #666666">=</span><span style="color: #BA2121">"summary"</span>) <span style="color: #008000; font-weight: bold">as</span> mock_sum:
        summarize_chunked(
            client<span style="color: #666666">=</span><span style="color: #008000">object</span>(),
            cache<span style="color: #666666">=</span>cache,
            key_prefix<span style="color: #666666">=</span><span style="color: #BA2121">"k"</span>,
            text<span style="color: #666666">=</span>text,
            prompt_type<span style="color: #666666">=</span><span style="color: #BA2121">"module"</span>,
            max_context_tokens<span style="color: #666666">=10</span>,
            chunk_token_budget<span style="color: #666666">=5</span>,
        )
        <span style="color: #008000; font-weight: bold">assert</span> mock_sum<span style="color: #666666">.</span>call_count <span style="color: #666666">&gt;</span> <span style="color: #666666">1</span>
</code></pre>
<h3 id="test_chunking_accounts_for_prompt_overhead">test_chunking_accounts_for_prompt_overhead(tmp_path: Path) -&gt; None</h3>
<p>The function `test_chunking_accounts_for_prompt_overhead` tests that the chunking mechanism in `summarize_chunked` properly accounts for prompt overhead when determining chunk sizes. It creates a tokenizer, defines a sample text, and calculates the token overhead from system and template prompts. Using a mocked summary function, it verifies that the text is split into multiple chunks when the maximum context tokens are exceeded due to overhead, ensuring the chunking logic correctly handles prompt-related token usage.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">test_chunking_accounts_for_prompt_overhead</span>(tmp_path: Path) <span style="color: #666666">-&gt;</span> <span style="color: #008000; font-weight: bold">None</span>:
    <span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">cache</span> <span style="color: #008000; font-weight: bold">import</span> ResponseCache
    <span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">chunk_utils</span> <span style="color: #008000; font-weight: bold">import</span> get_tokenizer
    <span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">summarize_utils</span> <span style="color: #008000; font-weight: bold">import</span> summarize_chunked
    <span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">llm_client</span> <span style="color: #008000; font-weight: bold">import</span> SYSTEM_PROMPT, PROMPT_TEMPLATES

    tokenizer <span style="color: #666666">=</span> get_tokenizer()
    text <span style="color: #666666">=</span> <span style="color: #BA2121">"word "</span> <span style="color: #666666">*</span> <span style="color: #666666">15</span>
    cache <span style="color: #666666">=</span> ResponseCache(<span style="color: #008000">str</span>(tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">"cache.json"</span>))
    template <span style="color: #666666">=</span> PROMPT_TEMPLATES[<span style="color: #BA2121">"module"</span>]
    overhead <span style="color: #666666">=</span> <span style="color: #008000">len</span>(tokenizer<span style="color: #666666">.</span>encode(SYSTEM_PROMPT)) <span style="color: #666666">+</span> <span style="color: #008000">len</span>(tokenizer<span style="color: #666666">.</span>encode(template<span style="color: #666666">.</span>format(text<span style="color: #666666">=</span><span style="color: #BA2121">""</span>)))
    max_context_tokens <span style="color: #666666">=</span> overhead <span style="color: #666666">+</span> <span style="color: #666666">10</span>

    <span style="color: #008000; font-weight: bold">with</span> patch(<span style="color: #BA2121">"summarize_utils._summarize"</span>, return_value<span style="color: #666666">=</span><span style="color: #BA2121">"summary"</span>) <span style="color: #008000; font-weight: bold">as</span> mock_sum:
        summarize_chunked(
            client<span style="color: #666666">=</span><span style="color: #008000">object</span>(),
            cache<span style="color: #666666">=</span>cache,
            key_prefix<span style="color: #666666">=</span><span style="color: #BA2121">"k"</span>,
            text<span style="color: #666666">=</span>text,
            prompt_type<span style="color: #666666">=</span><span style="color: #BA2121">"module"</span>,
            max_context_tokens<span style="color: #666666">=</span>max_context_tokens,
            chunk_token_budget<span style="color: #666666">=100</span>,
        )
        <span style="color: #008000; font-weight: bold">assert</span> mock_sum<span style="color: #666666">.</span>call_count <span style="color: #666666">&gt;</span> <span style="color: #666666">1</span>
</code></pre>
<h3 id="test_merge_recurses_when_prompt_too_long">test_merge_recurses_when_prompt_too_long(tmp_path: Path) -&gt; None</h3>
<p>The function `test_merge_recurses_when_prompt_too_long` tests the recursive merging behavior of the `summarize_chunked` utility when the prompt exceeds the maximum context length. It sets up a mock tokenizer and cache, defines a fake summarization function that enforces token limits, and verifies that multiple calls are made with the `"docstring"` prompt type when chunking occurs due to exceeding the token budget. The test ensures that the system correctly handles long inputs by recursively processing them in smaller segments.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">test_merge_recurses_when_prompt_too_long</span>(tmp_path: Path) <span style="color: #666666">-&gt;</span> <span style="color: #008000; font-weight: bold">None</span>:
    <span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">cache</span> <span style="color: #008000; font-weight: bold">import</span> ResponseCache
    <span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">chunk_utils</span> <span style="color: #008000; font-weight: bold">import</span> get_tokenizer
    <span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">summarize_utils</span> <span style="color: #008000; font-weight: bold">import</span> summarize_chunked
    <span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">llm_client</span> <span style="color: #008000; font-weight: bold">import</span> SYSTEM_PROMPT, PROMPT_TEMPLATES

    tokenizer <span style="color: #666666">=</span> get_tokenizer()
    text <span style="color: #666666">=</span> <span style="color: #BA2121">"word "</span> <span style="color: #666666">*</span> <span style="color: #666666">200</span>
    cache <span style="color: #666666">=</span> ResponseCache(<span style="color: #008000">str</span>(tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">"cache.json"</span>))
    template <span style="color: #666666">=</span> PROMPT_TEMPLATES[<span style="color: #BA2121">"module"</span>]
    overhead <span style="color: #666666">=</span> <span style="color: #008000">len</span>(tokenizer<span style="color: #666666">.</span>encode(SYSTEM_PROMPT)) <span style="color: #666666">+</span> <span style="color: #008000">len</span>(
        tokenizer<span style="color: #666666">.</span>encode(template<span style="color: #666666">.</span>format(text<span style="color: #666666">=</span><span style="color: #BA2121">""</span>))
    )
    max_context_tokens <span style="color: #666666">=</span> overhead <span style="color: #666666">+</span> <span style="color: #666666">50</span>

    <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">fake_sum</span>(client, cache_obj, key, text_arg, prompt_type, <span style="color: #666666">*</span>, system_prompt<span style="color: #666666">=</span><span style="color: #BA2121">""</span>):
        template <span style="color: #666666">=</span> PROMPT_TEMPLATES<span style="color: #666666">.</span>get(prompt_type, PROMPT_TEMPLATES[<span style="color: #BA2121">"module"</span>])
        overhead <span style="color: #666666">=</span> <span style="color: #008000">len</span>(tokenizer<span style="color: #666666">.</span>encode(SYSTEM_PROMPT)) <span style="color: #666666">+</span> <span style="color: #008000">len</span>(
            tokenizer<span style="color: #666666">.</span>encode(template<span style="color: #666666">.</span>format(text<span style="color: #666666">=</span><span style="color: #BA2121">""</span>))
        )
        available <span style="color: #666666">=</span> max_context_tokens <span style="color: #666666">-</span> overhead
        <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #008000">len</span>(tokenizer<span style="color: #666666">.</span>encode(text_arg)) <span style="color: #666666">&lt;=</span> available
        <span style="color: #008000; font-weight: bold">if</span> prompt_type <span style="color: #666666">==</span> <span style="color: #BA2121">"module"</span>:
            <span style="color: #008000; font-weight: bold">return</span> <span style="color: #BA2121">"summary "</span> <span style="color: #666666">*</span> <span style="color: #666666">30</span>
        <span style="color: #008000; font-weight: bold">return</span> <span style="color: #BA2121">"short"</span>

    <span style="color: #008000; font-weight: bold">with</span> patch(<span style="color: #BA2121">"summarize_utils._summarize"</span>, side_effect<span style="color: #666666">=</span>fake_sum) <span style="color: #008000; font-weight: bold">as</span> mock_sum:
        summarize_chunked(
            client<span style="color: #666666">=</span><span style="color: #008000">object</span>(),
            cache<span style="color: #666666">=</span>cache,
            key_prefix<span style="color: #666666">=</span><span style="color: #BA2121">"k"</span>,
            text<span style="color: #666666">=</span>text,
            prompt_type<span style="color: #666666">=</span><span style="color: #BA2121">"module"</span>,
            max_context_tokens<span style="color: #666666">=</span>max_context_tokens,
            chunk_token_budget<span style="color: #666666">=10</span>,
        )
        merge_calls <span style="color: #666666">=</span> [c <span style="color: #008000; font-weight: bold">for</span> c <span style="color: #AA22FF; font-weight: bold">in</span> mock_sum<span style="color: #666666">.</span>call_args_list <span style="color: #008000; font-weight: bold">if</span> c<span style="color: #666666">.</span>args[<span style="color: #666666">4</span>] <span style="color: #666666">==</span> <span style="color: #BA2121">"docstring"</span>]
        <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #008000">len</span>(merge_calls) <span style="color: #666666">&gt;</span> <span style="color: #666666">1</span>
</code></pre>
<details>
<summary>Subfunction: fake_sum(client, cache_obj, key, text_arg, prompt_type, *, system_prompt='')</summary>
<h4 id="fake_sum">fake_sum(client, cache_obj, key, text_arg, prompt_type, *, system_prompt='')</h4>
<p>The function `fake_sum` generates a fake summary based on the provided arguments. It retrieves a prompt template corresponding to the given `prompt_type`, calculates the token overhead of the system prompt and template, and determines the available tokens for the input text. It asserts that the input text fits within the available token limit. If the `prompt_type` is "module", it returns a repeated string "summary ". Otherwise, it returns the string "short". The function appears to be a placeholder or mock implementation for testing purposes.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">fake_sum</span>(client, cache_obj, key, text_arg, prompt_type, <span style="color: #666666">*</span>, system_prompt<span style="color: #666666">=</span><span style="color: #BA2121">""</span>):
        template <span style="color: #666666">=</span> PROMPT_TEMPLATES<span style="color: #666666">.</span>get(prompt_type, PROMPT_TEMPLATES[<span style="color: #BA2121">"module"</span>])
        overhead <span style="color: #666666">=</span> <span style="color: #008000">len</span>(tokenizer<span style="color: #666666">.</span>encode(SYSTEM_PROMPT)) <span style="color: #666666">+</span> <span style="color: #008000">len</span>(
            tokenizer<span style="color: #666666">.</span>encode(template<span style="color: #666666">.</span>format(text<span style="color: #666666">=</span><span style="color: #BA2121">""</span>))
        )
        available <span style="color: #666666">=</span> max_context_tokens <span style="color: #666666">-</span> overhead
        <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #008000">len</span>(tokenizer<span style="color: #666666">.</span>encode(text_arg)) <span style="color: #666666">&lt;=</span> available
        <span style="color: #008000; font-weight: bold">if</span> prompt_type <span style="color: #666666">==</span> <span style="color: #BA2121">"module"</span>:
            <span style="color: #008000; font-weight: bold">return</span> <span style="color: #BA2121">"summary "</span> <span style="color: #666666">*</span> <span style="color: #666666">30</span>
        <span style="color: #008000; font-weight: bold">return</span> <span style="color: #BA2121">"short"</span>
</code></pre>
</details>
<h3 id="test_single_long_partial_is_recursively_chunked">test_single_long_partial_is_recursively_chunked(tmp_path: Path) -&gt; None</h3>
<p>This function tests that a single long partial text is recursively chunked during summarization. It sets up a mock environment with a fixed token budget and a fake summarization function that enforces token limits. The test verifies that when a text exceeds the token budget, it is split into multiple chunks, as indicated by multiple calls to the `docstring` prompt type in the mocked summarization function. The test ensures recursive chunking behavior under token constraints.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">test_single_long_partial_is_recursively_chunked</span>(tmp_path: Path) <span style="color: #666666">-&gt;</span> <span style="color: #008000; font-weight: bold">None</span>:
    <span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">cache</span> <span style="color: #008000; font-weight: bold">import</span> ResponseCache
    <span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">chunk_utils</span> <span style="color: #008000; font-weight: bold">import</span> get_tokenizer
    <span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">summarize_utils</span> <span style="color: #008000; font-weight: bold">import</span> summarize_chunked
    <span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">llm_client</span> <span style="color: #008000; font-weight: bold">import</span> SYSTEM_PROMPT, PROMPT_TEMPLATES

    tokenizer <span style="color: #666666">=</span> get_tokenizer()
    text <span style="color: #666666">=</span> <span style="color: #BA2121">"word "</span> <span style="color: #666666">*</span> <span style="color: #666666">200</span>
    cache <span style="color: #666666">=</span> ResponseCache(<span style="color: #008000">str</span>(tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">"cache.json"</span>))
    template <span style="color: #666666">=</span> PROMPT_TEMPLATES[<span style="color: #BA2121">"module"</span>]
    overhead <span style="color: #666666">=</span> <span style="color: #008000">len</span>(tokenizer<span style="color: #666666">.</span>encode(SYSTEM_PROMPT)) <span style="color: #666666">+</span> <span style="color: #008000">len</span>(tokenizer<span style="color: #666666">.</span>encode(template<span style="color: #666666">.</span>format(text<span style="color: #666666">=</span><span style="color: #BA2121">""</span>)))
    max_context_tokens <span style="color: #666666">=</span> overhead <span style="color: #666666">+</span> <span style="color: #666666">50</span>

    <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">fake_sum</span>(client, cache_obj, key, text_arg, prompt_type, <span style="color: #666666">*</span>, system_prompt<span style="color: #666666">=</span><span style="color: #BA2121">""</span>):
        template <span style="color: #666666">=</span> PROMPT_TEMPLATES<span style="color: #666666">.</span>get(prompt_type, PROMPT_TEMPLATES[<span style="color: #BA2121">"module"</span>])
        overhead_local <span style="color: #666666">=</span> <span style="color: #008000">len</span>(tokenizer<span style="color: #666666">.</span>encode(SYSTEM_PROMPT)) <span style="color: #666666">+</span> <span style="color: #008000">len</span>(
            tokenizer<span style="color: #666666">.</span>encode(template<span style="color: #666666">.</span>format(text<span style="color: #666666">=</span><span style="color: #BA2121">""</span>))
        )
        available <span style="color: #666666">=</span> max_context_tokens <span style="color: #666666">-</span> overhead_local
        <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #008000">len</span>(tokenizer<span style="color: #666666">.</span>encode(text_arg)) <span style="color: #666666">&lt;=</span> available
        <span style="color: #008000; font-weight: bold">if</span> prompt_type <span style="color: #666666">==</span> <span style="color: #BA2121">"module"</span>:
            <span style="color: #008000; font-weight: bold">return</span> <span style="color: #BA2121">"long "</span> <span style="color: #666666">*</span> <span style="color: #666666">200</span>
        <span style="color: #008000; font-weight: bold">return</span> <span style="color: #BA2121">"short"</span>

    <span style="color: #008000; font-weight: bold">with</span> patch(<span style="color: #BA2121">"summarize_utils._summarize"</span>, side_effect<span style="color: #666666">=</span>fake_sum) <span style="color: #008000; font-weight: bold">as</span> mock_sum:
        summarize_chunked(
            client<span style="color: #666666">=</span><span style="color: #008000">object</span>(),
            cache<span style="color: #666666">=</span>cache,
            key_prefix<span style="color: #666666">=</span><span style="color: #BA2121">"k"</span>,
            text<span style="color: #666666">=</span>text,
            prompt_type<span style="color: #666666">=</span><span style="color: #BA2121">"module"</span>,
            max_context_tokens<span style="color: #666666">=</span>max_context_tokens,
            chunk_token_budget<span style="color: #666666">=10</span>,
        )
        doc_calls <span style="color: #666666">=</span> [c <span style="color: #008000; font-weight: bold">for</span> c <span style="color: #AA22FF; font-weight: bold">in</span> mock_sum<span style="color: #666666">.</span>call_args_list <span style="color: #008000; font-weight: bold">if</span> c<span style="color: #666666">.</span>args[<span style="color: #666666">4</span>] <span style="color: #666666">==</span> <span style="color: #BA2121">"docstring"</span>]
        <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #008000">len</span>(doc_calls) <span style="color: #666666">&gt;</span> <span style="color: #666666">1</span>
</code></pre>
<details>
<summary>Subfunction: fake_sum(client, cache_obj, key, text_arg, prompt_type, *, system_prompt='')</summary>
<h4 id="fake_sum">fake_sum(client, cache_obj, key, text_arg, prompt_type, *, system_prompt='')</h4>
<p>The function `fake_sum` generates a fake summary based on the provided arguments. It retrieves a prompt template corresponding to the specified `prompt_type`, calculates the token overhead for system and template prompts, and verifies that the input text fits within the available token context. If the `prompt_type` is "module", it returns a long dummy summary consisting of repeated "long " strings. For other prompt types, it returns a short dummy summary. The function uses a tokenizer to encode prompts and text arguments for token count calculations.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">fake_sum</span>(client, cache_obj, key, text_arg, prompt_type, <span style="color: #666666">*</span>, system_prompt<span style="color: #666666">=</span><span style="color: #BA2121">""</span>):
        template <span style="color: #666666">=</span> PROMPT_TEMPLATES<span style="color: #666666">.</span>get(prompt_type, PROMPT_TEMPLATES[<span style="color: #BA2121">"module"</span>])
        overhead_local <span style="color: #666666">=</span> <span style="color: #008000">len</span>(tokenizer<span style="color: #666666">.</span>encode(SYSTEM_PROMPT)) <span style="color: #666666">+</span> <span style="color: #008000">len</span>(
            tokenizer<span style="color: #666666">.</span>encode(template<span style="color: #666666">.</span>format(text<span style="color: #666666">=</span><span style="color: #BA2121">""</span>))
        )
        available <span style="color: #666666">=</span> max_context_tokens <span style="color: #666666">-</span> overhead_local
        <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #008000">len</span>(tokenizer<span style="color: #666666">.</span>encode(text_arg)) <span style="color: #666666">&lt;=</span> available
        <span style="color: #008000; font-weight: bold">if</span> prompt_type <span style="color: #666666">==</span> <span style="color: #BA2121">"module"</span>:
            <span style="color: #008000; font-weight: bold">return</span> <span style="color: #BA2121">"long "</span> <span style="color: #666666">*</span> <span style="color: #666666">200</span>
        <span style="color: #008000; font-weight: bold">return</span> <span style="color: #BA2121">"short"</span>
</code></pre>
</details>
<h3 id="test_structured_chunker_keeps_functions_atomic">test_structured_chunker_keeps_functions_atomic(tmp_path: Path) -&gt; None</h3>
<p>The function `test_structured_chunker_keeps_functions_atomic` tests that the chunking mechanism preserves individual functions as atomic units during summarization. It creates a Python source file containing two functions, parses it, and then uses a mocked summarization function to verify that each function is processed as a separate chunk. The test ensures that the token budgeting logic correctly isolates each function's source code when summarizing a module, maintaining the integrity of individual function boundaries within the chunking process. The test checks that exactly two chunks are generated, corresponding to the two functions, and that their sources match the original parsed function sources.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">test_structured_chunker_keeps_functions_atomic</span>(tmp_path: Path) <span style="color: #666666">-&gt;</span> <span style="color: #008000; font-weight: bold">None</span>:
    <span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">cache</span> <span style="color: #008000; font-weight: bold">import</span> ResponseCache
    <span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">parser_python</span> <span style="color: #008000; font-weight: bold">import</span> parse_python_file
    <span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">chunk_utils</span> <span style="color: #008000; font-weight: bold">import</span> get_tokenizer
    <span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">docgenerator</span> <span style="color: #008000; font-weight: bold">import</span> _summarize_module_chunked
    <span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">llm_client</span> <span style="color: #008000; font-weight: bold">import</span> SYSTEM_PROMPT, PROMPT_TEMPLATES

    src <span style="color: #666666">=</span> (
        <span style="color: #BA2121">"def f1():</span><span style="color: #AA5D1F; font-weight: bold">\n</span><span style="color: #BA2121">"</span>
        <span style="color: #BA2121">"    x = 1</span><span style="color: #AA5D1F; font-weight: bold">\n</span><span style="color: #BA2121">"</span>
        <span style="color: #666666">+</span> <span style="color: #BA2121">"    x += 1</span><span style="color: #AA5D1F; font-weight: bold">\n</span><span style="color: #BA2121">"</span> <span style="color: #666666">*</span> <span style="color: #666666">5</span>
        <span style="color: #666666">+</span> <span style="color: #BA2121">"    return x</span><span style="color: #AA5D1F; font-weight: bold">\n\n</span><span style="color: #BA2121">"</span>
        <span style="color: #BA2121">"def f2():</span><span style="color: #AA5D1F; font-weight: bold">\n</span><span style="color: #BA2121">"</span>
        <span style="color: #BA2121">"    y = 1</span><span style="color: #AA5D1F; font-weight: bold">\n</span><span style="color: #BA2121">"</span>
        <span style="color: #666666">+</span> <span style="color: #BA2121">"    y += 1</span><span style="color: #AA5D1F; font-weight: bold">\n</span><span style="color: #BA2121">"</span> <span style="color: #666666">*</span> <span style="color: #666666">5</span>
        <span style="color: #666666">+</span> <span style="color: #BA2121">"    return y</span><span style="color: #AA5D1F; font-weight: bold">\n</span><span style="color: #BA2121">"</span>
    )
    file <span style="color: #666666">=</span> tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">"m.py"</span>
    file<span style="color: #666666">.</span>write_text(src)
    parsed <span style="color: #666666">=</span> parse_python_file(<span style="color: #008000">str</span>(file))

    tokenizer <span style="color: #666666">=</span> get_tokenizer()
    cache <span style="color: #666666">=</span> ResponseCache(<span style="color: #008000">str</span>(tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">"cache.json"</span>))

    <span style="color: #008000; font-weight: bold">with</span> patch(<span style="color: #BA2121">"docgenerator._summarize"</span>, return_value<span style="color: #666666">=</span><span style="color: #BA2121">"sum"</span>) <span style="color: #008000; font-weight: bold">as</span> mock_sum:
        flen <span style="color: #666666">=</span> <span style="color: #008000">len</span>(tokenizer<span style="color: #666666">.</span>encode(parsed[<span style="color: #BA2121">"functions"</span>][<span style="color: #666666">0</span>][<span style="color: #BA2121">"source"</span>]))
        budget <span style="color: #666666">=</span> flen <span style="color: #666666">+</span> <span style="color: #666666">5</span>
        overhead <span style="color: #666666">=</span> <span style="color: #008000">len</span>(tokenizer<span style="color: #666666">.</span>encode(SYSTEM_PROMPT)) <span style="color: #666666">+</span> <span style="color: #008000">len</span>(tokenizer<span style="color: #666666">.</span>encode(PROMPT_TEMPLATES[<span style="color: #BA2121">"module"</span>]<span style="color: #666666">.</span>format(text<span style="color: #666666">=</span><span style="color: #BA2121">""</span>)))
        _summarize_module_chunked(
            client<span style="color: #666666">=</span><span style="color: #008000">object</span>(),
            cache<span style="color: #666666">=</span>cache,
            key_prefix<span style="color: #666666">=</span><span style="color: #BA2121">"k"</span>,
            module_text<span style="color: #666666">=</span>src,
            module<span style="color: #666666">=</span>parsed,
            tokenizer<span style="color: #666666">=</span>tokenizer,
            max_context_tokens<span style="color: #666666">=</span>overhead <span style="color: #666666">+</span> budget,
            chunk_token_budget<span style="color: #666666">=</span>budget,
        )

        chunks <span style="color: #666666">=</span> [c<span style="color: #666666">.</span>args[<span style="color: #666666">3</span>] <span style="color: #008000; font-weight: bold">for</span> c <span style="color: #AA22FF; font-weight: bold">in</span> mock_sum<span style="color: #666666">.</span>call_args_list <span style="color: #008000; font-weight: bold">if</span> c<span style="color: #666666">.</span>args[<span style="color: #666666">4</span>] <span style="color: #666666">==</span> <span style="color: #BA2121">"module"</span>]
        <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #008000">len</span>(chunks) <span style="color: #666666">==</span> <span style="color: #666666">2</span>
        func_sources <span style="color: #666666">=</span> {f[<span style="color: #BA2121">"source"</span>] <span style="color: #008000; font-weight: bold">for</span> f <span style="color: #AA22FF; font-weight: bold">in</span> parsed[<span style="color: #BA2121">"functions"</span>]}
        <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #008000">set</span>(chunks) <span style="color: #666666">==</span> func_sources
</code></pre>
<h3 id="test_structured_chunker_splits_large_class_by_method">test_structured_chunker_splits_large_class_by_method(tmp_path: Path) -&gt; None</h3>
<p>This function tests the behavior of `_summarize_module_chunked` when processing a large class by splitting it into method-level chunks. It creates a Python class with two methods, parses the source code, and uses a mocked summarization function to verify that each method is processed as a separate chunk. The test ensures that the chunking logic correctly isolates individual methods from a class and passes them to the summarization function with the appropriate token budget and context limits. The assertion confirms that the number of chunks matches the number of methods and that each chunk corresponds to the source code of a method.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">test_structured_chunker_splits_large_class_by_method</span>(tmp_path: Path) <span style="color: #666666">-&gt;</span> <span style="color: #008000; font-weight: bold">None</span>:
    <span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">cache</span> <span style="color: #008000; font-weight: bold">import</span> ResponseCache
    <span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">parser_python</span> <span style="color: #008000; font-weight: bold">import</span> parse_python_file
    <span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">chunk_utils</span> <span style="color: #008000; font-weight: bold">import</span> get_tokenizer
    <span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">docgenerator</span> <span style="color: #008000; font-weight: bold">import</span> _summarize_module_chunked
    <span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">llm_client</span> <span style="color: #008000; font-weight: bold">import</span> SYSTEM_PROMPT, PROMPT_TEMPLATES

    class_src <span style="color: #666666">=</span> (
        <span style="color: #BA2121">"class Foo:</span><span style="color: #AA5D1F; font-weight: bold">\n</span><span style="color: #BA2121">"</span>
        <span style="color: #BA2121">"    def a(self):</span><span style="color: #AA5D1F; font-weight: bold">\n</span><span style="color: #BA2121">"</span>
        <span style="color: #666666">+</span> <span style="color: #BA2121">"        x = 1</span><span style="color: #AA5D1F; font-weight: bold">\n</span><span style="color: #BA2121">"</span>
        <span style="color: #666666">+</span> <span style="color: #BA2121">"        x += 1</span><span style="color: #AA5D1F; font-weight: bold">\n</span><span style="color: #BA2121">"</span> <span style="color: #666666">*</span> <span style="color: #666666">5</span>
        <span style="color: #666666">+</span> <span style="color: #BA2121">"        return x</span><span style="color: #AA5D1F; font-weight: bold">\n\n</span><span style="color: #BA2121">"</span>
        <span style="color: #BA2121">"    def b(self):</span><span style="color: #AA5D1F; font-weight: bold">\n</span><span style="color: #BA2121">"</span>
        <span style="color: #666666">+</span> <span style="color: #BA2121">"        y = 1</span><span style="color: #AA5D1F; font-weight: bold">\n</span><span style="color: #BA2121">"</span>
        <span style="color: #666666">+</span> <span style="color: #BA2121">"        y += 1</span><span style="color: #AA5D1F; font-weight: bold">\n</span><span style="color: #BA2121">"</span> <span style="color: #666666">*</span> <span style="color: #666666">5</span>
        <span style="color: #666666">+</span> <span style="color: #BA2121">"        return y</span><span style="color: #AA5D1F; font-weight: bold">\n</span><span style="color: #BA2121">"</span>
    )
    file <span style="color: #666666">=</span> tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">"m.py"</span>
    file<span style="color: #666666">.</span>write_text(class_src)
    parsed <span style="color: #666666">=</span> parse_python_file(<span style="color: #008000">str</span>(file))

    tokenizer <span style="color: #666666">=</span> get_tokenizer()
    cache <span style="color: #666666">=</span> ResponseCache(<span style="color: #008000">str</span>(tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">"cache.json"</span>))

    <span style="color: #008000; font-weight: bold">with</span> patch(<span style="color: #BA2121">"docgenerator._summarize"</span>, return_value<span style="color: #666666">=</span><span style="color: #BA2121">"sum"</span>) <span style="color: #008000; font-weight: bold">as</span> mock_sum:
        mlen <span style="color: #666666">=</span> <span style="color: #008000">len</span>(tokenizer<span style="color: #666666">.</span>encode(parsed[<span style="color: #BA2121">"classes"</span>][<span style="color: #666666">0</span>][<span style="color: #BA2121">"methods"</span>][<span style="color: #666666">0</span>][<span style="color: #BA2121">"source"</span>]))
        budget <span style="color: #666666">=</span> mlen <span style="color: #666666">+</span> <span style="color: #666666">5</span>
        overhead <span style="color: #666666">=</span> <span style="color: #008000">len</span>(tokenizer<span style="color: #666666">.</span>encode(SYSTEM_PROMPT)) <span style="color: #666666">+</span> <span style="color: #008000">len</span>(tokenizer<span style="color: #666666">.</span>encode(PROMPT_TEMPLATES[<span style="color: #BA2121">"module"</span>]<span style="color: #666666">.</span>format(text<span style="color: #666666">=</span><span style="color: #BA2121">""</span>)))
        _summarize_module_chunked(
            client<span style="color: #666666">=</span><span style="color: #008000">object</span>(),
            cache<span style="color: #666666">=</span>cache,
            key_prefix<span style="color: #666666">=</span><span style="color: #BA2121">"k"</span>,
            module_text<span style="color: #666666">=</span>class_src,
            module<span style="color: #666666">=</span>parsed,
            tokenizer<span style="color: #666666">=</span>tokenizer,
            max_context_tokens<span style="color: #666666">=</span>overhead <span style="color: #666666">+</span> budget,
            chunk_token_budget<span style="color: #666666">=</span>budget,
        )

        chunks <span style="color: #666666">=</span> [c<span style="color: #666666">.</span>args[<span style="color: #666666">3</span>] <span style="color: #008000; font-weight: bold">for</span> c <span style="color: #AA22FF; font-weight: bold">in</span> mock_sum<span style="color: #666666">.</span>call_args_list <span style="color: #008000; font-weight: bold">if</span> c<span style="color: #666666">.</span>args[<span style="color: #666666">4</span>] <span style="color: #666666">==</span> <span style="color: #BA2121">"module"</span>]
        methods <span style="color: #666666">=</span> parsed[<span style="color: #BA2121">"classes"</span>][<span style="color: #666666">0</span>][<span style="color: #BA2121">"methods"</span>]
        method_sources <span style="color: #666666">=</span> {m[<span style="color: #BA2121">"source"</span>] <span style="color: #008000; font-weight: bold">for</span> m <span style="color: #AA22FF; font-weight: bold">in</span> methods}
        <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #008000">len</span>(chunks) <span style="color: #666666">==</span> <span style="color: #008000">len</span>(methods)
        <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #008000">set</span>(chunks) <span style="color: #666666">==</span> method_sources
</code></pre>
<h3 id="test_subclass_methods_are_summarized">test_subclass_methods_are_summarized(tmp_path: Path) -&gt; None</h3>
<p>The function `test_subclass_methods_are_summarized` tests that methods within nested classes (subclasses) are properly summarized during the documentation generation process. It creates a temporary project directory with a Python module containing a class `A` that includes a nested class `B`, which in turn contains a method `m`. The test mocks the `LLMClient` and summarization functions to simulate LLM interactions and verifies that the method `B:m` is included in the arguments passed to the chunked summarization function. The main execution flow is invoked with the project directory and output directory as command-line arguments, and the test asserts that the return code is zero, indicating successful execution. The assertion checks that the method name `B:m` appears in the arguments of at least one call to `_summarize_chunked`.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">test_subclass_methods_are_summarized</span>(tmp_path: Path) <span style="color: #666666">-&gt;</span> <span style="color: #008000; font-weight: bold">None</span>:
    project_dir <span style="color: #666666">=</span> tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">"proj"</span>
    project_dir<span style="color: #666666">.</span>mkdir()
    (project_dir <span style="color: #666666">/</span> <span style="color: #BA2121">"mod.py"</span>)<span style="color: #666666">.</span>write_text(
        <span style="color: #BA2121">"class A:</span><span style="color: #AA5D1F; font-weight: bold">\n</span><span style="color: #BA2121">    class B:</span><span style="color: #AA5D1F; font-weight: bold">\n</span><span style="color: #BA2121">        def m(self):</span><span style="color: #AA5D1F; font-weight: bold">\n</span><span style="color: #BA2121">            pass</span><span style="color: #AA5D1F; font-weight: bold">\n</span><span style="color: #BA2121">"</span>
    )

    output_dir <span style="color: #666666">=</span> tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">"docs"</span>

    <span style="color: #008000; font-weight: bold">with</span> patch(<span style="color: #BA2121">"docgenerator.LLMClient"</span>) <span style="color: #008000; font-weight: bold">as</span> MockClient, patch(
        <span style="color: #BA2121">"docgenerator._summarize"</span>,
        return_value<span style="color: #666666">=</span><span style="color: #BA2121">"summary"</span>,
    ), patch(
        <span style="color: #BA2121">"docgenerator._summarize_chunked"</span>,
        return_value<span style="color: #666666">=</span><span style="color: #BA2121">"summary"</span>,
    ) <span style="color: #008000; font-weight: bold">as</span> mock_chunk:
        instance <span style="color: #666666">=</span> MockClient<span style="color: #666666">.</span>return_value
        instance<span style="color: #666666">.</span>ping<span style="color: #666666">.</span>return_value <span style="color: #666666">=</span> <span style="color: #008000; font-weight: bold">True</span>
        ret <span style="color: #666666">=</span> main([<span style="color: #008000">str</span>(project_dir), <span style="color: #BA2121">"--output"</span>, <span style="color: #008000">str</span>(output_dir)])
        <span style="color: #008000; font-weight: bold">assert</span> ret <span style="color: #666666">==</span> <span style="color: #666666">0</span>

    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #008000">any</span>(<span style="color: #BA2121">"B:m"</span> <span style="color: #AA22FF; font-weight: bold">in</span> call<span style="color: #666666">.</span>args[<span style="color: #666666">2</span>] <span style="color: #008000; font-weight: bold">for</span> call <span style="color: #AA22FF; font-weight: bold">in</span> mock_chunk<span style="color: #666666">.</span>call_args_list)
</code></pre>
<h3 id="test_processes_cpp_file">test_processes_cpp_file(tmp_path: Path) -&gt; None</h3>
<p>The function `test_processes_cpp_file` tests the processing of a C++ source file within a temporary directory structure. It creates a project directory with a C++ file containing a simple function, then defines a mock parsed representation of the file's contents including a class with a variable. The test patches the C++ parser and LLM client to simulate successful parsing and summarization. It calls the main function with the project and output directories as arguments, asserts that the main function returns zero (indicating success), verifies that the parser was called once, and checks that the expected HTML output file is created.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">test_processes_cpp_file</span>(tmp_path: Path) <span style="color: #666666">-&gt;</span> <span style="color: #008000; font-weight: bold">None</span>:
    project_dir <span style="color: #666666">=</span> tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">"proj"</span>
    project_dir<span style="color: #666666">.</span>mkdir()
    (project_dir <span style="color: #666666">/</span> <span style="color: #BA2121">"mod.cpp"</span>)<span style="color: #666666">.</span>write_text(<span style="color: #BA2121">"int add(int a, int b) { return a + b; }</span><span style="color: #AA5D1F; font-weight: bold">\n</span><span style="color: #BA2121">"</span>)

    output_dir <span style="color: #666666">=</span> tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">"docs"</span>

    parsed <span style="color: #666666">=</span> {
        <span style="color: #BA2121">"module_docstring"</span>: <span style="color: #BA2121">""</span>,
        <span style="color: #BA2121">"classes"</span>: [
            {
                <span style="color: #BA2121">"name"</span>: <span style="color: #BA2121">"Foo"</span>,
                <span style="color: #BA2121">"docstring"</span>: <span style="color: #BA2121">""</span>,
                <span style="color: #BA2121">"methods"</span>: [],
                <span style="color: #BA2121">"variables"</span>: [{<span style="color: #BA2121">"name"</span>: <span style="color: #BA2121">"x"</span>, <span style="color: #BA2121">"docstring"</span>: <span style="color: #BA2121">""</span>, <span style="color: #BA2121">"source"</span>: <span style="color: #BA2121">"int x;"</span>}],
                <span style="color: #BA2121">"source"</span>: <span style="color: #BA2121">"class Foo { int x; };"</span>,
            }
        ],
        <span style="color: #BA2121">"functions"</span>: [],
    }

    <span style="color: #008000; font-weight: bold">with</span> patch(<span style="color: #BA2121">"docgenerator.parse_cpp_file"</span>, return_value<span style="color: #666666">=</span>parsed) <span style="color: #008000; font-weight: bold">as</span> mock_parse, patch(
        <span style="color: #BA2121">"docgenerator.LLMClient"</span>
    ) <span style="color: #008000; font-weight: bold">as</span> MockClient:
        instance <span style="color: #666666">=</span> MockClient<span style="color: #666666">.</span>return_value
        instance<span style="color: #666666">.</span>ping<span style="color: #666666">.</span>return_value <span style="color: #666666">=</span> <span style="color: #008000; font-weight: bold">True</span>
        instance<span style="color: #666666">.</span>summarize<span style="color: #666666">.</span>return_value <span style="color: #666666">=</span> <span style="color: #BA2121">"summary"</span>
        ret <span style="color: #666666">=</span> main([<span style="color: #008000">str</span>(project_dir), <span style="color: #BA2121">"--output"</span>, <span style="color: #008000">str</span>(output_dir)])
        <span style="color: #008000; font-weight: bold">assert</span> ret <span style="color: #666666">==</span> <span style="color: #666666">0</span>
        mock_parse<span style="color: #666666">.</span>assert_called_once()

    <span style="color: #008000; font-weight: bold">assert</span> (output_dir <span style="color: #666666">/</span> <span style="color: #BA2121">"mod.html"</span>)<span style="color: #666666">.</span>exists()
</code></pre>
<h3 id="test_processes_java_file">test_processes_java_file(tmp_path: Path) -&gt; None</h3>
<p>The function `test_processes_java_file` tests the processing of a Java source file within a temporary directory structure. It creates a Java class file named `Mod.java` containing a public class `Foo` with a variable and method. The test sets up mocked return values for `parse_java_file` and `LLMClient` to simulate parsing and summarization behavior. After invoking the main function with specified project and output directories, it verifies that the main function returns zero (indicating success), the parser was called once, and the expected HTML output file `Mod.html` is created in the output directory.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">test_processes_java_file</span>(tmp_path: Path) <span style="color: #666666">-&gt;</span> <span style="color: #008000; font-weight: bold">None</span>:
    project_dir <span style="color: #666666">=</span> tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">"proj"</span>
    project_dir<span style="color: #666666">.</span>mkdir()
    (project_dir <span style="color: #666666">/</span> <span style="color: #BA2121">"Mod.java"</span>)<span style="color: #666666">.</span>write_text(
        <span style="color: #BA2121">"public class Foo { public int x; public void bar() </span><span style="color: #A45A77; font-weight: bold">{}</span><span style="color: #BA2121"> }</span><span style="color: #AA5D1F; font-weight: bold">\n</span><span style="color: #BA2121">"</span>
    )

    output_dir <span style="color: #666666">=</span> tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">"docs"</span>

    parsed <span style="color: #666666">=</span> {
        <span style="color: #BA2121">"module_docstring"</span>: <span style="color: #BA2121">""</span>,
        <span style="color: #BA2121">"classes"</span>: [
            {
                <span style="color: #BA2121">"name"</span>: <span style="color: #BA2121">"Foo"</span>,
                <span style="color: #BA2121">"docstring"</span>: <span style="color: #BA2121">""</span>,
                <span style="color: #BA2121">"methods"</span>: [],
                <span style="color: #BA2121">"variables"</span>: [{<span style="color: #BA2121">"name"</span>: <span style="color: #BA2121">"x"</span>, <span style="color: #BA2121">"docstring"</span>: <span style="color: #BA2121">""</span>, <span style="color: #BA2121">"source"</span>: <span style="color: #BA2121">"public int x;"</span>}],
                <span style="color: #BA2121">"source"</span>: <span style="color: #BA2121">"public class Foo { public int x; }"</span>,
            }
        ],
        <span style="color: #BA2121">"functions"</span>: [],
    }

    <span style="color: #008000; font-weight: bold">with</span> patch(<span style="color: #BA2121">"docgenerator.parse_java_file"</span>, return_value<span style="color: #666666">=</span>parsed) <span style="color: #008000; font-weight: bold">as</span> mock_parse, patch(
        <span style="color: #BA2121">"docgenerator.LLMClient"</span>
    ) <span style="color: #008000; font-weight: bold">as</span> MockClient:
        instance <span style="color: #666666">=</span> MockClient<span style="color: #666666">.</span>return_value
        instance<span style="color: #666666">.</span>ping<span style="color: #666666">.</span>return_value <span style="color: #666666">=</span> <span style="color: #008000; font-weight: bold">True</span>
        instance<span style="color: #666666">.</span>summarize<span style="color: #666666">.</span>return_value <span style="color: #666666">=</span> <span style="color: #BA2121">"summary"</span>
        ret <span style="color: #666666">=</span> main([<span style="color: #008000">str</span>(project_dir), <span style="color: #BA2121">"--output"</span>, <span style="color: #008000">str</span>(output_dir)])
        <span style="color: #008000; font-weight: bold">assert</span> ret <span style="color: #666666">==</span> <span style="color: #666666">0</span>
        mock_parse<span style="color: #666666">.</span>assert_called_once()

    <span style="color: #008000; font-weight: bold">assert</span> (output_dir <span style="color: #666666">/</span> <span style="color: #BA2121">"Mod.html"</span>)<span style="color: #666666">.</span>exists()
</code></pre>
</main>
<footer aria-label="Page footer" class="page-footer"><p>Generated documentation</p></footer><script src="static/toggle.js"></script>
</body>
</html>
