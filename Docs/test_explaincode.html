<!-- Generated by DocGen-LM -->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>test_explaincode</title>
    <link rel="stylesheet" href="static/style.css">
</head>
<body>
    <button id="sidebar-toggle">Menu</button>
    <div class="sidebar">
        <h2>Navigation</h2>
        <ul>
        <li><a href="index.html"><strong>üè† Project Overview</strong></a></li>
<li><a href="cache.html">cache</a></li>
<li><a href="chunk_utils.html">chunk_utils</a></li>
<li><a href="docgenerator.html">docgenerator</a></li>
<li><a href="explaincode.html">explaincode</a></li>
<li><a href="gui_wrapper.html">gui_wrapper</a></li>
<li><a href="html_writer.html">html_writer</a></li>
<li><a href="llm_client.html">llm_client</a></li>
<li><a href="manual_utils.html">manual_utils</a></li>
<li><a href="parser_matlab.html">parser_matlab</a></li>
<li><a href="parser_python.html">parser_python</a></li>
<li><a href="reviewer.html">reviewer</a></li>
<li><a href="scanner.html">scanner</a></li>
<li><a href="setup.html">setup</a></li>
<li><a href="summarize_utils.html">summarize_utils</a></li>
<li><a href="test_cache.html">test_cache</a></li>
<li><a href="test_chunk_utils.html">test_chunk_utils</a></li>
<li><a href="test_docgenerator.html">test_docgenerator</a></li>
<li><a href="test_docgenerator_subclasses.html">test_docgenerator_subclasses</a></li>
<li><a href="test_explaincode.html">test_explaincode</a></li>
<li><a href="test_html_writer.html">test_html_writer</a></li>
<li><a href="test_integration.html">test_integration</a></li>
<li><a href="test_llm_client.html">test_llm_client</a></li>
<li><a href="test_manual_utils.html">test_manual_utils</a></li>
<li><a href="test_parser_matlab.html">test_parser_matlab</a></li>
<li><a href="test_parser_python.html">test_parser_python</a></li>
<li><a href="test_reviewer.html">test_reviewer</a></li>
<li><a href="test_scanner.html">test_scanner</a></li>
        </ul>
    </div>
    <div class="content">
        <h1>test_explaincode</h1>
        <p>The module defines several functions and tests for creating documentation summaries, extracting text from files, rendering HTML, and handling different file formats. It includes a fixture creation function `_create_fixture`, a mock language model client `_mock_llm_client`, and various test cases to ensure functionality across Markdown, HTML, and DOCX files. The module also handles the extraction of snippets, code scanning, and evidence mapping for documentation sections.

The module contains several test functions for a code documentation tool using `pytest` fixtures like `tmp_path`, `monkeypatch`, and `caplog`. It mocks various functions in the `explaincode` module to simulate different scenarios, such as collecting documentation, ranking files, extracting snippets, and interacting with an LLM client. The tests cover categorizing code snippets into sections, filling placeholders in a manual using evidence from code snippets, generating full documentation without scanning code if not needed, triggering code fallback when specific sections are missing, handling the `--no-code` and `--force-code` flags, customizing the title and filename of the output, inserting generated documentation into an existing index file, and ensuring proper insertion of the documentation into a root index file. The tests validate that the tool behaves as expected under various conditions, including mocking external dependencies and handling different user inputs and configurations.

Additionally, this module contains several test functions for a summarization process, each testing different aspects of the summarization logic, such as chunking, merging, caching, and handling system prompts.</p>
<h2>Functions</h2>
<h3 id="_create_fixture">_create_fixture(tmp_path: Path) -&gt; None</h3>
<p>The function `_create_fixture` creates a temporary directory structure and files for testing purposes. It generates a nested subdirectory with an HTML file and writes a README.md file containing structured content about the project, including sections for overview, purpose, problem solving, usage instructions, inputs, outputs, system requirements, and examples. Additionally, it creates a sample JSON file with some input data.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">_create_fixture</span>(tmp_path: Path) <span style="color: #666666">-&gt;</span> <span style="color: #008000; font-weight: bold">None</span>:
    nested <span style="color: #666666">=</span> tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;subdir&quot;</span> <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;nested&quot;</span>
    nested<span style="color: #666666">.</span>mkdir(parents<span style="color: #666666">=</span><span style="color: #008000; font-weight: bold">True</span>)
    (nested <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;page.html&quot;</span>)<span style="color: #666666">.</span>write_text(
        <span style="color: #BA2121">&quot;&lt;html&gt;&lt;body&gt;&lt;h1&gt;Overview&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;&quot;</span>, encoding<span style="color: #666666">=</span><span style="color: #BA2121">&quot;utf-8&quot;</span>
    )
    content <span style="color: #666666">=</span> textwrap<span style="color: #666666">.</span>dedent(
<span style="color: #bbbbbb">        </span><span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;</span>
<span style="color: #BA2121; font-style: italic">        # Overview</span>
<span style="color: #BA2121; font-style: italic">        Demo project</span>

<span style="color: #BA2121; font-style: italic">        # Purpose &amp; Problem Solving</span>
<span style="color: #BA2121; font-style: italic">        Solves a problem</span>

<span style="color: #BA2121; font-style: italic">        # How to Run</span>
<span style="color: #BA2121; font-style: italic">        Usage: run it</span>

<span style="color: #BA2121; font-style: italic">        # Inputs</span>
<span style="color: #BA2121; font-style: italic">        Input data</span>

<span style="color: #BA2121; font-style: italic">        # Outputs</span>
<span style="color: #BA2121; font-style: italic">        Output data</span>

<span style="color: #BA2121; font-style: italic">        # System Requirements</span>
<span style="color: #BA2121; font-style: italic">        None</span>

<span style="color: #BA2121; font-style: italic">        # Examples</span>
<span style="color: #BA2121; font-style: italic">        Example usage</span>
<span style="color: #BA2121; font-style: italic">        &quot;&quot;&quot;</span>
    )<span style="color: #666666">.</span>strip()
    (tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;README.md&quot;</span>)<span style="color: #666666">.</span>write_text(content, encoding<span style="color: #666666">=</span><span style="color: #BA2121">&quot;utf-8&quot;</span>)
    (tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;sample.json&quot;</span>)<span style="color: #666666">.</span>write_text(<span style="color: #BA2121">&quot;{</span><span style="color: #AA5D1F; font-weight: bold">\&quot;</span><span style="color: #BA2121">input</span><span style="color: #AA5D1F; font-weight: bold">\&quot;</span><span style="color: #BA2121">: </span><span style="color: #AA5D1F; font-weight: bold">\&quot;</span><span style="color: #BA2121">data</span><span style="color: #AA5D1F; font-weight: bold">\&quot;</span><span style="color: #BA2121">}&quot;</span>, encoding<span style="color: #666666">=</span><span style="color: #BA2121">&quot;utf-8&quot;</span>)
</code></pre>
<h3 id="_mock_llm_client">_mock_llm_client() -&gt; object</h3>
<p>The function `_mock_llm_client` returns an object that simulates a language model client. This mock client has a method `summarize` which takes three parameters: `text`, `prompt_type`, and an optional `system_prompt`. The `summarize` method returns a predefined string formatted using `textwrap.dedent`, providing a simple summary of the project, including its purpose, problem-solving approach, execution instructions, inputs, outputs, system requirements, and examples.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">_mock_llm_client</span>() <span style="color: #666666">-&gt;</span> <span style="color: #008000">object</span>:
    <span style="color: #008000; font-weight: bold">class</span> <span style="color: #0000FF; font-weight: bold">Dummy</span>:
        <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">summarize</span>(<span style="color: #008000">self</span>, text: <span style="color: #008000">str</span>, prompt_type: <span style="color: #008000">str</span>, system_prompt: <span style="color: #008000">str</span> <span style="color: #666666">=</span> <span style="color: #BA2121">&quot;&quot;</span>) <span style="color: #666666">-&gt;</span> <span style="color: #008000">str</span>:  <span style="color: #3D7B7B; font-style: italic"># pragma: no cover - simple stub</span>
            <span style="color: #008000; font-weight: bold">return</span> textwrap<span style="color: #666666">.</span>dedent(
<span style="color: #bbbbbb">                </span><span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;</span>
<span style="color: #BA2121; font-style: italic">                Overview: Demo project</span>
<span style="color: #BA2121; font-style: italic">                Purpose &amp; Problem Solving: Solves a problem</span>
<span style="color: #BA2121; font-style: italic">                How to Run: Execute it</span>
<span style="color: #BA2121; font-style: italic">                Inputs: Input data</span>
<span style="color: #BA2121; font-style: italic">                Outputs: Output data</span>
<span style="color: #BA2121; font-style: italic">                System Requirements: None</span>
<span style="color: #BA2121; font-style: italic">                Examples: Example usage</span>
<span style="color: #BA2121; font-style: italic">                &quot;&quot;&quot;</span>
            )<span style="color: #666666">.</span>strip()

    <span style="color: #008000; font-weight: bold">return</span> Dummy()
</code></pre>
<h3 id="test_extract_text_markdown_preserves_headings_and_code">test_extract_text_markdown_preserves_headings_and_code(tmp_path: Path) -&gt; None</h3>
<p>This function tests the `extract_text` method from the `explaincode` module to ensure it correctly preserves headings and code blocks when reading Markdown files. It creates a temporary Markdown file with a heading and a Python code block, then reads the content using `extract_text`. The test asserts that the extracted text contains the original heading and code block, verifying that the extraction process maintains the structure of the input Markdown file.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">test_extract_text_markdown_preserves_headings_and_code</span>(tmp_path: Path) <span style="color: #666666">-&gt;</span> <span style="color: #008000; font-weight: bold">None</span>:
    content <span style="color: #666666">=</span> <span style="color: #BA2121">&quot;&quot;&quot;</span>
<span style="color: #BA2121"># Title</span>

<span style="color: #BA2121">Text</span>

<span style="color: #BA2121">```python</span>
<span style="color: #BA2121">print(&#39;hi&#39;)</span>
<span style="color: #BA2121">```</span>
<span style="color: #BA2121">&quot;&quot;&quot;</span>
    md <span style="color: #666666">=</span> tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;readme.md&quot;</span>
    md<span style="color: #666666">.</span>write_text(content, encoding<span style="color: #666666">=</span><span style="color: #BA2121">&quot;utf-8&quot;</span>)
    text <span style="color: #666666">=</span> explaincode<span style="color: #666666">.</span>extract_text(md)
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #BA2121">&quot;# Title&quot;</span> <span style="color: #AA22FF; font-weight: bold">in</span> text
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #BA2121">&quot;```python&quot;</span> <span style="color: #AA22FF; font-weight: bold">in</span> text
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #BA2121">&quot;print(&#39;hi&#39;)&quot;</span> <span style="color: #AA22FF; font-weight: bold">in</span> text
</code></pre>
<h3 id="test_extract_text_html_preserves_headings_and_code">test_extract_text_html_preserves_headings_and_code(tmp_path: Path) -&gt; None</h3>
<p>The function `test_extract_text_html_preserves_headings_and_code` is designed to test the ability of a hypothetical `extract_text` function from the `explaincode` module to correctly extract and preserve headings (`&lt;h1&gt;`, `&lt;h2&gt;`) and code blocks (`&lt;pre&gt;&lt;code&gt;...&lt;/code&gt;&lt;/pre&gt;`) from HTML files. It uses a temporary file path provided by `tmp_path` to create an HTML file named &quot;page.html&quot; with specific content including headings and a code block. The function then reads this HTML file, extracts the text using the `extract_text` method, and asserts that the extracted text contains the preserved headings (`# Main`, `## Section`) and the code block (with triple backticks and the code `print(&#x27;hi&#x27;)`).</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">test_extract_text_html_preserves_headings_and_code</span>(tmp_path: Path) <span style="color: #666666">-&gt;</span> <span style="color: #008000; font-weight: bold">None</span>:
    html <span style="color: #666666">=</span> (
        <span style="color: #BA2121">&quot;&lt;html&gt;&lt;body&gt;&lt;h1&gt;Main&lt;/h1&gt;&lt;p&gt;Intro&lt;/p&gt;&quot;</span>
        <span style="color: #BA2121">&quot;&lt;h2&gt;Section&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;print(&#39;hi&#39;)&lt;/code&gt;&lt;/pre&gt;&lt;/body&gt;&lt;/html&gt;&quot;</span>
    )
    page <span style="color: #666666">=</span> tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;page.html&quot;</span>
    page<span style="color: #666666">.</span>write_text(html, encoding<span style="color: #666666">=</span><span style="color: #BA2121">&quot;utf-8&quot;</span>)
    text <span style="color: #666666">=</span> explaincode<span style="color: #666666">.</span>extract_text(page)
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #BA2121">&quot;# Main&quot;</span> <span style="color: #AA22FF; font-weight: bold">in</span> text
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #BA2121">&quot;## Section&quot;</span> <span style="color: #AA22FF; font-weight: bold">in</span> text
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #BA2121">&quot;```&quot;</span> <span style="color: #AA22FF; font-weight: bold">in</span> text <span style="color: #AA22FF; font-weight: bold">and</span> <span style="color: #BA2121">&quot;print(&#39;hi&#39;)&quot;</span> <span style="color: #AA22FF; font-weight: bold">in</span> text
</code></pre>
<h3 id="test_extract_text_docx_preserves_headings">test_extract_text_docx_preserves_headings(tmp_path: Path) -&gt; None</h3>
<p>The function `test_extract_text_docx_preserves_headings` is designed to test the ability of a hypothetical `explaincode` module to extract text from a DOCX file while preserving headings. It uses the `python-docx` library to create a sample DOCX document with a heading and a paragraph, saves it to a temporary directory, and then attempts to extract the text using the `extract_text` function from the `explaincode` module. The test asserts that the first line of the extracted text is &quot;# Title&quot;, indicating that the heading has been preserved, and that the text &quot;Text&quot; is present in the extracted content.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">test_extract_text_docx_preserves_headings</span>(tmp_path: Path) <span style="color: #666666">-&gt;</span> <span style="color: #008000; font-weight: bold">None</span>:
    <span style="color: #008000; font-weight: bold">try</span>:
        <span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">docx</span> <span style="color: #008000; font-weight: bold">import</span> Document
    <span style="color: #008000; font-weight: bold">except</span> <span style="color: #CB3F38; font-weight: bold">Exception</span>:  <span style="color: #3D7B7B; font-style: italic"># pragma: no cover - dependency missing</span>
        pytest<span style="color: #666666">.</span>skip(<span style="color: #BA2121">&quot;python-docx not installed&quot;</span>)

    doc <span style="color: #666666">=</span> Document()
    doc<span style="color: #666666">.</span>add_heading(<span style="color: #BA2121">&quot;Title&quot;</span>, level<span style="color: #666666">=1</span>)
    doc<span style="color: #666666">.</span>add_paragraph(<span style="color: #BA2121">&quot;Text&quot;</span>)
    path <span style="color: #666666">=</span> tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;doc.docx&quot;</span>
    doc<span style="color: #666666">.</span>save(path)
    text <span style="color: #666666">=</span> explaincode<span style="color: #666666">.</span>extract_text(path)
    <span style="color: #008000; font-weight: bold">assert</span> text<span style="color: #666666">.</span>splitlines()[<span style="color: #666666">0</span>] <span style="color: #666666">==</span> <span style="color: #BA2121">&quot;# Title&quot;</span>
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #BA2121">&quot;Text&quot;</span> <span style="color: #AA22FF; font-weight: bold">in</span> text
</code></pre>
<h3 id="test_render_html_renders_markdown_headings_and_code">test_render_html_renders_markdown_headings_and_code() -&gt; None</h3>
<p>The function `test_render_html_renders_markdown_headings_and_code` tests the `render_html` function from the `explaincode` module. It creates a dictionary of sections, where each section contains a Markdown heading followed by Python code. The function then renders these sections into HTML using `explaincode.render_html`. The rendered HTML is parsed using BeautifulSoup to check if the Markdown headings and code are correctly converted to HTML elements (`&lt;h1&gt;` for headings and `&lt;pre&gt;&lt;code&gt;` for code blocks). The assertions ensure that the title &quot;Title&quot; is present as an `&lt;h1&gt;` element and that the Python code `print(&#x27;hi&#x27;)` is included within a `&lt;code&gt;` block inside a `&lt;pre&gt;` tag.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">test_render_html_renders_markdown_headings_and_code</span>() <span style="color: #666666">-&gt;</span> <span style="color: #008000; font-weight: bold">None</span>:
    sections <span style="color: #666666">=</span> {
        <span style="color: #BA2121">&quot;Intro&quot;</span>: <span style="color: #BA2121">&quot;# Title</span><span style="color: #AA5D1F; font-weight: bold">\n\n</span><span style="color: #BA2121">```python</span><span style="color: #AA5D1F; font-weight: bold">\n</span><span style="color: #BA2121">print(&#39;hi&#39;)</span><span style="color: #AA5D1F; font-weight: bold">\n</span><span style="color: #BA2121">```&quot;</span>,
    }
    html <span style="color: #666666">=</span> explaincode<span style="color: #666666">.</span>render_html(sections, <span style="color: #BA2121">&quot;Manual&quot;</span>)
    soup <span style="color: #666666">=</span> BeautifulSoup(html, <span style="color: #BA2121">&quot;html.parser&quot;</span>)
    <span style="color: #008000; font-weight: bold">assert</span> soup<span style="color: #666666">.</span>find(<span style="color: #BA2121">&quot;h1&quot;</span>, string<span style="color: #666666">=</span><span style="color: #BA2121">&quot;Title&quot;</span>) <span style="color: #AA22FF; font-weight: bold">is</span> <span style="color: #AA22FF; font-weight: bold">not</span> <span style="color: #008000; font-weight: bold">None</span>
    code <span style="color: #666666">=</span> soup<span style="color: #666666">.</span>find(<span style="color: #BA2121">&quot;pre&quot;</span>)<span style="color: #666666">.</span>find(<span style="color: #BA2121">&quot;code&quot;</span>)
    <span style="color: #008000; font-weight: bold">assert</span> code <span style="color: #AA22FF; font-weight: bold">is</span> <span style="color: #AA22FF; font-weight: bold">not</span> <span style="color: #008000; font-weight: bold">None</span> <span style="color: #AA22FF; font-weight: bold">and</span> <span style="color: #BA2121">&quot;print(&#39;hi&#39;)&quot;</span> <span style="color: #AA22FF; font-weight: bold">in</span> code<span style="color: #666666">.</span>text
</code></pre>
<h3 id="test_render_html_includes_toc_and_sources_block">test_render_html_includes_toc_and_sources_block() -&gt; None</h3>
<p>This function `test_render_html_includes_toc_and_sources_block` is designed to test the rendering of HTML documentation by the `explaincode.render_html` function. It checks if the generated HTML includes a table of contents (TOC) and source code blocks.

The function starts by defining two sections, &quot;Overview&quot; and &quot;How to Run&quot;, each with empty content. It then creates evidence for these sections, specifying snippets from different files: &quot;info&quot; from &quot;readme.md&quot; and &quot;run&quot; from &quot;run.py&quot;.

Next, it calls `explaincode.render_html` with the sections and evidence to generate HTML output. The generated HTML is parsed using BeautifulSoup.

The function asserts that the HTML contains a `&lt;nav&gt;` element with an anchor (`&lt;a&gt;`) linking to the &quot;Overview&quot; section. It also checks for the presence of source code blocks (`&lt;div class=&quot;sources&quot;&gt;`) containing text from both &quot;readme.md&quot; and &quot;run.py&quot;.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">test_render_html_includes_toc_and_sources_block</span>() <span style="color: #666666">-&gt;</span> <span style="color: #008000; font-weight: bold">None</span>:
    sections <span style="color: #666666">=</span> {<span style="color: #BA2121">&quot;Overview&quot;</span>: <span style="color: #BA2121">&quot;&quot;</span>, <span style="color: #BA2121">&quot;How to Run&quot;</span>: <span style="color: #BA2121">&quot;&quot;</span>}
    evidence <span style="color: #666666">=</span> {
        <span style="color: #BA2121">&quot;Overview&quot;</span>: {<span style="color: #BA2121">&quot;evidence&quot;</span>: [{<span style="color: #BA2121">&quot;snippet&quot;</span>: <span style="color: #BA2121">&quot;info&quot;</span>, <span style="color: #BA2121">&quot;file&quot;</span>: <span style="color: #BA2121">&quot;readme.md&quot;</span>}]},
        <span style="color: #BA2121">&quot;How to Run&quot;</span>: {<span style="color: #BA2121">&quot;evidence&quot;</span>: [{<span style="color: #BA2121">&quot;snippet&quot;</span>: <span style="color: #BA2121">&quot;run&quot;</span>, <span style="color: #BA2121">&quot;file&quot;</span>: <span style="color: #BA2121">&quot;run.py&quot;</span>}]},
    }
    html <span style="color: #666666">=</span> explaincode<span style="color: #666666">.</span>render_html(sections, <span style="color: #BA2121">&quot;Manual&quot;</span>, evidence)
    soup <span style="color: #666666">=</span> BeautifulSoup(html, <span style="color: #BA2121">&quot;html.parser&quot;</span>)
    nav <span style="color: #666666">=</span> soup<span style="color: #666666">.</span>find(<span style="color: #BA2121">&quot;nav&quot;</span>)
    <span style="color: #008000; font-weight: bold">assert</span> nav <span style="color: #AA22FF; font-weight: bold">is</span> <span style="color: #AA22FF; font-weight: bold">not</span> <span style="color: #008000; font-weight: bold">None</span> <span style="color: #AA22FF; font-weight: bold">and</span> nav<span style="color: #666666">.</span>find(<span style="color: #BA2121">&quot;a&quot;</span>, href<span style="color: #666666">=</span><span style="color: #BA2121">&quot;#overview&quot;</span>) <span style="color: #AA22FF; font-weight: bold">is</span> <span style="color: #AA22FF; font-weight: bold">not</span> <span style="color: #008000; font-weight: bold">None</span>
    sources_blocks <span style="color: #666666">=</span> soup<span style="color: #666666">.</span>find_all(<span style="color: #BA2121">&quot;div&quot;</span>, class_<span style="color: #666666">=</span><span style="color: #BA2121">&quot;sources&quot;</span>)
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #008000">any</span>(<span style="color: #BA2121">&quot;readme.md&quot;</span> <span style="color: #AA22FF; font-weight: bold">in</span> block<span style="color: #666666">.</span>text <span style="color: #008000; font-weight: bold">for</span> block <span style="color: #AA22FF; font-weight: bold">in</span> sources_blocks)
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #008000">any</span>(<span style="color: #BA2121">&quot;run.py&quot;</span> <span style="color: #AA22FF; font-weight: bold">in</span> block<span style="color: #666666">.</span>text <span style="color: #008000; font-weight: bold">for</span> block <span style="color: #AA22FF; font-weight: bold">in</span> sources_blocks)
</code></pre>
<h3 id="test_html_summary_creation">test_html_summary_creation(tmp_path: Path, monkeypatch: pytest.MonkeyPatch) -&gt; None</h3>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">test_html_summary_creation</span>(tmp_path: Path, monkeypatch: pytest<span style="color: #666666">.</span>MonkeyPatch) <span style="color: #666666">-&gt;</span> <span style="color: #008000; font-weight: bold">None</span>:
    _create_fixture(tmp_path)
    monkeypatch<span style="color: #666666">.</span>setattr(explaincode, <span style="color: #BA2121">&quot;LLMClient&quot;</span>, _mock_llm_client)
    main([<span style="color: #BA2121">&quot;--path&quot;</span>, <span style="color: #008000">str</span>(tmp_path)])
    manual <span style="color: #666666">=</span> tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;user_manual.html&quot;</span>
    evidence <span style="color: #666666">=</span> tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;user_manual_evidence.json&quot;</span>
    <span style="color: #008000; font-weight: bold">assert</span> manual<span style="color: #666666">.</span>exists()
    <span style="color: #008000; font-weight: bold">assert</span> evidence<span style="color: #666666">.</span>exists()
    data <span style="color: #666666">=</span> json<span style="color: #666666">.</span>loads(evidence<span style="color: #666666">.</span>read_text(encoding<span style="color: #666666">=</span><span style="color: #BA2121">&quot;utf-8&quot;</span>))
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #BA2121">&quot;Overview&quot;</span> <span style="color: #AA22FF; font-weight: bold">in</span> data
    <span style="color: #008000; font-weight: bold">assert</span> data[<span style="color: #BA2121">&quot;Overview&quot;</span>][<span style="color: #BA2121">&quot;evidence&quot;</span>]
    html_text <span style="color: #666666">=</span> manual<span style="color: #666666">.</span>read_text(encoding<span style="color: #666666">=</span><span style="color: #BA2121">&quot;utf-8&quot;</span>)
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #BA2121">&quot;No information provided.&quot;</span> <span style="color: #AA22FF; font-weight: bold">not</span> <span style="color: #AA22FF; font-weight: bold">in</span> html_text
    soup <span style="color: #666666">=</span> BeautifulSoup(html_text, <span style="color: #BA2121">&quot;html.parser&quot;</span>)
    nav <span style="color: #666666">=</span> soup<span style="color: #666666">.</span>find(<span style="color: #BA2121">&quot;nav&quot;</span>)
    <span style="color: #008000; font-weight: bold">assert</span> nav <span style="color: #AA22FF; font-weight: bold">is</span> <span style="color: #AA22FF; font-weight: bold">not</span> <span style="color: #008000; font-weight: bold">None</span> <span style="color: #AA22FF; font-weight: bold">and</span> nav<span style="color: #666666">.</span>find(<span style="color: #BA2121">&quot;a&quot;</span>, href<span style="color: #666666">=</span><span style="color: #BA2121">&quot;#overview&quot;</span>) <span style="color: #AA22FF; font-weight: bold">is</span> <span style="color: #AA22FF; font-weight: bold">not</span> <span style="color: #008000; font-weight: bold">None</span>
</code></pre>
<h3 id="test_pdf_summary_creation">test_pdf_summary_creation(tmp_path: Path, monkeypatch: pytest.MonkeyPatch) -&gt; None</h3>
<p>This function `test_pdf_summary_creation` is designed to test the creation of a PDF summary for project documentation. It performs the following steps:

1. Checks if the `reportlab` package is installed. If not, it skips the test.
2. Creates a fixture using `_create_fixture` with the provided temporary path.
3. Mocks the `LLMClient` from the `explaincode` module using `_mock_llm_client`.
4. Calls the `main` function with specified arguments to generate documentation in PDF format.
5. Asserts that the generated PDF file (`user_manual.pdf`) and evidence JSON file (`user_manual_evidence.json`) exist in the temporary path.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">test_pdf_summary_creation</span>(tmp_path: Path, monkeypatch: pytest<span style="color: #666666">.</span>MonkeyPatch) <span style="color: #666666">-&gt;</span> <span style="color: #008000; font-weight: bold">None</span>:
    <span style="color: #008000; font-weight: bold">if</span> importlib<span style="color: #666666">.</span>util<span style="color: #666666">.</span>find_spec(<span style="color: #BA2121">&quot;reportlab&quot;</span>) <span style="color: #AA22FF; font-weight: bold">is</span> <span style="color: #008000; font-weight: bold">None</span>:
        pytest<span style="color: #666666">.</span>skip(<span style="color: #BA2121">&quot;reportlab not installed&quot;</span>)
    _create_fixture(tmp_path)
    monkeypatch<span style="color: #666666">.</span>setattr(explaincode, <span style="color: #BA2121">&quot;LLMClient&quot;</span>, _mock_llm_client)
    main([<span style="color: #BA2121">&quot;--path&quot;</span>, <span style="color: #008000">str</span>(tmp_path), <span style="color: #BA2121">&quot;--output-format&quot;</span>, <span style="color: #BA2121">&quot;pdf&quot;</span>])
    <span style="color: #008000; font-weight: bold">assert</span> (tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;user_manual.pdf&quot;</span>)<span style="color: #666666">.</span>exists()
    <span style="color: #008000; font-weight: bold">assert</span> (tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;user_manual_evidence.json&quot;</span>)<span style="color: #666666">.</span>exists()
</code></pre>
<h3 id="test_graceful_missing_docx">test_graceful_missing_docx(monkeypatch: pytest.MonkeyPatch, tmp_path: Path) -&gt; None</h3>
<p>The function `test_graceful_missing_docx` is a test case designed to verify the behavior of the `explaincode` module when the `python-docx` library, which is used for creating and manipulating Word documents, is not available. It uses the `monkeypatch` fixture from the `pytest` framework to temporarily replace the `Document` class with `None` and mock the `LLMClient`. The function then calls the `main` function with a specified path to generate documentation. Finally, it asserts that the output files for the user manual and evidence exist in the temporary directory.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">test_graceful_missing_docx</span>(monkeypatch: pytest<span style="color: #666666">.</span>MonkeyPatch, tmp_path: Path) <span style="color: #666666">-&gt;</span> <span style="color: #008000; font-weight: bold">None</span>:
    _create_fixture(tmp_path)
    <span style="color: #008000; font-weight: bold">try</span>:
        <span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">docx</span> <span style="color: #008000; font-weight: bold">import</span> Document
    <span style="color: #008000; font-weight: bold">except</span> <span style="color: #CB3F38; font-weight: bold">Exception</span>:  <span style="color: #3D7B7B; font-style: italic"># pragma: no cover - dependency missing</span>
        Document <span style="color: #666666">=</span> <span style="color: #008000; font-weight: bold">None</span>  <span style="color: #3D7B7B; font-style: italic"># type: ignore</span>
    <span style="color: #008000; font-weight: bold">if</span> Document:
        doc <span style="color: #666666">=</span> Document()
        doc<span style="color: #666666">.</span>add_paragraph(<span style="color: #BA2121">&quot;hi&quot;</span>)
        doc<span style="color: #666666">.</span>save(tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;guide.docx&quot;</span>)
    monkeypatch<span style="color: #666666">.</span>setattr(explaincode, <span style="color: #BA2121">&quot;Document&quot;</span>, <span style="color: #008000; font-weight: bold">None</span>)
    monkeypatch<span style="color: #666666">.</span>setattr(explaincode, <span style="color: #BA2121">&quot;LLMClient&quot;</span>, _mock_llm_client)
    main([<span style="color: #BA2121">&quot;--path&quot;</span>, <span style="color: #008000">str</span>(tmp_path)])
    <span style="color: #008000; font-weight: bold">assert</span> (tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;user_manual.html&quot;</span>)<span style="color: #666666">.</span>exists()
    <span style="color: #008000; font-weight: bold">assert</span> (tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;user_manual_evidence.json&quot;</span>)<span style="color: #666666">.</span>exists()
</code></pre>
<h3 id="test_custom_output_directory">test_custom_output_directory(tmp_path: Path, monkeypatch: pytest.MonkeyPatch) -&gt; None</h3>
<p>This function, `test_custom_output_directory`, is designed to test the functionality of generating documentation in a custom output directory. It uses a temporary path provided by `tmp_path` and a monkeypatch to mock an LLM client for testing purposes. The function creates a fixture using `_create_fixture`, sets up an output directory named &quot;dist&quot; within the temporary path, and then calls the `main` function with specified arguments to generate documentation. Finally, it asserts that two files, `user_manual.html` and `user_manual_evidence.json`, exist in the custom output directory, indicating successful documentation generation.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">test_custom_output_directory</span>(tmp_path: Path, monkeypatch: pytest<span style="color: #666666">.</span>MonkeyPatch) <span style="color: #666666">-&gt;</span> <span style="color: #008000; font-weight: bold">None</span>:
    _create_fixture(tmp_path)
    out_dir <span style="color: #666666">=</span> tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;dist&quot;</span>
    monkeypatch<span style="color: #666666">.</span>setattr(explaincode, <span style="color: #BA2121">&quot;LLMClient&quot;</span>, _mock_llm_client)
    main([<span style="color: #BA2121">&quot;--path&quot;</span>, <span style="color: #008000">str</span>(tmp_path), <span style="color: #BA2121">&quot;--output&quot;</span>, <span style="color: #008000">str</span>(out_dir)])
    <span style="color: #008000; font-weight: bold">assert</span> (out_dir <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;user_manual.html&quot;</span>)<span style="color: #666666">.</span>exists()
    <span style="color: #008000; font-weight: bold">assert</span> (out_dir <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;user_manual_evidence.json&quot;</span>)<span style="color: #666666">.</span>exists()
</code></pre>
<h3 id="test_collect_docs_filters">test_collect_docs_filters(tmp_path: Path) -&gt; None</h3>
<p>The function `test_collect_docs_filters` is designed to test the functionality of collecting documentation files while applying filters based on file extensions. It creates a temporary directory structure with various files, including Markdown and text files, some of which are intended to be kept and others skipped. The function then calls `explaincode.collect_docs` with this temporary path and asserts that only the files intended to be kept (those with `.md` extension) are collected, while those intended to be skipped (`.txt`) are not included in the result.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">test_collect_docs_filters</span>(tmp_path: Path) <span style="color: #666666">-&gt;</span> <span style="color: #008000; font-weight: bold">None</span>:
    (tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;docs&quot;</span>)<span style="color: #666666">.</span>mkdir()
    (tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;docs&quot;</span> <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;keep.md&quot;</span>)<span style="color: #666666">.</span>write_text(<span style="color: #BA2121">&quot;hi&quot;</span>, encoding<span style="color: #666666">=</span><span style="color: #BA2121">&quot;utf-8&quot;</span>)
    (tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;docs&quot;</span> <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;skip.txt&quot;</span>)<span style="color: #666666">.</span>write_text(<span style="color: #BA2121">&quot;no&quot;</span>, encoding<span style="color: #666666">=</span><span style="color: #BA2121">&quot;utf-8&quot;</span>)
    (tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;README.md&quot;</span>)<span style="color: #666666">.</span>write_text(<span style="color: #BA2121">&quot;readme&quot;</span>, encoding<span style="color: #666666">=</span><span style="color: #BA2121">&quot;utf-8&quot;</span>)
    (tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;extra.md&quot;</span>)<span style="color: #666666">.</span>write_text(<span style="color: #BA2121">&quot;extra&quot;</span>, encoding<span style="color: #666666">=</span><span style="color: #BA2121">&quot;utf-8&quot;</span>)
    files <span style="color: #666666">=</span> explaincode<span style="color: #666666">.</span>collect_docs(tmp_path)
    names <span style="color: #666666">=</span> {f<span style="color: #666666">.</span>name <span style="color: #008000; font-weight: bold">for</span> f <span style="color: #AA22FF; font-weight: bold">in</span> files}
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #BA2121">&quot;keep.md&quot;</span> <span style="color: #AA22FF; font-weight: bold">in</span> names <span style="color: #AA22FF; font-weight: bold">and</span> <span style="color: #BA2121">&quot;skip.txt&quot;</span> <span style="color: #AA22FF; font-weight: bold">not</span> <span style="color: #AA22FF; font-weight: bold">in</span> names
</code></pre>
<h3 id="test_map_evidence_overview_priority_and_filters">test_map_evidence_overview_priority_and_filters() -&gt; None</h3>
<p>This function, `test_map_evidence_overview_priority_and_filters`, tests the functionality of mapping evidence to sections within a documentation project. It uses a dictionary `docs` that simulates file paths and their corresponding content. The function calls `explaincode.map_evidence_to_sections(docs)` to map these files to sections based on their content.

The test checks if certain files are excluded from the &quot;Overview&quot; section, specifically those under the &quot;tests&quot;, &quot;examples&quot;, and &quot;fixtures&quot; directories. It also verifies that the first two files in the &quot;Overview&quot; section are &quot;README.md&quot; and &quot;docs/guide.md&quot;, and that the third file is &quot;src/other.md&quot;.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">test_map_evidence_overview_priority_and_filters</span>() <span style="color: #666666">-&gt;</span> <span style="color: #008000; font-weight: bold">None</span>:
    docs <span style="color: #666666">=</span> {
        Path(<span style="color: #BA2121">&quot;README.md&quot;</span>): <span style="color: #BA2121">&quot;# Overview</span><span style="color: #AA5D1F; font-weight: bold">\n</span><span style="color: #BA2121">readme info&quot;</span>,
        Path(<span style="color: #BA2121">&quot;docs/guide.md&quot;</span>): <span style="color: #BA2121">&quot;# Overview</span><span style="color: #AA5D1F; font-weight: bold">\n</span><span style="color: #BA2121">docs info&quot;</span>,
        Path(<span style="color: #BA2121">&quot;src/other.md&quot;</span>): <span style="color: #BA2121">&quot;# Overview</span><span style="color: #AA5D1F; font-weight: bold">\n</span><span style="color: #BA2121">other info&quot;</span>,
        Path(<span style="color: #BA2121">&quot;tests/ignore.md&quot;</span>): <span style="color: #BA2121">&quot;# Overview</span><span style="color: #AA5D1F; font-weight: bold">\n</span><span style="color: #BA2121">test info&quot;</span>,
        Path(<span style="color: #BA2121">&quot;examples/ignore.md&quot;</span>): <span style="color: #BA2121">&quot;# Overview</span><span style="color: #AA5D1F; font-weight: bold">\n</span><span style="color: #BA2121">example info&quot;</span>,
        Path(<span style="color: #BA2121">&quot;fixtures/ignore.md&quot;</span>): <span style="color: #BA2121">&quot;# Overview</span><span style="color: #AA5D1F; font-weight: bold">\n</span><span style="color: #BA2121">fixture info&quot;</span>,
    }
    section_map, _ <span style="color: #666666">=</span> explaincode<span style="color: #666666">.</span>map_evidence_to_sections(docs)
    sources <span style="color: #666666">=</span> [p<span style="color: #666666">.</span>as_posix() <span style="color: #008000; font-weight: bold">for</span> p, _ <span style="color: #AA22FF; font-weight: bold">in</span> section_map[<span style="color: #BA2121">&quot;Overview&quot;</span>]]
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #BA2121">&quot;tests/ignore.md&quot;</span> <span style="color: #AA22FF; font-weight: bold">not</span> <span style="color: #AA22FF; font-weight: bold">in</span> sources
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #BA2121">&quot;examples/ignore.md&quot;</span> <span style="color: #AA22FF; font-weight: bold">not</span> <span style="color: #AA22FF; font-weight: bold">in</span> sources
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #BA2121">&quot;fixtures/ignore.md&quot;</span> <span style="color: #AA22FF; font-weight: bold">not</span> <span style="color: #AA22FF; font-weight: bold">in</span> sources
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #008000">set</span>(sources[:<span style="color: #666666">2</span>]) <span style="color: #666666">==</span> {<span style="color: #BA2121">&quot;README.md&quot;</span>, <span style="color: #BA2121">&quot;docs/guide.md&quot;</span>}
    <span style="color: #008000; font-weight: bold">assert</span> sources[<span style="color: #666666">2</span>] <span style="color: #666666">==</span> <span style="color: #BA2121">&quot;src/other.md&quot;</span>
</code></pre>
<h3 id="test_map_evidence_snippet_limits">test_map_evidence_snippet_limits() -&gt; None</h3>
<p>This function tests the `map_evidence_to_sections` method from the `explaincode` module. It creates a dictionary of file paths and their corresponding content, where one file contains more lines than the specified maximum snippet length (`MAX_SNIPPET_LINES`). The function then maps evidence to sections and extracts snippets. The test asserts that lines outside the maximum snippet limit are not included in the snippets for the long file, while all lines up to the maximum limit are included. Additionally, it checks that the short file&#x27;s content is correctly mapped as a single section.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">test_map_evidence_snippet_limits</span>() <span style="color: #666666">-&gt;</span> <span style="color: #008000; font-weight: bold">None</span>:
    long_content <span style="color: #666666">=</span> <span style="color: #BA2121">&quot;# Inputs</span><span style="color: #AA5D1F; font-weight: bold">\n</span><span style="color: #BA2121">&quot;</span> <span style="color: #666666">+</span> <span style="color: #BA2121">&quot;</span><span style="color: #AA5D1F; font-weight: bold">\n</span><span style="color: #BA2121">&quot;</span><span style="color: #666666">.</span>join(
        <span style="color: #BA2121">f&quot;line </span><span style="color: #A45A77; font-weight: bold">{</span>i<span style="color: #A45A77; font-weight: bold">}</span><span style="color: #BA2121">&quot;</span> <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(<span style="color: #666666">1</span>, explaincode<span style="color: #666666">.</span>MAX_SNIPPET_LINES <span style="color: #666666">+</span> <span style="color: #666666">10</span>)
    )
    docs <span style="color: #666666">=</span> {
        Path(<span style="color: #BA2121">&quot;src/long.md&quot;</span>): long_content,
        Path(<span style="color: #BA2121">&quot;tests/short.md&quot;</span>): long_content,
    }
    section_map, _ <span style="color: #666666">=</span> explaincode<span style="color: #666666">.</span>map_evidence_to_sections(docs)
    snippets <span style="color: #666666">=</span> {p<span style="color: #666666">.</span>as_posix(): snip <span style="color: #008000; font-weight: bold">for</span> p, snip <span style="color: #AA22FF; font-weight: bold">in</span> section_map[<span style="color: #BA2121">&quot;Inputs&quot;</span>]}
    <span style="color: #008000; font-weight: bold">assert</span> (
        <span style="color: #BA2121">f&quot;line </span><span style="color: #A45A77; font-weight: bold">{</span>explaincode<span style="color: #666666">.</span>MAX_SNIPPET_LINES<span style="color: #bbbbbb"> </span><span style="color: #666666">+</span><span style="color: #bbbbbb"> </span><span style="color: #666666">1</span><span style="color: #A45A77; font-weight: bold">}</span><span style="color: #BA2121">&quot;</span> <span style="color: #AA22FF; font-weight: bold">not</span> <span style="color: #AA22FF; font-weight: bold">in</span> snippets[<span style="color: #BA2121">&quot;src/long.md&quot;</span>]
    )
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #BA2121">f&quot;line </span><span style="color: #A45A77; font-weight: bold">{</span>explaincode<span style="color: #666666">.</span>MAX_SNIPPET_LINES<span style="color: #A45A77; font-weight: bold">}</span><span style="color: #BA2121">&quot;</span> <span style="color: #AA22FF; font-weight: bold">in</span> snippets[<span style="color: #BA2121">&quot;src/long.md&quot;</span>]
    <span style="color: #008000; font-weight: bold">assert</span> snippets[<span style="color: #BA2121">&quot;tests/short.md&quot;</span>] <span style="color: #666666">==</span> <span style="color: #BA2121">&quot;# Inputs&quot;</span>
</code></pre>
<h3 id="test_detect_placeholders">test_detect_placeholders() -&gt; None</h3>
<p>The function `test_detect_placeholders` is designed to test the capability of detecting placeholders within a given text. It takes a string `text` as input, which contains placeholders in the format `[[NEEDS_XXX]]`. The function uses the `explaincode.detect_placeholders` method to identify these placeholders and returns a set of placeholder names found in the text. In this specific test case, the input text includes two placeholders: &quot;Overview&quot; and &quot;Outputs&quot;. The function asserts that the set of missing placeholders matches the expected set containing &quot;Overview&quot; and &quot;Outputs&quot;, indicating that the placeholder detection is working as intended.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">test_detect_placeholders</span>() <span style="color: #666666">-&gt;</span> <span style="color: #008000; font-weight: bold">None</span>:
    text <span style="color: #666666">=</span> <span style="color: #BA2121">&quot;Overview: [[NEEDS_OVERVIEW]]</span><span style="color: #AA5D1F; font-weight: bold">\n</span><span style="color: #BA2121">Inputs: data</span><span style="color: #AA5D1F; font-weight: bold">\n</span><span style="color: #BA2121">Outputs: [[NEEDS_OUTPUTS]]&quot;</span>
    missing <span style="color: #666666">=</span> explaincode<span style="color: #666666">.</span>detect_placeholders(text)
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #008000">set</span>(missing) <span style="color: #666666">==</span> {<span style="color: #BA2121">&quot;Overview&quot;</span>, <span style="color: #BA2121">&quot;Outputs&quot;</span>}
</code></pre>
<h3 id="test_parse_manual_infers_missing_sections">test_parse_manual_infers_missing_sections() -&gt; None</h3>
<p>This function tests the `parse_manual` function from the `explaincode` module. It uses a stub class to simulate the behavior of a language model client, which provides a summary for a given prompt. The test checks if the `Overview` section is correctly parsed and if the `Inputs` section is inferred when no information is provided.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">test_parse_manual_infers_missing_sections</span>() <span style="color: #666666">-&gt;</span> <span style="color: #008000; font-weight: bold">None</span>:
    <span style="color: #008000; font-weight: bold">class</span> <span style="color: #0000FF; font-weight: bold">Stub</span>:
        <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">summarize</span>(<span style="color: #008000">self</span>, prompt: <span style="color: #008000">str</span>, prompt_type: <span style="color: #008000">str</span>, system_prompt: <span style="color: #008000">str</span> <span style="color: #666666">=</span> <span style="color: #BA2121">&quot;&quot;</span>) <span style="color: #666666">-&gt;</span> <span style="color: #008000">str</span>:
            <span style="color: #008000; font-weight: bold">return</span> <span style="color: #BA2121">&quot;guessed&quot;</span>

    client <span style="color: #666666">=</span> Stub()
    parsed <span style="color: #666666">=</span> explaincode<span style="color: #666666">.</span>parse_manual(<span style="color: #BA2121">&quot;Overview: hi&quot;</span>, client<span style="color: #666666">=</span>client)
    <span style="color: #008000; font-weight: bold">assert</span> parsed[<span style="color: #BA2121">&quot;Overview&quot;</span>] <span style="color: #666666">==</span> <span style="color: #BA2121">&quot;hi&quot;</span>
    <span style="color: #008000; font-weight: bold">assert</span> parsed[<span style="color: #BA2121">&quot;Inputs&quot;</span>]<span style="color: #666666">.</span>endswith(<span style="color: #BA2121">&quot;(inferred)&quot;</span>)
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #BA2121">&quot;No information provided.&quot;</span> <span style="color: #AA22FF; font-weight: bold">not</span> <span style="color: #AA22FF; font-weight: bold">in</span> parsed[<span style="color: #BA2121">&quot;Inputs&quot;</span>]
</code></pre>
<h3 id="test_validate_manual_references_flags_missing">test_validate_manual_references_flags_missing(tmp_path: Path) -&gt; None</h3>
<p>This function tests the validation of manual references within project documentation. It creates a temporary directory with a Python file named `exists.py` containing a simple pass statement. The function then defines a dictionary `sections` with an &quot;Overview&quot; section that refers to both `exists.py` and another non-existent file `missing.py`. An empty dictionary `evidence` is also provided.

The function calls `explaincode.validate_manual_references` with the `sections`, `tmp_path`, and `evidence` as arguments. After execution, it asserts that:
1. The &quot;Overview&quot; section now includes a reference to `exists.py`.
2. The &quot;Overview&quot; section includes a reference to `missing.py` with a &quot;[missing]&quot; tag.
3. The `evidence` dictionary contains a list of missing references under the key `missing_references`, specifically including `missing.py`.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">test_validate_manual_references_flags_missing</span>(tmp_path: Path) <span style="color: #666666">-&gt;</span> <span style="color: #008000; font-weight: bold">None</span>:
    (tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;exists.py&quot;</span>)<span style="color: #666666">.</span>write_text(<span style="color: #BA2121">&quot;pass&quot;</span>, encoding<span style="color: #666666">=</span><span style="color: #BA2121">&quot;utf-8&quot;</span>)
    sections <span style="color: #666666">=</span> {<span style="color: #BA2121">&quot;Overview&quot;</span>: <span style="color: #BA2121">&quot;See exists.py and missing.py for details&quot;</span>}
    evidence: <span style="color: #008000">dict</span>[<span style="color: #008000">str</span>, <span style="color: #008000">dict</span>[<span style="color: #008000">str</span>, <span style="color: #008000">object</span>]] <span style="color: #666666">=</span> {}
    explaincode<span style="color: #666666">.</span>validate_manual_references(sections, tmp_path, evidence)
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #BA2121">&quot;exists.py&quot;</span> <span style="color: #AA22FF; font-weight: bold">in</span> sections[<span style="color: #BA2121">&quot;Overview&quot;</span>]
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #BA2121">&quot;missing.py [missing]&quot;</span> <span style="color: #AA22FF; font-weight: bold">in</span> sections[<span style="color: #BA2121">&quot;Overview&quot;</span>]
    <span style="color: #008000; font-weight: bold">assert</span> evidence[<span style="color: #BA2121">&quot;Overview&quot;</span>][<span style="color: #BA2121">&quot;missing_references&quot;</span>] <span style="color: #666666">==</span> [<span style="color: #BA2121">&quot;missing.py&quot;</span>]
</code></pre>
<h3 id="test_infer_sections_infers_entries">test_infer_sections_infers_entries() -&gt; None</h3>
<p>The function `test_infer_sections_infers_entries` tests the `infer_sections` function from the `explaincode` module. It asserts that the returned dictionary contains an &quot;Overview&quot; key with the value &quot;Some context&quot;. For all other keys defined in `REQUIRED_SECTIONS`, it checks that their values end with &quot;(inferred)&quot;. Finally, it ensures that the string &quot;No information provided.&quot; is not present in any of the section values combined.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">test_infer_sections_infers_entries</span>() <span style="color: #666666">-&gt;</span> <span style="color: #008000; font-weight: bold">None</span>:
    sections <span style="color: #666666">=</span> explaincode<span style="color: #666666">.</span>infer_sections(<span style="color: #BA2121">&quot;Some context&quot;</span>)
    <span style="color: #008000; font-weight: bold">assert</span> sections[<span style="color: #BA2121">&quot;Overview&quot;</span>] <span style="color: #666666">==</span> <span style="color: #BA2121">&quot;Some context&quot;</span>
    <span style="color: #008000; font-weight: bold">for</span> key <span style="color: #AA22FF; font-weight: bold">in</span> explaincode<span style="color: #666666">.</span>REQUIRED_SECTIONS:
        <span style="color: #008000; font-weight: bold">if</span> key <span style="color: #666666">!=</span> <span style="color: #BA2121">&quot;Overview&quot;</span>:
            <span style="color: #008000; font-weight: bold">assert</span> sections[key]<span style="color: #666666">.</span>endswith(<span style="color: #BA2121">&quot;(inferred)&quot;</span>)
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #BA2121">&quot;No information provided.&quot;</span> <span style="color: #AA22FF; font-weight: bold">not</span> <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #BA2121">&quot;&quot;</span><span style="color: #666666">.</span>join(sections<span style="color: #666666">.</span>values())
</code></pre>
<h3 id="test_infer_sections_no_context_defaults">test_infer_sections_no_context_defaults() -&gt; None</h3>
<p>The function `test_infer_sections_no_context_defaults` is designed to test the behavior of a hypothetical module named `explaincode` when it attempts to infer sections from an empty string. The function asserts that if no context is provided (i.e., an empty string is passed), all values in the returned dictionary `sections` are equal to &quot;No information provided.&quot;</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">test_infer_sections_no_context_defaults</span>() <span style="color: #666666">-&gt;</span> <span style="color: #008000; font-weight: bold">None</span>:
    sections <span style="color: #666666">=</span> explaincode<span style="color: #666666">.</span>infer_sections(<span style="color: #BA2121">&quot;&quot;</span>)
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #008000">all</span>(v <span style="color: #666666">==</span> <span style="color: #BA2121">&quot;No information provided.&quot;</span> <span style="color: #008000; font-weight: bold">for</span> v <span style="color: #AA22FF; font-weight: bold">in</span> sections<span style="color: #666666">.</span>values())
</code></pre>
<h3 id="test_extract_snippets_skips_large_file">test_extract_snippets_skips_large_file(tmp_path: Path, caplog: pytest.LogCaptureFixture) -&gt; None</h3>
<p>This function tests the `extract_snippets` function from the `explaincode` module. It creates a temporary file named &quot;big.py&quot; with 210,000 bytes of data. The function is called with this file as input, setting a maximum file size limit of 200,000 bytes and a time budget of 5 seconds. The test asserts that the big file is not included in the snippets returned by the function. Additionally, it checks that an informational log message indicating the file size exceeds the limit is present in the captured logs.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">test_extract_snippets_skips_large_file</span>(
    tmp_path: Path, caplog: pytest<span style="color: #666666">.</span>LogCaptureFixture
) <span style="color: #666666">-&gt;</span> <span style="color: #008000; font-weight: bold">None</span>:
    big_file <span style="color: #666666">=</span> tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;big.py&quot;</span>
    big_file<span style="color: #666666">.</span>write_bytes(<span style="color: #BA2121">b&quot;a&quot;</span> <span style="color: #666666">*</span> <span style="color: #666666">210_000</span>)
    caplog<span style="color: #666666">.</span>set_level(logging<span style="color: #666666">.</span>INFO)
    snippets <span style="color: #666666">=</span> explaincode<span style="color: #666666">.</span>extract_snippets(
        [big_file], max_files<span style="color: #666666">=1</span>, time_budget<span style="color: #666666">=5</span>, max_bytes<span style="color: #666666">=200_000</span>
    )
    <span style="color: #008000; font-weight: bold">assert</span> big_file <span style="color: #AA22FF; font-weight: bold">not</span> <span style="color: #AA22FF; font-weight: bold">in</span> snippets
    log <span style="color: #666666">=</span> caplog<span style="color: #666666">.</span>text
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #BA2121">&quot;file size&quot;</span> <span style="color: #AA22FF; font-weight: bold">in</span> log <span style="color: #AA22FF; font-weight: bold">and</span> <span style="color: #BA2121">&quot;exceeds limit&quot;</span> <span style="color: #AA22FF; font-weight: bold">in</span> log
</code></pre>
<h3 id="test_scan_code_skips_non_source_dirs">test_scan_code_skips_non_source_dirs(tmp_path: Path, monkeypatch: pytest.MonkeyPatch) -&gt; None</h3>
<p>This function `test_scan_code_skips_non_source_dirs` is designed to test the behavior of a code scanning utility, specifically focusing on its ability to skip non-source directories during the scan process. The function uses a temporary directory structure with subdirectories for source files (`src`), tests (`tests`), and examples (`examples`). It writes Python scripts into these directories.

The `monkeypatch.setattr` is used to mock the `collect_docs` function from the `explaincode` module, which is presumably responsible for collecting documentation. The mocked function returns an empty list, indicating that no documentation should be collected.

The `scan_code` function is then called with parameters specifying the temporary path, a title (&quot;How to Run&quot;), and various limits on file handling. The function is expected to scan the directories and collect relevant source files.

The test asserts that after scanning, only the `src/main.py` file is included in the result under the &quot;How to Run&quot; key, indicating that non-source directories (`tests` and `examples`) were skipped during the scan process.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">test_scan_code_skips_non_source_dirs</span>(
    tmp_path: Path, monkeypatch: pytest<span style="color: #666666">.</span>MonkeyPatch
) <span style="color: #666666">-&gt;</span> <span style="color: #008000; font-weight: bold">None</span>:
    src <span style="color: #666666">=</span> tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;src&quot;</span>
    src<span style="color: #666666">.</span>mkdir()
    (src <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;main.py&quot;</span>)<span style="color: #666666">.</span>write_text(<span style="color: #BA2121">&#39;&quot;&quot;&quot;run code&quot;&quot;&quot;&#39;</span>, encoding<span style="color: #666666">=</span><span style="color: #BA2121">&quot;utf-8&quot;</span>)

    tests_dir <span style="color: #666666">=</span> tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;tests&quot;</span>
    tests_dir<span style="color: #666666">.</span>mkdir()
    (tests_dir <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;test_main.py&quot;</span>)<span style="color: #666666">.</span>write_text(<span style="color: #BA2121">&#39;&quot;&quot;&quot;run tests&quot;&quot;&quot;&#39;</span>, encoding<span style="color: #666666">=</span><span style="color: #BA2121">&quot;utf-8&quot;</span>)

    examples_dir <span style="color: #666666">=</span> tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;examples&quot;</span>
    examples_dir<span style="color: #666666">.</span>mkdir()
    (examples_dir <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;example.py&quot;</span>)<span style="color: #666666">.</span>write_text(<span style="color: #BA2121">&#39;&quot;&quot;&quot;run example&quot;&quot;&quot;&#39;</span>, encoding<span style="color: #666666">=</span><span style="color: #BA2121">&quot;utf-8&quot;</span>)

    monkeypatch<span style="color: #666666">.</span>setattr(explaincode, <span style="color: #BA2121">&quot;collect_docs&quot;</span>, <span style="color: #008000; font-weight: bold">lambda</span> base: [])
    result <span style="color: #666666">=</span> explaincode<span style="color: #666666">.</span>scan_code(
        tmp_path, [<span style="color: #BA2121">&quot;How to Run&quot;</span>], max_files<span style="color: #666666">=5</span>, time_budget<span style="color: #666666">=5</span>, max_bytes_per_file<span style="color: #666666">=1000</span>
    )

    how_to_run <span style="color: #666666">=</span> result<span style="color: #666666">.</span>get(<span style="color: #BA2121">&quot;How to Run&quot;</span>, {})
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #008000">set</span>(how_to_run<span style="color: #666666">.</span>keys()) <span style="color: #666666">==</span> {<span style="color: #BA2121">&quot;src/main.py&quot;</span>}
</code></pre>
<h3 id="test_scan_code_categorizes_snippets">test_scan_code_categorizes_snippets(tmp_path: Path, monkeypatch: pytest.MonkeyPatch) -&gt; None</h3>
<p>The function `test_scan_code_categorizes_snippets` is a test case designed to verify that the `explaincode.scan_code` function correctly categorizes code snippets based on specified patterns. It uses temporary files and monkeypatching to simulate the behavior of the `collect_docs`, `rank_code_files`, and `extract_snippets` functions from the `explaincode` module.

The test creates three empty Python files in a temporary directory and sets up mock implementations for the mentioned functions. The `fake_extract` function returns predefined snippets categorized as &quot;Inputs&quot;, &quot;Outputs&quot;, and &quot;How to Run&quot;. When `explaincode.scan_code` is called with these patterns, it should return a dictionary where each key corresponds to a category and the value is another dictionary mapping file paths to their respective snippets.

The assertions in the test case check that the function correctly categorizes the snippets as expected.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">test_scan_code_categorizes_snippets</span>(
    tmp_path: Path, monkeypatch: pytest<span style="color: #666666">.</span>MonkeyPatch
) <span style="color: #666666">-&gt;</span> <span style="color: #008000; font-weight: bold">None</span>:
    paths <span style="color: #666666">=</span> [tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;a.py&quot;</span>, tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;b.py&quot;</span>, tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;c.py&quot;</span>]
    <span style="color: #008000; font-weight: bold">for</span> p <span style="color: #AA22FF; font-weight: bold">in</span> paths:
        p<span style="color: #666666">.</span>write_text(<span style="color: #BA2121">&quot;&quot;</span>, encoding<span style="color: #666666">=</span><span style="color: #BA2121">&quot;utf-8&quot;</span>)

    monkeypatch<span style="color: #666666">.</span>setattr(explaincode, <span style="color: #BA2121">&quot;collect_docs&quot;</span>, <span style="color: #008000; font-weight: bold">lambda</span> base: [])
    monkeypatch<span style="color: #666666">.</span>setattr(explaincode, <span style="color: #BA2121">&quot;rank_code_files&quot;</span>, <span style="color: #008000; font-weight: bold">lambda</span> base, patterns: paths)

    <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">fake_extract</span>(
        files: Iterable[Path], <span style="color: #666666">*</span>, max_files: <span style="color: #008000">int</span>, time_budget: <span style="color: #008000">int</span>, max_bytes: <span style="color: #008000">int</span>
    ) <span style="color: #666666">-&gt;</span> <span style="color: #008000">dict</span>[Path, <span style="color: #008000">str</span>]:
        <span style="color: #008000; font-weight: bold">return</span> {
            paths[<span style="color: #666666">0</span>]: <span style="color: #BA2121">&quot;read input from user&quot;</span>,
            paths[<span style="color: #666666">1</span>]: <span style="color: #BA2121">&quot;write output&quot;</span>,
            paths[<span style="color: #666666">2</span>]: <span style="color: #BA2121">&quot;run the tool&quot;</span>,
        }

    monkeypatch<span style="color: #666666">.</span>setattr(explaincode, <span style="color: #BA2121">&quot;extract_snippets&quot;</span>, fake_extract)

    result <span style="color: #666666">=</span> explaincode<span style="color: #666666">.</span>scan_code(
        tmp_path, [<span style="color: #BA2121">&quot;Inputs&quot;</span>, <span style="color: #BA2121">&quot;Outputs&quot;</span>, <span style="color: #BA2121">&quot;How to Run&quot;</span>], max_files<span style="color: #666666">=3</span>, time_budget<span style="color: #666666">=5</span>, max_bytes_per_file<span style="color: #666666">=1000</span>
    )
    <span style="color: #008000; font-weight: bold">assert</span> result[<span style="color: #BA2121">&quot;Inputs&quot;</span>] <span style="color: #666666">==</span> {<span style="color: #BA2121">&quot;a.py&quot;</span>: <span style="color: #BA2121">&quot;read input from user&quot;</span>}
    <span style="color: #008000; font-weight: bold">assert</span> result[<span style="color: #BA2121">&quot;Outputs&quot;</span>] <span style="color: #666666">==</span> {<span style="color: #BA2121">&quot;b.py&quot;</span>: <span style="color: #BA2121">&quot;write output&quot;</span>}
    <span style="color: #008000; font-weight: bold">assert</span> result[<span style="color: #BA2121">&quot;How to Run&quot;</span>] <span style="color: #666666">==</span> {<span style="color: #BA2121">&quot;c.py&quot;</span>: <span style="color: #BA2121">&quot;run the tool&quot;</span>}
</code></pre>
<details>
<summary>Subfunction: fake_extract(files: Iterable[Path], *, max_files: int, time_budget: int, max_bytes: int) -&gt; dict[Path, str]</summary>
<h4 id="fake_extract">fake_extract(files: Iterable[Path], *, max_files: int, time_budget: int, max_bytes: int) -&gt; dict[Path, str]</h4>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">fake_extract</span>(
        files: Iterable[Path], <span style="color: #666666">*</span>, max_files: <span style="color: #008000">int</span>, time_budget: <span style="color: #008000">int</span>, max_bytes: <span style="color: #008000">int</span>
    ) <span style="color: #666666">-&gt;</span> <span style="color: #008000">dict</span>[Path, <span style="color: #008000">str</span>]:
        <span style="color: #008000; font-weight: bold">return</span> {
            paths[<span style="color: #666666">0</span>]: <span style="color: #BA2121">&quot;read input from user&quot;</span>,
            paths[<span style="color: #666666">1</span>]: <span style="color: #BA2121">&quot;write output&quot;</span>,
            paths[<span style="color: #666666">2</span>]: <span style="color: #BA2121">&quot;run the tool&quot;</span>,
        }
</code></pre>
</details>
<h3 id="test_llm_fill_placeholders_per_section_logging">test_llm_fill_placeholders_per_section_logging(tmp_path: Path, caplog: pytest.LogCaptureFixture) -&gt; None</h3>
<p>This function `test_llm_fill_placeholders_per_section_logging` is designed to test the functionality of filling placeholders in a manual string with evidence from a dictionary. It uses a dummy class `Dummy` that simulates an LLM client, which summarizes text and replaces placeholders based on section names. The function also uses a response cache and logs the process using `pytest.LogCaptureFixture`. The test asserts that the placeholders are correctly filled and that the logging captures the correct file references used to fill each placeholder.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">test_llm_fill_placeholders_per_section_logging</span>(
    tmp_path: Path, caplog: pytest<span style="color: #666666">.</span>LogCaptureFixture
) <span style="color: #666666">-&gt;</span> <span style="color: #008000; font-weight: bold">None</span>:
    manual <span style="color: #666666">=</span> <span style="color: #BA2121">&quot;Inputs: [[NEEDS_INPUTS]]</span><span style="color: #AA5D1F; font-weight: bold">\n</span><span style="color: #BA2121">Outputs: [[NEEDS_OUTPUTS]]&quot;</span>
    evidence <span style="color: #666666">=</span> {
        <span style="color: #BA2121">&quot;Inputs&quot;</span>: {<span style="color: #BA2121">&quot;in.py&quot;</span>: <span style="color: #BA2121">&quot;input data&quot;</span>},
        <span style="color: #BA2121">&quot;Outputs&quot;</span>: {<span style="color: #BA2121">&quot;out.py&quot;</span>: <span style="color: #BA2121">&quot;output data&quot;</span>},
    }

    <span style="color: #008000; font-weight: bold">class</span> <span style="color: #0000FF; font-weight: bold">Dummy</span>:
        <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">__init__</span>(<span style="color: #008000">self</span>) <span style="color: #666666">-&gt;</span> <span style="color: #008000; font-weight: bold">None</span>:
            <span style="color: #008000">self</span><span style="color: #666666">.</span>calls: <span style="color: #008000">list</span>[<span style="color: #008000">str</span>] <span style="color: #666666">=</span> []

        <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">summarize</span>(
            <span style="color: #008000">self</span>, text: <span style="color: #008000">str</span>, prompt_type: <span style="color: #008000">str</span>, system_prompt: <span style="color: #008000">str</span> <span style="color: #666666">=</span> <span style="color: #BA2121">&quot;&quot;</span>
        ) <span style="color: #666666">-&gt;</span> <span style="color: #008000">str</span>:
            <span style="color: #008000">self</span><span style="color: #666666">.</span>calls<span style="color: #666666">.</span>append(text)
            manual_match <span style="color: #666666">=</span> re<span style="color: #666666">.</span>search(<span style="color: #BA2121">r&quot;Manual:\n(.*?)\n\nSection:&quot;</span>, text, re<span style="color: #666666">.</span>DOTALL)
            section_match <span style="color: #666666">=</span> re<span style="color: #666666">.</span>search(<span style="color: #BA2121">r&quot;Section: (.*?)\n&quot;</span>, text)
            manual_text <span style="color: #666666">=</span> manual_match<span style="color: #666666">.</span>group(<span style="color: #666666">1</span>)
            section <span style="color: #666666">=</span> section_match<span style="color: #666666">.</span>group(<span style="color: #666666">1</span>)
            token <span style="color: #666666">=</span> explaincode<span style="color: #666666">.</span>SECTION_PLACEHOLDERS[section]
            <span style="color: #008000; font-weight: bold">return</span> manual_text<span style="color: #666666">.</span>replace(token, <span style="color: #BA2121">f&quot;filled </span><span style="color: #A45A77; font-weight: bold">{</span>section<span style="color: #A45A77; font-weight: bold">}</span><span style="color: #BA2121">&quot;</span>)

    client <span style="color: #666666">=</span> Dummy()
    cache <span style="color: #666666">=</span> ResponseCache(<span style="color: #008000">str</span>(tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;cache.json&quot;</span>))
    caplog<span style="color: #666666">.</span>set_level(logging<span style="color: #666666">.</span>INFO)
    result <span style="color: #666666">=</span> explaincode<span style="color: #666666">.</span>llm_fill_placeholders(manual, evidence, client, cache)
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #BA2121">&quot;filled Inputs&quot;</span> <span style="color: #AA22FF; font-weight: bold">in</span> result <span style="color: #AA22FF; font-weight: bold">and</span> <span style="color: #BA2121">&quot;filled Outputs&quot;</span> <span style="color: #AA22FF; font-weight: bold">in</span> result
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #008000">len</span>(client<span style="color: #666666">.</span>calls) <span style="color: #666666">==</span> <span style="color: #666666">2</span>
    log <span style="color: #666666">=</span> caplog<span style="color: #666666">.</span>text
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #BA2121">&quot;Filled Inputs using code from: in.py&quot;</span> <span style="color: #AA22FF; font-weight: bold">in</span> log
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #BA2121">&quot;Filled Outputs using code from: out.py&quot;</span> <span style="color: #AA22FF; font-weight: bold">in</span> log
</code></pre>
<h3 id="test_full_docs_no_code_scan">test_full_docs_no_code_scan(tmp_path: Path, monkeypatch: pytest.MonkeyPatch, caplog: pytest.LogCaptureFixture) -&gt; None</h3>
<p>The function `test_full_docs_no_code_scan` is a unit test for a documentation generation process. It uses the `pytest` framework and mocks several functions from the `explaincode` module to simulate the behavior of the actual code during testing.

Here&#x27;s what the function does:

1. **Setup**:
- Creates a temporary directory using `tmp_path`.
- Initializes a tracker dictionary to keep track of how many times certain functions are called.
- Defines two mock functions: `fake_rank` and `fake_extract`. These mocks increment the tracker values and return predefined results.

2. **Monkeypatching**:
- Replaces the actual implementations of `LLMClient`, `rank_code_files`, and `extract_snippets` with the mock functions using `monkeypatch`.

3. **Logging Configuration**:
- Sets the logging level to `INFO` for capturing log messages during the test.

4. **Test Execution**:
- Calls the `main` function with specific arguments (`--path` pointing to the temporary directory and `--scan-code-if-needed`).
- Asserts that the `fake_rank` and `fake_extract` functions were not called, indicating that the code scan was skipped.
- Verifies that the log output contains the strings &quot;DOC PASS&quot; and &quot;Code scan skipped&quot;, confirming that the test passed without performing a code scan.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">test_full_docs_no_code_scan</span>(
    tmp_path: Path, monkeypatch: pytest<span style="color: #666666">.</span>MonkeyPatch, caplog: pytest<span style="color: #666666">.</span>LogCaptureFixture
) <span style="color: #666666">-&gt;</span> <span style="color: #008000; font-weight: bold">None</span>:
    _create_fixture(tmp_path)
    tracker <span style="color: #666666">=</span> {<span style="color: #BA2121">&quot;rank&quot;</span>: <span style="color: #666666">0</span>, <span style="color: #BA2121">&quot;extract&quot;</span>: <span style="color: #666666">0</span>}

    <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">fake_rank</span>(root: Path, patterns: <span style="color: #008000">list</span>[<span style="color: #008000">str</span>]) <span style="color: #666666">-&gt;</span> <span style="color: #008000">list</span>[Path]:
        tracker[<span style="color: #BA2121">&quot;rank&quot;</span>] <span style="color: #666666">+=</span> <span style="color: #666666">1</span>
        <span style="color: #008000; font-weight: bold">return</span> [tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;a.py&quot;</span>]

    <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">fake_extract</span>(
        files: Iterable[Path], <span style="color: #666666">*</span>, max_files: <span style="color: #008000">int</span>, time_budget: <span style="color: #008000">int</span>, max_bytes: <span style="color: #008000">int</span>
    ) <span style="color: #666666">-&gt;</span> <span style="color: #008000">dict</span>[Path, <span style="color: #008000">str</span>]:
        tracker[<span style="color: #BA2121">&quot;extract&quot;</span>] <span style="color: #666666">+=</span> <span style="color: #666666">1</span>
        <span style="color: #008000; font-weight: bold">return</span> {}

    monkeypatch<span style="color: #666666">.</span>setattr(explaincode, <span style="color: #BA2121">&quot;LLMClient&quot;</span>, _mock_llm_client)
    monkeypatch<span style="color: #666666">.</span>setattr(explaincode, <span style="color: #BA2121">&quot;rank_code_files&quot;</span>, fake_rank)
    monkeypatch<span style="color: #666666">.</span>setattr(explaincode, <span style="color: #BA2121">&quot;extract_snippets&quot;</span>, fake_extract)

    caplog<span style="color: #666666">.</span>set_level(logging<span style="color: #666666">.</span>INFO)
    main([<span style="color: #BA2121">&quot;--path&quot;</span>, <span style="color: #008000">str</span>(tmp_path), <span style="color: #BA2121">&quot;--scan-code-if-needed&quot;</span>])
    <span style="color: #008000; font-weight: bold">assert</span> tracker[<span style="color: #BA2121">&quot;rank&quot;</span>] <span style="color: #666666">==</span> <span style="color: #666666">0</span>
    <span style="color: #008000; font-weight: bold">assert</span> tracker[<span style="color: #BA2121">&quot;extract&quot;</span>] <span style="color: #666666">==</span> <span style="color: #666666">0</span>
    log <span style="color: #666666">=</span> caplog<span style="color: #666666">.</span>text
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #BA2121">&quot;DOC PASS&quot;</span> <span style="color: #AA22FF; font-weight: bold">in</span> log
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #BA2121">&quot;Code scan skipped&quot;</span> <span style="color: #AA22FF; font-weight: bold">in</span> log
</code></pre>
<details>
<summary>Subfunction: fake_rank(root: Path, patterns: list[str]) -&gt; list[Path]</summary>
<h4 id="fake_rank">fake_rank(root: Path, patterns: list[str]) -&gt; list[Path]</h4>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">fake_rank</span>(root: Path, patterns: <span style="color: #008000">list</span>[<span style="color: #008000">str</span>]) <span style="color: #666666">-&gt;</span> <span style="color: #008000">list</span>[Path]:
        tracker[<span style="color: #BA2121">&quot;rank&quot;</span>] <span style="color: #666666">+=</span> <span style="color: #666666">1</span>
        <span style="color: #008000; font-weight: bold">return</span> [tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;a.py&quot;</span>]
</code></pre>
</details>
<details>
<summary>Subfunction: fake_extract(files: Iterable[Path], *, max_files: int, time_budget: int, max_bytes: int) -&gt; dict[Path, str]</summary>
<h4 id="fake_extract">fake_extract(files: Iterable[Path], *, max_files: int, time_budget: int, max_bytes: int) -&gt; dict[Path, str]</h4>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">fake_extract</span>(
        files: Iterable[Path], <span style="color: #666666">*</span>, max_files: <span style="color: #008000">int</span>, time_budget: <span style="color: #008000">int</span>, max_bytes: <span style="color: #008000">int</span>
    ) <span style="color: #666666">-&gt;</span> <span style="color: #008000">dict</span>[Path, <span style="color: #008000">str</span>]:
        tracker[<span style="color: #BA2121">&quot;extract&quot;</span>] <span style="color: #666666">+=</span> <span style="color: #666666">1</span>
        <span style="color: #008000; font-weight: bold">return</span> {}
</code></pre>
</details>
<h3 id="test_missing_run_triggers_code_fallback_with_limits">test_missing_run_triggers_code_fallback_with_limits(tmp_path: Path, monkeypatch: pytest.MonkeyPatch, caplog: pytest.LogCaptureFixture) -&gt; None</h3>
<p>This function, `test_missing_run_triggers_code_fallback_with_limits`, tests the behavior of a documentation generation system when certain sections are missing. It uses a temporary directory (`tmp_path`) and a mock object (`Dummy`) to simulate the behavior of language model interactions and code extraction. The test ensures that if the &quot;How to Run&quot; section is missing, it falls back to using code snippets for instructions. The function also checks that the system correctly handles limits on the number of files and time budget during code extraction.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">test_missing_run_triggers_code_fallback_with_limits</span>(
    tmp_path: Path, monkeypatch: pytest<span style="color: #666666">.</span>MonkeyPatch, caplog: pytest<span style="color: #666666">.</span>LogCaptureFixture
) <span style="color: #666666">-&gt;</span> <span style="color: #008000; font-weight: bold">None</span>:
    (tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;README.md&quot;</span>)<span style="color: #666666">.</span>write_text(<span style="color: #BA2121">&quot;Only overview&quot;</span>, encoding<span style="color: #666666">=</span><span style="color: #BA2121">&quot;utf-8&quot;</span>)

    <span style="color: #008000; font-weight: bold">class</span> <span style="color: #0000FF; font-weight: bold">Dummy</span>:
        <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">summarize</span>(<span style="color: #008000">self</span>, text: <span style="color: #008000">str</span>, prompt_type: <span style="color: #008000">str</span>, system_prompt: <span style="color: #008000">str</span> <span style="color: #666666">=</span> <span style="color: #BA2121">&quot;&quot;</span>) <span style="color: #666666">-&gt;</span> <span style="color: #008000">str</span>:
            <span style="color: #008000; font-weight: bold">if</span> <span style="color: #BA2121">&quot;How to Run&quot;</span> <span style="color: #AA22FF; font-weight: bold">in</span> system_prompt:
                <span style="color: #008000; font-weight: bold">return</span> <span style="color: #BA2121">&quot;[[NEEDS_RUN_INSTRUCTIONS]]&quot;</span>
            <span style="color: #008000; font-weight: bold">if</span> <span style="color: #BA2121">&quot;enhancing a user manual&quot;</span> <span style="color: #AA22FF; font-weight: bold">in</span> system_prompt:
                manual_match <span style="color: #666666">=</span> re<span style="color: #666666">.</span>search(<span style="color: #BA2121">r&quot;Manual:\n(.*?)\n\nSection:&quot;</span>, text, re<span style="color: #666666">.</span>DOTALL)
                manual_text <span style="color: #666666">=</span> manual_match<span style="color: #666666">.</span>group(<span style="color: #666666">1</span>)
                <span style="color: #008000; font-weight: bold">return</span> manual_text<span style="color: #666666">.</span>replace(<span style="color: #BA2121">&quot;[[NEEDS_RUN_INSTRUCTIONS]]&quot;</span>, <span style="color: #BA2121">&quot;use it&quot;</span>)
            <span style="color: #008000; font-weight: bold">return</span> <span style="color: #BA2121">&quot;x&quot;</span>

    paths <span style="color: #666666">=</span> [tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">f&quot;f</span><span style="color: #A45A77; font-weight: bold">{</span>i<span style="color: #A45A77; font-weight: bold">}</span><span style="color: #BA2121">.py&quot;</span> <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(<span style="color: #666666">3</span>)]
    tracker: <span style="color: #008000">dict</span>[<span style="color: #008000">str</span>, <span style="color: #008000">object</span>] <span style="color: #666666">=</span> {<span style="color: #BA2121">&quot;rank&quot;</span>: <span style="color: #666666">0</span>, <span style="color: #BA2121">&quot;extract&quot;</span>: <span style="color: #666666">0</span>}

    <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">fake_rank</span>(root: Path, patterns: <span style="color: #008000">list</span>[<span style="color: #008000">str</span>]) <span style="color: #666666">-&gt;</span> <span style="color: #008000">list</span>[Path]:
        tracker[<span style="color: #BA2121">&quot;rank&quot;</span>] <span style="color: #666666">+=</span> <span style="color: #666666">1</span>
        <span style="color: #008000; font-weight: bold">return</span> paths

    <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">fake_extract</span>(
        files: Iterable[Path], <span style="color: #666666">*</span>, max_files: <span style="color: #008000">int</span>, time_budget: <span style="color: #008000">int</span>, max_bytes: <span style="color: #008000">int</span>
    ) <span style="color: #666666">-&gt;</span> <span style="color: #008000">dict</span>[Path, <span style="color: #008000">str</span>]:
        tracker[<span style="color: #BA2121">&quot;extract&quot;</span>] <span style="color: #666666">+=</span> <span style="color: #666666">1</span>
        lst <span style="color: #666666">=</span> <span style="color: #008000">list</span>(files)
        tracker[<span style="color: #BA2121">&quot;kwargs&quot;</span>] <span style="color: #666666">=</span> {<span style="color: #BA2121">&quot;max_files&quot;</span>: max_files, <span style="color: #BA2121">&quot;time_budget&quot;</span>: time_budget}
        tracker[<span style="color: #BA2121">&quot;scanned&quot;</span>] <span style="color: #666666">=</span> lst[:max_files]
        <span style="color: #008000; font-weight: bold">return</span> {p: <span style="color: #BA2121">&quot;run code&quot;</span> <span style="color: #008000; font-weight: bold">for</span> p <span style="color: #AA22FF; font-weight: bold">in</span> lst[:max_files]}

    monkeypatch<span style="color: #666666">.</span>setattr(explaincode, <span style="color: #BA2121">&quot;LLMClient&quot;</span>, <span style="color: #008000; font-weight: bold">lambda</span>: Dummy())
    monkeypatch<span style="color: #666666">.</span>setattr(explaincode, <span style="color: #BA2121">&quot;rank_code_files&quot;</span>, fake_rank)
    monkeypatch<span style="color: #666666">.</span>setattr(explaincode, <span style="color: #BA2121">&quot;extract_snippets&quot;</span>, fake_extract)

    caplog<span style="color: #666666">.</span>set_level(logging<span style="color: #666666">.</span>INFO)
    main(
        [
            <span style="color: #BA2121">&quot;--path&quot;</span>,
            <span style="color: #008000">str</span>(tmp_path),
            <span style="color: #BA2121">&quot;--scan-code-if-needed&quot;</span>,
            <span style="color: #BA2121">&quot;--max-code-files&quot;</span>,
            <span style="color: #BA2121">&quot;1&quot;</span>,
            <span style="color: #BA2121">&quot;--code-time-budget-seconds&quot;</span>,
            <span style="color: #BA2121">&quot;5&quot;</span>,
        ]
    )
    html <span style="color: #666666">=</span> (tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;user_manual.html&quot;</span>)<span style="color: #666666">.</span>read_text(encoding<span style="color: #666666">=</span><span style="color: #BA2121">&quot;utf-8&quot;</span>)
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #BA2121">&quot;NEEDS_RUN_INSTRUCTIONS&quot;</span> <span style="color: #AA22FF; font-weight: bold">not</span> <span style="color: #AA22FF; font-weight: bold">in</span> html
    <span style="color: #008000; font-weight: bold">assert</span> tracker[<span style="color: #BA2121">&quot;rank&quot;</span>] <span style="color: #666666">==</span> <span style="color: #666666">1</span>
    <span style="color: #008000; font-weight: bold">assert</span> tracker[<span style="color: #BA2121">&quot;extract&quot;</span>] <span style="color: #666666">==</span> <span style="color: #666666">1</span>
    <span style="color: #008000; font-weight: bold">assert</span> tracker[<span style="color: #BA2121">&quot;kwargs&quot;</span>] <span style="color: #666666">==</span> {<span style="color: #BA2121">&quot;max_files&quot;</span>: <span style="color: #666666">1</span>, <span style="color: #BA2121">&quot;time_budget&quot;</span>: <span style="color: #666666">5</span>}
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #008000">len</span>(tracker[<span style="color: #BA2121">&quot;scanned&quot;</span>]) <span style="color: #666666">==</span> <span style="color: #666666">1</span>
    log <span style="color: #666666">=</span> caplog<span style="color: #666666">.</span>text
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #BA2121">&quot;Pass 1 missing sections&quot;</span> <span style="color: #AA22FF; font-weight: bold">in</span> log
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #BA2121">&quot;How to Run&quot;</span> <span style="color: #AA22FF; font-weight: bold">in</span> log
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #BA2121">&quot;Filled How to Run using code from: f0.py&quot;</span> <span style="color: #AA22FF; font-weight: bold">in</span> log
</code></pre>
<details>
<summary>Subfunction: fake_rank(root: Path, patterns: list[str]) -&gt; list[Path]</summary>
<h4 id="fake_rank">fake_rank(root: Path, patterns: list[str]) -&gt; list[Path]</h4>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">fake_rank</span>(root: Path, patterns: <span style="color: #008000">list</span>[<span style="color: #008000">str</span>]) <span style="color: #666666">-&gt;</span> <span style="color: #008000">list</span>[Path]:
        tracker[<span style="color: #BA2121">&quot;rank&quot;</span>] <span style="color: #666666">+=</span> <span style="color: #666666">1</span>
        <span style="color: #008000; font-weight: bold">return</span> paths
</code></pre>
</details>
<details>
<summary>Subfunction: fake_extract(files: Iterable[Path], *, max_files: int, time_budget: int, max_bytes: int) -&gt; dict[Path, str]</summary>
<h4 id="fake_extract">fake_extract(files: Iterable[Path], *, max_files: int, time_budget: int, max_bytes: int) -&gt; dict[Path, str]</h4>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">fake_extract</span>(
        files: Iterable[Path], <span style="color: #666666">*</span>, max_files: <span style="color: #008000">int</span>, time_budget: <span style="color: #008000">int</span>, max_bytes: <span style="color: #008000">int</span>
    ) <span style="color: #666666">-&gt;</span> <span style="color: #008000">dict</span>[Path, <span style="color: #008000">str</span>]:
        tracker[<span style="color: #BA2121">&quot;extract&quot;</span>] <span style="color: #666666">+=</span> <span style="color: #666666">1</span>
        lst <span style="color: #666666">=</span> <span style="color: #008000">list</span>(files)
        tracker[<span style="color: #BA2121">&quot;kwargs&quot;</span>] <span style="color: #666666">=</span> {<span style="color: #BA2121">&quot;max_files&quot;</span>: max_files, <span style="color: #BA2121">&quot;time_budget&quot;</span>: time_budget}
        tracker[<span style="color: #BA2121">&quot;scanned&quot;</span>] <span style="color: #666666">=</span> lst[:max_files]
        <span style="color: #008000; font-weight: bold">return</span> {p: <span style="color: #BA2121">&quot;run code&quot;</span> <span style="color: #008000; font-weight: bold">for</span> p <span style="color: #AA22FF; font-weight: bold">in</span> lst[:max_files]}
</code></pre>
</details>
<h3 id="test_no_code_flag_skips_code_fallback">test_no_code_flag_skips_code_fallback(tmp_path: Path, monkeypatch: pytest.MonkeyPatch, caplog: pytest.LogCaptureFixture) -&gt; None</h3>
<p>This function `test_no_code_flag_skips_code_fallback` is a test case for the `main` function, which generates documentation. The test checks that when the `--no-code` flag is provided, the code scanning and summarization processes are skipped. It sets up a temporary directory with a README file, mocks the necessary functions to simulate the behavior of the `explaincode` module, and uses `monkeypatch` to replace these functions with dummy implementations that do not perform any actual work. The test then calls the `main` function with the `--no-code` flag and verifies that the code scanning and summarization processes are indeed skipped by checking the values in a tracker dictionary and the log output.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">test_no_code_flag_skips_code_fallback</span>(
    tmp_path: Path, monkeypatch: pytest<span style="color: #666666">.</span>MonkeyPatch, caplog: pytest<span style="color: #666666">.</span>LogCaptureFixture
) <span style="color: #666666">-&gt;</span> <span style="color: #008000; font-weight: bold">None</span>:
    (tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;README.md&quot;</span>)<span style="color: #666666">.</span>write_text(<span style="color: #BA2121">&quot;Only overview&quot;</span>, encoding<span style="color: #666666">=</span><span style="color: #BA2121">&quot;utf-8&quot;</span>)

    <span style="color: #008000; font-weight: bold">class</span> <span style="color: #0000FF; font-weight: bold">Dummy</span>:
        <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">summarize</span>(
            <span style="color: #008000">self</span>, text: <span style="color: #008000">str</span>, prompt_type: <span style="color: #008000">str</span>, system_prompt: <span style="color: #008000">str</span> <span style="color: #666666">=</span> <span style="color: #BA2121">&quot;&quot;</span>
        ) <span style="color: #666666">-&gt;</span> <span style="color: #008000">str</span>:
            <span style="color: #008000; font-weight: bold">return</span> <span style="color: #BA2121">&quot;Overview: x</span><span style="color: #AA5D1F; font-weight: bold">\\</span><span style="color: #BA2121">nHow to Run: [[NEEDS_RUN_INSTRUCTIONS]]&quot;</span>

    tracker <span style="color: #666666">=</span> {<span style="color: #BA2121">&quot;rank&quot;</span>: <span style="color: #666666">0</span>, <span style="color: #BA2121">&quot;extract&quot;</span>: <span style="color: #666666">0</span>}

    <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">fake_rank</span>(root: Path, patterns: <span style="color: #008000">list</span>[<span style="color: #008000">str</span>]) <span style="color: #666666">-&gt;</span> <span style="color: #008000">list</span>[Path]:
        tracker[<span style="color: #BA2121">&quot;rank&quot;</span>] <span style="color: #666666">+=</span> <span style="color: #666666">1</span>
        <span style="color: #008000; font-weight: bold">return</span> []

    <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">fake_extract</span>(
        files: Iterable[Path], <span style="color: #666666">*</span>, max_files: <span style="color: #008000">int</span>, time_budget: <span style="color: #008000">int</span>, max_bytes: <span style="color: #008000">int</span>
    ) <span style="color: #666666">-&gt;</span> <span style="color: #008000">dict</span>[Path, <span style="color: #008000">str</span>]:
        tracker[<span style="color: #BA2121">&quot;extract&quot;</span>] <span style="color: #666666">+=</span> <span style="color: #666666">1</span>
        <span style="color: #008000; font-weight: bold">return</span> {}

    monkeypatch<span style="color: #666666">.</span>setattr(explaincode, <span style="color: #BA2121">&quot;LLMClient&quot;</span>, <span style="color: #008000; font-weight: bold">lambda</span>: Dummy())
    monkeypatch<span style="color: #666666">.</span>setattr(explaincode, <span style="color: #BA2121">&quot;rank_code_files&quot;</span>, fake_rank)
    monkeypatch<span style="color: #666666">.</span>setattr(explaincode, <span style="color: #BA2121">&quot;extract_snippets&quot;</span>, fake_extract)

    caplog<span style="color: #666666">.</span>set_level(logging<span style="color: #666666">.</span>INFO)
    main([<span style="color: #BA2121">&quot;--path&quot;</span>, <span style="color: #008000">str</span>(tmp_path), <span style="color: #BA2121">&quot;--scan-code-if-needed&quot;</span>, <span style="color: #BA2121">&quot;--no-code&quot;</span>])
    <span style="color: #008000; font-weight: bold">assert</span> tracker[<span style="color: #BA2121">&quot;rank&quot;</span>] <span style="color: #666666">==</span> <span style="color: #666666">0</span>
    <span style="color: #008000; font-weight: bold">assert</span> tracker[<span style="color: #BA2121">&quot;extract&quot;</span>] <span style="color: #666666">==</span> <span style="color: #666666">0</span>
    log <span style="color: #666666">=</span> caplog<span style="color: #666666">.</span>text
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #BA2121">&quot;Code scan skipped: --no-code specified&quot;</span> <span style="color: #AA22FF; font-weight: bold">in</span> log
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #BA2121">&quot;How to Run&quot;</span> <span style="color: #AA22FF; font-weight: bold">in</span> log
</code></pre>
<details>
<summary>Subfunction: fake_rank(root: Path, patterns: list[str]) -&gt; list[Path]</summary>
<h4 id="fake_rank">fake_rank(root: Path, patterns: list[str]) -&gt; list[Path]</h4>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">fake_rank</span>(root: Path, patterns: <span style="color: #008000">list</span>[<span style="color: #008000">str</span>]) <span style="color: #666666">-&gt;</span> <span style="color: #008000">list</span>[Path]:
        tracker[<span style="color: #BA2121">&quot;rank&quot;</span>] <span style="color: #666666">+=</span> <span style="color: #666666">1</span>
        <span style="color: #008000; font-weight: bold">return</span> []
</code></pre>
</details>
<details>
<summary>Subfunction: fake_extract(files: Iterable[Path], *, max_files: int, time_budget: int, max_bytes: int) -&gt; dict[Path, str]</summary>
<h4 id="fake_extract">fake_extract(files: Iterable[Path], *, max_files: int, time_budget: int, max_bytes: int) -&gt; dict[Path, str]</h4>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">fake_extract</span>(
        files: Iterable[Path], <span style="color: #666666">*</span>, max_files: <span style="color: #008000">int</span>, time_budget: <span style="color: #008000">int</span>, max_bytes: <span style="color: #008000">int</span>
    ) <span style="color: #666666">-&gt;</span> <span style="color: #008000">dict</span>[Path, <span style="color: #008000">str</span>]:
        tracker[<span style="color: #BA2121">&quot;extract&quot;</span>] <span style="color: #666666">+=</span> <span style="color: #666666">1</span>
        <span style="color: #008000; font-weight: bold">return</span> {}
</code></pre>
</details>
<h3 id="test_force_code_flag_triggers_code_fallback">test_force_code_flag_triggers_code_fallback(tmp_path: Path, monkeypatch: pytest.MonkeyPatch, caplog: pytest.LogCaptureFixture) -&gt; None</h3>
<p>This function `test_force_code_flag_triggers_code_fallback` is designed to test the behavior of a documentation generation tool when the `--force-code` flag is used. It sets up a temporary directory, mocks certain functions from the `explaincode` module, and then runs the main function with the specified path and force code flag. The test checks that the mocked functions are called once each, logs the appropriate messages indicating that the code scan was triggered and that no sections were missing, and asserts that the expected log messages are present in the captured output.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">test_force_code_flag_triggers_code_fallback</span>(
    tmp_path: Path, monkeypatch: pytest<span style="color: #666666">.</span>MonkeyPatch, caplog: pytest<span style="color: #666666">.</span>LogCaptureFixture
) <span style="color: #666666">-&gt;</span> <span style="color: #008000; font-weight: bold">None</span>:
    _create_fixture(tmp_path)
    tracker <span style="color: #666666">=</span> {<span style="color: #BA2121">&quot;rank&quot;</span>: <span style="color: #666666">0</span>, <span style="color: #BA2121">&quot;extract&quot;</span>: <span style="color: #666666">0</span>}

    <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">fake_rank</span>(root: Path, patterns: <span style="color: #008000">list</span>[<span style="color: #008000">str</span>]) <span style="color: #666666">-&gt;</span> <span style="color: #008000">list</span>[Path]:
        tracker[<span style="color: #BA2121">&quot;rank&quot;</span>] <span style="color: #666666">+=</span> <span style="color: #666666">1</span>
        <span style="color: #008000; font-weight: bold">return</span> [tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;script.py&quot;</span>]

    <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">fake_extract</span>(
        files: Iterable[Path], <span style="color: #666666">*</span>, max_files: <span style="color: #008000">int</span>, time_budget: <span style="color: #008000">int</span>, max_bytes: <span style="color: #008000">int</span>
    ) <span style="color: #666666">-&gt;</span> <span style="color: #008000">dict</span>[Path, <span style="color: #008000">str</span>]:
        tracker[<span style="color: #BA2121">&quot;extract&quot;</span>] <span style="color: #666666">+=</span> <span style="color: #666666">1</span>
        <span style="color: #008000; font-weight: bold">return</span> {<span style="color: #008000">next</span>(<span style="color: #008000">iter</span>(files)): <span style="color: #BA2121">&quot;code&quot;</span>}

    monkeypatch<span style="color: #666666">.</span>setattr(explaincode, <span style="color: #BA2121">&quot;LLMClient&quot;</span>, _mock_llm_client)
    monkeypatch<span style="color: #666666">.</span>setattr(explaincode, <span style="color: #BA2121">&quot;rank_code_files&quot;</span>, fake_rank)
    monkeypatch<span style="color: #666666">.</span>setattr(explaincode, <span style="color: #BA2121">&quot;extract_snippets&quot;</span>, fake_extract)

    caplog<span style="color: #666666">.</span>set_level(logging<span style="color: #666666">.</span>INFO)
    main([<span style="color: #BA2121">&quot;--path&quot;</span>, <span style="color: #008000">str</span>(tmp_path), <span style="color: #BA2121">&quot;--force-code&quot;</span>])
    <span style="color: #008000; font-weight: bold">assert</span> tracker[<span style="color: #BA2121">&quot;rank&quot;</span>] <span style="color: #666666">==</span> <span style="color: #666666">1</span>
    <span style="color: #008000; font-weight: bold">assert</span> tracker[<span style="color: #BA2121">&quot;extract&quot;</span>] <span style="color: #666666">==</span> <span style="color: #666666">1</span>
    log <span style="color: #666666">=</span> caplog<span style="color: #666666">.</span>text
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #BA2121">&quot;Code scan triggered: --force-code enabled&quot;</span> <span style="color: #AA22FF; font-weight: bold">in</span> log
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #BA2121">&quot;Pass 1 complete: no sections missing&quot;</span> <span style="color: #AA22FF; font-weight: bold">in</span> log
</code></pre>
<details>
<summary>Subfunction: fake_rank(root: Path, patterns: list[str]) -&gt; list[Path]</summary>
<h4 id="fake_rank">fake_rank(root: Path, patterns: list[str]) -&gt; list[Path]</h4>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">fake_rank</span>(root: Path, patterns: <span style="color: #008000">list</span>[<span style="color: #008000">str</span>]) <span style="color: #666666">-&gt;</span> <span style="color: #008000">list</span>[Path]:
        tracker[<span style="color: #BA2121">&quot;rank&quot;</span>] <span style="color: #666666">+=</span> <span style="color: #666666">1</span>
        <span style="color: #008000; font-weight: bold">return</span> [tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;script.py&quot;</span>]
</code></pre>
</details>
<details>
<summary>Subfunction: fake_extract(files: Iterable[Path], *, max_files: int, time_budget: int, max_bytes: int) -&gt; dict[Path, str]</summary>
<h4 id="fake_extract">fake_extract(files: Iterable[Path], *, max_files: int, time_budget: int, max_bytes: int) -&gt; dict[Path, str]</h4>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">fake_extract</span>(
        files: Iterable[Path], <span style="color: #666666">*</span>, max_files: <span style="color: #008000">int</span>, time_budget: <span style="color: #008000">int</span>, max_bytes: <span style="color: #008000">int</span>
    ) <span style="color: #666666">-&gt;</span> <span style="color: #008000">dict</span>[Path, <span style="color: #008000">str</span>]:
        tracker[<span style="color: #BA2121">&quot;extract&quot;</span>] <span style="color: #666666">+=</span> <span style="color: #666666">1</span>
        <span style="color: #008000; font-weight: bold">return</span> {<span style="color: #008000">next</span>(<span style="color: #008000">iter</span>(files)): <span style="color: #BA2121">&quot;code&quot;</span>}
</code></pre>
</details>
<h3 id="test_custom_title_and_filename">test_custom_title_and_filename(tmp_path: Path, monkeypatch: pytest.MonkeyPatch) -&gt; None</h3>
<p>This function tests the generation of documentation with a custom title and filename. It creates a fixture, mocks an LLM client, runs the main function with specified path and title, and asserts that the output file and evidence file exist. The output HTML file contains the specified custom title.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">test_custom_title_and_filename</span>(tmp_path: Path, monkeypatch: pytest<span style="color: #666666">.</span>MonkeyPatch) <span style="color: #666666">-&gt;</span> <span style="color: #008000; font-weight: bold">None</span>:
    _create_fixture(tmp_path)
    monkeypatch<span style="color: #666666">.</span>setattr(explaincode, <span style="color: #BA2121">&quot;LLMClient&quot;</span>, _mock_llm_client)
    main([<span style="color: #BA2121">&quot;--path&quot;</span>, <span style="color: #008000">str</span>(tmp_path), <span style="color: #BA2121">&quot;--title&quot;</span>, <span style="color: #BA2121">&quot;Fancy Guide&quot;</span>])
    out_file <span style="color: #666666">=</span> tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;fancy_guide.html&quot;</span>
    evidence_file <span style="color: #666666">=</span> tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;fancy_guide_evidence.json&quot;</span>
    <span style="color: #008000; font-weight: bold">assert</span> out_file<span style="color: #666666">.</span>exists()
    <span style="color: #008000; font-weight: bold">assert</span> evidence_file<span style="color: #666666">.</span>exists()
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #BA2121">&quot;&lt;h1&gt;Fancy Guide&lt;/h1&gt;&quot;</span> <span style="color: #AA22FF; font-weight: bold">in</span> out_file<span style="color: #666666">.</span>read_text(encoding<span style="color: #666666">=</span><span style="color: #BA2121">&quot;utf-8&quot;</span>)
</code></pre>
<h3 id="test_insert_into_index">test_insert_into_index(tmp_path: Path, monkeypatch: pytest.MonkeyPatch) -&gt; None</h3>
<p>The function `test_insert_into_index` is designed to test the functionality of inserting a new link into an existing HTML index file. It uses temporary directory and monkeypatching for simulation. The test creates a fixture, sets up an output directory with an initial index.html file, mocks an LLMClient, runs the main function with specified arguments, and then checks if the expected link is present in the updated index.html file.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">test_insert_into_index</span>(tmp_path: Path, monkeypatch: pytest<span style="color: #666666">.</span>MonkeyPatch) <span style="color: #666666">-&gt;</span> <span style="color: #008000; font-weight: bold">None</span>:
    _create_fixture(tmp_path)
    out_dir <span style="color: #666666">=</span> tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;out&quot;</span>
    out_dir<span style="color: #666666">.</span>mkdir()
    index <span style="color: #666666">=</span> out_dir <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;index.html&quot;</span>
    index<span style="color: #666666">.</span>write_text(<span style="color: #BA2121">&quot;&lt;html&gt;&lt;body&gt;&lt;ul&gt;&lt;/ul&gt;&lt;/body&gt;&lt;/html&gt;&quot;</span>, encoding<span style="color: #666666">=</span><span style="color: #BA2121">&quot;utf-8&quot;</span>)
    monkeypatch<span style="color: #666666">.</span>setattr(explaincode, <span style="color: #BA2121">&quot;LLMClient&quot;</span>, _mock_llm_client)
    main([<span style="color: #BA2121">&quot;--path&quot;</span>, <span style="color: #008000">str</span>(tmp_path), <span style="color: #BA2121">&quot;--output&quot;</span>, <span style="color: #008000">str</span>(out_dir), <span style="color: #BA2121">&quot;--insert-into-index&quot;</span>])
    html <span style="color: #666666">=</span> index<span style="color: #666666">.</span>read_text(encoding<span style="color: #666666">=</span><span style="color: #BA2121">&quot;utf-8&quot;</span>)
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #BA2121">&#39;&lt;a href=&quot;user_manual.html&quot;&gt;User Manual&lt;/a&gt;&#39;</span> <span style="color: #AA22FF; font-weight: bold">in</span> html
</code></pre>
<h3 id="test_docs_index_default_and_injection">test_docs_index_default_and_injection(tmp_path: Path, monkeypatch: pytest.MonkeyPatch) -&gt; None</h3>
<p>This function `test_docs_index_default_and_injection` tests the generation of documentation index with default settings and code injection. It creates a temporary directory, sets up a mock language model client, and runs the main documentation generation script with specified options. The test checks if the user manual HTML file and evidence JSON file are created in the output directory. It also verifies that the navigation section of the index.html contains a link to the user manual.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">test_docs_index_default_and_injection</span>(
    tmp_path: Path, monkeypatch: pytest<span style="color: #666666">.</span>MonkeyPatch
) <span style="color: #666666">-&gt;</span> <span style="color: #008000; font-weight: bold">None</span>:
    _create_fixture(tmp_path)
    docs_dir <span style="color: #666666">=</span> tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;docs&quot;</span>
    docs_dir<span style="color: #666666">.</span>mkdir()
    (docs_dir <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;index.html&quot;</span>)<span style="color: #666666">.</span>write_text(<span style="color: #BA2121">&quot;&lt;html&gt;&lt;body&gt;&lt;nav&gt;&lt;/nav&gt;&lt;/body&gt;&lt;/html&gt;&quot;</span>, encoding<span style="color: #666666">=</span><span style="color: #BA2121">&quot;utf-8&quot;</span>)
    monkeypatch<span style="color: #666666">.</span>setattr(explaincode, <span style="color: #BA2121">&quot;LLMClient&quot;</span>, _mock_llm_client)
    main([<span style="color: #BA2121">&quot;--path&quot;</span>, <span style="color: #008000">str</span>(tmp_path), <span style="color: #BA2121">&quot;--insert-into-index&quot;</span>])
    manual <span style="color: #666666">=</span> docs_dir <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;user_manual.html&quot;</span>
    evidence <span style="color: #666666">=</span> docs_dir <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;user_manual_evidence.json&quot;</span>
    <span style="color: #008000; font-weight: bold">assert</span> manual<span style="color: #666666">.</span>exists()
    <span style="color: #008000; font-weight: bold">assert</span> evidence<span style="color: #666666">.</span>exists()
    soup <span style="color: #666666">=</span> BeautifulSoup((docs_dir <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;index.html&quot;</span>)<span style="color: #666666">.</span>read_text(encoding<span style="color: #666666">=</span><span style="color: #BA2121">&quot;utf-8&quot;</span>), <span style="color: #BA2121">&quot;html.parser&quot;</span>)
    nav <span style="color: #666666">=</span> soup<span style="color: #666666">.</span>find(<span style="color: #BA2121">&quot;nav&quot;</span>)
    <span style="color: #008000; font-weight: bold">assert</span> nav <span style="color: #AA22FF; font-weight: bold">is</span> <span style="color: #AA22FF; font-weight: bold">not</span> <span style="color: #008000; font-weight: bold">None</span>
    first <span style="color: #666666">=</span> nav<span style="color: #666666">.</span>find(<span style="color: #BA2121">&quot;a&quot;</span>)
    <span style="color: #008000; font-weight: bold">assert</span> first <span style="color: #AA22FF; font-weight: bold">and</span> first[<span style="color: #BA2121">&quot;href&quot;</span>] <span style="color: #666666">==</span> <span style="color: #BA2121">&quot;user_manual.html&quot;</span>
</code></pre>
<h3 id="test_insert_into_root_index">test_insert_into_root_index(tmp_path: Path, monkeypatch: pytest.MonkeyPatch) -&gt; None</h3>
<p>This function tests the insertion of a generated user manual into an existing HTML index file. It uses a temporary path to create a fixture, writes an initial HTML structure with a `&lt;nav&gt;` element, and then calls the `main` function with specific arguments to insert the documentation. The test checks if the user manual and evidence files are created in the expected directory, and verifies that the navigation link points to the correct location of the user manual within the index file.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">test_insert_into_root_index</span>(tmp_path: Path, monkeypatch: pytest<span style="color: #666666">.</span>MonkeyPatch) <span style="color: #666666">-&gt;</span> <span style="color: #008000; font-weight: bold">None</span>:
    _create_fixture(tmp_path)
    (tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;index.html&quot;</span>)<span style="color: #666666">.</span>write_text(<span style="color: #BA2121">&quot;&lt;html&gt;&lt;body&gt;&lt;nav&gt;&lt;/nav&gt;&lt;/body&gt;&lt;/html&gt;&quot;</span>, encoding<span style="color: #666666">=</span><span style="color: #BA2121">&quot;utf-8&quot;</span>)
    monkeypatch<span style="color: #666666">.</span>setattr(explaincode, <span style="color: #BA2121">&quot;LLMClient&quot;</span>, _mock_llm_client)
    main([<span style="color: #BA2121">&quot;--path&quot;</span>, <span style="color: #008000">str</span>(tmp_path), <span style="color: #BA2121">&quot;--insert-into-index&quot;</span>])
    manual <span style="color: #666666">=</span> tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;docs&quot;</span> <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;user_manual.html&quot;</span>
    evidence <span style="color: #666666">=</span> tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;docs&quot;</span> <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;user_manual_evidence.json&quot;</span>
    <span style="color: #008000; font-weight: bold">assert</span> manual<span style="color: #666666">.</span>exists()
    <span style="color: #008000; font-weight: bold">assert</span> evidence<span style="color: #666666">.</span>exists()
    soup <span style="color: #666666">=</span> BeautifulSoup((tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;index.html&quot;</span>)<span style="color: #666666">.</span>read_text(encoding<span style="color: #666666">=</span><span style="color: #BA2121">&quot;utf-8&quot;</span>), <span style="color: #BA2121">&quot;html.parser&quot;</span>)
    nav <span style="color: #666666">=</span> soup<span style="color: #666666">.</span>find(<span style="color: #BA2121">&quot;nav&quot;</span>)
    <span style="color: #008000; font-weight: bold">assert</span> nav <span style="color: #AA22FF; font-weight: bold">is</span> <span style="color: #AA22FF; font-weight: bold">not</span> <span style="color: #008000; font-weight: bold">None</span>
    first <span style="color: #666666">=</span> nav<span style="color: #666666">.</span>find(<span style="color: #BA2121">&quot;a&quot;</span>)
    <span style="color: #008000; font-weight: bold">assert</span> first <span style="color: #AA22FF; font-weight: bold">and</span> first[<span style="color: #BA2121">&quot;href&quot;</span>] <span style="color: #666666">==</span> <span style="color: #BA2121">&quot;docs/user_manual.html&quot;</span>
</code></pre>
<h3 id="test_chunking_triggers_multiple_calls_and_logs">test_chunking_triggers_multiple_calls_and_logs(tmp_path: Path, capsys: pytest.CaptureFixture[str]) -&gt; None</h3>
<p>This function tests the chunking and summarization process for a given text. It creates two large paragraphs, joins them with newlines, and then uses a dummy client to simulate language model calls. The client records each call it receives, distinguishing between chunking and merging prompts. The function asserts that the final result is &quot;final&quot;, that three calls were made (two chunking and one merging), and that the system prompts are correctly identified as chunking for the first two calls and merging for the last. Additionally, it checks that output captured by `capsys` includes messages indicating chunk processing and merged response length.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">test_chunking_triggers_multiple_calls_and_logs</span>(
    tmp_path: Path, capsys: pytest<span style="color: #666666">.</span>CaptureFixture[<span style="color: #008000">str</span>]
) <span style="color: #666666">-&gt;</span> <span style="color: #008000; font-weight: bold">None</span>:
    paragraph1 <span style="color: #666666">=</span> <span style="color: #BA2121">&quot;aaa &quot;</span> <span style="color: #666666">*</span> <span style="color: #666666">2000</span>
    paragraph2 <span style="color: #666666">=</span> <span style="color: #BA2121">&quot;bbb &quot;</span> <span style="color: #666666">*</span> <span style="color: #666666">2000</span>
    text <span style="color: #666666">=</span> <span style="color: #BA2121">&quot;</span><span style="color: #AA5D1F; font-weight: bold">\n\n</span><span style="color: #BA2121">&quot;</span><span style="color: #666666">.</span>join([paragraph1, paragraph2])

    <span style="color: #008000; font-weight: bold">class</span> <span style="color: #0000FF; font-weight: bold">Dummy</span>:
        <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">__init__</span>(<span style="color: #008000">self</span>) <span style="color: #666666">-&gt;</span> <span style="color: #008000; font-weight: bold">None</span>:
            <span style="color: #008000">self</span><span style="color: #666666">.</span>calls: <span style="color: #008000">list</span>[<span style="color: #008000">dict</span>] <span style="color: #666666">=</span> []

        <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">summarize</span>(<span style="color: #008000">self</span>, text: <span style="color: #008000">str</span>, prompt_type: <span style="color: #008000">str</span>, system_prompt: <span style="color: #008000">str</span> <span style="color: #666666">=</span> <span style="color: #BA2121">&quot;&quot;</span>) <span style="color: #666666">-&gt;</span> <span style="color: #008000">str</span>:
            <span style="color: #008000">self</span><span style="color: #666666">.</span>calls<span style="color: #666666">.</span>append(
                {<span style="color: #BA2121">&quot;text&quot;</span>: text, <span style="color: #BA2121">&quot;prompt_type&quot;</span>: prompt_type, <span style="color: #BA2121">&quot;system_prompt&quot;</span>: system_prompt}
            )
            <span style="color: #008000; font-weight: bold">if</span> system_prompt <span style="color: #666666">==</span> explaincode<span style="color: #666666">.</span>MERGE_SYSTEM_PROMPT:
                <span style="color: #008000; font-weight: bold">return</span> <span style="color: #BA2121">&quot;final&quot;</span>
            <span style="color: #008000; font-weight: bold">return</span> text<span style="color: #666666">.</span>split()[<span style="color: #666666">0</span>]

    client <span style="color: #666666">=</span> Dummy()
    cache <span style="color: #666666">=</span> ResponseCache(<span style="color: #008000">str</span>(tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;cache.json&quot;</span>))
    logging<span style="color: #666666">.</span>basicConfig(stream<span style="color: #666666">=</span>sys<span style="color: #666666">.</span>stdout, level<span style="color: #666666">=</span>logging<span style="color: #666666">.</span>DEBUG, force<span style="color: #666666">=</span><span style="color: #008000; font-weight: bold">True</span>)
    result <span style="color: #666666">=</span> manual_utils<span style="color: #666666">.</span>_summarize_manual(
        client, cache, text, chunking<span style="color: #666666">=</span><span style="color: #BA2121">&quot;auto&quot;</span>, source<span style="color: #666666">=</span><span style="color: #BA2121">&quot;src&quot;</span>
    )

    <span style="color: #008000; font-weight: bold">assert</span> result <span style="color: #666666">==</span> <span style="color: #BA2121">&quot;final&quot;</span>
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #008000">len</span>(client<span style="color: #666666">.</span>calls) <span style="color: #666666">==</span> <span style="color: #666666">3</span>
    chunk_calls <span style="color: #666666">=</span> client<span style="color: #666666">.</span>calls[:<span style="color: #666666">-1</span>]
    merge_call <span style="color: #666666">=</span> client<span style="color: #666666">.</span>calls[<span style="color: #666666">-1</span>]
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #008000">all</span>(c[<span style="color: #BA2121">&quot;system_prompt&quot;</span>] <span style="color: #666666">==</span> explaincode<span style="color: #666666">.</span>CHUNK_SYSTEM_PROMPT <span style="color: #008000; font-weight: bold">for</span> c <span style="color: #AA22FF; font-weight: bold">in</span> chunk_calls)
    <span style="color: #008000; font-weight: bold">assert</span> merge_call[<span style="color: #BA2121">&quot;system_prompt&quot;</span>] <span style="color: #666666">==</span> explaincode<span style="color: #666666">.</span>MERGE_SYSTEM_PROMPT
    <span style="color: #008000; font-weight: bold">assert</span> merge_call[<span style="color: #BA2121">&quot;text&quot;</span>] <span style="color: #666666">==</span> <span style="color: #BA2121">&quot;aaa</span><span style="color: #AA5D1F; font-weight: bold">\n\n</span><span style="color: #BA2121">bbb&quot;</span>

    out <span style="color: #666666">=</span> capsys<span style="color: #666666">.</span>readouterr()<span style="color: #666666">.</span>out
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #BA2121">&quot;Chunk 1/2 from src&quot;</span> <span style="color: #AA22FF; font-weight: bold">in</span> out
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #BA2121">&quot;Merged LLM response length&quot;</span> <span style="color: #AA22FF; font-weight: bold">in</span> out
</code></pre>
<h3 id="test_chunk_edit_hook_applied">test_chunk_edit_hook_applied(tmp_path: Path) -&gt; None</h3>
<p>This function `test_chunk_edit_hook_applied` tests the integration of a hook function with the `_summarize_manual` utility. It creates a dummy client that records calls to its `summarize` method and simulates a cache. The function then processes a large text by chunking it, applying an uppercase transformation via a post-chunk hook, and using a custom system prompt for summarization. The test asserts that the final result is &quot;final&quot; and that the last call to the dummy client&#x27;s `summarize` method has its text transformed to uppercase.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">test_chunk_edit_hook_applied</span>(tmp_path: Path) <span style="color: #666666">-&gt;</span> <span style="color: #008000; font-weight: bold">None</span>:
    paragraph1 <span style="color: #666666">=</span> <span style="color: #BA2121">&quot;aaa &quot;</span> <span style="color: #666666">*</span> <span style="color: #666666">2000</span>
    paragraph2 <span style="color: #666666">=</span> <span style="color: #BA2121">&quot;bbb &quot;</span> <span style="color: #666666">*</span> <span style="color: #666666">2000</span>
    text <span style="color: #666666">=</span> <span style="color: #BA2121">&quot;</span><span style="color: #AA5D1F; font-weight: bold">\n\n</span><span style="color: #BA2121">&quot;</span><span style="color: #666666">.</span>join([paragraph1, paragraph2])

    <span style="color: #008000; font-weight: bold">class</span> <span style="color: #0000FF; font-weight: bold">Dummy</span>:
        <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">__init__</span>(<span style="color: #008000">self</span>) <span style="color: #666666">-&gt;</span> <span style="color: #008000; font-weight: bold">None</span>:
            <span style="color: #008000">self</span><span style="color: #666666">.</span>calls: <span style="color: #008000">list</span>[<span style="color: #008000">dict</span>] <span style="color: #666666">=</span> []

        <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">summarize</span>(<span style="color: #008000">self</span>, text: <span style="color: #008000">str</span>, prompt_type: <span style="color: #008000">str</span>, system_prompt: <span style="color: #008000">str</span> <span style="color: #666666">=</span> <span style="color: #BA2121">&quot;&quot;</span>) <span style="color: #666666">-&gt;</span> <span style="color: #008000">str</span>:
            <span style="color: #008000">self</span><span style="color: #666666">.</span>calls<span style="color: #666666">.</span>append(
                {<span style="color: #BA2121">&quot;text&quot;</span>: text, <span style="color: #BA2121">&quot;prompt_type&quot;</span>: prompt_type, <span style="color: #BA2121">&quot;system_prompt&quot;</span>: system_prompt}
            )
            <span style="color: #008000; font-weight: bold">if</span> system_prompt <span style="color: #666666">==</span> explaincode<span style="color: #666666">.</span>MERGE_SYSTEM_PROMPT:
                <span style="color: #008000; font-weight: bold">return</span> <span style="color: #BA2121">&quot;final&quot;</span>
            <span style="color: #008000; font-weight: bold">return</span> text<span style="color: #666666">.</span>split()[<span style="color: #666666">0</span>]

    <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">hook</span>(chunks: <span style="color: #008000">list</span>[<span style="color: #008000">str</span>]) <span style="color: #666666">-&gt;</span> <span style="color: #008000">list</span>[<span style="color: #008000">str</span>]:
        <span style="color: #008000; font-weight: bold">return</span> [c<span style="color: #666666">.</span>upper() <span style="color: #008000; font-weight: bold">for</span> c <span style="color: #AA22FF; font-weight: bold">in</span> chunks]

    client <span style="color: #666666">=</span> Dummy()
    cache <span style="color: #666666">=</span> ResponseCache(<span style="color: #008000">str</span>(tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;cache.json&quot;</span>))
    result <span style="color: #666666">=</span> manual_utils<span style="color: #666666">.</span>_summarize_manual(
        client, cache, text, chunking<span style="color: #666666">=</span><span style="color: #BA2121">&quot;auto&quot;</span>, source<span style="color: #666666">=</span><span style="color: #BA2121">&quot;src&quot;</span>, post_chunk_hook<span style="color: #666666">=</span>hook
    )

    <span style="color: #008000; font-weight: bold">assert</span> result <span style="color: #666666">==</span> <span style="color: #BA2121">&quot;final&quot;</span>
    <span style="color: #008000; font-weight: bold">assert</span> client<span style="color: #666666">.</span>calls[<span style="color: #666666">-1</span>][<span style="color: #BA2121">&quot;text&quot;</span>] <span style="color: #666666">==</span> <span style="color: #BA2121">&quot;AAA</span><span style="color: #AA5D1F; font-weight: bold">\n\n</span><span style="color: #BA2121">BBB&quot;</span>
</code></pre>
<details>
<summary>Subfunction: hook(chunks: list[str]) -&gt; list[str]</summary>
<h4 id="hook">hook(chunks: list[str]) -&gt; list[str]</h4>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">hook</span>(chunks: <span style="color: #008000">list</span>[<span style="color: #008000">str</span>]) <span style="color: #666666">-&gt;</span> <span style="color: #008000">list</span>[<span style="color: #008000">str</span>]:
        <span style="color: #008000; font-weight: bold">return</span> [c<span style="color: #666666">.</span>upper() <span style="color: #008000; font-weight: bold">for</span> c <span style="color: #AA22FF; font-weight: bold">in</span> chunks]
</code></pre>
</details>
<h3 id="test_parallel_chunk_summarization">test_parallel_chunk_summarization(tmp_path: Path) -&gt; None</h3>
<p>This function `test_parallel_chunk_summarization` tests the parallel summarization of text using a slow client and a response cache. It creates a large text by repeating a paragraph, simulates a slow server response with a delay, and measures the time taken to summarize the text. The test asserts that the total duration is less than 1.5 times the delay, ensuring that the parallel processing works as expected.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">test_parallel_chunk_summarization</span>(tmp_path: Path) <span style="color: #666666">-&gt;</span> <span style="color: #008000; font-weight: bold">None</span>:
    paragraph <span style="color: #666666">=</span> <span style="color: #BA2121">&quot;word &quot;</span> <span style="color: #666666">*</span> <span style="color: #666666">2000</span>
    text <span style="color: #666666">=</span> <span style="color: #BA2121">&quot;</span><span style="color: #AA5D1F; font-weight: bold">\n\n</span><span style="color: #BA2121">&quot;</span><span style="color: #666666">.</span>join([paragraph, paragraph])
    delay <span style="color: #666666">=</span> <span style="color: #666666">0.2</span>

    <span style="color: #008000; font-weight: bold">class</span> <span style="color: #0000FF; font-weight: bold">SlowClient</span>:
        <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">summarize</span>(<span style="color: #008000">self</span>, text: <span style="color: #008000">str</span>, prompt_type: <span style="color: #008000">str</span>, system_prompt: <span style="color: #008000">str</span> <span style="color: #666666">=</span> <span style="color: #BA2121">&quot;&quot;</span>) <span style="color: #666666">-&gt;</span> <span style="color: #008000">str</span>:
            <span style="color: #008000; font-weight: bold">if</span> system_prompt <span style="color: #666666">==</span> explaincode<span style="color: #666666">.</span>CHUNK_SYSTEM_PROMPT:
                time<span style="color: #666666">.</span>sleep(delay)
            <span style="color: #008000; font-weight: bold">return</span> <span style="color: #BA2121">&quot;ok&quot;</span>

    client <span style="color: #666666">=</span> SlowClient()
    cache <span style="color: #666666">=</span> ResponseCache(<span style="color: #008000">str</span>(tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;cache.json&quot;</span>))
    start <span style="color: #666666">=</span> time<span style="color: #666666">.</span>perf_counter()
    manual_utils<span style="color: #666666">.</span>_summarize_manual(client, cache, text, chunking<span style="color: #666666">=</span><span style="color: #BA2121">&quot;auto&quot;</span>, source<span style="color: #666666">=</span><span style="color: #BA2121">&quot;src&quot;</span>)
    duration <span style="color: #666666">=</span> time<span style="color: #666666">.</span>perf_counter() <span style="color: #666666">-</span> start
    <span style="color: #008000; font-weight: bold">assert</span> duration <span style="color: #666666">&lt;</span> delay <span style="color: #666666">*</span> <span style="color: #666666">1.5</span>
</code></pre>
<h3 id="test_hierarchical_merge_logged">test_hierarchical_merge_logged(tmp_path: Path, capsys: pytest.CaptureFixture[str]) -&gt; None</h3>
<p>The function `test_hierarchical_merge_logged` is a unit test for a code summarization process. It uses a mock client with predefined behavior to simulate interactions with a language model, a response cache to store previous results, and logging to capture output. The test constructs a large text input by repeating a string multiple times, simulating a scenario where the summarization process might be applied to a large codebase.

The function then calls `manual_utils._summarize_manual` with the mock client, cache, and text input. It asserts that the result returned by the summarization function is &quot;short&quot;, indicating that the summarization process has successfully reduced the input text. Additionally, it checks that the mock client&#x27;s `calls` list contains more than three entries, suggesting that multiple summarization passes were performed as part of the hierarchical merge process.

Finally, the test reads the captured output from the logging system and asserts that a specific log message &quot;Hierarchical merge pass&quot; is present in the output, indicating that the hierarchical merge logic was executed during the test.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">test_hierarchical_merge_logged</span>(
    tmp_path: Path, capsys: pytest<span style="color: #666666">.</span>CaptureFixture[<span style="color: #008000">str</span>]
) <span style="color: #666666">-&gt;</span> <span style="color: #008000; font-weight: bold">None</span>:
    big <span style="color: #666666">=</span> <span style="color: #BA2121">&quot;word &quot;</span> <span style="color: #666666">*</span> <span style="color: #666666">5000</span>
    text <span style="color: #666666">=</span> <span style="color: #BA2121">&quot;</span><span style="color: #AA5D1F; font-weight: bold">\n\n</span><span style="color: #BA2121">&quot;</span><span style="color: #666666">.</span>join([big, big])

    <span style="color: #008000; font-weight: bold">class</span> <span style="color: #0000FF; font-weight: bold">Dummy</span>:
        <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">__init__</span>(<span style="color: #008000">self</span>) <span style="color: #666666">-&gt;</span> <span style="color: #008000; font-weight: bold">None</span>:
            <span style="color: #008000">self</span><span style="color: #666666">.</span>calls: <span style="color: #008000">list</span>[<span style="color: #008000">dict</span>] <span style="color: #666666">=</span> []

        <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">summarize</span>(<span style="color: #008000">self</span>, text: <span style="color: #008000">str</span>, prompt_type: <span style="color: #008000">str</span>, system_prompt: <span style="color: #008000">str</span> <span style="color: #666666">=</span> <span style="color: #BA2121">&quot;&quot;</span>) <span style="color: #666666">-&gt;</span> <span style="color: #008000">str</span>:
            <span style="color: #008000">self</span><span style="color: #666666">.</span>calls<span style="color: #666666">.</span>append(
                {<span style="color: #BA2121">&quot;text&quot;</span>: text, <span style="color: #BA2121">&quot;prompt_type&quot;</span>: prompt_type, <span style="color: #BA2121">&quot;system_prompt&quot;</span>: system_prompt}
            )
            <span style="color: #008000; font-weight: bold">if</span> <span style="color: #008000">len</span>(<span style="color: #008000">self</span><span style="color: #666666">.</span>calls) <span style="color: #666666">&lt;=</span> <span style="color: #666666">2</span>:
                <span style="color: #008000; font-weight: bold">return</span> big
            <span style="color: #008000; font-weight: bold">return</span> <span style="color: #BA2121">&quot;short&quot;</span>

    client <span style="color: #666666">=</span> Dummy()
    cache <span style="color: #666666">=</span> ResponseCache(<span style="color: #008000">str</span>(tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;cache.json&quot;</span>))
    logging<span style="color: #666666">.</span>basicConfig(stream<span style="color: #666666">=</span>sys<span style="color: #666666">.</span>stdout, level<span style="color: #666666">=</span>logging<span style="color: #666666">.</span>DEBUG, force<span style="color: #666666">=</span><span style="color: #008000; font-weight: bold">True</span>)
    result <span style="color: #666666">=</span> manual_utils<span style="color: #666666">.</span>_summarize_manual(
        client, cache, text, chunking<span style="color: #666666">=</span><span style="color: #BA2121">&quot;auto&quot;</span>, source<span style="color: #666666">=</span><span style="color: #BA2121">&quot;src&quot;</span>
    )

    <span style="color: #008000; font-weight: bold">assert</span> result <span style="color: #666666">==</span> <span style="color: #BA2121">&quot;short&quot;</span>
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #008000">len</span>(client<span style="color: #666666">.</span>calls) <span style="color: #666666">&gt;</span> <span style="color: #666666">3</span>
    out <span style="color: #666666">=</span> capsys<span style="color: #666666">.</span>readouterr()<span style="color: #666666">.</span>out
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #BA2121">&quot;Hierarchical merge pass&quot;</span> <span style="color: #AA22FF; font-weight: bold">in</span> out
</code></pre>
<h3 id="test_cached_chunks_reused">test_cached_chunks_reused(tmp_path: Path) -&gt; None</h3>
<p>The function `test_cached_chunks_reused` tests the caching mechanism in the documentation generation system. It creates a dummy client with a `summarize` method that records its calls. The function then uses this client to summarize a large text by chunking it automatically, using both a direct call and a cached call. The first call successfully summarizes the text and records three calls (one for each chunk). The second call retrieves the result from the cache without making additional calls, as expected.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">test_cached_chunks_reused</span>(tmp_path: Path) <span style="color: #666666">-&gt;</span> <span style="color: #008000; font-weight: bold">None</span>:
    paragraph <span style="color: #666666">=</span> <span style="color: #BA2121">&quot;word &quot;</span> <span style="color: #666666">*</span> <span style="color: #666666">2000</span>
    text <span style="color: #666666">=</span> <span style="color: #BA2121">&quot;</span><span style="color: #AA5D1F; font-weight: bold">\n\n</span><span style="color: #BA2121">&quot;</span><span style="color: #666666">.</span>join([paragraph, paragraph])

    <span style="color: #008000; font-weight: bold">class</span> <span style="color: #0000FF; font-weight: bold">Dummy</span>:
        <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">__init__</span>(<span style="color: #008000">self</span>) <span style="color: #666666">-&gt;</span> <span style="color: #008000; font-weight: bold">None</span>:
            <span style="color: #008000">self</span><span style="color: #666666">.</span>calls: <span style="color: #008000">list</span>[<span style="color: #008000">dict</span>] <span style="color: #666666">=</span> []

        <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">summarize</span>(<span style="color: #008000">self</span>, text: <span style="color: #008000">str</span>, prompt_type: <span style="color: #008000">str</span>, system_prompt: <span style="color: #008000">str</span> <span style="color: #666666">=</span> <span style="color: #BA2121">&quot;&quot;</span>) <span style="color: #666666">-&gt;</span> <span style="color: #008000">str</span>:
            <span style="color: #008000">self</span><span style="color: #666666">.</span>calls<span style="color: #666666">.</span>append(
                {<span style="color: #BA2121">&quot;text&quot;</span>: text, <span style="color: #BA2121">&quot;prompt_type&quot;</span>: prompt_type, <span style="color: #BA2121">&quot;system_prompt&quot;</span>: system_prompt}
            )
            <span style="color: #008000; font-weight: bold">return</span> <span style="color: #BA2121">f&quot;resp</span><span style="color: #A45A77; font-weight: bold">{</span><span style="color: #008000">len</span>(<span style="color: #008000">self</span><span style="color: #666666">.</span>calls)<span style="color: #A45A77; font-weight: bold">}</span><span style="color: #BA2121">&quot;</span>

    cache_file <span style="color: #666666">=</span> tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;cache.json&quot;</span>
    cache <span style="color: #666666">=</span> ResponseCache(<span style="color: #008000">str</span>(cache_file))
    client1 <span style="color: #666666">=</span> Dummy()
    result1 <span style="color: #666666">=</span> manual_utils<span style="color: #666666">.</span>_summarize_manual(
        client1, cache, text, chunking<span style="color: #666666">=</span><span style="color: #BA2121">&quot;auto&quot;</span>, source<span style="color: #666666">=</span><span style="color: #BA2121">&quot;src&quot;</span>
    )
    <span style="color: #008000; font-weight: bold">assert</span> result1 <span style="color: #666666">==</span> <span style="color: #BA2121">&quot;resp3&quot;</span>
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #008000">len</span>(client1<span style="color: #666666">.</span>calls) <span style="color: #666666">==</span> <span style="color: #666666">3</span>

    client2 <span style="color: #666666">=</span> Dummy()
    cache2 <span style="color: #666666">=</span> ResponseCache(<span style="color: #008000">str</span>(cache_file))
    result2 <span style="color: #666666">=</span> manual_utils<span style="color: #666666">.</span>_summarize_manual(
        client2, cache2, text, chunking<span style="color: #666666">=</span><span style="color: #BA2121">&quot;auto&quot;</span>, source<span style="color: #666666">=</span><span style="color: #BA2121">&quot;src&quot;</span>
    )
    <span style="color: #008000; font-weight: bold">assert</span> result2 <span style="color: #666666">==</span> <span style="color: #BA2121">&quot;resp3&quot;</span>
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #008000">len</span>(client2<span style="color: #666666">.</span>calls) <span style="color: #666666">==</span> <span style="color: #666666">0</span>
</code></pre>
<h3 id="test_chunking_none_no_llm_calls">test_chunking_none_no_llm_calls(tmp_path: Path, monkeypatch: pytest.MonkeyPatch) -&gt; None</h3>
<p>The function `test_chunking_none_no_llm_calls` tests the behavior of a documentation generation tool when chunking is disabled and no language model calls are expected. It creates a large text file, initializes a mock language model client that records its calls, and then runs the main documentation generation function with specific arguments. The test asserts that the mock language model was called five times and that the first call includes the system prompt containing &quot;Overview&quot;.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">test_chunking_none_no_llm_calls</span>(tmp_path: Path, monkeypatch: pytest<span style="color: #666666">.</span>MonkeyPatch) <span style="color: #666666">-&gt;</span> <span style="color: #008000; font-weight: bold">None</span>:
    big_text <span style="color: #666666">=</span> <span style="color: #BA2121">&quot;data &quot;</span> <span style="color: #666666">*</span> <span style="color: #666666">5000</span>
    (tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;README.md&quot;</span>)<span style="color: #666666">.</span>write_text(<span style="color: #BA2121">&quot;# Overview</span><span style="color: #AA5D1F; font-weight: bold">\n</span><span style="color: #BA2121">&quot;</span> <span style="color: #666666">+</span> big_text, encoding<span style="color: #666666">=</span><span style="color: #BA2121">&quot;utf-8&quot;</span>)

    <span style="color: #008000; font-weight: bold">class</span> <span style="color: #0000FF; font-weight: bold">Dummy</span>:
        <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">__init__</span>(<span style="color: #008000">self</span>) <span style="color: #666666">-&gt;</span> <span style="color: #008000; font-weight: bold">None</span>:
            <span style="color: #008000">self</span><span style="color: #666666">.</span>calls: <span style="color: #008000">list</span>[<span style="color: #008000">dict</span>] <span style="color: #666666">=</span> []

        <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">summarize</span>(<span style="color: #008000">self</span>, text: <span style="color: #008000">str</span>, prompt_type: <span style="color: #008000">str</span>, system_prompt: <span style="color: #008000">str</span> <span style="color: #666666">=</span> <span style="color: #BA2121">&quot;&quot;</span>) <span style="color: #666666">-&gt;</span> <span style="color: #008000">str</span>:
            <span style="color: #008000">self</span><span style="color: #666666">.</span>calls<span style="color: #666666">.</span>append(
                {<span style="color: #BA2121">&quot;text&quot;</span>: text, <span style="color: #BA2121">&quot;prompt_type&quot;</span>: prompt_type, <span style="color: #BA2121">&quot;system_prompt&quot;</span>: system_prompt}
            )
            <span style="color: #008000; font-weight: bold">return</span> <span style="color: #BA2121">&quot;done&quot;</span>

    dummy <span style="color: #666666">=</span> Dummy()
    monkeypatch<span style="color: #666666">.</span>setattr(explaincode, <span style="color: #BA2121">&quot;LLMClient&quot;</span>, <span style="color: #008000; font-weight: bold">lambda</span>: dummy)
    main([<span style="color: #BA2121">&quot;--path&quot;</span>, <span style="color: #008000">str</span>(tmp_path), <span style="color: #BA2121">&quot;--chunking&quot;</span>, <span style="color: #BA2121">&quot;none&quot;</span>])

    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #008000">len</span>(dummy<span style="color: #666666">.</span>calls) <span style="color: #666666">==</span> <span style="color: #666666">5</span>
    call <span style="color: #666666">=</span> dummy<span style="color: #666666">.</span>calls[<span style="color: #666666">0</span>]
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #BA2121">&quot;Overview&quot;</span> <span style="color: #AA22FF; font-weight: bold">in</span> call[<span style="color: #BA2121">&quot;system_prompt&quot;</span>]
</code></pre>
    </div>
    <script src="static/toggle.js"></script>
</body>
</html>
