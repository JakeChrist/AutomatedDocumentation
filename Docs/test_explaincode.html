<!-- Generated by DocGen-LM -->
<!DOCTYPE html>

<html lang="en">
<head>
<meta charset="utf-8"/><meta content="width=device-width, initial-scale=1" name="viewport"/>
    
<title>test_explaincode</title>
<link href="static/style.css" rel="stylesheet"/>
</head>
<body class="doc-body">
<button aria-label="Toggle navigation menu" class="sidebar-toggle" id="sidebar-toggle">Menu</button>
<div aria-label="Documentation navigation" class="sidebar" role="navigation">
<h2>Navigation</h2>
<ul><li><a href="index.html"><strong>üè† Project Overview</strong></a></li><li><a href="cache.html">cache</a></li><li><a href="chunk_utils.html">chunk_utils</a></li><li><a href="docgenerator.html">docgenerator</a></li><li><a href="explaincode.html">explaincode</a></li><li><a href="gui_wrapper.html">gui_wrapper</a></li><li><a href="html_writer.html">html_writer</a></li><li><a href="llm_client.html">llm_client</a></li><li><a href="manual_utils.html">manual_utils</a></li><li><a href="parser_cpp.html">parser_cpp</a></li><li><a href="parser_java.html">parser_java</a></li><li><a href="parser_matlab.html">parser_matlab</a></li><li><a href="parser_python.html">parser_python</a></li><li><a href="retrofit_sidebar.html">retrofit_sidebar</a></li><li><a href="reviewer.html">reviewer</a></li><li><a href="sanitize_docs.html">sanitize_docs</a></li><li><a href="scanner.html">scanner</a></li><li><a href="setup.html">setup</a></li><li><a href="summarize_utils.html">summarize_utils</a></li><li><details><summary>tests</summary><ul><li><a href="test_cache.html">test_cache</a></li><li><a href="test_chunk_utils.html">test_chunk_utils</a></li><li><a href="test_docgenerator.html">test_docgenerator</a></li><li><a href="test_docgenerator_subclasses.html">test_docgenerator_subclasses</a></li><li><a href="test_explaincode.html">test_explaincode</a></li><li><a href="test_html_writer.html">test_html_writer</a></li><li><a href="test_integration.html">test_integration</a></li><li><a href="test_llm_client.html">test_llm_client</a></li><li><a href="test_manual_utils.html">test_manual_utils</a></li><li><a href="test_parser_cpp.html">test_parser_cpp</a></li><li><a href="test_parser_java.html">test_parser_java</a></li><li><a href="test_parser_matlab.html">test_parser_matlab</a></li><li><a href="test_parser_python.html">test_parser_python</a></li><li><a href="test_resume_progress.html">test_resume_progress</a></li><li><a href="test_retrofit_sidebar.html">test_retrofit_sidebar</a></li><li><a href="test_reviewer.html">test_reviewer</a></li><li><a href="test_sanitize_docs.html">test_sanitize_docs</a></li><li><a href="test_scanner.html">test_scanner</a></li></ul></details></li></ul>
</div>
<main class="content" role="main">
        <div class="content-inner">
<h1>test_explaincode</h1>
<p>The code defines a comprehensive testing suite for documentation processing and summarization workflows, encompassing fixture creation and LLM client mocking functionalities. It includes tests for extracting text from various file formats (Markdown, HTML, DOCX), rendering HTML summaries with tables of contents and evidence blocks, generating user manuals in HTML and PDF formats, handling missing dependencies, custom output directories, collecting documentation files, mapping evidence to sections with priority and filtering, limiting snippet lengths, detecting placeholders, parsing manual sections with inferred content, validating references, inferring section content, skipping large files during snippet extraction, and scanning code while excluding non-source directories. Additional test cases cover code documentation generation functionality including snippet categorization, file ranking with language support, LLM placeholder filling with logging, code scan skipping behaviors, fallback mechanisms with limits, code flag interactions, custom output naming, and index insertion features. The suite also verifies automatic chunking and summarization logic in `manual_utils._summarize_manual`, confirming multiple LLM calls during chunking, proper system prompts for chunk and merge operations, logging of chunking steps, application of post-processing hooks, parallel execution of chunk summaries, hierarchical merging with logging, reuse of cached chunk results, absence of LLM calls when chunking is disabled, and sanitization of</p>
<h2>Functions</h2>
<h3 id="_create_fixture">_create_fixture(tmp_path: Path) -&gt; None</h3>
<p>The function `_create_fixture` creates a temporary directory structure and populates it with sample files for testing purposes. It generates a nested directory path, writes an HTML file containing a basic HTML document with a heading, creates a README.md file with structured content including sections for overview, purpose, usage, inputs, outputs, requirements, and examples, and adds a sample JSON file with basic data. The function uses `Path` from the `pathlib` module to manage directory paths and file operations, ensuring proper encoding when writing text files.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">_create_fixture</span>(tmp_path: Path) <span style="color: #666666">-&gt;</span> <span style="color: #008000; font-weight: bold">None</span>:
    nested <span style="color: #666666">=</span> tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">"subdir"</span> <span style="color: #666666">/</span> <span style="color: #BA2121">"nested"</span>
    nested<span style="color: #666666">.</span>mkdir(parents<span style="color: #666666">=</span><span style="color: #008000; font-weight: bold">True</span>)
    (nested <span style="color: #666666">/</span> <span style="color: #BA2121">"page.html"</span>)<span style="color: #666666">.</span>write_text(
        <span style="color: #BA2121">"&lt;html&gt;&lt;body&gt;&lt;h1&gt;Overview&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;"</span>, encoding<span style="color: #666666">=</span><span style="color: #BA2121">"utf-8"</span>
    )
    content <span style="color: #666666">=</span> textwrap<span style="color: #666666">.</span>dedent(
<span style="color: #bbbbbb">        </span><span style="color: #BA2121; font-style: italic">"""</span>
<span style="color: #BA2121; font-style: italic">        # Overview</span>
<span style="color: #BA2121; font-style: italic">        Demo project</span>

<span style="color: #BA2121; font-style: italic">        # Purpose &amp; Problem Solving</span>
<span style="color: #BA2121; font-style: italic">        Solves a problem</span>

<span style="color: #BA2121; font-style: italic">        # How to Run</span>
<span style="color: #BA2121; font-style: italic">        Usage: run it</span>

<span style="color: #BA2121; font-style: italic">        # Inputs</span>
<span style="color: #BA2121; font-style: italic">        Input data</span>

<span style="color: #BA2121; font-style: italic">        # Outputs</span>
<span style="color: #BA2121; font-style: italic">        Output data</span>

<span style="color: #BA2121; font-style: italic">        # System Requirements</span>
<span style="color: #BA2121; font-style: italic">        None</span>

<span style="color: #BA2121; font-style: italic">        # Examples</span>
<span style="color: #BA2121; font-style: italic">        Example usage</span>
<span style="color: #BA2121; font-style: italic">        """</span>
    )<span style="color: #666666">.</span>strip()
    (tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">"README.md"</span>)<span style="color: #666666">.</span>write_text(content, encoding<span style="color: #666666">=</span><span style="color: #BA2121">"utf-8"</span>)
    (tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">"sample.json"</span>)<span style="color: #666666">.</span>write_text(<span style="color: #BA2121">"{</span><span style="color: #AA5D1F; font-weight: bold">\"</span><span style="color: #BA2121">input</span><span style="color: #AA5D1F; font-weight: bold">\"</span><span style="color: #BA2121">: </span><span style="color: #AA5D1F; font-weight: bold">\"</span><span style="color: #BA2121">data</span><span style="color: #AA5D1F; font-weight: bold">\"</span><span style="color: #BA2121">}"</span>, encoding<span style="color: #666666">=</span><span style="color: #BA2121">"utf-8"</span>)
</code></pre>
<h3 id="_mock_llm_client">_mock_llm_client() -&gt; object</h3>
<p>The function `_mock_llm_client` returns a dummy object that simulates an LLM client for testing purposes. The returned object implements a `summarize` method which takes a text string, a prompt type, and an optional system prompt, and returns a fixed, formatted summary string. This stub implementation is used to avoid actual LLM calls during testing or demonstration scenarios.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">_mock_llm_client</span>() <span style="color: #666666">-&gt;</span> <span style="color: #008000">object</span>:
    <span style="color: #008000; font-weight: bold">class</span> <span style="color: #0000FF; font-weight: bold">Dummy</span>:
        <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">summarize</span>(<span style="color: #008000">self</span>, text: <span style="color: #008000">str</span>, prompt_type: <span style="color: #008000">str</span>, system_prompt: <span style="color: #008000">str</span> <span style="color: #666666">=</span> <span style="color: #BA2121">""</span>) <span style="color: #666666">-&gt;</span> <span style="color: #008000">str</span>:  <span style="color: #3D7B7B; font-style: italic"># pragma: no cover - simple stub</span>
            <span style="color: #008000; font-weight: bold">return</span> textwrap<span style="color: #666666">.</span>dedent(
<span style="color: #bbbbbb">                </span><span style="color: #BA2121; font-style: italic">"""</span>
<span style="color: #BA2121; font-style: italic">                Overview: Demo project</span>
<span style="color: #BA2121; font-style: italic">                Purpose &amp; Problem Solving: Solves a problem</span>
<span style="color: #BA2121; font-style: italic">                How to Run: Execute it</span>
<span style="color: #BA2121; font-style: italic">                Inputs: Input data</span>
<span style="color: #BA2121; font-style: italic">                Outputs: Output data</span>
<span style="color: #BA2121; font-style: italic">                System Requirements: None</span>
<span style="color: #BA2121; font-style: italic">                Examples: Example usage</span>
<span style="color: #BA2121; font-style: italic">                """</span>
            )<span style="color: #666666">.</span>strip()

    <span style="color: #008000; font-weight: bold">return</span> Dummy()
</code></pre>
<h3 id="test_extract_text_markdown_preserves_headings_and_code">test_extract_text_markdown_preserves_headings_and_code(tmp_path: Path) -&gt; None</h3>
<p>The function `test_extract_text_markdown_preserves_headings_and_code` tests the functionality of extracting text from a Markdown file while preserving headings and code blocks. It creates a temporary Markdown file with a title, some text, and a Python code block. The test verifies that the extracted text contains the title, the code block marker, and the code content. The function uses `explaincode.extract_text` to perform the extraction and asserts the presence of specific strings in the output.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">test_extract_text_markdown_preserves_headings_and_code</span>(tmp_path: Path) <span style="color: #666666">-&gt;</span> <span style="color: #008000; font-weight: bold">None</span>:
    content <span style="color: #666666">=</span> <span style="color: #BA2121">"""</span>
<span style="color: #BA2121"># Title</span>

<span style="color: #BA2121">Text</span>

<span style="color: #BA2121">```python</span>
<span style="color: #BA2121">print('hi')</span>
<span style="color: #BA2121">```</span>
<span style="color: #BA2121">"""</span>
    md <span style="color: #666666">=</span> tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">"readme.md"</span>
    md<span style="color: #666666">.</span>write_text(content, encoding<span style="color: #666666">=</span><span style="color: #BA2121">"utf-8"</span>)
    text <span style="color: #666666">=</span> explaincode<span style="color: #666666">.</span>extract_text(md)
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #BA2121">"# Title"</span> <span style="color: #AA22FF; font-weight: bold">in</span> text
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #BA2121">"```python"</span> <span style="color: #AA22FF; font-weight: bold">in</span> text
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #BA2121">"print('hi')"</span> <span style="color: #AA22FF; font-weight: bold">in</span> text
</code></pre>
<h3 id="test_extract_text_html_preserves_headings_and_code">test_extract_text_html_preserves_headings_and_code(tmp_path: Path) -&gt; None</h3>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">test_extract_text_html_preserves_headings_and_code</span>(tmp_path: Path) <span style="color: #666666">-&gt;</span> <span style="color: #008000; font-weight: bold">None</span>:
    html <span style="color: #666666">=</span> (
        <span style="color: #BA2121">"&lt;html&gt;&lt;body&gt;&lt;h1&gt;Main&lt;/h1&gt;&lt;p&gt;Intro&lt;/p&gt;"</span>
        <span style="color: #BA2121">"&lt;h2&gt;Section&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;print('hi')&lt;/code&gt;&lt;/pre&gt;&lt;/body&gt;&lt;/html&gt;"</span>
    )
    page <span style="color: #666666">=</span> tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">"page.html"</span>
    page<span style="color: #666666">.</span>write_text(html, encoding<span style="color: #666666">=</span><span style="color: #BA2121">"utf-8"</span>)
    text <span style="color: #666666">=</span> explaincode<span style="color: #666666">.</span>extract_text(page)
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #BA2121">"# Main"</span> <span style="color: #AA22FF; font-weight: bold">in</span> text
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #BA2121">"## Section"</span> <span style="color: #AA22FF; font-weight: bold">in</span> text
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #BA2121">"```"</span> <span style="color: #AA22FF; font-weight: bold">in</span> text <span style="color: #AA22FF; font-weight: bold">and</span> <span style="color: #BA2121">"print('hi')"</span> <span style="color: #AA22FF; font-weight: bold">in</span> text
</code></pre>
<h3 id="test_extract_text_docx_preserves_headings">test_extract_text_docx_preserves_headings(tmp_path: Path) -&gt; None</h3>
<p>The function `test_extract_text_docx_preserves_headings` tests the extraction of text from a `.docx` file while preserving heading formatting. It creates a Word document with a level 1 heading and a paragraph, saves it to a temporary path, and then uses `explaincode.extract_text` to extract the content. The test verifies that the extracted text has the heading formatted as a Markdown-style header (`# Title`) and that the paragraph text is present in the output. The test skips execution if the `python-docx` library is not installed.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">test_extract_text_docx_preserves_headings</span>(tmp_path: Path) <span style="color: #666666">-&gt;</span> <span style="color: #008000; font-weight: bold">None</span>:
    <span style="color: #008000; font-weight: bold">try</span>:
        <span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">docx</span> <span style="color: #008000; font-weight: bold">import</span> Document
    <span style="color: #008000; font-weight: bold">except</span> <span style="color: #CB3F38; font-weight: bold">Exception</span>:  <span style="color: #3D7B7B; font-style: italic"># pragma: no cover - dependency missing</span>
        pytest<span style="color: #666666">.</span>skip(<span style="color: #BA2121">"python-docx not installed"</span>)

    doc <span style="color: #666666">=</span> Document()
    doc<span style="color: #666666">.</span>add_heading(<span style="color: #BA2121">"Title"</span>, level<span style="color: #666666">=1</span>)
    doc<span style="color: #666666">.</span>add_paragraph(<span style="color: #BA2121">"Text"</span>)
    path <span style="color: #666666">=</span> tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">"doc.docx"</span>
    doc<span style="color: #666666">.</span>save(path)
    text <span style="color: #666666">=</span> explaincode<span style="color: #666666">.</span>extract_text(path)
    <span style="color: #008000; font-weight: bold">assert</span> text<span style="color: #666666">.</span>splitlines()[<span style="color: #666666">0</span>] <span style="color: #666666">==</span> <span style="color: #BA2121">"# Title"</span>
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #BA2121">"Text"</span> <span style="color: #AA22FF; font-weight: bold">in</span> text
</code></pre>
<h3 id="test_render_html_renders_markdown_headings_and_code">test_render_html_renders_markdown_headings_and_code() -&gt; None</h3>
<p>The function `test_render_html_renders_markdown_headings_and_code` tests the rendering of HTML content generated by the `explaincode.render_html` function. It verifies that markdown headings and code blocks are correctly processed. The test creates a dictionary with a single section containing a markdown title and a Python code block. It then checks that the resulting HTML contains an `&lt;h1&gt;` element with the title "Title" and that the code block is rendered as a `&lt;pre&gt;&lt;code&gt;` structure with the correct content.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">test_render_html_renders_markdown_headings_and_code</span>() <span style="color: #666666">-&gt;</span> <span style="color: #008000; font-weight: bold">None</span>:
    sections <span style="color: #666666">=</span> {
        <span style="color: #BA2121">"Intro"</span>: <span style="color: #BA2121">"# Title</span><span style="color: #AA5D1F; font-weight: bold">\n\n</span><span style="color: #BA2121">```python</span><span style="color: #AA5D1F; font-weight: bold">\n</span><span style="color: #BA2121">print('hi')</span><span style="color: #AA5D1F; font-weight: bold">\n</span><span style="color: #BA2121">```"</span>,
    }
    html <span style="color: #666666">=</span> explaincode<span style="color: #666666">.</span>render_html(sections, <span style="color: #BA2121">"Manual"</span>)
    soup <span style="color: #666666">=</span> BeautifulSoup(html, <span style="color: #BA2121">"html.parser"</span>)
    <span style="color: #008000; font-weight: bold">assert</span> soup<span style="color: #666666">.</span>find(<span style="color: #BA2121">"h1"</span>, string<span style="color: #666666">=</span><span style="color: #BA2121">"Title"</span>) <span style="color: #AA22FF; font-weight: bold">is</span> <span style="color: #AA22FF; font-weight: bold">not</span> <span style="color: #008000; font-weight: bold">None</span>
    code <span style="color: #666666">=</span> soup<span style="color: #666666">.</span>find(<span style="color: #BA2121">"pre"</span>)<span style="color: #666666">.</span>find(<span style="color: #BA2121">"code"</span>)
    <span style="color: #008000; font-weight: bold">assert</span> code <span style="color: #AA22FF; font-weight: bold">is</span> <span style="color: #AA22FF; font-weight: bold">not</span> <span style="color: #008000; font-weight: bold">None</span> <span style="color: #AA22FF; font-weight: bold">and</span> <span style="color: #BA2121">"print('hi')"</span> <span style="color: #AA22FF; font-weight: bold">in</span> code<span style="color: #666666">.</span>text
</code></pre>
<h3 id="test_render_html_includes_toc_and_sources_block">test_render_html_includes_toc_and_sources_block() -&gt; None</h3>
<p>The function `test_render_html_includes_toc_and_sources_block` tests the rendering of HTML output by the `explaincode.render_html` function. It verifies that the generated HTML includes a table of contents (TOC) with links to sections and source code blocks referencing the files used in the evidence. The test creates mock data for sections and their corresponding evidence, renders the HTML, parses it using BeautifulSoup, and asserts the presence of navigation links and source file references within the output.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">test_render_html_includes_toc_and_sources_block</span>() <span style="color: #666666">-&gt;</span> <span style="color: #008000; font-weight: bold">None</span>:
    sections <span style="color: #666666">=</span> {<span style="color: #BA2121">"Overview"</span>: <span style="color: #BA2121">""</span>, <span style="color: #BA2121">"How to Run"</span>: <span style="color: #BA2121">""</span>}
    evidence <span style="color: #666666">=</span> {
        <span style="color: #BA2121">"Overview"</span>: {<span style="color: #BA2121">"evidence"</span>: [{<span style="color: #BA2121">"snippet"</span>: <span style="color: #BA2121">"info"</span>, <span style="color: #BA2121">"file"</span>: <span style="color: #BA2121">"readme.md"</span>}]},
        <span style="color: #BA2121">"How to Run"</span>: {<span style="color: #BA2121">"evidence"</span>: [{<span style="color: #BA2121">"snippet"</span>: <span style="color: #BA2121">"run"</span>, <span style="color: #BA2121">"file"</span>: <span style="color: #BA2121">"run.py"</span>}]},
    }
    html <span style="color: #666666">=</span> explaincode<span style="color: #666666">.</span>render_html(sections, <span style="color: #BA2121">"Manual"</span>, evidence)
    soup <span style="color: #666666">=</span> BeautifulSoup(html, <span style="color: #BA2121">"html.parser"</span>)
    nav <span style="color: #666666">=</span> soup<span style="color: #666666">.</span>find(<span style="color: #BA2121">"nav"</span>)
    <span style="color: #008000; font-weight: bold">assert</span> nav <span style="color: #AA22FF; font-weight: bold">is</span> <span style="color: #AA22FF; font-weight: bold">not</span> <span style="color: #008000; font-weight: bold">None</span> <span style="color: #AA22FF; font-weight: bold">and</span> nav<span style="color: #666666">.</span>find(<span style="color: #BA2121">"a"</span>, href<span style="color: #666666">=</span><span style="color: #BA2121">"#overview"</span>) <span style="color: #AA22FF; font-weight: bold">is</span> <span style="color: #AA22FF; font-weight: bold">not</span> <span style="color: #008000; font-weight: bold">None</span>
    sources_blocks <span style="color: #666666">=</span> soup<span style="color: #666666">.</span>find_all(<span style="color: #BA2121">"div"</span>, class_<span style="color: #666666">=</span><span style="color: #BA2121">"sources"</span>)
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #008000">any</span>(<span style="color: #BA2121">"readme.md"</span> <span style="color: #AA22FF; font-weight: bold">in</span> block<span style="color: #666666">.</span>text <span style="color: #008000; font-weight: bold">for</span> block <span style="color: #AA22FF; font-weight: bold">in</span> sources_blocks)
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #008000">any</span>(<span style="color: #BA2121">"run.py"</span> <span style="color: #AA22FF; font-weight: bold">in</span> block<span style="color: #666666">.</span>text <span style="color: #008000; font-weight: bold">for</span> block <span style="color: #AA22FF; font-weight: bold">in</span> sources_blocks)
</code></pre>
<h3 id="test_html_summary_creation">test_html_summary_creation(tmp_path: Path, monkeypatch: pytest.MonkeyPatch) -&gt; None</h3>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">test_html_summary_creation</span>(tmp_path: Path, monkeypatch: pytest<span style="color: #666666">.</span>MonkeyPatch) <span style="color: #666666">-&gt;</span> <span style="color: #008000; font-weight: bold">None</span>:
    _create_fixture(tmp_path)
    monkeypatch<span style="color: #666666">.</span>setattr(explaincode, <span style="color: #BA2121">"LLMClient"</span>, _mock_llm_client)
    main([<span style="color: #BA2121">"--path"</span>, <span style="color: #008000">str</span>(tmp_path)])
    manual <span style="color: #666666">=</span> tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">"user_manual.html"</span>
    evidence <span style="color: #666666">=</span> tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">"user_manual_evidence.json"</span>
    <span style="color: #008000; font-weight: bold">assert</span> manual<span style="color: #666666">.</span>exists()
    <span style="color: #008000; font-weight: bold">assert</span> evidence<span style="color: #666666">.</span>exists()
    data <span style="color: #666666">=</span> json<span style="color: #666666">.</span>loads(evidence<span style="color: #666666">.</span>read_text(encoding<span style="color: #666666">=</span><span style="color: #BA2121">"utf-8"</span>))
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #BA2121">"Overview"</span> <span style="color: #AA22FF; font-weight: bold">in</span> data
    <span style="color: #008000; font-weight: bold">assert</span> data[<span style="color: #BA2121">"Overview"</span>][<span style="color: #BA2121">"evidence"</span>]
    html_text <span style="color: #666666">=</span> manual<span style="color: #666666">.</span>read_text(encoding<span style="color: #666666">=</span><span style="color: #BA2121">"utf-8"</span>)
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #BA2121">"No information provided."</span> <span style="color: #AA22FF; font-weight: bold">not</span> <span style="color: #AA22FF; font-weight: bold">in</span> html_text
    soup <span style="color: #666666">=</span> BeautifulSoup(html_text, <span style="color: #BA2121">"html.parser"</span>)
    nav <span style="color: #666666">=</span> soup<span style="color: #666666">.</span>find(<span style="color: #BA2121">"nav"</span>)
    <span style="color: #008000; font-weight: bold">assert</span> nav <span style="color: #AA22FF; font-weight: bold">is</span> <span style="color: #AA22FF; font-weight: bold">not</span> <span style="color: #008000; font-weight: bold">None</span> <span style="color: #AA22FF; font-weight: bold">and</span> nav<span style="color: #666666">.</span>find(<span style="color: #BA2121">"a"</span>, href<span style="color: #666666">=</span><span style="color: #BA2121">"#overview"</span>) <span style="color: #AA22FF; font-weight: bold">is</span> <span style="color: #AA22FF; font-weight: bold">not</span> <span style="color: #008000; font-weight: bold">None</span>
</code></pre>
<h3 id="test_pdf_summary_creation">test_pdf_summary_creation(tmp_path: Path, monkeypatch: pytest.MonkeyPatch) -&gt; None</h3>
<p>This function tests the creation of a PDF summary by verifying that the `reportlab` library is available, setting up a temporary directory with fixture data, mocking the LLM client, and executing the main documentation generation process with the PDF output format. It asserts that both the generated PDF file and an associated evidence JSON file are created in the specified output directory.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">test_pdf_summary_creation</span>(tmp_path: Path, monkeypatch: pytest<span style="color: #666666">.</span>MonkeyPatch) <span style="color: #666666">-&gt;</span> <span style="color: #008000; font-weight: bold">None</span>:
    <span style="color: #008000; font-weight: bold">if</span> importlib<span style="color: #666666">.</span>util<span style="color: #666666">.</span>find_spec(<span style="color: #BA2121">"reportlab"</span>) <span style="color: #AA22FF; font-weight: bold">is</span> <span style="color: #008000; font-weight: bold">None</span>:
        pytest<span style="color: #666666">.</span>skip(<span style="color: #BA2121">"reportlab not installed"</span>)
    _create_fixture(tmp_path)
    monkeypatch<span style="color: #666666">.</span>setattr(explaincode, <span style="color: #BA2121">"LLMClient"</span>, _mock_llm_client)
    main([<span style="color: #BA2121">"--path"</span>, <span style="color: #008000">str</span>(tmp_path), <span style="color: #BA2121">"--output-format"</span>, <span style="color: #BA2121">"pdf"</span>])
    <span style="color: #008000; font-weight: bold">assert</span> (tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">"user_manual.pdf"</span>)<span style="color: #666666">.</span>exists()
    <span style="color: #008000; font-weight: bold">assert</span> (tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">"user_manual_evidence.json"</span>)<span style="color: #666666">.</span>exists()
</code></pre>
<h3 id="test_graceful_missing_docx">test_graceful_missing_docx(monkeypatch: pytest.MonkeyPatch, tmp_path: Path) -&gt; None</h3>
<p>The function `test_graceful_missing_docx` tests the behavior of the documentation generation process when the `python-docx` library is unavailable. It creates a temporary directory fixture, simulates the absence of the `Document` class from `docx` by setting it to `None`, and mocks the `LLMClient` from the `explaincode` module. The function then invokes the main documentation generation entry point with the path set to the temporary directory. It asserts that the expected output files, `user_manual.html` and `user_manual_evidence.json`, are created in the directory, ensuring the process handles missing dependencies gracefully.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">test_graceful_missing_docx</span>(monkeypatch: pytest<span style="color: #666666">.</span>MonkeyPatch, tmp_path: Path) <span style="color: #666666">-&gt;</span> <span style="color: #008000; font-weight: bold">None</span>:
    _create_fixture(tmp_path)
    <span style="color: #008000; font-weight: bold">try</span>:
        <span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">docx</span> <span style="color: #008000; font-weight: bold">import</span> Document
    <span style="color: #008000; font-weight: bold">except</span> <span style="color: #CB3F38; font-weight: bold">Exception</span>:  <span style="color: #3D7B7B; font-style: italic"># pragma: no cover - dependency missing</span>
        Document <span style="color: #666666">=</span> <span style="color: #008000; font-weight: bold">None</span>  <span style="color: #3D7B7B; font-style: italic"># type: ignore</span>
    <span style="color: #008000; font-weight: bold">if</span> Document:
        doc <span style="color: #666666">=</span> Document()
        doc<span style="color: #666666">.</span>add_paragraph(<span style="color: #BA2121">"hi"</span>)
        doc<span style="color: #666666">.</span>save(tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">"guide.docx"</span>)
    monkeypatch<span style="color: #666666">.</span>setattr(explaincode, <span style="color: #BA2121">"Document"</span>, <span style="color: #008000; font-weight: bold">None</span>)
    monkeypatch<span style="color: #666666">.</span>setattr(explaincode, <span style="color: #BA2121">"LLMClient"</span>, _mock_llm_client)
    main([<span style="color: #BA2121">"--path"</span>, <span style="color: #008000">str</span>(tmp_path)])
    <span style="color: #008000; font-weight: bold">assert</span> (tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">"user_manual.html"</span>)<span style="color: #666666">.</span>exists()
    <span style="color: #008000; font-weight: bold">assert</span> (tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">"user_manual_evidence.json"</span>)<span style="color: #666666">.</span>exists()
</code></pre>
<h3 id="test_custom_output_directory">test_custom_output_directory(tmp_path: Path, monkeypatch: pytest.MonkeyPatch) -&gt; None</h3>
<p>The function `test_custom_output_directory` tests the functionality of specifying a custom output directory for documentation generation. It creates a temporary test environment using `_create_fixture`, sets up a target output directory within the temporary path, and mocks the `LLMClient` class from the `explaincode` module with a placeholder implementation `_mock_llm_client`. The main documentation generation process is invoked with command-line arguments specifying the source path and output path. The test verifies that the expected output files, namely `user_manual.html` and `user_manual_evidence.json`, are created in the specified custom output directory.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">test_custom_output_directory</span>(tmp_path: Path, monkeypatch: pytest<span style="color: #666666">.</span>MonkeyPatch) <span style="color: #666666">-&gt;</span> <span style="color: #008000; font-weight: bold">None</span>:
    _create_fixture(tmp_path)
    out_dir <span style="color: #666666">=</span> tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">"dist"</span>
    monkeypatch<span style="color: #666666">.</span>setattr(explaincode, <span style="color: #BA2121">"LLMClient"</span>, _mock_llm_client)
    main([<span style="color: #BA2121">"--path"</span>, <span style="color: #008000">str</span>(tmp_path), <span style="color: #BA2121">"--output"</span>, <span style="color: #008000">str</span>(out_dir)])
    <span style="color: #008000; font-weight: bold">assert</span> (out_dir <span style="color: #666666">/</span> <span style="color: #BA2121">"user_manual.html"</span>)<span style="color: #666666">.</span>exists()
    <span style="color: #008000; font-weight: bold">assert</span> (out_dir <span style="color: #666666">/</span> <span style="color: #BA2121">"user_manual_evidence.json"</span>)<span style="color: #666666">.</span>exists()
</code></pre>
<h3 id="test_collect_docs_filters">test_collect_docs_filters(tmp_path: Path) -&gt; None</h3>
<p>The function `test_collect_docs_filters` tests the `explaincode.collect_docs` utility by creating a temporary directory structure with multiple files of different extensions. It verifies that `collect_docs` correctly identifies and returns only files with the `.md` extension, excluding those with other extensions such as `.txt`. The test confirms that the function filters files based on their extensions, ensuring that only Markdown files are included in the returned list.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">test_collect_docs_filters</span>(tmp_path: Path) <span style="color: #666666">-&gt;</span> <span style="color: #008000; font-weight: bold">None</span>:
    (tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">"docs"</span>)<span style="color: #666666">.</span>mkdir()
    (tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">"docs"</span> <span style="color: #666666">/</span> <span style="color: #BA2121">"keep.md"</span>)<span style="color: #666666">.</span>write_text(<span style="color: #BA2121">"hi"</span>, encoding<span style="color: #666666">=</span><span style="color: #BA2121">"utf-8"</span>)
    (tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">"docs"</span> <span style="color: #666666">/</span> <span style="color: #BA2121">"skip.txt"</span>)<span style="color: #666666">.</span>write_text(<span style="color: #BA2121">"no"</span>, encoding<span style="color: #666666">=</span><span style="color: #BA2121">"utf-8"</span>)
    (tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">"README.md"</span>)<span style="color: #666666">.</span>write_text(<span style="color: #BA2121">"readme"</span>, encoding<span style="color: #666666">=</span><span style="color: #BA2121">"utf-8"</span>)
    (tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">"extra.md"</span>)<span style="color: #666666">.</span>write_text(<span style="color: #BA2121">"extra"</span>, encoding<span style="color: #666666">=</span><span style="color: #BA2121">"utf-8"</span>)
    files <span style="color: #666666">=</span> explaincode<span style="color: #666666">.</span>collect_docs(tmp_path)
    names <span style="color: #666666">=</span> {f<span style="color: #666666">.</span>name <span style="color: #008000; font-weight: bold">for</span> f <span style="color: #AA22FF; font-weight: bold">in</span> files}
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #BA2121">"keep.md"</span> <span style="color: #AA22FF; font-weight: bold">in</span> names <span style="color: #AA22FF; font-weight: bold">and</span> <span style="color: #BA2121">"skip.txt"</span> <span style="color: #AA22FF; font-weight: bold">not</span> <span style="color: #AA22FF; font-weight: bold">in</span> names
</code></pre>
<h3 id="test_map_evidence_overview_priority_and_filters">test_map_evidence_overview_priority_and_filters() -&gt; None</h3>
<p>The function `test_map_evidence_overview_priority_and_filters` tests the behavior of `explaincode.map_evidence_to_sections` by evaluating how it processes a set of documentation files and organizes them under the "Overview" section. It verifies that certain files, specifically those located in `tests/`, `examples/`, and `fixtures/` directories, are excluded from the results, while files in `README.md`, `docs/guide.md`, and `src/other.md` are included. The test ensures that the priority of inclusion is maintained, with `README.md` and `docs/guide.md` appearing first in the list of sources, followed by `src/other.md`. The function does not return any value but asserts the expected filtering and ordering behavior of the mapping process.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">test_map_evidence_overview_priority_and_filters</span>() <span style="color: #666666">-&gt;</span> <span style="color: #008000; font-weight: bold">None</span>:
    docs <span style="color: #666666">=</span> {
        Path(<span style="color: #BA2121">"README.md"</span>): <span style="color: #BA2121">"# Overview</span><span style="color: #AA5D1F; font-weight: bold">\n</span><span style="color: #BA2121">readme info"</span>,
        Path(<span style="color: #BA2121">"docs/guide.md"</span>): <span style="color: #BA2121">"# Overview</span><span style="color: #AA5D1F; font-weight: bold">\n</span><span style="color: #BA2121">docs info"</span>,
        Path(<span style="color: #BA2121">"src/other.md"</span>): <span style="color: #BA2121">"# Overview</span><span style="color: #AA5D1F; font-weight: bold">\n</span><span style="color: #BA2121">other info"</span>,
        Path(<span style="color: #BA2121">"tests/ignore.md"</span>): <span style="color: #BA2121">"# Overview</span><span style="color: #AA5D1F; font-weight: bold">\n</span><span style="color: #BA2121">test info"</span>,
        Path(<span style="color: #BA2121">"examples/ignore.md"</span>): <span style="color: #BA2121">"# Overview</span><span style="color: #AA5D1F; font-weight: bold">\n</span><span style="color: #BA2121">example info"</span>,
        Path(<span style="color: #BA2121">"fixtures/ignore.md"</span>): <span style="color: #BA2121">"# Overview</span><span style="color: #AA5D1F; font-weight: bold">\n</span><span style="color: #BA2121">fixture info"</span>,
    }
    section_map, _ <span style="color: #666666">=</span> explaincode<span style="color: #666666">.</span>map_evidence_to_sections(docs)
    sources <span style="color: #666666">=</span> [p<span style="color: #666666">.</span>as_posix() <span style="color: #008000; font-weight: bold">for</span> p, _ <span style="color: #AA22FF; font-weight: bold">in</span> section_map[<span style="color: #BA2121">"Overview"</span>]]
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #BA2121">"tests/ignore.md"</span> <span style="color: #AA22FF; font-weight: bold">not</span> <span style="color: #AA22FF; font-weight: bold">in</span> sources
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #BA2121">"examples/ignore.md"</span> <span style="color: #AA22FF; font-weight: bold">not</span> <span style="color: #AA22FF; font-weight: bold">in</span> sources
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #BA2121">"fixtures/ignore.md"</span> <span style="color: #AA22FF; font-weight: bold">not</span> <span style="color: #AA22FF; font-weight: bold">in</span> sources
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #008000">set</span>(sources[:<span style="color: #666666">2</span>]) <span style="color: #666666">==</span> {<span style="color: #BA2121">"README.md"</span>, <span style="color: #BA2121">"docs/guide.md"</span>}
    <span style="color: #008000; font-weight: bold">assert</span> sources[<span style="color: #666666">2</span>] <span style="color: #666666">==</span> <span style="color: #BA2121">"src/other.md"</span>
</code></pre>
<h3 id="test_map_evidence_snippet_limits">test_map_evidence_snippet_limits() -&gt; None</h3>
<p>The function `test_map_evidence_snippet_limits` tests the behavior of the `map_evidence_to_sections` function when processing documentation content that exceeds a maximum line limit for snippets. It creates two mock documentation files (`src/long.md` and `tests/short.md`) with content containing more lines than the defined maximum (`explaincode.MAX_SNIPPET_LINES`). The test verifies that:

2. The last line within the allowed limit is included in the snippet for `src/long.md`.
3. The snippet for `tests/short.md` is correctly truncated to only the initial section header (`# Inputs`).

This ensures that the function properly enforces the maximum snippet line limit when mapping evidence to sections.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">test_map_evidence_snippet_limits</span>() <span style="color: #666666">-&gt;</span> <span style="color: #008000; font-weight: bold">None</span>:
    long_content <span style="color: #666666">=</span> <span style="color: #BA2121">"# Inputs</span><span style="color: #AA5D1F; font-weight: bold">\n</span><span style="color: #BA2121">"</span> <span style="color: #666666">+</span> <span style="color: #BA2121">"</span><span style="color: #AA5D1F; font-weight: bold">\n</span><span style="color: #BA2121">"</span><span style="color: #666666">.</span>join(
        <span style="color: #BA2121">f"line </span><span style="color: #A45A77; font-weight: bold">{</span>i<span style="color: #A45A77; font-weight: bold">}</span><span style="color: #BA2121">"</span> <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(<span style="color: #666666">1</span>, explaincode<span style="color: #666666">.</span>MAX_SNIPPET_LINES <span style="color: #666666">+</span> <span style="color: #666666">10</span>)
    )
    docs <span style="color: #666666">=</span> {
        Path(<span style="color: #BA2121">"src/long.md"</span>): long_content,
        Path(<span style="color: #BA2121">"tests/short.md"</span>): long_content,
    }
    section_map, _ <span style="color: #666666">=</span> explaincode<span style="color: #666666">.</span>map_evidence_to_sections(docs)
    snippets <span style="color: #666666">=</span> {p<span style="color: #666666">.</span>as_posix(): snip <span style="color: #008000; font-weight: bold">for</span> p, snip <span style="color: #AA22FF; font-weight: bold">in</span> section_map[<span style="color: #BA2121">"Inputs"</span>]}
    <span style="color: #008000; font-weight: bold">assert</span> (
        <span style="color: #BA2121">f"line </span><span style="color: #A45A77; font-weight: bold">{</span>explaincode<span style="color: #666666">.</span>MAX_SNIPPET_LINES<span style="color: #bbbbbb"> </span><span style="color: #666666">+</span><span style="color: #bbbbbb"> </span><span style="color: #666666">1</span><span style="color: #A45A77; font-weight: bold">}</span><span style="color: #BA2121">"</span> <span style="color: #AA22FF; font-weight: bold">not</span> <span style="color: #AA22FF; font-weight: bold">in</span> snippets[<span style="color: #BA2121">"src/long.md"</span>]
    )
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #BA2121">f"line </span><span style="color: #A45A77; font-weight: bold">{</span>explaincode<span style="color: #666666">.</span>MAX_SNIPPET_LINES<span style="color: #A45A77; font-weight: bold">}</span><span style="color: #BA2121">"</span> <span style="color: #AA22FF; font-weight: bold">in</span> snippets[<span style="color: #BA2121">"src/long.md"</span>]
    <span style="color: #008000; font-weight: bold">assert</span> snippets[<span style="color: #BA2121">"tests/short.md"</span>] <span style="color: #666666">==</span> <span style="color: #BA2121">"# Inputs"</span>
</code></pre>
<h3 id="test_detect_placeholders">test_detect_placeholders() -&gt; None</h3>
<p>The function `test_detect_placeholders` tests the `detect_placeholders` function from the `explaincode` module. It verifies that the function correctly identifies placeholder strings in a given text, specifically `"[[NEEDS_OVERVIEW]]"` and `"[[NEEDS_OUTPUTS]]"`, and returns a set containing the corresponding placeholder names, `"Overview"` and `"Outputs"`. The test ensures that the detection logic accurately extracts these placeholders from a formatted input string.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">test_detect_placeholders</span>() <span style="color: #666666">-&gt;</span> <span style="color: #008000; font-weight: bold">None</span>:
    text <span style="color: #666666">=</span> <span style="color: #BA2121">"Overview: [[NEEDS_OVERVIEW]]</span><span style="color: #AA5D1F; font-weight: bold">\n</span><span style="color: #BA2121">Inputs: data</span><span style="color: #AA5D1F; font-weight: bold">\n</span><span style="color: #BA2121">Outputs: [[NEEDS_OUTPUTS]]"</span>
    missing <span style="color: #666666">=</span> explaincode<span style="color: #666666">.</span>detect_placeholders(text)
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #008000">set</span>(missing) <span style="color: #666666">==</span> {<span style="color: #BA2121">"Overview"</span>, <span style="color: #BA2121">"Outputs"</span>}
</code></pre>
<h3 id="test_parse_manual_infers_missing_sections">test_parse_manual_infers_missing_sections() -&gt; None</h3>
<p>The function `test_parse_manual_infers_missing_sections` tests the behavior of the `explaincode.parse_manual` function when processing a manually provided code overview. It verifies that the function correctly extracts the "Overview" section and infers the "Inputs" section by appending "(inferred)" to it, while ensuring that the placeholder text "No information provided." does not appear in the inferred section. The test uses a stub client that returns a fixed response to simulate the behavior of a language model.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">test_parse_manual_infers_missing_sections</span>() <span style="color: #666666">-&gt;</span> <span style="color: #008000; font-weight: bold">None</span>:
    <span style="color: #008000; font-weight: bold">class</span> <span style="color: #0000FF; font-weight: bold">Stub</span>:
        <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">summarize</span>(<span style="color: #008000">self</span>, prompt: <span style="color: #008000">str</span>, prompt_type: <span style="color: #008000">str</span>, system_prompt: <span style="color: #008000">str</span> <span style="color: #666666">=</span> <span style="color: #BA2121">""</span>) <span style="color: #666666">-&gt;</span> <span style="color: #008000">str</span>:
            <span style="color: #008000; font-weight: bold">return</span> <span style="color: #BA2121">"guessed"</span>

    client <span style="color: #666666">=</span> Stub()
    parsed <span style="color: #666666">=</span> explaincode<span style="color: #666666">.</span>parse_manual(<span style="color: #BA2121">"Overview: hi"</span>, client<span style="color: #666666">=</span>client)
    <span style="color: #008000; font-weight: bold">assert</span> parsed[<span style="color: #BA2121">"Overview"</span>] <span style="color: #666666">==</span> <span style="color: #BA2121">"hi"</span>
    <span style="color: #008000; font-weight: bold">assert</span> parsed[<span style="color: #BA2121">"Inputs"</span>]<span style="color: #666666">.</span>endswith(<span style="color: #BA2121">"(inferred)"</span>)
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #BA2121">"No information provided."</span> <span style="color: #AA22FF; font-weight: bold">not</span> <span style="color: #AA22FF; font-weight: bold">in</span> parsed[<span style="color: #BA2121">"Inputs"</span>]
</code></pre>
<h3 id="test_validate_manual_references_flags_missing">test_validate_manual_references_flags_missing(tmp_path: Path) -&gt; None</h3>
<p>The function `test_validate_manual_references_flags_missing` tests the behavior of `validate_manual_references` when processing manual references in documentation sections. It creates a temporary Python file (`exists.py`) with minimal content, defines a section containing references to both an existing file (`exists.py`) and a missing file (`missing.py`). The function then calls `validate_manual_references` to process these references, updating the section text and evidence dictionary. The test asserts that the existing file reference is preserved in the updated section, the missing file reference is appended with `[missing]`, and the evidence dictionary correctly records the missing reference. This validates the handling of missing file references during documentation generation.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">test_validate_manual_references_flags_missing</span>(tmp_path: Path) <span style="color: #666666">-&gt;</span> <span style="color: #008000; font-weight: bold">None</span>:
    (tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">"exists.py"</span>)<span style="color: #666666">.</span>write_text(<span style="color: #BA2121">"pass"</span>, encoding<span style="color: #666666">=</span><span style="color: #BA2121">"utf-8"</span>)
    sections <span style="color: #666666">=</span> {<span style="color: #BA2121">"Overview"</span>: <span style="color: #BA2121">"See exists.py and missing.py for details"</span>}
    evidence: <span style="color: #008000">dict</span>[<span style="color: #008000">str</span>, <span style="color: #008000">dict</span>[<span style="color: #008000">str</span>, <span style="color: #008000">object</span>]] <span style="color: #666666">=</span> {}
    explaincode<span style="color: #666666">.</span>validate_manual_references(sections, tmp_path, evidence)
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #BA2121">"exists.py"</span> <span style="color: #AA22FF; font-weight: bold">in</span> sections[<span style="color: #BA2121">"Overview"</span>]
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #BA2121">"missing.py [missing]"</span> <span style="color: #AA22FF; font-weight: bold">in</span> sections[<span style="color: #BA2121">"Overview"</span>]
    <span style="color: #008000; font-weight: bold">assert</span> evidence[<span style="color: #BA2121">"Overview"</span>][<span style="color: #BA2121">"missing_references"</span>] <span style="color: #666666">==</span> [<span style="color: #BA2121">"missing.py"</span>]
</code></pre>
<h3 id="test_infer_sections_infers_entries">test_infer_sections_infers_entries() -&gt; None</h3>
<p>The function `test_infer_sections_infers_entries` tests the behavior of the `explaincode.infer_sections` function. It verifies that when given a context string, the function returns a dictionary of sections where:


This test ensures that the section inference logic correctly populates sections based on the input context and applies consistent formatting to inferred content.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">test_infer_sections_infers_entries</span>() <span style="color: #666666">-&gt;</span> <span style="color: #008000; font-weight: bold">None</span>:
    sections <span style="color: #666666">=</span> explaincode<span style="color: #666666">.</span>infer_sections(<span style="color: #BA2121">"Some context"</span>)
    <span style="color: #008000; font-weight: bold">assert</span> sections[<span style="color: #BA2121">"Overview"</span>] <span style="color: #666666">==</span> <span style="color: #BA2121">"Some context"</span>
    <span style="color: #008000; font-weight: bold">for</span> key <span style="color: #AA22FF; font-weight: bold">in</span> explaincode<span style="color: #666666">.</span>REQUIRED_SECTIONS:
        <span style="color: #008000; font-weight: bold">if</span> key <span style="color: #666666">!=</span> <span style="color: #BA2121">"Overview"</span>:
            <span style="color: #008000; font-weight: bold">assert</span> sections[key]<span style="color: #666666">.</span>endswith(<span style="color: #BA2121">"(inferred)"</span>)
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #BA2121">"No information provided."</span> <span style="color: #AA22FF; font-weight: bold">not</span> <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #BA2121">""</span><span style="color: #666666">.</span>join(sections<span style="color: #666666">.</span>values())
</code></pre>
<h3 id="test_infer_sections_no_context_defaults">test_infer_sections_no_context_defaults() -&gt; None</h3>
<p>The function `test_infer_sections_no_context_defaults` tests the behavior of the `explaincode.infer_sections` method when called with an empty string as input. It verifies that all values in the returned dictionary are set to the default message "No information provided." This ensures consistent handling of empty or null input by the section inference logic.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">test_infer_sections_no_context_defaults</span>() <span style="color: #666666">-&gt;</span> <span style="color: #008000; font-weight: bold">None</span>:
    sections <span style="color: #666666">=</span> explaincode<span style="color: #666666">.</span>infer_sections(<span style="color: #BA2121">""</span>)
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #008000">all</span>(v <span style="color: #666666">==</span> <span style="color: #BA2121">"No information provided."</span> <span style="color: #008000; font-weight: bold">for</span> v <span style="color: #AA22FF; font-weight: bold">in</span> sections<span style="color: #666666">.</span>values())
</code></pre>
<h3 id="test_extract_snippets_skips_large_file">test_extract_snippets_skips_large_file(tmp_path: Path, caplog: pytest.LogCaptureFixture) -&gt; None</h3>
<p>The function `test_extract_snippets_skips_large_file` tests the behavior of the `explaincode.extract_snippets` function when processing a file that exceeds a specified size limit. It creates a large Python file filled with repeated bytes, then calls `extract_snippets` with parameters that restrict the maximum file size. The test verifies that the large file is excluded from the returned snippets and that an appropriate log message indicating the file size exceeded the limit is generated.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">test_extract_snippets_skips_large_file</span>(
    tmp_path: Path, caplog: pytest<span style="color: #666666">.</span>LogCaptureFixture
) <span style="color: #666666">-&gt;</span> <span style="color: #008000; font-weight: bold">None</span>:
    big_file <span style="color: #666666">=</span> tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">"big.py"</span>
    big_file<span style="color: #666666">.</span>write_bytes(<span style="color: #BA2121">b"a"</span> <span style="color: #666666">*</span> <span style="color: #666666">210_000</span>)
    caplog<span style="color: #666666">.</span>set_level(logging<span style="color: #666666">.</span>INFO)
    snippets <span style="color: #666666">=</span> explaincode<span style="color: #666666">.</span>extract_snippets(
        [big_file], max_files<span style="color: #666666">=1</span>, time_budget<span style="color: #666666">=5</span>, max_bytes<span style="color: #666666">=200_000</span>
    )
    <span style="color: #008000; font-weight: bold">assert</span> big_file <span style="color: #AA22FF; font-weight: bold">not</span> <span style="color: #AA22FF; font-weight: bold">in</span> snippets
    log <span style="color: #666666">=</span> caplog<span style="color: #666666">.</span>text
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #BA2121">"file size"</span> <span style="color: #AA22FF; font-weight: bold">in</span> log <span style="color: #AA22FF; font-weight: bold">and</span> <span style="color: #BA2121">"exceeds limit"</span> <span style="color: #AA22FF; font-weight: bold">in</span> log
</code></pre>
<h3 id="test_scan_code_skips_non_source_dirs">test_scan_code_skips_non_source_dirs(tmp_path: Path, monkeypatch: pytest.MonkeyPatch) -&gt; None</h3>
<p>The function `test_scan_code_skips_non_source_dirs` tests that the `scan_code` function correctly excludes non-source directories (such as `tests` and `examples`) when analyzing a project structure. It creates a temporary directory with source code in a `src` folder and test/example files in `tests` and `examples` folders, then verifies that only files from the `src` directory are included in the scan results under the "How to Run" category. The test uses `monkeypatch` to mock the `collect_docs` function and ensures that `scan_code` respects directory filtering based on the provided configuration.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">test_scan_code_skips_non_source_dirs</span>(
    tmp_path: Path, monkeypatch: pytest<span style="color: #666666">.</span>MonkeyPatch
) <span style="color: #666666">-&gt;</span> <span style="color: #008000; font-weight: bold">None</span>:
    src <span style="color: #666666">=</span> tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">"src"</span>
    src<span style="color: #666666">.</span>mkdir()
    (src <span style="color: #666666">/</span> <span style="color: #BA2121">"main.py"</span>)<span style="color: #666666">.</span>write_text(<span style="color: #BA2121">'"""run code"""'</span>, encoding<span style="color: #666666">=</span><span style="color: #BA2121">"utf-8"</span>)

    tests_dir <span style="color: #666666">=</span> tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">"tests"</span>
    tests_dir<span style="color: #666666">.</span>mkdir()
    (tests_dir <span style="color: #666666">/</span> <span style="color: #BA2121">"test_main.py"</span>)<span style="color: #666666">.</span>write_text(<span style="color: #BA2121">'"""run tests"""'</span>, encoding<span style="color: #666666">=</span><span style="color: #BA2121">"utf-8"</span>)

    examples_dir <span style="color: #666666">=</span> tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">"examples"</span>
    examples_dir<span style="color: #666666">.</span>mkdir()
    (examples_dir <span style="color: #666666">/</span> <span style="color: #BA2121">"example.py"</span>)<span style="color: #666666">.</span>write_text(<span style="color: #BA2121">'"""run example"""'</span>, encoding<span style="color: #666666">=</span><span style="color: #BA2121">"utf-8"</span>)

    monkeypatch<span style="color: #666666">.</span>setattr(explaincode, <span style="color: #BA2121">"collect_docs"</span>, <span style="color: #008000; font-weight: bold">lambda</span> base: [])
    result <span style="color: #666666">=</span> explaincode<span style="color: #666666">.</span>scan_code(
        tmp_path, [<span style="color: #BA2121">"How to Run"</span>], max_files<span style="color: #666666">=5</span>, time_budget<span style="color: #666666">=5</span>, max_bytes_per_file<span style="color: #666666">=1000</span>
    )

    how_to_run <span style="color: #666666">=</span> result<span style="color: #666666">.</span>get(<span style="color: #BA2121">"How to Run"</span>, {})
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #008000">set</span>(how_to_run<span style="color: #666666">.</span>keys()) <span style="color: #666666">==</span> {<span style="color: #BA2121">"src/main.py"</span>}
</code></pre>
<h3 id="test_scan_code_categorizes_snippets">test_scan_code_categorizes_snippets(tmp_path: Path, monkeypatch: pytest.MonkeyPatch) -&gt; None</h3>
<p>The function `test_scan_code_categorizes_snippets` tests the `scan_code` function from the `explaincode` module. It creates three empty Python files in a temporary directory, patches several functions in `explaincode` to return predefined values, and then calls `scan_code` with specific categories and parameters. The test verifies that the output of `scan_code` correctly maps file paths to their respective snippet content based on the provided categories. Specifically, it checks that the "Inputs" category contains the snippet from the first file, "Outputs" from the second file, and "How to Run" from the third file.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">test_scan_code_categorizes_snippets</span>(
    tmp_path: Path, monkeypatch: pytest<span style="color: #666666">.</span>MonkeyPatch
) <span style="color: #666666">-&gt;</span> <span style="color: #008000; font-weight: bold">None</span>:
    paths <span style="color: #666666">=</span> [tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">"a.py"</span>, tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">"b.py"</span>, tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">"c.py"</span>]
    <span style="color: #008000; font-weight: bold">for</span> p <span style="color: #AA22FF; font-weight: bold">in</span> paths:
        p<span style="color: #666666">.</span>write_text(<span style="color: #BA2121">""</span>, encoding<span style="color: #666666">=</span><span style="color: #BA2121">"utf-8"</span>)

    monkeypatch<span style="color: #666666">.</span>setattr(explaincode, <span style="color: #BA2121">"collect_docs"</span>, <span style="color: #008000; font-weight: bold">lambda</span> base: [])
    monkeypatch<span style="color: #666666">.</span>setattr(explaincode, <span style="color: #BA2121">"rank_code_files"</span>, <span style="color: #008000; font-weight: bold">lambda</span> base, patterns: paths)

    <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">fake_extract</span>(
        files: Iterable[Path], <span style="color: #666666">*</span>, max_files: <span style="color: #008000">int</span>, time_budget: <span style="color: #008000">int</span>, max_bytes: <span style="color: #008000">int</span>
    ) <span style="color: #666666">-&gt;</span> <span style="color: #008000">dict</span>[Path, <span style="color: #008000">str</span>]:
        <span style="color: #008000; font-weight: bold">return</span> {
            paths[<span style="color: #666666">0</span>]: <span style="color: #BA2121">"read input from user"</span>,
            paths[<span style="color: #666666">1</span>]: <span style="color: #BA2121">"write output"</span>,
            paths[<span style="color: #666666">2</span>]: <span style="color: #BA2121">"run the tool"</span>,
        }

    monkeypatch<span style="color: #666666">.</span>setattr(explaincode, <span style="color: #BA2121">"extract_snippets"</span>, fake_extract)

    result <span style="color: #666666">=</span> explaincode<span style="color: #666666">.</span>scan_code(
        tmp_path, [<span style="color: #BA2121">"Inputs"</span>, <span style="color: #BA2121">"Outputs"</span>, <span style="color: #BA2121">"How to Run"</span>], max_files<span style="color: #666666">=3</span>, time_budget<span style="color: #666666">=5</span>, max_bytes_per_file<span style="color: #666666">=1000</span>
    )
    <span style="color: #008000; font-weight: bold">assert</span> result[<span style="color: #BA2121">"Inputs"</span>] <span style="color: #666666">==</span> {<span style="color: #BA2121">"a.py"</span>: <span style="color: #BA2121">"read input from user"</span>}
    <span style="color: #008000; font-weight: bold">assert</span> result[<span style="color: #BA2121">"Outputs"</span>] <span style="color: #666666">==</span> {<span style="color: #BA2121">"b.py"</span>: <span style="color: #BA2121">"write output"</span>}
    <span style="color: #008000; font-weight: bold">assert</span> result[<span style="color: #BA2121">"How to Run"</span>] <span style="color: #666666">==</span> {<span style="color: #BA2121">"c.py"</span>: <span style="color: #BA2121">"run the tool"</span>}
</code></pre>
<details>
<summary>Subfunction: fake_extract(files: Iterable[Path], *, max_files: int, time_budget: int, max_bytes: int) -&gt; dict[Path, str]</summary>
<h4 id="fake_extract">fake_extract(files: Iterable[Path], *, max_files: int, time_budget: int, max_bytes: int) -&gt; dict[Path, str]</h4>
<p>The function `fake_extract` takes an iterable of file paths and several configuration parameters, then returns a dictionary mapping the first three paths to predefined string descriptions. The parameters `max_files`, `time_budget`, and `max_bytes` are unused in the implementation. The returned dictionary contains fixed string values for the first three paths in the input iterable, representing simplified actions: "read input from user", "write output", and "run the tool".</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">fake_extract</span>(
        files: Iterable[Path], <span style="color: #666666">*</span>, max_files: <span style="color: #008000">int</span>, time_budget: <span style="color: #008000">int</span>, max_bytes: <span style="color: #008000">int</span>
    ) <span style="color: #666666">-&gt;</span> <span style="color: #008000">dict</span>[Path, <span style="color: #008000">str</span>]:
        <span style="color: #008000; font-weight: bold">return</span> {
            paths[<span style="color: #666666">0</span>]: <span style="color: #BA2121">"read input from user"</span>,
            paths[<span style="color: #666666">1</span>]: <span style="color: #BA2121">"write output"</span>,
            paths[<span style="color: #666666">2</span>]: <span style="color: #BA2121">"run the tool"</span>,
        }
</code></pre>
</details>
<h3 id="test_rank_code_files_supports_cpp_h_java">test_rank_code_files_supports_cpp_h_java(tmp_path: Path) -&gt; None</h3>
<p>The function `test_rank_code_files_supports_cpp_h_java` tests the `rank_code_files` function from the `explaincode` module. It creates a temporary directory with multiple files of different types, including Python (.py), C++ source (.cpp), C++ header (.h), and Java (.java) files, as well as an ignored text file (.txt). The test calls `rank_code_files` on the temporary directory and verifies that the returned list of files includes the code files (main.py, lib.cpp, lib.h, Main.java) while excluding the non-code file (ignore.txt). The assertion confirms that the code files are present in the ranked output and that the text file is not included.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">test_rank_code_files_supports_cpp_h_java</span>(tmp_path: Path) <span style="color: #666666">-&gt;</span> <span style="color: #008000; font-weight: bold">None</span>:
    files <span style="color: #666666">=</span> [
        tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">"main.py"</span>,
        tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">"lib.cpp"</span>,
        tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">"lib.h"</span>,
        tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">"Main.java"</span>,
        tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">"ignore.txt"</span>,
    ]
    <span style="color: #008000; font-weight: bold">for</span> f <span style="color: #AA22FF; font-weight: bold">in</span> files:
        f<span style="color: #666666">.</span>write_text(<span style="color: #BA2121">""</span>, encoding<span style="color: #666666">=</span><span style="color: #BA2121">"utf-8"</span>)
    ranked <span style="color: #666666">=</span> explaincode<span style="color: #666666">.</span>rank_code_files(tmp_path, [])
    names <span style="color: #666666">=</span> {p<span style="color: #666666">.</span>name <span style="color: #008000; font-weight: bold">for</span> p <span style="color: #AA22FF; font-weight: bold">in</span> ranked}
    <span style="color: #008000; font-weight: bold">assert</span> {<span style="color: #BA2121">"main.py"</span>, <span style="color: #BA2121">"lib.cpp"</span>, <span style="color: #BA2121">"lib.h"</span>, <span style="color: #BA2121">"Main.java"</span>} <span style="color: #666666">&lt;=</span> names
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #BA2121">"ignore.txt"</span> <span style="color: #AA22FF; font-weight: bold">not</span> <span style="color: #AA22FF; font-weight: bold">in</span> names
</code></pre>
<h3 id="test_llm_fill_placeholders_per_section_logging">test_llm_fill_placeholders_per_section_logging(tmp_path: Path, caplog: pytest.LogCaptureFixture) -&gt; None</h3>
<p>The function `test_llm_fill_placeholders_per_section_logging` tests the behavior of `explaincode.llm_fill_placeholders` by simulating an LLM client and verifying placeholder replacement and logging. It uses a dummy client that processes input text to identify section placeholders and replaces them with filled values. The test ensures that placeholders for "Inputs" and "Outputs" are correctly replaced and that corresponding log messages are generated indicating the source files used for each replacement. The function also verifies that the LLM client is called twice, once for each section.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">test_llm_fill_placeholders_per_section_logging</span>(
    tmp_path: Path, caplog: pytest<span style="color: #666666">.</span>LogCaptureFixture
) <span style="color: #666666">-&gt;</span> <span style="color: #008000; font-weight: bold">None</span>:
    manual <span style="color: #666666">=</span> <span style="color: #BA2121">"Inputs: [[NEEDS_INPUTS]]</span><span style="color: #AA5D1F; font-weight: bold">\n</span><span style="color: #BA2121">Outputs: [[NEEDS_OUTPUTS]]"</span>
    evidence <span style="color: #666666">=</span> {
        <span style="color: #BA2121">"Inputs"</span>: {<span style="color: #BA2121">"in.py"</span>: <span style="color: #BA2121">"input data"</span>},
        <span style="color: #BA2121">"Outputs"</span>: {<span style="color: #BA2121">"out.py"</span>: <span style="color: #BA2121">"output data"</span>},
    }

    <span style="color: #008000; font-weight: bold">class</span> <span style="color: #0000FF; font-weight: bold">Dummy</span>:
        <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">__init__</span>(<span style="color: #008000">self</span>) <span style="color: #666666">-&gt;</span> <span style="color: #008000; font-weight: bold">None</span>:
            <span style="color: #008000">self</span><span style="color: #666666">.</span>calls: <span style="color: #008000">list</span>[<span style="color: #008000">str</span>] <span style="color: #666666">=</span> []

        <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">summarize</span>(
            <span style="color: #008000">self</span>, text: <span style="color: #008000">str</span>, prompt_type: <span style="color: #008000">str</span>, system_prompt: <span style="color: #008000">str</span> <span style="color: #666666">=</span> <span style="color: #BA2121">""</span>
        ) <span style="color: #666666">-&gt;</span> <span style="color: #008000">str</span>:
            <span style="color: #008000">self</span><span style="color: #666666">.</span>calls<span style="color: #666666">.</span>append(text)
            manual_match <span style="color: #666666">=</span> re<span style="color: #666666">.</span>search(<span style="color: #BA2121">r"Manual:\n(.*?)\n\nSection:"</span>, text, re<span style="color: #666666">.</span>DOTALL)
            section_match <span style="color: #666666">=</span> re<span style="color: #666666">.</span>search(<span style="color: #BA2121">r"Section: (.*?)\n"</span>, text)
            manual_text <span style="color: #666666">=</span> manual_match<span style="color: #666666">.</span>group(<span style="color: #666666">1</span>)
            section <span style="color: #666666">=</span> section_match<span style="color: #666666">.</span>group(<span style="color: #666666">1</span>)
            token <span style="color: #666666">=</span> explaincode<span style="color: #666666">.</span>SECTION_PLACEHOLDERS[section]
            <span style="color: #008000; font-weight: bold">return</span> manual_text<span style="color: #666666">.</span>replace(token, <span style="color: #BA2121">f"filled </span><span style="color: #A45A77; font-weight: bold">{</span>section<span style="color: #A45A77; font-weight: bold">}</span><span style="color: #BA2121">"</span>)

    client <span style="color: #666666">=</span> Dummy()
    cache <span style="color: #666666">=</span> ResponseCache(<span style="color: #008000">str</span>(tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">"cache.json"</span>))
    caplog<span style="color: #666666">.</span>set_level(logging<span style="color: #666666">.</span>INFO)
    result <span style="color: #666666">=</span> explaincode<span style="color: #666666">.</span>llm_fill_placeholders(manual, evidence, client, cache)
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #BA2121">"filled Inputs"</span> <span style="color: #AA22FF; font-weight: bold">in</span> result <span style="color: #AA22FF; font-weight: bold">and</span> <span style="color: #BA2121">"filled Outputs"</span> <span style="color: #AA22FF; font-weight: bold">in</span> result
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #008000">len</span>(client<span style="color: #666666">.</span>calls) <span style="color: #666666">==</span> <span style="color: #666666">2</span>
    log <span style="color: #666666">=</span> caplog<span style="color: #666666">.</span>text
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #BA2121">"Filled Inputs using code from: in.py"</span> <span style="color: #AA22FF; font-weight: bold">in</span> log
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #BA2121">"Filled Outputs using code from: out.py"</span> <span style="color: #AA22FF; font-weight: bold">in</span> log
</code></pre>
<h3 id="test_full_docs_no_code_scan">test_full_docs_no_code_scan(tmp_path: Path, monkeypatch: pytest.MonkeyPatch, caplog: pytest.LogCaptureFixture) -&gt; None</h3>
<p>This function tests the behavior of the documentation generation process when code scanning is explicitly disabled. It creates a temporary test directory with fixture files, then patches key functions in the `explaincode` module to simulate skipping file ranking and snippet extraction. The test verifies that these operations are not performed by checking that their respective counters remain at zero. It also confirms that the process logs "DOC PASS" and "Code scan skipped" messages, ensuring the correct execution path is taken when code scanning is disabled.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">test_full_docs_no_code_scan</span>(
    tmp_path: Path, monkeypatch: pytest<span style="color: #666666">.</span>MonkeyPatch, caplog: pytest<span style="color: #666666">.</span>LogCaptureFixture
) <span style="color: #666666">-&gt;</span> <span style="color: #008000; font-weight: bold">None</span>:
    _create_fixture(tmp_path)
    tracker <span style="color: #666666">=</span> {<span style="color: #BA2121">"rank"</span>: <span style="color: #666666">0</span>, <span style="color: #BA2121">"extract"</span>: <span style="color: #666666">0</span>}

    <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">fake_rank</span>(root: Path, patterns: <span style="color: #008000">list</span>[<span style="color: #008000">str</span>]) <span style="color: #666666">-&gt;</span> <span style="color: #008000">list</span>[Path]:
        tracker[<span style="color: #BA2121">"rank"</span>] <span style="color: #666666">+=</span> <span style="color: #666666">1</span>
        <span style="color: #008000; font-weight: bold">return</span> [tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">"a.py"</span>]

    <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">fake_extract</span>(
        files: Iterable[Path], <span style="color: #666666">*</span>, max_files: <span style="color: #008000">int</span>, time_budget: <span style="color: #008000">int</span>, max_bytes: <span style="color: #008000">int</span>
    ) <span style="color: #666666">-&gt;</span> <span style="color: #008000">dict</span>[Path, <span style="color: #008000">str</span>]:
        tracker[<span style="color: #BA2121">"extract"</span>] <span style="color: #666666">+=</span> <span style="color: #666666">1</span>
        <span style="color: #008000; font-weight: bold">return</span> {}

    monkeypatch<span style="color: #666666">.</span>setattr(explaincode, <span style="color: #BA2121">"LLMClient"</span>, _mock_llm_client)
    monkeypatch<span style="color: #666666">.</span>setattr(explaincode, <span style="color: #BA2121">"rank_code_files"</span>, fake_rank)
    monkeypatch<span style="color: #666666">.</span>setattr(explaincode, <span style="color: #BA2121">"extract_snippets"</span>, fake_extract)

    caplog<span style="color: #666666">.</span>set_level(logging<span style="color: #666666">.</span>INFO)
    main([<span style="color: #BA2121">"--path"</span>, <span style="color: #008000">str</span>(tmp_path), <span style="color: #BA2121">"--scan-code-if-needed"</span>])
    <span style="color: #008000; font-weight: bold">assert</span> tracker[<span style="color: #BA2121">"rank"</span>] <span style="color: #666666">==</span> <span style="color: #666666">0</span>
    <span style="color: #008000; font-weight: bold">assert</span> tracker[<span style="color: #BA2121">"extract"</span>] <span style="color: #666666">==</span> <span style="color: #666666">0</span>
    log <span style="color: #666666">=</span> caplog<span style="color: #666666">.</span>text
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #BA2121">"DOC PASS"</span> <span style="color: #AA22FF; font-weight: bold">in</span> log
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #BA2121">"Code scan skipped"</span> <span style="color: #AA22FF; font-weight: bold">in</span> log
</code></pre>
<details>
<summary>Subfunction: fake_rank(root: Path, patterns: list[str]) -&gt; list[Path]</summary>
<h4 id="fake_rank">fake_rank(root: Path, patterns: list[str]) -&gt; list[Path]</h4>
<p>The function `fake_rank` takes a root path and a list of patterns as input, increments a global or shared counter tracked under the key "rank", and returns a list containing a single Path object pointing to a temporary file named "a.py" within a temporary directory. The function appears to be a placeholder or mock implementation, likely used for testing or demonstration purposes, as it does not utilize the provided root path or patterns in its logic.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">fake_rank</span>(root: Path, patterns: <span style="color: #008000">list</span>[<span style="color: #008000">str</span>]) <span style="color: #666666">-&gt;</span> <span style="color: #008000">list</span>[Path]:
        tracker[<span style="color: #BA2121">"rank"</span>] <span style="color: #666666">+=</span> <span style="color: #666666">1</span>
        <span style="color: #008000; font-weight: bold">return</span> [tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">"a.py"</span>]
</code></pre>
</details>
<details>
<summary>Subfunction: fake_extract(files: Iterable[Path], *, max_files: int, time_budget: int, max_bytes: int) -&gt; dict[Path, str]</summary>
<h4 id="fake_extract">fake_extract(files: Iterable[Path], *, max_files: int, time_budget: int, max_bytes: int) -&gt; dict[Path, str]</h4>
<p>The function `fake_extract` takes an iterable of file paths and configuration parameters including maximum number of files, time budget, and maximum bytes. It increments a counter in the global `tracker` dictionary under the key "extract" and returns an empty dictionary mapping paths to strings. This implementation appears to be a placeholder or mock version of an extraction function, as it does not perform any actual file reading or content extraction.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">fake_extract</span>(
        files: Iterable[Path], <span style="color: #666666">*</span>, max_files: <span style="color: #008000">int</span>, time_budget: <span style="color: #008000">int</span>, max_bytes: <span style="color: #008000">int</span>
    ) <span style="color: #666666">-&gt;</span> <span style="color: #008000">dict</span>[Path, <span style="color: #008000">str</span>]:
        tracker[<span style="color: #BA2121">"extract"</span>] <span style="color: #666666">+=</span> <span style="color: #666666">1</span>
        <span style="color: #008000; font-weight: bold">return</span> {}
</code></pre>
</details>
<h3 id="test_missing_run_triggers_code_fallback_with_limits">test_missing_run_triggers_code_fallback_with_limits(tmp_path: Path, monkeypatch: pytest.MonkeyPatch, caplog: pytest.LogCaptureFixture) -&gt; None</h3>
<p>This function tests the behavior of the documentation generator when run instructions are missing and code fallback is triggered, with specified limits on code files and time budget. It sets up a dummy language model that simulates summarization responses, patches file ranking and code extraction functions to track their calls and parameters, and executes the main documentation generation process with specific flags. The test verifies that the generated HTML does not contain unresolved placeholders, checks that the code extraction was invoked with correct parameters, confirms the expected number of files were scanned, and ensures relevant log messages are present indicating the fallback mechanism was activated.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">test_missing_run_triggers_code_fallback_with_limits</span>(
    tmp_path: Path, monkeypatch: pytest<span style="color: #666666">.</span>MonkeyPatch, caplog: pytest<span style="color: #666666">.</span>LogCaptureFixture
) <span style="color: #666666">-&gt;</span> <span style="color: #008000; font-weight: bold">None</span>:
    (tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">"README.md"</span>)<span style="color: #666666">.</span>write_text(<span style="color: #BA2121">"Only overview"</span>, encoding<span style="color: #666666">=</span><span style="color: #BA2121">"utf-8"</span>)

    <span style="color: #008000; font-weight: bold">class</span> <span style="color: #0000FF; font-weight: bold">Dummy</span>:
        <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">summarize</span>(<span style="color: #008000">self</span>, text: <span style="color: #008000">str</span>, prompt_type: <span style="color: #008000">str</span>, system_prompt: <span style="color: #008000">str</span> <span style="color: #666666">=</span> <span style="color: #BA2121">""</span>) <span style="color: #666666">-&gt;</span> <span style="color: #008000">str</span>:
            <span style="color: #008000; font-weight: bold">if</span> <span style="color: #BA2121">"How to Run"</span> <span style="color: #AA22FF; font-weight: bold">in</span> system_prompt:
                <span style="color: #008000; font-weight: bold">return</span> <span style="color: #BA2121">"[[NEEDS_RUN_INSTRUCTIONS]]"</span>
            <span style="color: #008000; font-weight: bold">if</span> <span style="color: #BA2121">"enhancing a user manual"</span> <span style="color: #AA22FF; font-weight: bold">in</span> system_prompt:
                manual_match <span style="color: #666666">=</span> re<span style="color: #666666">.</span>search(<span style="color: #BA2121">r"Manual:\n(.*?)\n\nSection:"</span>, text, re<span style="color: #666666">.</span>DOTALL)
                manual_text <span style="color: #666666">=</span> manual_match<span style="color: #666666">.</span>group(<span style="color: #666666">1</span>)
                <span style="color: #008000; font-weight: bold">return</span> manual_text<span style="color: #666666">.</span>replace(<span style="color: #BA2121">"[[NEEDS_RUN_INSTRUCTIONS]]"</span>, <span style="color: #BA2121">"use it"</span>)
            <span style="color: #008000; font-weight: bold">return</span> <span style="color: #BA2121">"x"</span>

    paths <span style="color: #666666">=</span> [tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">f"f</span><span style="color: #A45A77; font-weight: bold">{</span>i<span style="color: #A45A77; font-weight: bold">}</span><span style="color: #BA2121">.py"</span> <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(<span style="color: #666666">3</span>)]
    tracker: <span style="color: #008000">dict</span>[<span style="color: #008000">str</span>, <span style="color: #008000">object</span>] <span style="color: #666666">=</span> {<span style="color: #BA2121">"rank"</span>: <span style="color: #666666">0</span>, <span style="color: #BA2121">"extract"</span>: <span style="color: #666666">0</span>}

    <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">fake_rank</span>(root: Path, patterns: <span style="color: #008000">list</span>[<span style="color: #008000">str</span>]) <span style="color: #666666">-&gt;</span> <span style="color: #008000">list</span>[Path]:
        tracker[<span style="color: #BA2121">"rank"</span>] <span style="color: #666666">+=</span> <span style="color: #666666">1</span>
        <span style="color: #008000; font-weight: bold">return</span> paths

    <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">fake_extract</span>(
        files: Iterable[Path], <span style="color: #666666">*</span>, max_files: <span style="color: #008000">int</span>, time_budget: <span style="color: #008000">int</span>, max_bytes: <span style="color: #008000">int</span>
    ) <span style="color: #666666">-&gt;</span> <span style="color: #008000">dict</span>[Path, <span style="color: #008000">str</span>]:
        tracker[<span style="color: #BA2121">"extract"</span>] <span style="color: #666666">+=</span> <span style="color: #666666">1</span>
        lst <span style="color: #666666">=</span> <span style="color: #008000">list</span>(files)
        tracker[<span style="color: #BA2121">"kwargs"</span>] <span style="color: #666666">=</span> {<span style="color: #BA2121">"max_files"</span>: max_files, <span style="color: #BA2121">"time_budget"</span>: time_budget}
        tracker[<span style="color: #BA2121">"scanned"</span>] <span style="color: #666666">=</span> lst[:max_files]
        <span style="color: #008000; font-weight: bold">return</span> {p: <span style="color: #BA2121">"run code"</span> <span style="color: #008000; font-weight: bold">for</span> p <span style="color: #AA22FF; font-weight: bold">in</span> lst[:max_files]}

    monkeypatch<span style="color: #666666">.</span>setattr(explaincode, <span style="color: #BA2121">"LLMClient"</span>, <span style="color: #008000; font-weight: bold">lambda</span>: Dummy())
    monkeypatch<span style="color: #666666">.</span>setattr(explaincode, <span style="color: #BA2121">"rank_code_files"</span>, fake_rank)
    monkeypatch<span style="color: #666666">.</span>setattr(explaincode, <span style="color: #BA2121">"extract_snippets"</span>, fake_extract)

    caplog<span style="color: #666666">.</span>set_level(logging<span style="color: #666666">.</span>INFO)
    main(
        [
            <span style="color: #BA2121">"--path"</span>,
            <span style="color: #008000">str</span>(tmp_path),
            <span style="color: #BA2121">"--scan-code-if-needed"</span>,
            <span style="color: #BA2121">"--max-code-files"</span>,
            <span style="color: #BA2121">"1"</span>,
            <span style="color: #BA2121">"--code-time-budget-seconds"</span>,
            <span style="color: #BA2121">"5"</span>,
        ]
    )
    html <span style="color: #666666">=</span> (tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">"user_manual.html"</span>)<span style="color: #666666">.</span>read_text(encoding<span style="color: #666666">=</span><span style="color: #BA2121">"utf-8"</span>)
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #BA2121">"NEEDS_RUN_INSTRUCTIONS"</span> <span style="color: #AA22FF; font-weight: bold">not</span> <span style="color: #AA22FF; font-weight: bold">in</span> html
    <span style="color: #008000; font-weight: bold">assert</span> tracker[<span style="color: #BA2121">"rank"</span>] <span style="color: #666666">==</span> <span style="color: #666666">1</span>
    <span style="color: #008000; font-weight: bold">assert</span> tracker[<span style="color: #BA2121">"extract"</span>] <span style="color: #666666">==</span> <span style="color: #666666">1</span>
    <span style="color: #008000; font-weight: bold">assert</span> tracker[<span style="color: #BA2121">"kwargs"</span>] <span style="color: #666666">==</span> {<span style="color: #BA2121">"max_files"</span>: <span style="color: #666666">1</span>, <span style="color: #BA2121">"time_budget"</span>: <span style="color: #666666">5</span>}
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #008000">len</span>(tracker[<span style="color: #BA2121">"scanned"</span>]) <span style="color: #666666">==</span> <span style="color: #666666">1</span>
    log <span style="color: #666666">=</span> caplog<span style="color: #666666">.</span>text
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #BA2121">"Pass 1 missing sections"</span> <span style="color: #AA22FF; font-weight: bold">in</span> log
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #BA2121">"How to Run"</span> <span style="color: #AA22FF; font-weight: bold">in</span> log
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #BA2121">"Filled How to Run using code from: f0.py"</span> <span style="color: #AA22FF; font-weight: bold">in</span> log
</code></pre>
<details>
<summary>Subfunction: fake_rank(root: Path, patterns: list[str]) -&gt; list[Path]</summary>
<h4 id="fake_rank">fake_rank(root: Path, patterns: list[str]) -&gt; list[Path]</h4>
<p>The function `fake_rank` takes a `Path` object `root` and a list of string patterns, increments a counter in the global `tracker` dictionary under the key `"rank"`, and returns the value of the global variable `paths`. The function does not use the `root` or `patterns` parameters in its implementation.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">fake_rank</span>(root: Path, patterns: <span style="color: #008000">list</span>[<span style="color: #008000">str</span>]) <span style="color: #666666">-&gt;</span> <span style="color: #008000">list</span>[Path]:
        tracker[<span style="color: #BA2121">"rank"</span>] <span style="color: #666666">+=</span> <span style="color: #666666">1</span>
        <span style="color: #008000; font-weight: bold">return</span> paths
</code></pre>
</details>
<details>
<summary>Subfunction: fake_extract(files: Iterable[Path], *, max_files: int, time_budget: int, max_bytes: int) -&gt; dict[Path, str]</summary>
<h4 id="fake_extract">fake_extract(files: Iterable[Path], *, max_files: int, time_budget: int, max_bytes: int) -&gt; dict[Path, str]</h4>
<p>The function `fake_extract` processes an iterable of file paths and returns a dictionary mapping selected files to the string "run code". It updates a global `tracker` object with information about the extraction process, including the number of times it has been called, the arguments provided (`max_files`, `time_budget`), and the list of files scanned up to the maximum allowed. The function limits the processing to `max_files` number of files from the input iterable and does not consider the `max_bytes` parameter in its implementation.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">fake_extract</span>(
        files: Iterable[Path], <span style="color: #666666">*</span>, max_files: <span style="color: #008000">int</span>, time_budget: <span style="color: #008000">int</span>, max_bytes: <span style="color: #008000">int</span>
    ) <span style="color: #666666">-&gt;</span> <span style="color: #008000">dict</span>[Path, <span style="color: #008000">str</span>]:
        tracker[<span style="color: #BA2121">"extract"</span>] <span style="color: #666666">+=</span> <span style="color: #666666">1</span>
        lst <span style="color: #666666">=</span> <span style="color: #008000">list</span>(files)
        tracker[<span style="color: #BA2121">"kwargs"</span>] <span style="color: #666666">=</span> {<span style="color: #BA2121">"max_files"</span>: max_files, <span style="color: #BA2121">"time_budget"</span>: time_budget}
        tracker[<span style="color: #BA2121">"scanned"</span>] <span style="color: #666666">=</span> lst[:max_files]
        <span style="color: #008000; font-weight: bold">return</span> {p: <span style="color: #BA2121">"run code"</span> <span style="color: #008000; font-weight: bold">for</span> p <span style="color: #AA22FF; font-weight: bold">in</span> lst[:max_files]}
</code></pre>
</details>
<h3 id="test_no_code_flag_skips_code_fallback">test_no_code_flag_skips_code_fallback(tmp_path: Path, monkeypatch: pytest.MonkeyPatch, caplog: pytest.LogCaptureFixture) -&gt; None</h3>
<p>The function `test_no_code_flag_skips_code_fallback` is a test case that verifies the behavior of the documentation generator when the `--no-code` flag is used. It ensures that code scanning and extraction are skipped under this condition.

The test:</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">test_no_code_flag_skips_code_fallback</span>(
    tmp_path: Path, monkeypatch: pytest<span style="color: #666666">.</span>MonkeyPatch, caplog: pytest<span style="color: #666666">.</span>LogCaptureFixture
) <span style="color: #666666">-&gt;</span> <span style="color: #008000; font-weight: bold">None</span>:
    (tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">"README.md"</span>)<span style="color: #666666">.</span>write_text(<span style="color: #BA2121">"Only overview"</span>, encoding<span style="color: #666666">=</span><span style="color: #BA2121">"utf-8"</span>)

    <span style="color: #008000; font-weight: bold">class</span> <span style="color: #0000FF; font-weight: bold">Dummy</span>:
        <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">summarize</span>(
            <span style="color: #008000">self</span>, text: <span style="color: #008000">str</span>, prompt_type: <span style="color: #008000">str</span>, system_prompt: <span style="color: #008000">str</span> <span style="color: #666666">=</span> <span style="color: #BA2121">""</span>
        ) <span style="color: #666666">-&gt;</span> <span style="color: #008000">str</span>:
            <span style="color: #008000; font-weight: bold">return</span> <span style="color: #BA2121">"Overview: x</span><span style="color: #AA5D1F; font-weight: bold">\\</span><span style="color: #BA2121">nHow to Run: [[NEEDS_RUN_INSTRUCTIONS]]"</span>

    tracker <span style="color: #666666">=</span> {<span style="color: #BA2121">"rank"</span>: <span style="color: #666666">0</span>, <span style="color: #BA2121">"extract"</span>: <span style="color: #666666">0</span>}

    <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">fake_rank</span>(root: Path, patterns: <span style="color: #008000">list</span>[<span style="color: #008000">str</span>]) <span style="color: #666666">-&gt;</span> <span style="color: #008000">list</span>[Path]:
        tracker[<span style="color: #BA2121">"rank"</span>] <span style="color: #666666">+=</span> <span style="color: #666666">1</span>
        <span style="color: #008000; font-weight: bold">return</span> []

    <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">fake_extract</span>(
        files: Iterable[Path], <span style="color: #666666">*</span>, max_files: <span style="color: #008000">int</span>, time_budget: <span style="color: #008000">int</span>, max_bytes: <span style="color: #008000">int</span>
    ) <span style="color: #666666">-&gt;</span> <span style="color: #008000">dict</span>[Path, <span style="color: #008000">str</span>]:
        tracker[<span style="color: #BA2121">"extract"</span>] <span style="color: #666666">+=</span> <span style="color: #666666">1</span>
        <span style="color: #008000; font-weight: bold">return</span> {}

    monkeypatch<span style="color: #666666">.</span>setattr(explaincode, <span style="color: #BA2121">"LLMClient"</span>, <span style="color: #008000; font-weight: bold">lambda</span>: Dummy())
    monkeypatch<span style="color: #666666">.</span>setattr(explaincode, <span style="color: #BA2121">"rank_code_files"</span>, fake_rank)
    monkeypatch<span style="color: #666666">.</span>setattr(explaincode, <span style="color: #BA2121">"extract_snippets"</span>, fake_extract)

    caplog<span style="color: #666666">.</span>set_level(logging<span style="color: #666666">.</span>INFO)
    main([<span style="color: #BA2121">"--path"</span>, <span style="color: #008000">str</span>(tmp_path), <span style="color: #BA2121">"--scan-code-if-needed"</span>, <span style="color: #BA2121">"--no-code"</span>])
    <span style="color: #008000; font-weight: bold">assert</span> tracker[<span style="color: #BA2121">"rank"</span>] <span style="color: #666666">==</span> <span style="color: #666666">0</span>
    <span style="color: #008000; font-weight: bold">assert</span> tracker[<span style="color: #BA2121">"extract"</span>] <span style="color: #666666">==</span> <span style="color: #666666">0</span>
    log <span style="color: #666666">=</span> caplog<span style="color: #666666">.</span>text
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #BA2121">"Code scan skipped: --no-code specified"</span> <span style="color: #AA22FF; font-weight: bold">in</span> log
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #BA2121">"How to Run"</span> <span style="color: #AA22FF; font-weight: bold">in</span> log
</code></pre>
<details>
<summary>Subfunction: fake_rank(root: Path, patterns: list[str]) -&gt; list[Path]</summary>
<h4 id="fake_rank">fake_rank(root: Path, patterns: list[str]) -&gt; list[Path]</h4>
<p>The function `fake_rank` takes a `Path` object and a list of strings as input parameters. It increments a global or shared variable `tracker["rank"]` by one and returns an empty list of `Path` objects. The function appears to be a placeholder or mock implementation, likely used for testing or simulation purposes, as it does not perform any actual ranking or path processing.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">fake_rank</span>(root: Path, patterns: <span style="color: #008000">list</span>[<span style="color: #008000">str</span>]) <span style="color: #666666">-&gt;</span> <span style="color: #008000">list</span>[Path]:
        tracker[<span style="color: #BA2121">"rank"</span>] <span style="color: #666666">+=</span> <span style="color: #666666">1</span>
        <span style="color: #008000; font-weight: bold">return</span> []
</code></pre>
</details>
<details>
<summary>Subfunction: fake_extract(files: Iterable[Path], *, max_files: int, time_budget: int, max_bytes: int) -&gt; dict[Path, str]</summary>
<h4 id="fake_extract">fake_extract(files: Iterable[Path], *, max_files: int, time_budget: int, max_bytes: int) -&gt; dict[Path, str]</h4>
<p>The function `fake_extract` takes an iterable of file paths and configuration parameters including maximum number of files, time budget, and maximum bytes. It increments a counter in the global `tracker` dictionary under the key "extract" and returns an empty dictionary mapping paths to strings. This implementation appears to be a placeholder or mock version of an extraction function, as it does not perform any actual file reading or content extraction.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">fake_extract</span>(
        files: Iterable[Path], <span style="color: #666666">*</span>, max_files: <span style="color: #008000">int</span>, time_budget: <span style="color: #008000">int</span>, max_bytes: <span style="color: #008000">int</span>
    ) <span style="color: #666666">-&gt;</span> <span style="color: #008000">dict</span>[Path, <span style="color: #008000">str</span>]:
        tracker[<span style="color: #BA2121">"extract"</span>] <span style="color: #666666">+=</span> <span style="color: #666666">1</span>
        <span style="color: #008000; font-weight: bold">return</span> {}
</code></pre>
</details>
<h3 id="test_force_code_flag_triggers_code_fallback">test_force_code_flag_triggers_code_fallback(tmp_path: Path, monkeypatch: pytest.MonkeyPatch, caplog: pytest.LogCaptureFixture) -&gt; None</h3>
<p>This function tests that the `--force-code` flag triggers a code fallback mechanism during documentation generation. It sets up a temporary test environment, patches functions responsible for ranking code files and extracting snippets, and verifies that these functions are called exactly once when the flag is enabled. The test also confirms that appropriate log messages indicating the code scan trigger and pass completion are recorded. The function uses `pytest` fixtures for managing the temporary path, mocking behavior, and capturing logs.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">test_force_code_flag_triggers_code_fallback</span>(
    tmp_path: Path, monkeypatch: pytest<span style="color: #666666">.</span>MonkeyPatch, caplog: pytest<span style="color: #666666">.</span>LogCaptureFixture
) <span style="color: #666666">-&gt;</span> <span style="color: #008000; font-weight: bold">None</span>:
    _create_fixture(tmp_path)
    tracker <span style="color: #666666">=</span> {<span style="color: #BA2121">"rank"</span>: <span style="color: #666666">0</span>, <span style="color: #BA2121">"extract"</span>: <span style="color: #666666">0</span>}

    <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">fake_rank</span>(root: Path, patterns: <span style="color: #008000">list</span>[<span style="color: #008000">str</span>]) <span style="color: #666666">-&gt;</span> <span style="color: #008000">list</span>[Path]:
        tracker[<span style="color: #BA2121">"rank"</span>] <span style="color: #666666">+=</span> <span style="color: #666666">1</span>
        <span style="color: #008000; font-weight: bold">return</span> [tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">"script.py"</span>]

    <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">fake_extract</span>(
        files: Iterable[Path], <span style="color: #666666">*</span>, max_files: <span style="color: #008000">int</span>, time_budget: <span style="color: #008000">int</span>, max_bytes: <span style="color: #008000">int</span>
    ) <span style="color: #666666">-&gt;</span> <span style="color: #008000">dict</span>[Path, <span style="color: #008000">str</span>]:
        tracker[<span style="color: #BA2121">"extract"</span>] <span style="color: #666666">+=</span> <span style="color: #666666">1</span>
        <span style="color: #008000; font-weight: bold">return</span> {<span style="color: #008000">next</span>(<span style="color: #008000">iter</span>(files)): <span style="color: #BA2121">"code"</span>}

    monkeypatch<span style="color: #666666">.</span>setattr(explaincode, <span style="color: #BA2121">"LLMClient"</span>, _mock_llm_client)
    monkeypatch<span style="color: #666666">.</span>setattr(explaincode, <span style="color: #BA2121">"rank_code_files"</span>, fake_rank)
    monkeypatch<span style="color: #666666">.</span>setattr(explaincode, <span style="color: #BA2121">"extract_snippets"</span>, fake_extract)

    caplog<span style="color: #666666">.</span>set_level(logging<span style="color: #666666">.</span>INFO)
    main([<span style="color: #BA2121">"--path"</span>, <span style="color: #008000">str</span>(tmp_path), <span style="color: #BA2121">"--force-code"</span>])
    <span style="color: #008000; font-weight: bold">assert</span> tracker[<span style="color: #BA2121">"rank"</span>] <span style="color: #666666">==</span> <span style="color: #666666">1</span>
    <span style="color: #008000; font-weight: bold">assert</span> tracker[<span style="color: #BA2121">"extract"</span>] <span style="color: #666666">==</span> <span style="color: #666666">1</span>
    log <span style="color: #666666">=</span> caplog<span style="color: #666666">.</span>text
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #BA2121">"Code scan triggered: --force-code enabled"</span> <span style="color: #AA22FF; font-weight: bold">in</span> log
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #BA2121">"Pass 1 complete: no sections missing"</span> <span style="color: #AA22FF; font-weight: bold">in</span> log
</code></pre>
<details>
<summary>Subfunction: fake_rank(root: Path, patterns: list[str]) -&gt; list[Path]</summary>
<h4 id="fake_rank">fake_rank(root: Path, patterns: list[str]) -&gt; list[Path]</h4>
<p>The function `fake_rank` takes a root path and a list of patterns as input, increments a global or external `tracker` dictionary's "rank" key by one, and returns a list containing a single Path object pointing to a file named "script.py" located within a temporary path (`tmp_path`). The purpose of this function appears to be a placeholder or mock implementation, likely used for testing or simulation purposes.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">fake_rank</span>(root: Path, patterns: <span style="color: #008000">list</span>[<span style="color: #008000">str</span>]) <span style="color: #666666">-&gt;</span> <span style="color: #008000">list</span>[Path]:
        tracker[<span style="color: #BA2121">"rank"</span>] <span style="color: #666666">+=</span> <span style="color: #666666">1</span>
        <span style="color: #008000; font-weight: bold">return</span> [tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">"script.py"</span>]
</code></pre>
</details>
<details>
<summary>Subfunction: fake_extract(files: Iterable[Path], *, max_files: int, time_budget: int, max_bytes: int) -&gt; dict[Path, str]</summary>
<h4 id="fake_extract">fake_extract(files: Iterable[Path], *, max_files: int, time_budget: int, max_bytes: int) -&gt; dict[Path, str]</h4>
<p>The function `fake_extract` takes an iterable of file paths and extraction parameters, increments a global tracker for the "extract" operation, and returns a dictionary mapping the first file in the input to the string "code". The function does not actually extract or process the files; it serves as a placeholder implementation.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">fake_extract</span>(
        files: Iterable[Path], <span style="color: #666666">*</span>, max_files: <span style="color: #008000">int</span>, time_budget: <span style="color: #008000">int</span>, max_bytes: <span style="color: #008000">int</span>
    ) <span style="color: #666666">-&gt;</span> <span style="color: #008000">dict</span>[Path, <span style="color: #008000">str</span>]:
        tracker[<span style="color: #BA2121">"extract"</span>] <span style="color: #666666">+=</span> <span style="color: #666666">1</span>
        <span style="color: #008000; font-weight: bold">return</span> {<span style="color: #008000">next</span>(<span style="color: #008000">iter</span>(files)): <span style="color: #BA2121">"code"</span>}
</code></pre>
</details>
<h3 id="test_custom_title_and_filename">test_custom_title_and_filename(tmp_path: Path, monkeypatch: pytest.MonkeyPatch) -&gt; None</h3>
<p>The function `test_custom_title_and_filename` tests the generation of an HTML documentation file with a custom title and filename. It creates a temporary test fixture, mocks the LLM client, and invokes the main documentation generation process with a specified title. The test verifies that the output HTML file and an associated evidence JSON file are created, and that the HTML file contains the expected custom title within an `&lt;h1&gt;` heading element.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">test_custom_title_and_filename</span>(tmp_path: Path, monkeypatch: pytest<span style="color: #666666">.</span>MonkeyPatch) <span style="color: #666666">-&gt;</span> <span style="color: #008000; font-weight: bold">None</span>:
    _create_fixture(tmp_path)
    monkeypatch<span style="color: #666666">.</span>setattr(explaincode, <span style="color: #BA2121">"LLMClient"</span>, _mock_llm_client)
    main([<span style="color: #BA2121">"--path"</span>, <span style="color: #008000">str</span>(tmp_path), <span style="color: #BA2121">"--title"</span>, <span style="color: #BA2121">"Fancy Guide"</span>])
    out_file <span style="color: #666666">=</span> tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">"fancy_guide.html"</span>
    evidence_file <span style="color: #666666">=</span> tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">"fancy_guide_evidence.json"</span>
    <span style="color: #008000; font-weight: bold">assert</span> out_file<span style="color: #666666">.</span>exists()
    <span style="color: #008000; font-weight: bold">assert</span> evidence_file<span style="color: #666666">.</span>exists()
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #BA2121">"&lt;h1&gt;Fancy Guide&lt;/h1&gt;"</span> <span style="color: #AA22FF; font-weight: bold">in</span> out_file<span style="color: #666666">.</span>read_text(encoding<span style="color: #666666">=</span><span style="color: #BA2121">"utf-8"</span>)
</code></pre>
<h3 id="test_insert_into_index">test_insert_into_index(tmp_path: Path, monkeypatch: pytest.MonkeyPatch) -&gt; None</h3>
<p>The function `test_insert_into_index` tests the functionality of inserting a link into an existing HTML index file during documentation generation. It creates a temporary directory structure with a fixture, sets up an output directory, and initializes an index.html file with basic HTML content. The test mocks the `LLMClient` to avoid actual LLM calls, then executes the main documentation generation process with the `--insert-into-index` flag. After execution, it reads the updated index file and asserts that a specific link (`&lt;a href="user_manual.html"&gt;User Manual&lt;/a&gt;`) has been inserted into the HTML content.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">test_insert_into_index</span>(tmp_path: Path, monkeypatch: pytest<span style="color: #666666">.</span>MonkeyPatch) <span style="color: #666666">-&gt;</span> <span style="color: #008000; font-weight: bold">None</span>:
    _create_fixture(tmp_path)
    out_dir <span style="color: #666666">=</span> tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">"out"</span>
    out_dir<span style="color: #666666">.</span>mkdir()
    index <span style="color: #666666">=</span> out_dir <span style="color: #666666">/</span> <span style="color: #BA2121">"index.html"</span>
    index<span style="color: #666666">.</span>write_text(<span style="color: #BA2121">"&lt;html&gt;&lt;body&gt;&lt;ul&gt;&lt;/ul&gt;&lt;/body&gt;&lt;/html&gt;"</span>, encoding<span style="color: #666666">=</span><span style="color: #BA2121">"utf-8"</span>)
    monkeypatch<span style="color: #666666">.</span>setattr(explaincode, <span style="color: #BA2121">"LLMClient"</span>, _mock_llm_client)
    main([<span style="color: #BA2121">"--path"</span>, <span style="color: #008000">str</span>(tmp_path), <span style="color: #BA2121">"--output"</span>, <span style="color: #008000">str</span>(out_dir), <span style="color: #BA2121">"--insert-into-index"</span>])
    html <span style="color: #666666">=</span> index<span style="color: #666666">.</span>read_text(encoding<span style="color: #666666">=</span><span style="color: #BA2121">"utf-8"</span>)
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #BA2121">'&lt;a href="user_manual.html"&gt;User Manual&lt;/a&gt;'</span> <span style="color: #AA22FF; font-weight: bold">in</span> html
</code></pre>
<h3 id="test_docs_index_default_and_injection">test_docs_index_default_and_injection(tmp_path: Path, monkeypatch: pytest.MonkeyPatch) -&gt; None</h3>
<p>The function `test_docs_index_default_and_injection` tests the behavior of documentation generation when inserting a new entry into an existing index file. It creates a temporary directory structure with a fixture, sets up a mock LLM client, and runs the main documentation generation process with the `--insert-into-index` flag. The test verifies that the generated HTML documentation and evidence files are created, and checks that the navigation element in the index.html file correctly includes a link to the generated user manual.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">test_docs_index_default_and_injection</span>(
    tmp_path: Path, monkeypatch: pytest<span style="color: #666666">.</span>MonkeyPatch
) <span style="color: #666666">-&gt;</span> <span style="color: #008000; font-weight: bold">None</span>:
    _create_fixture(tmp_path)
    docs_dir <span style="color: #666666">=</span> tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">"docs"</span>
    docs_dir<span style="color: #666666">.</span>mkdir()
    (docs_dir <span style="color: #666666">/</span> <span style="color: #BA2121">"index.html"</span>)<span style="color: #666666">.</span>write_text(<span style="color: #BA2121">"&lt;html&gt;&lt;body&gt;&lt;nav&gt;&lt;/nav&gt;&lt;/body&gt;&lt;/html&gt;"</span>, encoding<span style="color: #666666">=</span><span style="color: #BA2121">"utf-8"</span>)
    monkeypatch<span style="color: #666666">.</span>setattr(explaincode, <span style="color: #BA2121">"LLMClient"</span>, _mock_llm_client)
    main([<span style="color: #BA2121">"--path"</span>, <span style="color: #008000">str</span>(tmp_path), <span style="color: #BA2121">"--insert-into-index"</span>])
    manual <span style="color: #666666">=</span> docs_dir <span style="color: #666666">/</span> <span style="color: #BA2121">"user_manual.html"</span>
    evidence <span style="color: #666666">=</span> docs_dir <span style="color: #666666">/</span> <span style="color: #BA2121">"user_manual_evidence.json"</span>
    <span style="color: #008000; font-weight: bold">assert</span> manual<span style="color: #666666">.</span>exists()
    <span style="color: #008000; font-weight: bold">assert</span> evidence<span style="color: #666666">.</span>exists()
    soup <span style="color: #666666">=</span> BeautifulSoup((docs_dir <span style="color: #666666">/</span> <span style="color: #BA2121">"index.html"</span>)<span style="color: #666666">.</span>read_text(encoding<span style="color: #666666">=</span><span style="color: #BA2121">"utf-8"</span>), <span style="color: #BA2121">"html.parser"</span>)
    nav <span style="color: #666666">=</span> soup<span style="color: #666666">.</span>find(<span style="color: #BA2121">"nav"</span>)
    <span style="color: #008000; font-weight: bold">assert</span> nav <span style="color: #AA22FF; font-weight: bold">is</span> <span style="color: #AA22FF; font-weight: bold">not</span> <span style="color: #008000; font-weight: bold">None</span>
    first <span style="color: #666666">=</span> nav<span style="color: #666666">.</span>find(<span style="color: #BA2121">"a"</span>)
    <span style="color: #008000; font-weight: bold">assert</span> first <span style="color: #AA22FF; font-weight: bold">and</span> first[<span style="color: #BA2121">"href"</span>] <span style="color: #666666">==</span> <span style="color: #BA2121">"user_manual.html"</span>
</code></pre>
<h3 id="test_insert_into_root_index">test_insert_into_root_index(tmp_path: Path, monkeypatch: pytest.MonkeyPatch) -&gt; None</h3>
<p>The function `test_insert_into_root_index` tests the functionality of inserting a generated documentation file into the root index of a project. It creates a temporary directory structure with a fixture, writes a basic HTML index file containing a navigation element, and mocks the `LLMClient` to simulate language model interactions. The test then runs the main documentation generation process with the `--insert-into-index` flag, which should generate a user manual and evidence files in a `docs` subdirectory. It verifies that these files are created and checks that the navigation element in the index HTML has been updated with a link to the generated manual file. The test ensures that the documentation generation process correctly integrates the new documentation into the existing index structure.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">test_insert_into_root_index</span>(tmp_path: Path, monkeypatch: pytest<span style="color: #666666">.</span>MonkeyPatch) <span style="color: #666666">-&gt;</span> <span style="color: #008000; font-weight: bold">None</span>:
    _create_fixture(tmp_path)
    (tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">"index.html"</span>)<span style="color: #666666">.</span>write_text(<span style="color: #BA2121">"&lt;html&gt;&lt;body&gt;&lt;nav&gt;&lt;/nav&gt;&lt;/body&gt;&lt;/html&gt;"</span>, encoding<span style="color: #666666">=</span><span style="color: #BA2121">"utf-8"</span>)
    monkeypatch<span style="color: #666666">.</span>setattr(explaincode, <span style="color: #BA2121">"LLMClient"</span>, _mock_llm_client)
    main([<span style="color: #BA2121">"--path"</span>, <span style="color: #008000">str</span>(tmp_path), <span style="color: #BA2121">"--insert-into-index"</span>])
    manual <span style="color: #666666">=</span> tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">"docs"</span> <span style="color: #666666">/</span> <span style="color: #BA2121">"user_manual.html"</span>
    evidence <span style="color: #666666">=</span> tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">"docs"</span> <span style="color: #666666">/</span> <span style="color: #BA2121">"user_manual_evidence.json"</span>
    <span style="color: #008000; font-weight: bold">assert</span> manual<span style="color: #666666">.</span>exists()
    <span style="color: #008000; font-weight: bold">assert</span> evidence<span style="color: #666666">.</span>exists()
    soup <span style="color: #666666">=</span> BeautifulSoup((tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">"index.html"</span>)<span style="color: #666666">.</span>read_text(encoding<span style="color: #666666">=</span><span style="color: #BA2121">"utf-8"</span>), <span style="color: #BA2121">"html.parser"</span>)
    nav <span style="color: #666666">=</span> soup<span style="color: #666666">.</span>find(<span style="color: #BA2121">"nav"</span>)
    <span style="color: #008000; font-weight: bold">assert</span> nav <span style="color: #AA22FF; font-weight: bold">is</span> <span style="color: #AA22FF; font-weight: bold">not</span> <span style="color: #008000; font-weight: bold">None</span>
    first <span style="color: #666666">=</span> nav<span style="color: #666666">.</span>find(<span style="color: #BA2121">"a"</span>)
    <span style="color: #008000; font-weight: bold">assert</span> first <span style="color: #AA22FF; font-weight: bold">and</span> first[<span style="color: #BA2121">"href"</span>] <span style="color: #666666">==</span> <span style="color: #BA2121">"docs/user_manual.html"</span>
</code></pre>
<h3 id="test_chunking_triggers_multiple_calls_and_logs">test_chunking_triggers_multiple_calls_and_logs(tmp_path: Path, capsys: pytest.CaptureFixture[str]) -&gt; None</h3>
<p>This function tests the behavior of manual summarization with automatic chunking, verifying that multiple calls are made to a dummy language model client and that appropriate system prompts are used. It checks that the text is split into chunks, each processed with a chunk system prompt, and then merged using a merge system prompt. The test also ensures that log output includes messages about chunking and merging. The function uses a mock client to simulate LLM interactions and verifies the structure of calls and final output.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">test_chunking_triggers_multiple_calls_and_logs</span>(
    tmp_path: Path, capsys: pytest<span style="color: #666666">.</span>CaptureFixture[<span style="color: #008000">str</span>]
) <span style="color: #666666">-&gt;</span> <span style="color: #008000; font-weight: bold">None</span>:
    paragraph1 <span style="color: #666666">=</span> <span style="color: #BA2121">"aaa "</span> <span style="color: #666666">*</span> <span style="color: #666666">2000</span>
    paragraph2 <span style="color: #666666">=</span> <span style="color: #BA2121">"bbb "</span> <span style="color: #666666">*</span> <span style="color: #666666">2000</span>
    text <span style="color: #666666">=</span> <span style="color: #BA2121">"</span><span style="color: #AA5D1F; font-weight: bold">\n\n</span><span style="color: #BA2121">"</span><span style="color: #666666">.</span>join([paragraph1, paragraph2])

    <span style="color: #008000; font-weight: bold">class</span> <span style="color: #0000FF; font-weight: bold">Dummy</span>:
        <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">__init__</span>(<span style="color: #008000">self</span>) <span style="color: #666666">-&gt;</span> <span style="color: #008000; font-weight: bold">None</span>:
            <span style="color: #008000">self</span><span style="color: #666666">.</span>calls: <span style="color: #008000">list</span>[<span style="color: #008000">dict</span>] <span style="color: #666666">=</span> []

        <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">summarize</span>(<span style="color: #008000">self</span>, text: <span style="color: #008000">str</span>, prompt_type: <span style="color: #008000">str</span>, system_prompt: <span style="color: #008000">str</span> <span style="color: #666666">=</span> <span style="color: #BA2121">""</span>) <span style="color: #666666">-&gt;</span> <span style="color: #008000">str</span>:
            <span style="color: #008000">self</span><span style="color: #666666">.</span>calls<span style="color: #666666">.</span>append(
                {<span style="color: #BA2121">"text"</span>: text, <span style="color: #BA2121">"prompt_type"</span>: prompt_type, <span style="color: #BA2121">"system_prompt"</span>: system_prompt}
            )
            <span style="color: #008000; font-weight: bold">if</span> system_prompt <span style="color: #666666">==</span> explaincode<span style="color: #666666">.</span>MERGE_SYSTEM_PROMPT:
                <span style="color: #008000; font-weight: bold">return</span> <span style="color: #BA2121">"final"</span>
            <span style="color: #008000; font-weight: bold">return</span> text<span style="color: #666666">.</span>split()[<span style="color: #666666">0</span>]

    client <span style="color: #666666">=</span> Dummy()
    cache <span style="color: #666666">=</span> ResponseCache(<span style="color: #008000">str</span>(tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">"cache.json"</span>))
    logging<span style="color: #666666">.</span>basicConfig(stream<span style="color: #666666">=</span>sys<span style="color: #666666">.</span>stdout, level<span style="color: #666666">=</span>logging<span style="color: #666666">.</span>DEBUG, force<span style="color: #666666">=</span><span style="color: #008000; font-weight: bold">True</span>)
    result <span style="color: #666666">=</span> manual_utils<span style="color: #666666">.</span>_summarize_manual(
        client, cache, text, chunking<span style="color: #666666">=</span><span style="color: #BA2121">"auto"</span>, source<span style="color: #666666">=</span><span style="color: #BA2121">"src"</span>
    )

    <span style="color: #008000; font-weight: bold">assert</span> result <span style="color: #666666">==</span> <span style="color: #BA2121">"final"</span>
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #008000">len</span>(client<span style="color: #666666">.</span>calls) <span style="color: #666666">==</span> <span style="color: #666666">3</span>
    chunk_calls <span style="color: #666666">=</span> client<span style="color: #666666">.</span>calls[:<span style="color: #666666">-1</span>]
    merge_call <span style="color: #666666">=</span> client<span style="color: #666666">.</span>calls[<span style="color: #666666">-1</span>]
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #008000">all</span>(c[<span style="color: #BA2121">"system_prompt"</span>] <span style="color: #666666">==</span> explaincode<span style="color: #666666">.</span>CHUNK_SYSTEM_PROMPT <span style="color: #008000; font-weight: bold">for</span> c <span style="color: #AA22FF; font-weight: bold">in</span> chunk_calls)
    <span style="color: #008000; font-weight: bold">assert</span> merge_call[<span style="color: #BA2121">"system_prompt"</span>] <span style="color: #666666">==</span> explaincode<span style="color: #666666">.</span>MERGE_SYSTEM_PROMPT
    <span style="color: #008000; font-weight: bold">assert</span> merge_call[<span style="color: #BA2121">"text"</span>] <span style="color: #666666">==</span> <span style="color: #BA2121">"aaa</span><span style="color: #AA5D1F; font-weight: bold">\n\n</span><span style="color: #BA2121">bbb"</span>

    out <span style="color: #666666">=</span> capsys<span style="color: #666666">.</span>readouterr()<span style="color: #666666">.</span>out
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #BA2121">"Chunk 1/2 from src"</span> <span style="color: #AA22FF; font-weight: bold">in</span> out
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #BA2121">"Merged LLM response length"</span> <span style="color: #AA22FF; font-weight: bold">in</span> out
</code></pre>
<h3 id="test_chunk_edit_hook_applied">test_chunk_edit_hook_applied(tmp_path: Path) -&gt; None</h3>
<p>The function `test_chunk_edit_hook_applied` tests the application of a chunk editing hook during manual text summarization. It creates two long paragraphs of repeated text, joins them with double newlines, and defines a dummy client class that tracks calls made to its `summarize` method. The `summarize` method appends call details to a list and returns either the first word of the input text or "final" when a specific system prompt is matched.

A hook function is defined to convert all chunks to uppercase. This hook is passed to `_summarize_manual`, which processes the text with automatic chunking and applies the hook to the chunks before summarization. The test asserts that the final result equals "final", indicating the merge system prompt was used, and checks that the last call's text input was transformed to uppercase ("AAA\n\nBBB") by the hook.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">test_chunk_edit_hook_applied</span>(tmp_path: Path) <span style="color: #666666">-&gt;</span> <span style="color: #008000; font-weight: bold">None</span>:
    paragraph1 <span style="color: #666666">=</span> <span style="color: #BA2121">"aaa "</span> <span style="color: #666666">*</span> <span style="color: #666666">2000</span>
    paragraph2 <span style="color: #666666">=</span> <span style="color: #BA2121">"bbb "</span> <span style="color: #666666">*</span> <span style="color: #666666">2000</span>
    text <span style="color: #666666">=</span> <span style="color: #BA2121">"</span><span style="color: #AA5D1F; font-weight: bold">\n\n</span><span style="color: #BA2121">"</span><span style="color: #666666">.</span>join([paragraph1, paragraph2])

    <span style="color: #008000; font-weight: bold">class</span> <span style="color: #0000FF; font-weight: bold">Dummy</span>:
        <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">__init__</span>(<span style="color: #008000">self</span>) <span style="color: #666666">-&gt;</span> <span style="color: #008000; font-weight: bold">None</span>:
            <span style="color: #008000">self</span><span style="color: #666666">.</span>calls: <span style="color: #008000">list</span>[<span style="color: #008000">dict</span>] <span style="color: #666666">=</span> []

        <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">summarize</span>(<span style="color: #008000">self</span>, text: <span style="color: #008000">str</span>, prompt_type: <span style="color: #008000">str</span>, system_prompt: <span style="color: #008000">str</span> <span style="color: #666666">=</span> <span style="color: #BA2121">""</span>) <span style="color: #666666">-&gt;</span> <span style="color: #008000">str</span>:
            <span style="color: #008000">self</span><span style="color: #666666">.</span>calls<span style="color: #666666">.</span>append(
                {<span style="color: #BA2121">"text"</span>: text, <span style="color: #BA2121">"prompt_type"</span>: prompt_type, <span style="color: #BA2121">"system_prompt"</span>: system_prompt}
            )
            <span style="color: #008000; font-weight: bold">if</span> system_prompt <span style="color: #666666">==</span> explaincode<span style="color: #666666">.</span>MERGE_SYSTEM_PROMPT:
                <span style="color: #008000; font-weight: bold">return</span> <span style="color: #BA2121">"final"</span>
            <span style="color: #008000; font-weight: bold">return</span> text<span style="color: #666666">.</span>split()[<span style="color: #666666">0</span>]

    <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">hook</span>(chunks: <span style="color: #008000">list</span>[<span style="color: #008000">str</span>]) <span style="color: #666666">-&gt;</span> <span style="color: #008000">list</span>[<span style="color: #008000">str</span>]:
        <span style="color: #008000; font-weight: bold">return</span> [c<span style="color: #666666">.</span>upper() <span style="color: #008000; font-weight: bold">for</span> c <span style="color: #AA22FF; font-weight: bold">in</span> chunks]

    client <span style="color: #666666">=</span> Dummy()
    cache <span style="color: #666666">=</span> ResponseCache(<span style="color: #008000">str</span>(tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">"cache.json"</span>))
    result <span style="color: #666666">=</span> manual_utils<span style="color: #666666">.</span>_summarize_manual(
        client, cache, text, chunking<span style="color: #666666">=</span><span style="color: #BA2121">"auto"</span>, source<span style="color: #666666">=</span><span style="color: #BA2121">"src"</span>, post_chunk_hook<span style="color: #666666">=</span>hook
    )

    <span style="color: #008000; font-weight: bold">assert</span> result <span style="color: #666666">==</span> <span style="color: #BA2121">"final"</span>
    <span style="color: #008000; font-weight: bold">assert</span> client<span style="color: #666666">.</span>calls[<span style="color: #666666">-1</span>][<span style="color: #BA2121">"text"</span>] <span style="color: #666666">==</span> <span style="color: #BA2121">"AAA</span><span style="color: #AA5D1F; font-weight: bold">\n\n</span><span style="color: #BA2121">BBB"</span>
</code></pre>
<details>
<summary>Subfunction: hook(chunks: list[str]) -&gt; list[str]</summary>
<h4 id="hook">hook(chunks: list[str]) -&gt; list[str]</h4>
<p>The function `hook` takes a list of strings as input and returns a new list where each string has been converted to uppercase. It applies the `upper()` method to each element in the input list using a list comprehension.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">hook</span>(chunks: <span style="color: #008000">list</span>[<span style="color: #008000">str</span>]) <span style="color: #666666">-&gt;</span> <span style="color: #008000">list</span>[<span style="color: #008000">str</span>]:
        <span style="color: #008000; font-weight: bold">return</span> [c<span style="color: #666666">.</span>upper() <span style="color: #008000; font-weight: bold">for</span> c <span style="color: #AA22FF; font-weight: bold">in</span> chunks]
</code></pre>
</details>
<h3 id="test_parallel_chunk_summarization">test_parallel_chunk_summarization(tmp_path: Path) -&gt; None</h3>
<p>The function `test_parallel_chunk_summarization` tests the parallel chunk summarization functionality by creating a large text input composed of repeated paragraphs and simulating a slow LLM client. It verifies that the summarization process completes within a specified time threshold, ensuring that chunking and caching mechanisms operate efficiently in parallel. The test uses a mock client that introduces a delay for specific system prompts and measures the total execution time to confirm parallel processing behavior.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">test_parallel_chunk_summarization</span>(tmp_path: Path) <span style="color: #666666">-&gt;</span> <span style="color: #008000; font-weight: bold">None</span>:
    paragraph <span style="color: #666666">=</span> <span style="color: #BA2121">"word "</span> <span style="color: #666666">*</span> <span style="color: #666666">2000</span>
    text <span style="color: #666666">=</span> <span style="color: #BA2121">"</span><span style="color: #AA5D1F; font-weight: bold">\n\n</span><span style="color: #BA2121">"</span><span style="color: #666666">.</span>join([paragraph, paragraph])
    delay <span style="color: #666666">=</span> <span style="color: #666666">0.2</span>

    <span style="color: #008000; font-weight: bold">class</span> <span style="color: #0000FF; font-weight: bold">SlowClient</span>:
        <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">summarize</span>(<span style="color: #008000">self</span>, text: <span style="color: #008000">str</span>, prompt_type: <span style="color: #008000">str</span>, system_prompt: <span style="color: #008000">str</span> <span style="color: #666666">=</span> <span style="color: #BA2121">""</span>) <span style="color: #666666">-&gt;</span> <span style="color: #008000">str</span>:
            <span style="color: #008000; font-weight: bold">if</span> system_prompt <span style="color: #666666">==</span> explaincode<span style="color: #666666">.</span>CHUNK_SYSTEM_PROMPT:
                time<span style="color: #666666">.</span>sleep(delay)
            <span style="color: #008000; font-weight: bold">return</span> <span style="color: #BA2121">"ok"</span>

    client <span style="color: #666666">=</span> SlowClient()
    cache <span style="color: #666666">=</span> ResponseCache(<span style="color: #008000">str</span>(tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">"cache.json"</span>))
    start <span style="color: #666666">=</span> time<span style="color: #666666">.</span>perf_counter()
    manual_utils<span style="color: #666666">.</span>_summarize_manual(client, cache, text, chunking<span style="color: #666666">=</span><span style="color: #BA2121">"auto"</span>, source<span style="color: #666666">=</span><span style="color: #BA2121">"src"</span>)
    duration <span style="color: #666666">=</span> time<span style="color: #666666">.</span>perf_counter() <span style="color: #666666">-</span> start
    <span style="color: #008000; font-weight: bold">assert</span> duration <span style="color: #666666">&lt;</span> delay <span style="color: #666666">*</span> <span style="color: #666666">1.5</span>
</code></pre>
<h3 id="test_hierarchical_merge_logged">test_hierarchical_merge_logged(tmp_path: Path, capsys: pytest.CaptureFixture[str]) -&gt; None</h3>
<p>The function `test_hierarchical_merge_logged` tests the hierarchical merging behavior of a manual summarization process. It creates a large text input composed of repeated content, then uses a dummy client that tracks calls made during summarization. The test verifies that the summarization process results in a shortened output after multiple call iterations, and confirms that logging includes a message indicating a "Hierarchical merge pass" was performed. The test also ensures that the number of calls made by the dummy client exceeds three, validating the multi-step nature of the summarization logic. A response cache is utilized during the test to store intermediate results.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">test_hierarchical_merge_logged</span>(
    tmp_path: Path, capsys: pytest<span style="color: #666666">.</span>CaptureFixture[<span style="color: #008000">str</span>]
) <span style="color: #666666">-&gt;</span> <span style="color: #008000; font-weight: bold">None</span>:
    big <span style="color: #666666">=</span> <span style="color: #BA2121">"word "</span> <span style="color: #666666">*</span> <span style="color: #666666">5000</span>
    text <span style="color: #666666">=</span> <span style="color: #BA2121">"</span><span style="color: #AA5D1F; font-weight: bold">\n\n</span><span style="color: #BA2121">"</span><span style="color: #666666">.</span>join([big, big])

    <span style="color: #008000; font-weight: bold">class</span> <span style="color: #0000FF; font-weight: bold">Dummy</span>:
        <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">__init__</span>(<span style="color: #008000">self</span>) <span style="color: #666666">-&gt;</span> <span style="color: #008000; font-weight: bold">None</span>:
            <span style="color: #008000">self</span><span style="color: #666666">.</span>calls: <span style="color: #008000">list</span>[<span style="color: #008000">dict</span>] <span style="color: #666666">=</span> []

        <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">summarize</span>(<span style="color: #008000">self</span>, text: <span style="color: #008000">str</span>, prompt_type: <span style="color: #008000">str</span>, system_prompt: <span style="color: #008000">str</span> <span style="color: #666666">=</span> <span style="color: #BA2121">""</span>) <span style="color: #666666">-&gt;</span> <span style="color: #008000">str</span>:
            <span style="color: #008000">self</span><span style="color: #666666">.</span>calls<span style="color: #666666">.</span>append(
                {<span style="color: #BA2121">"text"</span>: text, <span style="color: #BA2121">"prompt_type"</span>: prompt_type, <span style="color: #BA2121">"system_prompt"</span>: system_prompt}
            )
            <span style="color: #008000; font-weight: bold">if</span> <span style="color: #008000">len</span>(<span style="color: #008000">self</span><span style="color: #666666">.</span>calls) <span style="color: #666666">&lt;=</span> <span style="color: #666666">2</span>:
                <span style="color: #008000; font-weight: bold">return</span> big
            <span style="color: #008000; font-weight: bold">return</span> <span style="color: #BA2121">"short"</span>

    client <span style="color: #666666">=</span> Dummy()
    cache <span style="color: #666666">=</span> ResponseCache(<span style="color: #008000">str</span>(tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">"cache.json"</span>))
    logging<span style="color: #666666">.</span>basicConfig(stream<span style="color: #666666">=</span>sys<span style="color: #666666">.</span>stdout, level<span style="color: #666666">=</span>logging<span style="color: #666666">.</span>DEBUG, force<span style="color: #666666">=</span><span style="color: #008000; font-weight: bold">True</span>)
    result <span style="color: #666666">=</span> manual_utils<span style="color: #666666">.</span>_summarize_manual(
        client, cache, text, chunking<span style="color: #666666">=</span><span style="color: #BA2121">"auto"</span>, source<span style="color: #666666">=</span><span style="color: #BA2121">"src"</span>
    )

    <span style="color: #008000; font-weight: bold">assert</span> result <span style="color: #666666">==</span> <span style="color: #BA2121">"short"</span>
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #008000">len</span>(client<span style="color: #666666">.</span>calls) <span style="color: #666666">&gt;</span> <span style="color: #666666">3</span>
    out <span style="color: #666666">=</span> capsys<span style="color: #666666">.</span>readouterr()<span style="color: #666666">.</span>out
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #BA2121">"Hierarchical merge pass"</span> <span style="color: #AA22FF; font-weight: bold">in</span> out
</code></pre>
<h3 id="test_cached_chunks_reused">test_cached_chunks_reused(tmp_path: Path) -&gt; None</h3>
<p>The function `test_cached_chunks_reused` tests the reuse of cached chunks during manual summarization. It creates a large text input composed of repeated paragraphs and uses a dummy client that tracks calls to a summarization method. The test verifies that when the same text is summarized twice with caching enabled, the first call makes three calls to the summarizer, while the second call with the same cache incurs no additional calls, demonstrating that cached results are properly reused. The test ensures that the `ResponseCache` correctly stores and retrieves previous summarization results to avoid redundant processing.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">test_cached_chunks_reused</span>(tmp_path: Path) <span style="color: #666666">-&gt;</span> <span style="color: #008000; font-weight: bold">None</span>:
    paragraph <span style="color: #666666">=</span> <span style="color: #BA2121">"word "</span> <span style="color: #666666">*</span> <span style="color: #666666">2000</span>
    text <span style="color: #666666">=</span> <span style="color: #BA2121">"</span><span style="color: #AA5D1F; font-weight: bold">\n\n</span><span style="color: #BA2121">"</span><span style="color: #666666">.</span>join([paragraph, paragraph])

    <span style="color: #008000; font-weight: bold">class</span> <span style="color: #0000FF; font-weight: bold">Dummy</span>:
        <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">__init__</span>(<span style="color: #008000">self</span>) <span style="color: #666666">-&gt;</span> <span style="color: #008000; font-weight: bold">None</span>:
            <span style="color: #008000">self</span><span style="color: #666666">.</span>calls: <span style="color: #008000">list</span>[<span style="color: #008000">dict</span>] <span style="color: #666666">=</span> []

        <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">summarize</span>(<span style="color: #008000">self</span>, text: <span style="color: #008000">str</span>, prompt_type: <span style="color: #008000">str</span>, system_prompt: <span style="color: #008000">str</span> <span style="color: #666666">=</span> <span style="color: #BA2121">""</span>) <span style="color: #666666">-&gt;</span> <span style="color: #008000">str</span>:
            <span style="color: #008000">self</span><span style="color: #666666">.</span>calls<span style="color: #666666">.</span>append(
                {<span style="color: #BA2121">"text"</span>: text, <span style="color: #BA2121">"prompt_type"</span>: prompt_type, <span style="color: #BA2121">"system_prompt"</span>: system_prompt}
            )
            <span style="color: #008000; font-weight: bold">return</span> <span style="color: #BA2121">f"resp</span><span style="color: #A45A77; font-weight: bold">{</span><span style="color: #008000">len</span>(<span style="color: #008000">self</span><span style="color: #666666">.</span>calls)<span style="color: #A45A77; font-weight: bold">}</span><span style="color: #BA2121">"</span>

    cache_file <span style="color: #666666">=</span> tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">"cache.json"</span>
    cache <span style="color: #666666">=</span> ResponseCache(<span style="color: #008000">str</span>(cache_file))
    client1 <span style="color: #666666">=</span> Dummy()
    result1 <span style="color: #666666">=</span> manual_utils<span style="color: #666666">.</span>_summarize_manual(
        client1, cache, text, chunking<span style="color: #666666">=</span><span style="color: #BA2121">"auto"</span>, source<span style="color: #666666">=</span><span style="color: #BA2121">"src"</span>
    )
    <span style="color: #008000; font-weight: bold">assert</span> result1 <span style="color: #666666">==</span> <span style="color: #BA2121">"resp3"</span>
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #008000">len</span>(client1<span style="color: #666666">.</span>calls) <span style="color: #666666">==</span> <span style="color: #666666">3</span>

    client2 <span style="color: #666666">=</span> Dummy()
    cache2 <span style="color: #666666">=</span> ResponseCache(<span style="color: #008000">str</span>(cache_file))
    result2 <span style="color: #666666">=</span> manual_utils<span style="color: #666666">.</span>_summarize_manual(
        client2, cache2, text, chunking<span style="color: #666666">=</span><span style="color: #BA2121">"auto"</span>, source<span style="color: #666666">=</span><span style="color: #BA2121">"src"</span>
    )
    <span style="color: #008000; font-weight: bold">assert</span> result2 <span style="color: #666666">==</span> <span style="color: #BA2121">"resp3"</span>
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #008000">len</span>(client2<span style="color: #666666">.</span>calls) <span style="color: #666666">==</span> <span style="color: #666666">0</span>
</code></pre>
<h3 id="test_chunking_none_no_llm_calls">test_chunking_none_no_llm_calls(tmp_path: Path, monkeypatch: pytest.MonkeyPatch) -&gt; None</h3>
<p>The function `test_chunking_none_no_llm_calls` is a test case that verifies the behavior of the documentation generation process when chunking is set to "none" and no LLM calls are expected. It creates a large text file (`README.md`) with repeated content, patches the `LLMClient` to intercept LLM calls, and runs the main documentation generation process with the specified chunking option. The test asserts that exactly five LLM calls are made and checks that the first call's system prompt contains the word "Overview".</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">test_chunking_none_no_llm_calls</span>(tmp_path: Path, monkeypatch: pytest<span style="color: #666666">.</span>MonkeyPatch) <span style="color: #666666">-&gt;</span> <span style="color: #008000; font-weight: bold">None</span>:
    big_text <span style="color: #666666">=</span> <span style="color: #BA2121">"data "</span> <span style="color: #666666">*</span> <span style="color: #666666">5000</span>
    (tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">"README.md"</span>)<span style="color: #666666">.</span>write_text(<span style="color: #BA2121">"# Overview</span><span style="color: #AA5D1F; font-weight: bold">\n</span><span style="color: #BA2121">"</span> <span style="color: #666666">+</span> big_text, encoding<span style="color: #666666">=</span><span style="color: #BA2121">"utf-8"</span>)

    <span style="color: #008000; font-weight: bold">class</span> <span style="color: #0000FF; font-weight: bold">Dummy</span>:
        <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">__init__</span>(<span style="color: #008000">self</span>) <span style="color: #666666">-&gt;</span> <span style="color: #008000; font-weight: bold">None</span>:
            <span style="color: #008000">self</span><span style="color: #666666">.</span>calls: <span style="color: #008000">list</span>[<span style="color: #008000">dict</span>] <span style="color: #666666">=</span> []

        <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">summarize</span>(<span style="color: #008000">self</span>, text: <span style="color: #008000">str</span>, prompt_type: <span style="color: #008000">str</span>, system_prompt: <span style="color: #008000">str</span> <span style="color: #666666">=</span> <span style="color: #BA2121">""</span>) <span style="color: #666666">-&gt;</span> <span style="color: #008000">str</span>:
            <span style="color: #008000">self</span><span style="color: #666666">.</span>calls<span style="color: #666666">.</span>append(
                {<span style="color: #BA2121">"text"</span>: text, <span style="color: #BA2121">"prompt_type"</span>: prompt_type, <span style="color: #BA2121">"system_prompt"</span>: system_prompt}
            )
            <span style="color: #008000; font-weight: bold">return</span> <span style="color: #BA2121">"done"</span>

    dummy <span style="color: #666666">=</span> Dummy()
    monkeypatch<span style="color: #666666">.</span>setattr(explaincode, <span style="color: #BA2121">"LLMClient"</span>, <span style="color: #008000; font-weight: bold">lambda</span>: dummy)
    main([<span style="color: #BA2121">"--path"</span>, <span style="color: #008000">str</span>(tmp_path), <span style="color: #BA2121">"--chunking"</span>, <span style="color: #BA2121">"none"</span>])

    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #008000">len</span>(dummy<span style="color: #666666">.</span>calls) <span style="color: #666666">==</span> <span style="color: #666666">5</span>
    call <span style="color: #666666">=</span> dummy<span style="color: #666666">.</span>calls[<span style="color: #666666">0</span>]
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #BA2121">"Overview"</span> <span style="color: #AA22FF; font-weight: bold">in</span> call[<span style="color: #BA2121">"system_prompt"</span>]
</code></pre>
<h3 id="test_llm_generate_manual_sanitizes_and_caches">test_llm_generate_manual_sanitizes_and_caches(tmp_path: Path, monkeypatch: pytest.MonkeyPatch) -&gt; None</h3>
<p>The function `test_llm_generate_manual_sanitizes_and_caches` tests the behavior of the `llm_generate_manual` function in the `explaincode` module. It verifies that the output from the language model is sanitized to remove specific prompt-related text and that the results are properly cached.

The test:

This test ensures that the LLM output is sanitized and that caching works correctly for manual documentation generation.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">test_llm_generate_manual_sanitizes_and_caches</span>(tmp_path: Path, monkeypatch: pytest<span style="color: #666666">.</span>MonkeyPatch) <span style="color: #666666">-&gt;</span> <span style="color: #008000; font-weight: bold">None</span>:
    docs <span style="color: #666666">=</span> {Path(<span style="color: #BA2121">"readme.md"</span>): <span style="color: #BA2121">"# Overview</span><span style="color: #AA5D1F; font-weight: bold">\n</span><span style="color: #BA2121">Example"</span>}
    cache <span style="color: #666666">=</span> ResponseCache(<span style="color: #008000">str</span>(tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">"cache.json"</span>))
    client <span style="color: #666666">=</span> explaincode<span style="color: #666666">.</span>LLMClient(<span style="color: #BA2121">"http://fake"</span>)

    <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">fake_summarize</span>(prompt: <span style="color: #008000">str</span>, prompt_type: <span style="color: #008000">str</span>, system_prompt: <span style="color: #008000">str</span> <span style="color: #666666">=</span> <span style="color: #BA2121">""</span>) <span style="color: #666666">-&gt;</span> <span style="color: #008000">str</span>:
        <span style="color: #008000; font-weight: bold">return</span> (
            <span style="color: #BA2121">"You are a documentation engine. Summarize the following.</span><span style="color: #AA5D1F; font-weight: bold">\n</span><span style="color: #BA2121">"</span>
            <span style="color: #BA2121">"It prints output."</span>
        )

    monkeypatch<span style="color: #666666">.</span>setattr(client, <span style="color: #BA2121">"summarize"</span>, fake_summarize)
    manual, _, _ <span style="color: #666666">=</span> explaincode<span style="color: #666666">.</span>llm_generate_manual(docs, client, cache, chunking<span style="color: #666666">=</span><span style="color: #BA2121">"none"</span>)
    lower <span style="color: #666666">=</span> manual<span style="color: #666666">.</span>lower()
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #BA2121">"documentation engine"</span> <span style="color: #AA22FF; font-weight: bold">not</span> <span style="color: #AA22FF; font-weight: bold">in</span> lower
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #BA2121">"summarize the following"</span> <span style="color: #AA22FF; font-weight: bold">not</span> <span style="color: #AA22FF; font-weight: bold">in</span> lower

    section_map, _ <span style="color: #666666">=</span> explaincode<span style="color: #666666">.</span>map_evidence_to_sections(docs)
    entries <span style="color: #666666">=</span> section_map[<span style="color: #BA2121">"Overview"</span>]
    context <span style="color: #666666">=</span> <span style="color: #BA2121">"</span><span style="color: #AA5D1F; font-weight: bold">\n\n</span><span style="color: #BA2121">"</span><span style="color: #666666">.</span>join(snippet <span style="color: #008000; font-weight: bold">for</span> _, snippet <span style="color: #AA22FF; font-weight: bold">in</span> entries)
    prompt <span style="color: #666666">=</span> (
        <span style="color: #BA2121">"Write the 'Overview' section of a user manual using the "</span>
        <span style="color: #BA2121">"following documentation snippets.</span><span style="color: #AA5D1F; font-weight: bold">\n\n</span><span style="color: #BA2121">"</span> <span style="color: #666666">+</span> context
    )
    key <span style="color: #666666">=</span> ResponseCache<span style="color: #666666">.</span>make_key(<span style="color: #BA2121">"section:Overview"</span>, prompt)
    cached <span style="color: #666666">=</span> cache<span style="color: #666666">.</span>get(key)
    <span style="color: #008000; font-weight: bold">assert</span> cached <span style="color: #AA22FF; font-weight: bold">is</span> <span style="color: #AA22FF; font-weight: bold">not</span> <span style="color: #008000; font-weight: bold">None</span>
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #BA2121">"documentation engine"</span> <span style="color: #AA22FF; font-weight: bold">not</span> <span style="color: #AA22FF; font-weight: bold">in</span> cached<span style="color: #666666">.</span>lower()
</code></pre>
<details>
<summary>Subfunction: fake_summarize(prompt: str, prompt_type: str, system_prompt: str='') -&gt; str</summary>
<h4 id="fake_summarize">fake_summarize(prompt: str, prompt_type: str, system_prompt: str='') -&gt; str</h4>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">fake_summarize</span>(prompt: <span style="color: #008000">str</span>, prompt_type: <span style="color: #008000">str</span>, system_prompt: <span style="color: #008000">str</span> <span style="color: #666666">=</span> <span style="color: #BA2121">""</span>) <span style="color: #666666">-&gt;</span> <span style="color: #008000">str</span>:
        <span style="color: #008000; font-weight: bold">return</span> (
            <span style="color: #BA2121">"You are a documentation engine. Summarize the following.</span><span style="color: #AA5D1F; font-weight: bold">\n</span><span style="color: #BA2121">"</span>
            <span style="color: #BA2121">"It prints output."</span>
        )
</code></pre>
</details>
</div>
    </main>
<script src="static/toggle.js"></script>
</body>
</html>
