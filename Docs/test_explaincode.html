<!-- Generated by DocGen-LM -->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>test_explaincode</title>
    <link rel="stylesheet" href="static/style.css">
</head>
<body>
    <button id="sidebar-toggle">Menu</button>
    <div class="sidebar">
        <h2>Navigation</h2>
        <ul>
        <li><a href="index.html"><strong>üè† Project Overview</strong></a></li>
<li><a href="cache.html">cache</a></li>
<li><a href="chunk_utils.html">chunk_utils</a></li>
<li><a href="docgenerator.html">docgenerator</a></li>
<li><a href="explaincode.html">explaincode</a></li>
<li><a href="gui_wrapper.html">gui_wrapper</a></li>
<li><a href="html_writer.html">html_writer</a></li>
<li><a href="llm_client.html">llm_client</a></li>
<li><a href="manual_utils.html">manual_utils</a></li>
<li><a href="parser_cpp.html">parser_cpp</a></li>
<li><a href="parser_java.html">parser_java</a></li>
<li><a href="parser_matlab.html">parser_matlab</a></li>
<li><a href="parser_python.html">parser_python</a></li>
<li><a href="reviewer.html">reviewer</a></li>
<li><a href="scanner.html">scanner</a></li>
<li><a href="setup.html">setup</a></li>
<li><a href="summarize_utils.html">summarize_utils</a></li>
<li><a href="test_cache.html">test_cache</a></li>
<li><a href="test_chunk_utils.html">test_chunk_utils</a></li>
<li><a href="test_docgenerator.html">test_docgenerator</a></li>
<li><a href="test_docgenerator_subclasses.html">test_docgenerator_subclasses</a></li>
<li><a href="test_explaincode.html">test_explaincode</a></li>
<li><a href="test_html_writer.html">test_html_writer</a></li>
<li><a href="test_integration.html">test_integration</a></li>
<li><a href="test_llm_client.html">test_llm_client</a></li>
<li><a href="test_manual_utils.html">test_manual_utils</a></li>
<li><a href="test_parser_cpp.html">test_parser_cpp</a></li>
<li><a href="test_parser_java.html">test_parser_java</a></li>
<li><a href="test_parser_matlab.html">test_parser_matlab</a></li>
<li><a href="test_parser_python.html">test_parser_python</a></li>
<li><a href="test_reviewer.html">test_reviewer</a></li>
<li><a href="test_scanner.html">test_scanner</a></li>
        </ul>
    </div>
    <div class="content">
        <h1>test_explaincode</h1>
        <p>The code defines several functions and tests for creating documentation summaries, extracting text from files, rendering HTML, and handling different file formats. It includes a fixture creation function `_create_fixture`, a mock LLM client `_mock_llm_client`, and various test functions to ensure the functionality works as expected. The tests cover Markdown, HTML, and DOCX file processing, as well as PDF output generation. Additionally, there are functions for inferring sections from text, detecting placeholders, parsing manual content, validating references, and extracting snippets from code files. The module also contains several test functions for a code documentation tool, testing aspects such as categorizing code snippets, ranking code files, filling placeholders in user manuals, and handling various command-line options. These tests use `pytest` fixtures to set up temporary directories and mock objects for dependencies like file operations and external API calls. Furthermore, the module includes test functions for a summarization process, covering chunking, merging, caching, and large text handling. These tests utilize a mock client to simulate LLM calls and validate system behavior under different conditions.</p>
<h2>Functions</h2>
<h3 id="_create_fixture">_create_fixture(tmp_path: Path) -&gt; None</h3>
<p>Creates a temporary directory structure with nested subdirectories and files. Generates an HTML file in the nested directory, a README.md file with structured content, and a sample JSON file.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">_create_fixture</span>(tmp_path: Path) <span style="color: #666666">-&gt;</span> <span style="color: #008000; font-weight: bold">None</span>:
    nested <span style="color: #666666">=</span> tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;subdir&quot;</span> <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;nested&quot;</span>
    nested<span style="color: #666666">.</span>mkdir(parents<span style="color: #666666">=</span><span style="color: #008000; font-weight: bold">True</span>)
    (nested <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;page.html&quot;</span>)<span style="color: #666666">.</span>write_text(
        <span style="color: #BA2121">&quot;&lt;html&gt;&lt;body&gt;&lt;h1&gt;Overview&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;&quot;</span>, encoding<span style="color: #666666">=</span><span style="color: #BA2121">&quot;utf-8&quot;</span>
    )
    content <span style="color: #666666">=</span> textwrap<span style="color: #666666">.</span>dedent(
<span style="color: #bbbbbb">        </span><span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;</span>
<span style="color: #BA2121; font-style: italic">        # Overview</span>
<span style="color: #BA2121; font-style: italic">        Demo project</span>

<span style="color: #BA2121; font-style: italic">        # Purpose &amp; Problem Solving</span>
<span style="color: #BA2121; font-style: italic">        Solves a problem</span>

<span style="color: #BA2121; font-style: italic">        # How to Run</span>
<span style="color: #BA2121; font-style: italic">        Usage: run it</span>

<span style="color: #BA2121; font-style: italic">        # Inputs</span>
<span style="color: #BA2121; font-style: italic">        Input data</span>

<span style="color: #BA2121; font-style: italic">        # Outputs</span>
<span style="color: #BA2121; font-style: italic">        Output data</span>

<span style="color: #BA2121; font-style: italic">        # System Requirements</span>
<span style="color: #BA2121; font-style: italic">        None</span>

<span style="color: #BA2121; font-style: italic">        # Examples</span>
<span style="color: #BA2121; font-style: italic">        Example usage</span>
<span style="color: #BA2121; font-style: italic">        &quot;&quot;&quot;</span>
    )<span style="color: #666666">.</span>strip()
    (tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;README.md&quot;</span>)<span style="color: #666666">.</span>write_text(content, encoding<span style="color: #666666">=</span><span style="color: #BA2121">&quot;utf-8&quot;</span>)
    (tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;sample.json&quot;</span>)<span style="color: #666666">.</span>write_text(<span style="color: #BA2121">&quot;{</span><span style="color: #AA5D1F; font-weight: bold">\&quot;</span><span style="color: #BA2121">input</span><span style="color: #AA5D1F; font-weight: bold">\&quot;</span><span style="color: #BA2121">: </span><span style="color: #AA5D1F; font-weight: bold">\&quot;</span><span style="color: #BA2121">data</span><span style="color: #AA5D1F; font-weight: bold">\&quot;</span><span style="color: #BA2121">}&quot;</span>, encoding<span style="color: #666666">=</span><span style="color: #BA2121">&quot;utf-8&quot;</span>)
</code></pre>
<h3 id="_mock_llm_client">_mock_llm_client() -&gt; object</h3>
<p>This function `_mock_llm_client` returns an object that simulates a client for interacting with a language model (LLM). The returned object has a method `summarize` which takes three parameters: `text`, `prompt_type`, and an optional `system_prompt`. When called, this method returns a predefined summary string formatted using `textwrap.dedent`. The summary includes sections such as Overview, Purpose &amp; Problem Solving, How to Run, Inputs, Outputs, System Requirements, and Examples. This mock LLM client is intended for testing or demonstration purposes where an actual LLM interaction is not required.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">_mock_llm_client</span>() <span style="color: #666666">-&gt;</span> <span style="color: #008000">object</span>:
    <span style="color: #008000; font-weight: bold">class</span> <span style="color: #0000FF; font-weight: bold">Dummy</span>:
        <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">summarize</span>(<span style="color: #008000">self</span>, text: <span style="color: #008000">str</span>, prompt_type: <span style="color: #008000">str</span>, system_prompt: <span style="color: #008000">str</span> <span style="color: #666666">=</span> <span style="color: #BA2121">&quot;&quot;</span>) <span style="color: #666666">-&gt;</span> <span style="color: #008000">str</span>:  <span style="color: #3D7B7B; font-style: italic"># pragma: no cover - simple stub</span>
            <span style="color: #008000; font-weight: bold">return</span> textwrap<span style="color: #666666">.</span>dedent(
<span style="color: #bbbbbb">                </span><span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;</span>
<span style="color: #BA2121; font-style: italic">                Overview: Demo project</span>
<span style="color: #BA2121; font-style: italic">                Purpose &amp; Problem Solving: Solves a problem</span>
<span style="color: #BA2121; font-style: italic">                How to Run: Execute it</span>
<span style="color: #BA2121; font-style: italic">                Inputs: Input data</span>
<span style="color: #BA2121; font-style: italic">                Outputs: Output data</span>
<span style="color: #BA2121; font-style: italic">                System Requirements: None</span>
<span style="color: #BA2121; font-style: italic">                Examples: Example usage</span>
<span style="color: #BA2121; font-style: italic">                &quot;&quot;&quot;</span>
            )<span style="color: #666666">.</span>strip()

    <span style="color: #008000; font-weight: bold">return</span> Dummy()
</code></pre>
<h3 id="test_extract_text_markdown_preserves_headings_and_code">test_extract_text_markdown_preserves_headings_and_code(tmp_path: Path) -&gt; None</h3>
<p>This function `test_extract_text_markdown_preserves_headings_and_code` tests the `extract_text` function from the `explaincode` module. It creates a temporary Markdown file with headings and code blocks, writes it to disk, and then reads it back using the `extract_text` function. The test asserts that the extracted text contains the original headings (`# Title`) and code blocks (including the Python print statement).</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">test_extract_text_markdown_preserves_headings_and_code</span>(tmp_path: Path) <span style="color: #666666">-&gt;</span> <span style="color: #008000; font-weight: bold">None</span>:
    content <span style="color: #666666">=</span> <span style="color: #BA2121">&quot;&quot;&quot;</span>
<span style="color: #BA2121"># Title</span>

<span style="color: #BA2121">Text</span>

<span style="color: #BA2121">```python</span>
<span style="color: #BA2121">print(&#39;hi&#39;)</span>
<span style="color: #BA2121">```</span>
<span style="color: #BA2121">&quot;&quot;&quot;</span>
    md <span style="color: #666666">=</span> tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;readme.md&quot;</span>
    md<span style="color: #666666">.</span>write_text(content, encoding<span style="color: #666666">=</span><span style="color: #BA2121">&quot;utf-8&quot;</span>)
    text <span style="color: #666666">=</span> explaincode<span style="color: #666666">.</span>extract_text(md)
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #BA2121">&quot;# Title&quot;</span> <span style="color: #AA22FF; font-weight: bold">in</span> text
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #BA2121">&quot;```python&quot;</span> <span style="color: #AA22FF; font-weight: bold">in</span> text
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #BA2121">&quot;print(&#39;hi&#39;)&quot;</span> <span style="color: #AA22FF; font-weight: bold">in</span> text
</code></pre>
<h3 id="test_extract_text_html_preserves_headings_and_code">test_extract_text_html_preserves_headings_and_code(tmp_path: Path) -&gt; None</h3>
<p>The function `test_extract_text_html_preserves_headings_and_code` tests the `extract_text` function from the `explaincode` module. It creates a temporary HTML file with headings (`&lt;h1&gt;`, `&lt;h2&gt;`) and code blocks (`&lt;pre&gt;&lt;code&gt;`). The function reads this HTML file, extracts the text while preserving the structure of headings and code blocks, and asserts that the extracted text contains the expected headings and code content.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">test_extract_text_html_preserves_headings_and_code</span>(tmp_path: Path) <span style="color: #666666">-&gt;</span> <span style="color: #008000; font-weight: bold">None</span>:
    html <span style="color: #666666">=</span> (
        <span style="color: #BA2121">&quot;&lt;html&gt;&lt;body&gt;&lt;h1&gt;Main&lt;/h1&gt;&lt;p&gt;Intro&lt;/p&gt;&quot;</span>
        <span style="color: #BA2121">&quot;&lt;h2&gt;Section&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;print(&#39;hi&#39;)&lt;/code&gt;&lt;/pre&gt;&lt;/body&gt;&lt;/html&gt;&quot;</span>
    )
    page <span style="color: #666666">=</span> tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;page.html&quot;</span>
    page<span style="color: #666666">.</span>write_text(html, encoding<span style="color: #666666">=</span><span style="color: #BA2121">&quot;utf-8&quot;</span>)
    text <span style="color: #666666">=</span> explaincode<span style="color: #666666">.</span>extract_text(page)
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #BA2121">&quot;# Main&quot;</span> <span style="color: #AA22FF; font-weight: bold">in</span> text
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #BA2121">&quot;## Section&quot;</span> <span style="color: #AA22FF; font-weight: bold">in</span> text
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #BA2121">&quot;```&quot;</span> <span style="color: #AA22FF; font-weight: bold">in</span> text <span style="color: #AA22FF; font-weight: bold">and</span> <span style="color: #BA2121">&quot;print(&#39;hi&#39;)&quot;</span> <span style="color: #AA22FF; font-weight: bold">in</span> text
</code></pre>
<h3 id="test_extract_text_docx_preserves_headings">test_extract_text_docx_preserves_headings(tmp_path: Path) -&gt; None</h3>
<p>The function `test_extract_text_docx_preserves_headings` tests the ability of a hypothetical `explaincode.extract_text` function to correctly extract and preserve headings from a DOCX file. It creates a temporary DOCX document with a heading and a paragraph, saves it, and then uses `explaincode.extract_text` to read the content. The test asserts that the extracted text starts with a Markdown-formatted heading (`# Title`) and includes the plain text &quot;Text&quot;.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">test_extract_text_docx_preserves_headings</span>(tmp_path: Path) <span style="color: #666666">-&gt;</span> <span style="color: #008000; font-weight: bold">None</span>:
    <span style="color: #008000; font-weight: bold">try</span>:
        <span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">docx</span> <span style="color: #008000; font-weight: bold">import</span> Document
    <span style="color: #008000; font-weight: bold">except</span> <span style="color: #CB3F38; font-weight: bold">Exception</span>:  <span style="color: #3D7B7B; font-style: italic"># pragma: no cover - dependency missing</span>
        pytest<span style="color: #666666">.</span>skip(<span style="color: #BA2121">&quot;python-docx not installed&quot;</span>)

    doc <span style="color: #666666">=</span> Document()
    doc<span style="color: #666666">.</span>add_heading(<span style="color: #BA2121">&quot;Title&quot;</span>, level<span style="color: #666666">=1</span>)
    doc<span style="color: #666666">.</span>add_paragraph(<span style="color: #BA2121">&quot;Text&quot;</span>)
    path <span style="color: #666666">=</span> tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;doc.docx&quot;</span>
    doc<span style="color: #666666">.</span>save(path)
    text <span style="color: #666666">=</span> explaincode<span style="color: #666666">.</span>extract_text(path)
    <span style="color: #008000; font-weight: bold">assert</span> text<span style="color: #666666">.</span>splitlines()[<span style="color: #666666">0</span>] <span style="color: #666666">==</span> <span style="color: #BA2121">&quot;# Title&quot;</span>
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #BA2121">&quot;Text&quot;</span> <span style="color: #AA22FF; font-weight: bold">in</span> text
</code></pre>
<h3 id="test_render_html_renders_markdown_headings_and_code">test_render_html_renders_markdown_headings_and_code() -&gt; None</h3>
<p>The function `test_render_html_renders_markdown_headings_and_code` tests the `render_html` function from the `explaincode` module. It creates a dictionary of sections with a Markdown heading and Python code snippet. The function then renders this into HTML using `explaincode.render_html`. The rendered HTML is parsed using BeautifulSoup to check if it contains an `&lt;h1&gt;` element with the text &quot;Title&quot; and a `&lt;pre&gt;&lt;code&gt;` block containing the string &quot;print(&#x27;hi&#x27;)&quot;.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">test_render_html_renders_markdown_headings_and_code</span>() <span style="color: #666666">-&gt;</span> <span style="color: #008000; font-weight: bold">None</span>:
    sections <span style="color: #666666">=</span> {
        <span style="color: #BA2121">&quot;Intro&quot;</span>: <span style="color: #BA2121">&quot;# Title</span><span style="color: #AA5D1F; font-weight: bold">\n\n</span><span style="color: #BA2121">```python</span><span style="color: #AA5D1F; font-weight: bold">\n</span><span style="color: #BA2121">print(&#39;hi&#39;)</span><span style="color: #AA5D1F; font-weight: bold">\n</span><span style="color: #BA2121">```&quot;</span>,
    }
    html <span style="color: #666666">=</span> explaincode<span style="color: #666666">.</span>render_html(sections, <span style="color: #BA2121">&quot;Manual&quot;</span>)
    soup <span style="color: #666666">=</span> BeautifulSoup(html, <span style="color: #BA2121">&quot;html.parser&quot;</span>)
    <span style="color: #008000; font-weight: bold">assert</span> soup<span style="color: #666666">.</span>find(<span style="color: #BA2121">&quot;h1&quot;</span>, string<span style="color: #666666">=</span><span style="color: #BA2121">&quot;Title&quot;</span>) <span style="color: #AA22FF; font-weight: bold">is</span> <span style="color: #AA22FF; font-weight: bold">not</span> <span style="color: #008000; font-weight: bold">None</span>
    code <span style="color: #666666">=</span> soup<span style="color: #666666">.</span>find(<span style="color: #BA2121">&quot;pre&quot;</span>)<span style="color: #666666">.</span>find(<span style="color: #BA2121">&quot;code&quot;</span>)
    <span style="color: #008000; font-weight: bold">assert</span> code <span style="color: #AA22FF; font-weight: bold">is</span> <span style="color: #AA22FF; font-weight: bold">not</span> <span style="color: #008000; font-weight: bold">None</span> <span style="color: #AA22FF; font-weight: bold">and</span> <span style="color: #BA2121">&quot;print(&#39;hi&#39;)&quot;</span> <span style="color: #AA22FF; font-weight: bold">in</span> code<span style="color: #666666">.</span>text
</code></pre>
<h3 id="test_render_html_includes_toc_and_sources_block">test_render_html_includes_toc_and_sources_block() -&gt; None</h3>
<p>The function `test_render_html_includes_toc_and_sources_block` tests the HTML rendering functionality of a documentation tool. It verifies that the generated HTML includes a table of contents (TOC) and source blocks containing specific file snippets. The test uses predefined sections and evidence, renders the HTML using the `explaincode.render_html` function, and then checks if the TOC contains links to &quot;Overview&quot; and &quot;How to Run&quot;. Additionally, it ensures that the source blocks include text from &quot;readme.md&quot; and &quot;run.py&quot; files.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">test_render_html_includes_toc_and_sources_block</span>() <span style="color: #666666">-&gt;</span> <span style="color: #008000; font-weight: bold">None</span>:
    sections <span style="color: #666666">=</span> {<span style="color: #BA2121">&quot;Overview&quot;</span>: <span style="color: #BA2121">&quot;&quot;</span>, <span style="color: #BA2121">&quot;How to Run&quot;</span>: <span style="color: #BA2121">&quot;&quot;</span>}
    evidence <span style="color: #666666">=</span> {
        <span style="color: #BA2121">&quot;Overview&quot;</span>: {<span style="color: #BA2121">&quot;evidence&quot;</span>: [{<span style="color: #BA2121">&quot;snippet&quot;</span>: <span style="color: #BA2121">&quot;info&quot;</span>, <span style="color: #BA2121">&quot;file&quot;</span>: <span style="color: #BA2121">&quot;readme.md&quot;</span>}]},
        <span style="color: #BA2121">&quot;How to Run&quot;</span>: {<span style="color: #BA2121">&quot;evidence&quot;</span>: [{<span style="color: #BA2121">&quot;snippet&quot;</span>: <span style="color: #BA2121">&quot;run&quot;</span>, <span style="color: #BA2121">&quot;file&quot;</span>: <span style="color: #BA2121">&quot;run.py&quot;</span>}]},
    }
    html <span style="color: #666666">=</span> explaincode<span style="color: #666666">.</span>render_html(sections, <span style="color: #BA2121">&quot;Manual&quot;</span>, evidence)
    soup <span style="color: #666666">=</span> BeautifulSoup(html, <span style="color: #BA2121">&quot;html.parser&quot;</span>)
    nav <span style="color: #666666">=</span> soup<span style="color: #666666">.</span>find(<span style="color: #BA2121">&quot;nav&quot;</span>)
    <span style="color: #008000; font-weight: bold">assert</span> nav <span style="color: #AA22FF; font-weight: bold">is</span> <span style="color: #AA22FF; font-weight: bold">not</span> <span style="color: #008000; font-weight: bold">None</span> <span style="color: #AA22FF; font-weight: bold">and</span> nav<span style="color: #666666">.</span>find(<span style="color: #BA2121">&quot;a&quot;</span>, href<span style="color: #666666">=</span><span style="color: #BA2121">&quot;#overview&quot;</span>) <span style="color: #AA22FF; font-weight: bold">is</span> <span style="color: #AA22FF; font-weight: bold">not</span> <span style="color: #008000; font-weight: bold">None</span>
    sources_blocks <span style="color: #666666">=</span> soup<span style="color: #666666">.</span>find_all(<span style="color: #BA2121">&quot;div&quot;</span>, class_<span style="color: #666666">=</span><span style="color: #BA2121">&quot;sources&quot;</span>)
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #008000">any</span>(<span style="color: #BA2121">&quot;readme.md&quot;</span> <span style="color: #AA22FF; font-weight: bold">in</span> block<span style="color: #666666">.</span>text <span style="color: #008000; font-weight: bold">for</span> block <span style="color: #AA22FF; font-weight: bold">in</span> sources_blocks)
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #008000">any</span>(<span style="color: #BA2121">&quot;run.py&quot;</span> <span style="color: #AA22FF; font-weight: bold">in</span> block<span style="color: #666666">.</span>text <span style="color: #008000; font-weight: bold">for</span> block <span style="color: #AA22FF; font-weight: bold">in</span> sources_blocks)
</code></pre>
<h3 id="test_html_summary_creation">test_html_summary_creation(tmp_path: Path, monkeypatch: pytest.MonkeyPatch) -&gt; None</h3>
<p>This function `test_html_summary_creation` tests the creation of HTML summaries for a project. It uses a temporary path (`tmp_path`) and a monkeypatch to mock an LLM client. The function calls `main` with a specified path, which presumably generates documentation. It then checks that both a manual file (`user_manual.html`) and evidence file (`user_manual_evidence.json`) exist in the temporary path. The evidence file is parsed to ensure it contains an &quot;Overview&quot; section with evidence data. The HTML text is read and checked to ensure it does not contain the string &quot;No information provided.&quot; Finally, the function uses BeautifulSoup to parse the HTML and verifies that a navigation element (`nav`) exists with a link to the &quot;Overview&quot; section.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">test_html_summary_creation</span>(tmp_path: Path, monkeypatch: pytest<span style="color: #666666">.</span>MonkeyPatch) <span style="color: #666666">-&gt;</span> <span style="color: #008000; font-weight: bold">None</span>:
    _create_fixture(tmp_path)
    monkeypatch<span style="color: #666666">.</span>setattr(explaincode, <span style="color: #BA2121">&quot;LLMClient&quot;</span>, _mock_llm_client)
    main([<span style="color: #BA2121">&quot;--path&quot;</span>, <span style="color: #008000">str</span>(tmp_path)])
    manual <span style="color: #666666">=</span> tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;user_manual.html&quot;</span>
    evidence <span style="color: #666666">=</span> tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;user_manual_evidence.json&quot;</span>
    <span style="color: #008000; font-weight: bold">assert</span> manual<span style="color: #666666">.</span>exists()
    <span style="color: #008000; font-weight: bold">assert</span> evidence<span style="color: #666666">.</span>exists()
    data <span style="color: #666666">=</span> json<span style="color: #666666">.</span>loads(evidence<span style="color: #666666">.</span>read_text(encoding<span style="color: #666666">=</span><span style="color: #BA2121">&quot;utf-8&quot;</span>))
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #BA2121">&quot;Overview&quot;</span> <span style="color: #AA22FF; font-weight: bold">in</span> data
    <span style="color: #008000; font-weight: bold">assert</span> data[<span style="color: #BA2121">&quot;Overview&quot;</span>][<span style="color: #BA2121">&quot;evidence&quot;</span>]
    html_text <span style="color: #666666">=</span> manual<span style="color: #666666">.</span>read_text(encoding<span style="color: #666666">=</span><span style="color: #BA2121">&quot;utf-8&quot;</span>)
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #BA2121">&quot;No information provided.&quot;</span> <span style="color: #AA22FF; font-weight: bold">not</span> <span style="color: #AA22FF; font-weight: bold">in</span> html_text
    soup <span style="color: #666666">=</span> BeautifulSoup(html_text, <span style="color: #BA2121">&quot;html.parser&quot;</span>)
    nav <span style="color: #666666">=</span> soup<span style="color: #666666">.</span>find(<span style="color: #BA2121">&quot;nav&quot;</span>)
    <span style="color: #008000; font-weight: bold">assert</span> nav <span style="color: #AA22FF; font-weight: bold">is</span> <span style="color: #AA22FF; font-weight: bold">not</span> <span style="color: #008000; font-weight: bold">None</span> <span style="color: #AA22FF; font-weight: bold">and</span> nav<span style="color: #666666">.</span>find(<span style="color: #BA2121">&quot;a&quot;</span>, href<span style="color: #666666">=</span><span style="color: #BA2121">&quot;#overview&quot;</span>) <span style="color: #AA22FF; font-weight: bold">is</span> <span style="color: #AA22FF; font-weight: bold">not</span> <span style="color: #008000; font-weight: bold">None</span>
</code></pre>
<h3 id="test_pdf_summary_creation">test_pdf_summary_creation(tmp_path: Path, monkeypatch: pytest.MonkeyPatch) -&gt; None</h3>
<p>This function tests the creation of a PDF summary for a project. It checks if `reportlab` is installed, creates a fixture using `_create_fixture`, mocks an LLM client with `_mock_llm_client`, runs the main function with specified path and output format, and asserts that the generated PDF and evidence JSON files exist in the temporary path.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">test_pdf_summary_creation</span>(tmp_path: Path, monkeypatch: pytest<span style="color: #666666">.</span>MonkeyPatch) <span style="color: #666666">-&gt;</span> <span style="color: #008000; font-weight: bold">None</span>:
    <span style="color: #008000; font-weight: bold">if</span> importlib<span style="color: #666666">.</span>util<span style="color: #666666">.</span>find_spec(<span style="color: #BA2121">&quot;reportlab&quot;</span>) <span style="color: #AA22FF; font-weight: bold">is</span> <span style="color: #008000; font-weight: bold">None</span>:
        pytest<span style="color: #666666">.</span>skip(<span style="color: #BA2121">&quot;reportlab not installed&quot;</span>)
    _create_fixture(tmp_path)
    monkeypatch<span style="color: #666666">.</span>setattr(explaincode, <span style="color: #BA2121">&quot;LLMClient&quot;</span>, _mock_llm_client)
    main([<span style="color: #BA2121">&quot;--path&quot;</span>, <span style="color: #008000">str</span>(tmp_path), <span style="color: #BA2121">&quot;--output-format&quot;</span>, <span style="color: #BA2121">&quot;pdf&quot;</span>])
    <span style="color: #008000; font-weight: bold">assert</span> (tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;user_manual.pdf&quot;</span>)<span style="color: #666666">.</span>exists()
    <span style="color: #008000; font-weight: bold">assert</span> (tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;user_manual_evidence.json&quot;</span>)<span style="color: #666666">.</span>exists()
</code></pre>
<h3 id="test_graceful_missing_docx">test_graceful_missing_docx(monkeypatch: pytest.MonkeyPatch, tmp_path: Path) -&gt; None</h3>
<p>The function `test_graceful_missing_docx` is a test case designed to verify the behavior of a documentation generation tool when the required `python-docx` library is missing. It uses pytest fixtures for setup and teardown, ensuring that a temporary directory is created and used during the test.

1. The function first creates a fixture using `_create_fixture(tmp_path)`, which likely sets up some initial conditions or files in the temporary path.
2. It attempts to import `Document` from the `docx` module. If successful, it creates a new document, adds a paragraph, and saves it as &quot;guide.docx&quot; in the temporary path.
3. The function then uses `monkeypatch.setattr` to mock out the `Document` class and `LLMClient` within the `explaincode` module with `_mock_llm_client`.
4. It calls the `main` function with a command-line argument specifying the path of the temporary directory.
5. Finally, it asserts that two files are created in the temporary path: &quot;user_manual.html&quot; and &quot;user_manual_evidence.json&quot;. This indicates that the documentation generation process completed successfully even though the `python-docx` library was not available.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">test_graceful_missing_docx</span>(monkeypatch: pytest<span style="color: #666666">.</span>MonkeyPatch, tmp_path: Path) <span style="color: #666666">-&gt;</span> <span style="color: #008000; font-weight: bold">None</span>:
    _create_fixture(tmp_path)
    <span style="color: #008000; font-weight: bold">try</span>:
        <span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">docx</span> <span style="color: #008000; font-weight: bold">import</span> Document
    <span style="color: #008000; font-weight: bold">except</span> <span style="color: #CB3F38; font-weight: bold">Exception</span>:  <span style="color: #3D7B7B; font-style: italic"># pragma: no cover - dependency missing</span>
        Document <span style="color: #666666">=</span> <span style="color: #008000; font-weight: bold">None</span>  <span style="color: #3D7B7B; font-style: italic"># type: ignore</span>
    <span style="color: #008000; font-weight: bold">if</span> Document:
        doc <span style="color: #666666">=</span> Document()
        doc<span style="color: #666666">.</span>add_paragraph(<span style="color: #BA2121">&quot;hi&quot;</span>)
        doc<span style="color: #666666">.</span>save(tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;guide.docx&quot;</span>)
    monkeypatch<span style="color: #666666">.</span>setattr(explaincode, <span style="color: #BA2121">&quot;Document&quot;</span>, <span style="color: #008000; font-weight: bold">None</span>)
    monkeypatch<span style="color: #666666">.</span>setattr(explaincode, <span style="color: #BA2121">&quot;LLMClient&quot;</span>, _mock_llm_client)
    main([<span style="color: #BA2121">&quot;--path&quot;</span>, <span style="color: #008000">str</span>(tmp_path)])
    <span style="color: #008000; font-weight: bold">assert</span> (tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;user_manual.html&quot;</span>)<span style="color: #666666">.</span>exists()
    <span style="color: #008000; font-weight: bold">assert</span> (tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;user_manual_evidence.json&quot;</span>)<span style="color: #666666">.</span>exists()
</code></pre>
<h3 id="test_custom_output_directory">test_custom_output_directory(tmp_path: Path, monkeypatch: pytest.MonkeyPatch) -&gt; None</h3>
<p>This function tests the functionality of generating documentation in a custom output directory. It creates a fixture using `_create_fixture` and sets up a mock LLM client with `_mock_llm_client`. The `main` function is then called with the specified input path and custom output directory. The test asserts that the expected HTML file (`user_manual.html`) and JSON evidence file (`user_manual_evidence.json`) exist in the custom output directory.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">test_custom_output_directory</span>(tmp_path: Path, monkeypatch: pytest<span style="color: #666666">.</span>MonkeyPatch) <span style="color: #666666">-&gt;</span> <span style="color: #008000; font-weight: bold">None</span>:
    _create_fixture(tmp_path)
    out_dir <span style="color: #666666">=</span> tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;dist&quot;</span>
    monkeypatch<span style="color: #666666">.</span>setattr(explaincode, <span style="color: #BA2121">&quot;LLMClient&quot;</span>, _mock_llm_client)
    main([<span style="color: #BA2121">&quot;--path&quot;</span>, <span style="color: #008000">str</span>(tmp_path), <span style="color: #BA2121">&quot;--output&quot;</span>, <span style="color: #008000">str</span>(out_dir)])
    <span style="color: #008000; font-weight: bold">assert</span> (out_dir <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;user_manual.html&quot;</span>)<span style="color: #666666">.</span>exists()
    <span style="color: #008000; font-weight: bold">assert</span> (out_dir <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;user_manual_evidence.json&quot;</span>)<span style="color: #666666">.</span>exists()
</code></pre>
<h3 id="test_collect_docs_filters">test_collect_docs_filters(tmp_path: Path) -&gt; None</h3>
<p>The function `test_collect_docs_filters` tests the `collect_docs` function from the `explaincode` module. It creates a temporary directory with various files, including Markdown and text files. The `collect_docs` function is expected to filter out non-Markdown files and return only those named &quot;keep.md&quot;. The test asserts that &quot;keep.md&quot; is in the set of collected file names and that &quot;skip.txt&quot; is not included.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">test_collect_docs_filters</span>(tmp_path: Path) <span style="color: #666666">-&gt;</span> <span style="color: #008000; font-weight: bold">None</span>:
    (tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;docs&quot;</span>)<span style="color: #666666">.</span>mkdir()
    (tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;docs&quot;</span> <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;keep.md&quot;</span>)<span style="color: #666666">.</span>write_text(<span style="color: #BA2121">&quot;hi&quot;</span>, encoding<span style="color: #666666">=</span><span style="color: #BA2121">&quot;utf-8&quot;</span>)
    (tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;docs&quot;</span> <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;skip.txt&quot;</span>)<span style="color: #666666">.</span>write_text(<span style="color: #BA2121">&quot;no&quot;</span>, encoding<span style="color: #666666">=</span><span style="color: #BA2121">&quot;utf-8&quot;</span>)
    (tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;README.md&quot;</span>)<span style="color: #666666">.</span>write_text(<span style="color: #BA2121">&quot;readme&quot;</span>, encoding<span style="color: #666666">=</span><span style="color: #BA2121">&quot;utf-8&quot;</span>)
    (tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;extra.md&quot;</span>)<span style="color: #666666">.</span>write_text(<span style="color: #BA2121">&quot;extra&quot;</span>, encoding<span style="color: #666666">=</span><span style="color: #BA2121">&quot;utf-8&quot;</span>)
    files <span style="color: #666666">=</span> explaincode<span style="color: #666666">.</span>collect_docs(tmp_path)
    names <span style="color: #666666">=</span> {f<span style="color: #666666">.</span>name <span style="color: #008000; font-weight: bold">for</span> f <span style="color: #AA22FF; font-weight: bold">in</span> files}
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #BA2121">&quot;keep.md&quot;</span> <span style="color: #AA22FF; font-weight: bold">in</span> names <span style="color: #AA22FF; font-weight: bold">and</span> <span style="color: #BA2121">&quot;skip.txt&quot;</span> <span style="color: #AA22FF; font-weight: bold">not</span> <span style="color: #AA22FF; font-weight: bold">in</span> names
</code></pre>
<h3 id="test_map_evidence_overview_priority_and_filters">test_map_evidence_overview_priority_and_filters() -&gt; None</h3>
<p>The function `test_map_evidence_overview_priority_and_filters` tests the `map_evidence_to_sections` function from the `explaincode` module. It creates a dictionary of file paths and their content, simulating a collection of documentation files. The function maps these files to sections based on their content and filters out files in specific directories (`tests`, `examples`, `fixtures`). The test asserts that files in ignored directories are not included in the mapped sections and that the first two files are from the expected paths, while the third file is from a different path.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">test_map_evidence_overview_priority_and_filters</span>() <span style="color: #666666">-&gt;</span> <span style="color: #008000; font-weight: bold">None</span>:
    docs <span style="color: #666666">=</span> {
        Path(<span style="color: #BA2121">&quot;README.md&quot;</span>): <span style="color: #BA2121">&quot;# Overview</span><span style="color: #AA5D1F; font-weight: bold">\n</span><span style="color: #BA2121">readme info&quot;</span>,
        Path(<span style="color: #BA2121">&quot;docs/guide.md&quot;</span>): <span style="color: #BA2121">&quot;# Overview</span><span style="color: #AA5D1F; font-weight: bold">\n</span><span style="color: #BA2121">docs info&quot;</span>,
        Path(<span style="color: #BA2121">&quot;src/other.md&quot;</span>): <span style="color: #BA2121">&quot;# Overview</span><span style="color: #AA5D1F; font-weight: bold">\n</span><span style="color: #BA2121">other info&quot;</span>,
        Path(<span style="color: #BA2121">&quot;tests/ignore.md&quot;</span>): <span style="color: #BA2121">&quot;# Overview</span><span style="color: #AA5D1F; font-weight: bold">\n</span><span style="color: #BA2121">test info&quot;</span>,
        Path(<span style="color: #BA2121">&quot;examples/ignore.md&quot;</span>): <span style="color: #BA2121">&quot;# Overview</span><span style="color: #AA5D1F; font-weight: bold">\n</span><span style="color: #BA2121">example info&quot;</span>,
        Path(<span style="color: #BA2121">&quot;fixtures/ignore.md&quot;</span>): <span style="color: #BA2121">&quot;# Overview</span><span style="color: #AA5D1F; font-weight: bold">\n</span><span style="color: #BA2121">fixture info&quot;</span>,
    }
    section_map, _ <span style="color: #666666">=</span> explaincode<span style="color: #666666">.</span>map_evidence_to_sections(docs)
    sources <span style="color: #666666">=</span> [p<span style="color: #666666">.</span>as_posix() <span style="color: #008000; font-weight: bold">for</span> p, _ <span style="color: #AA22FF; font-weight: bold">in</span> section_map[<span style="color: #BA2121">&quot;Overview&quot;</span>]]
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #BA2121">&quot;tests/ignore.md&quot;</span> <span style="color: #AA22FF; font-weight: bold">not</span> <span style="color: #AA22FF; font-weight: bold">in</span> sources
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #BA2121">&quot;examples/ignore.md&quot;</span> <span style="color: #AA22FF; font-weight: bold">not</span> <span style="color: #AA22FF; font-weight: bold">in</span> sources
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #BA2121">&quot;fixtures/ignore.md&quot;</span> <span style="color: #AA22FF; font-weight: bold">not</span> <span style="color: #AA22FF; font-weight: bold">in</span> sources
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #008000">set</span>(sources[:<span style="color: #666666">2</span>]) <span style="color: #666666">==</span> {<span style="color: #BA2121">&quot;README.md&quot;</span>, <span style="color: #BA2121">&quot;docs/guide.md&quot;</span>}
    <span style="color: #008000; font-weight: bold">assert</span> sources[<span style="color: #666666">2</span>] <span style="color: #666666">==</span> <span style="color: #BA2121">&quot;src/other.md&quot;</span>
</code></pre>
<h3 id="test_map_evidence_snippet_limits">test_map_evidence_snippet_limits() -&gt; None</h3>
<p>The function `test_map_evidence_snippet_limits` tests the functionality of mapping evidence to sections, specifically focusing on snippet limits. It creates a dictionary of document paths and their contents, simulating long and short documents. The function then maps these documents to sections using `explaincode.map_evidence_to_sections`. It asserts that lines exceeding `MAX_SNIPPET_LINES` are not included in the snippets for long documents, while lines within the limit are included. Additionally, it checks that the snippet for a short document is correctly set to &quot;# Inputs&quot;.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">test_map_evidence_snippet_limits</span>() <span style="color: #666666">-&gt;</span> <span style="color: #008000; font-weight: bold">None</span>:
    long_content <span style="color: #666666">=</span> <span style="color: #BA2121">&quot;# Inputs</span><span style="color: #AA5D1F; font-weight: bold">\n</span><span style="color: #BA2121">&quot;</span> <span style="color: #666666">+</span> <span style="color: #BA2121">&quot;</span><span style="color: #AA5D1F; font-weight: bold">\n</span><span style="color: #BA2121">&quot;</span><span style="color: #666666">.</span>join(
        <span style="color: #BA2121">f&quot;line </span><span style="color: #A45A77; font-weight: bold">{</span>i<span style="color: #A45A77; font-weight: bold">}</span><span style="color: #BA2121">&quot;</span> <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(<span style="color: #666666">1</span>, explaincode<span style="color: #666666">.</span>MAX_SNIPPET_LINES <span style="color: #666666">+</span> <span style="color: #666666">10</span>)
    )
    docs <span style="color: #666666">=</span> {
        Path(<span style="color: #BA2121">&quot;src/long.md&quot;</span>): long_content,
        Path(<span style="color: #BA2121">&quot;tests/short.md&quot;</span>): long_content,
    }
    section_map, _ <span style="color: #666666">=</span> explaincode<span style="color: #666666">.</span>map_evidence_to_sections(docs)
    snippets <span style="color: #666666">=</span> {p<span style="color: #666666">.</span>as_posix(): snip <span style="color: #008000; font-weight: bold">for</span> p, snip <span style="color: #AA22FF; font-weight: bold">in</span> section_map[<span style="color: #BA2121">&quot;Inputs&quot;</span>]}
    <span style="color: #008000; font-weight: bold">assert</span> (
        <span style="color: #BA2121">f&quot;line </span><span style="color: #A45A77; font-weight: bold">{</span>explaincode<span style="color: #666666">.</span>MAX_SNIPPET_LINES<span style="color: #bbbbbb"> </span><span style="color: #666666">+</span><span style="color: #bbbbbb"> </span><span style="color: #666666">1</span><span style="color: #A45A77; font-weight: bold">}</span><span style="color: #BA2121">&quot;</span> <span style="color: #AA22FF; font-weight: bold">not</span> <span style="color: #AA22FF; font-weight: bold">in</span> snippets[<span style="color: #BA2121">&quot;src/long.md&quot;</span>]
    )
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #BA2121">f&quot;line </span><span style="color: #A45A77; font-weight: bold">{</span>explaincode<span style="color: #666666">.</span>MAX_SNIPPET_LINES<span style="color: #A45A77; font-weight: bold">}</span><span style="color: #BA2121">&quot;</span> <span style="color: #AA22FF; font-weight: bold">in</span> snippets[<span style="color: #BA2121">&quot;src/long.md&quot;</span>]
    <span style="color: #008000; font-weight: bold">assert</span> snippets[<span style="color: #BA2121">&quot;tests/short.md&quot;</span>] <span style="color: #666666">==</span> <span style="color: #BA2121">&quot;# Inputs&quot;</span>
</code></pre>
<h3 id="test_detect_placeholders">test_detect_placeholders() -&gt; None</h3>
<p>The function `test_detect_placeholders` tests the `explaincode.detect_placeholders` method. It provides a string containing placeholders for an overview and outputs, and asserts that the detected placeholders match the expected set of missing elements.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">test_detect_placeholders</span>() <span style="color: #666666">-&gt;</span> <span style="color: #008000; font-weight: bold">None</span>:
    text <span style="color: #666666">=</span> <span style="color: #BA2121">&quot;Overview: [[NEEDS_OVERVIEW]]</span><span style="color: #AA5D1F; font-weight: bold">\n</span><span style="color: #BA2121">Inputs: data</span><span style="color: #AA5D1F; font-weight: bold">\n</span><span style="color: #BA2121">Outputs: [[NEEDS_OUTPUTS]]&quot;</span>
    missing <span style="color: #666666">=</span> explaincode<span style="color: #666666">.</span>detect_placeholders(text)
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #008000">set</span>(missing) <span style="color: #666666">==</span> {<span style="color: #BA2121">&quot;Overview&quot;</span>, <span style="color: #BA2121">&quot;Outputs&quot;</span>}
</code></pre>
<h3 id="test_parse_manual_infers_missing_sections">test_parse_manual_infers_missing_sections() -&gt; None</h3>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">test_parse_manual_infers_missing_sections</span>() <span style="color: #666666">-&gt;</span> <span style="color: #008000; font-weight: bold">None</span>:
    <span style="color: #008000; font-weight: bold">class</span> <span style="color: #0000FF; font-weight: bold">Stub</span>:
        <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">summarize</span>(<span style="color: #008000">self</span>, prompt: <span style="color: #008000">str</span>, prompt_type: <span style="color: #008000">str</span>, system_prompt: <span style="color: #008000">str</span> <span style="color: #666666">=</span> <span style="color: #BA2121">&quot;&quot;</span>) <span style="color: #666666">-&gt;</span> <span style="color: #008000">str</span>:
            <span style="color: #008000; font-weight: bold">return</span> <span style="color: #BA2121">&quot;guessed&quot;</span>

    client <span style="color: #666666">=</span> Stub()
    parsed <span style="color: #666666">=</span> explaincode<span style="color: #666666">.</span>parse_manual(<span style="color: #BA2121">&quot;Overview: hi&quot;</span>, client<span style="color: #666666">=</span>client)
    <span style="color: #008000; font-weight: bold">assert</span> parsed[<span style="color: #BA2121">&quot;Overview&quot;</span>] <span style="color: #666666">==</span> <span style="color: #BA2121">&quot;hi&quot;</span>
    <span style="color: #008000; font-weight: bold">assert</span> parsed[<span style="color: #BA2121">&quot;Inputs&quot;</span>]<span style="color: #666666">.</span>endswith(<span style="color: #BA2121">&quot;(inferred)&quot;</span>)
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #BA2121">&quot;No information provided.&quot;</span> <span style="color: #AA22FF; font-weight: bold">not</span> <span style="color: #AA22FF; font-weight: bold">in</span> parsed[<span style="color: #BA2121">&quot;Inputs&quot;</span>]
</code></pre>
<h3 id="test_validate_manual_references_flags_missing">test_validate_manual_references_flags_missing(tmp_path: Path) -&gt; None</h3>
<p>This function tests the validation of manual references in documentation sections. It creates a temporary directory with a Python file named `exists.py` containing the text &quot;pass&quot;. The function then defines a dictionary `sections` with an &quot;Overview&quot; section that mentions both `exists.py` and a missing file `missing.py`. An empty dictionary `evidence` is also created to store validation results.

The function calls `explaincode.validate_manual_references` with the `sections`, `tmp_path`, and `evidence` as arguments. After execution, it asserts that `exists.py` is included in the &quot;Overview&quot; section of `sections`, indicating it was found. It also checks that `missing.py [missing]` is added to the &quot;Overview&quot; section, showing it was not found. Finally, it verifies that the &quot;missing_references&quot; key in the evidence dictionary for the &quot;Overview&quot; section contains a list with the missing file `missing.py`.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">test_validate_manual_references_flags_missing</span>(tmp_path: Path) <span style="color: #666666">-&gt;</span> <span style="color: #008000; font-weight: bold">None</span>:
    (tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;exists.py&quot;</span>)<span style="color: #666666">.</span>write_text(<span style="color: #BA2121">&quot;pass&quot;</span>, encoding<span style="color: #666666">=</span><span style="color: #BA2121">&quot;utf-8&quot;</span>)
    sections <span style="color: #666666">=</span> {<span style="color: #BA2121">&quot;Overview&quot;</span>: <span style="color: #BA2121">&quot;See exists.py and missing.py for details&quot;</span>}
    evidence: <span style="color: #008000">dict</span>[<span style="color: #008000">str</span>, <span style="color: #008000">dict</span>[<span style="color: #008000">str</span>, <span style="color: #008000">object</span>]] <span style="color: #666666">=</span> {}
    explaincode<span style="color: #666666">.</span>validate_manual_references(sections, tmp_path, evidence)
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #BA2121">&quot;exists.py&quot;</span> <span style="color: #AA22FF; font-weight: bold">in</span> sections[<span style="color: #BA2121">&quot;Overview&quot;</span>]
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #BA2121">&quot;missing.py [missing]&quot;</span> <span style="color: #AA22FF; font-weight: bold">in</span> sections[<span style="color: #BA2121">&quot;Overview&quot;</span>]
    <span style="color: #008000; font-weight: bold">assert</span> evidence[<span style="color: #BA2121">&quot;Overview&quot;</span>][<span style="color: #BA2121">&quot;missing_references&quot;</span>] <span style="color: #666666">==</span> [<span style="color: #BA2121">&quot;missing.py&quot;</span>]
</code></pre>
<h3 id="test_infer_sections_infers_entries">test_infer_sections_infers_entries() -&gt; None</h3>
<p>The function `test_infer_sections_infers_entries` tests the `infer_sections` function from the `explaincode` module. It asserts that the returned dictionary contains an &quot;Overview&quot; key with the value &quot;Some context&quot;. For all other keys specified in `REQUIRED_SECTIONS`, it checks that their values end with &quot;(inferred)&quot;. Finally, it ensures that the string &quot;No information provided.&quot; is not present in any of the section values combined.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">test_infer_sections_infers_entries</span>() <span style="color: #666666">-&gt;</span> <span style="color: #008000; font-weight: bold">None</span>:
    sections <span style="color: #666666">=</span> explaincode<span style="color: #666666">.</span>infer_sections(<span style="color: #BA2121">&quot;Some context&quot;</span>)
    <span style="color: #008000; font-weight: bold">assert</span> sections[<span style="color: #BA2121">&quot;Overview&quot;</span>] <span style="color: #666666">==</span> <span style="color: #BA2121">&quot;Some context&quot;</span>
    <span style="color: #008000; font-weight: bold">for</span> key <span style="color: #AA22FF; font-weight: bold">in</span> explaincode<span style="color: #666666">.</span>REQUIRED_SECTIONS:
        <span style="color: #008000; font-weight: bold">if</span> key <span style="color: #666666">!=</span> <span style="color: #BA2121">&quot;Overview&quot;</span>:
            <span style="color: #008000; font-weight: bold">assert</span> sections[key]<span style="color: #666666">.</span>endswith(<span style="color: #BA2121">&quot;(inferred)&quot;</span>)
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #BA2121">&quot;No information provided.&quot;</span> <span style="color: #AA22FF; font-weight: bold">not</span> <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #BA2121">&quot;&quot;</span><span style="color: #666666">.</span>join(sections<span style="color: #666666">.</span>values())
</code></pre>
<h3 id="test_infer_sections_no_context_defaults">test_infer_sections_no_context_defaults() -&gt; None</h3>
<p>This function tests the `infer_sections` method from the `explaincode` module. It asserts that when an empty string is passed as input, the output dictionary has values equal to &quot;No information provided.&quot;</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">test_infer_sections_no_context_defaults</span>() <span style="color: #666666">-&gt;</span> <span style="color: #008000; font-weight: bold">None</span>:
    sections <span style="color: #666666">=</span> explaincode<span style="color: #666666">.</span>infer_sections(<span style="color: #BA2121">&quot;&quot;</span>)
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #008000">all</span>(v <span style="color: #666666">==</span> <span style="color: #BA2121">&quot;No information provided.&quot;</span> <span style="color: #008000; font-weight: bold">for</span> v <span style="color: #AA22FF; font-weight: bold">in</span> sections<span style="color: #666666">.</span>values())
</code></pre>
<h3 id="test_extract_snippets_skips_large_file">test_extract_snippets_skips_large_file(tmp_path: Path, caplog: pytest.LogCaptureFixture) -&gt; None</h3>
<p>The function `test_extract_snippets_skips_large_file` is a unit test for the `extract_snippets` function from the `explaincode` module. It checks that large files are skipped during snippet extraction when their size exceeds a specified limit. The test creates a temporary file with 210,000 bytes of data and attempts to extract snippets from it using the `extract_snippets` function with a maximum file size of 200,000 bytes. The test asserts that the large file is not included in the extracted snippets and logs an informational message indicating that the file size exceeds the limit.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">test_extract_snippets_skips_large_file</span>(
    tmp_path: Path, caplog: pytest<span style="color: #666666">.</span>LogCaptureFixture
) <span style="color: #666666">-&gt;</span> <span style="color: #008000; font-weight: bold">None</span>:
    big_file <span style="color: #666666">=</span> tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;big.py&quot;</span>
    big_file<span style="color: #666666">.</span>write_bytes(<span style="color: #BA2121">b&quot;a&quot;</span> <span style="color: #666666">*</span> <span style="color: #666666">210_000</span>)
    caplog<span style="color: #666666">.</span>set_level(logging<span style="color: #666666">.</span>INFO)
    snippets <span style="color: #666666">=</span> explaincode<span style="color: #666666">.</span>extract_snippets(
        [big_file], max_files<span style="color: #666666">=1</span>, time_budget<span style="color: #666666">=5</span>, max_bytes<span style="color: #666666">=200_000</span>
    )
    <span style="color: #008000; font-weight: bold">assert</span> big_file <span style="color: #AA22FF; font-weight: bold">not</span> <span style="color: #AA22FF; font-weight: bold">in</span> snippets
    log <span style="color: #666666">=</span> caplog<span style="color: #666666">.</span>text
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #BA2121">&quot;file size&quot;</span> <span style="color: #AA22FF; font-weight: bold">in</span> log <span style="color: #AA22FF; font-weight: bold">and</span> <span style="color: #BA2121">&quot;exceeds limit&quot;</span> <span style="color: #AA22FF; font-weight: bold">in</span> log
</code></pre>
<h3 id="test_scan_code_skips_non_source_dirs">test_scan_code_skips_non_source_dirs(tmp_path: Path, monkeypatch: pytest.MonkeyPatch) -&gt; None</h3>
<p>The function `test_scan_code_skips_non_source_dirs` tests the `scan_code` function from the `explaincode` module. It creates a temporary directory structure with source files in &quot;src&quot; and non-source directories for tests and examples. The `monkeypatch` is used to mock the `collect_docs` function, which is supposed to collect documentation from the codebase. The test asserts that only the source file under &quot;src&quot; is included in the result when scanning for documentation.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">test_scan_code_skips_non_source_dirs</span>(
    tmp_path: Path, monkeypatch: pytest<span style="color: #666666">.</span>MonkeyPatch
) <span style="color: #666666">-&gt;</span> <span style="color: #008000; font-weight: bold">None</span>:
    src <span style="color: #666666">=</span> tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;src&quot;</span>
    src<span style="color: #666666">.</span>mkdir()
    (src <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;main.py&quot;</span>)<span style="color: #666666">.</span>write_text(<span style="color: #BA2121">&#39;&quot;&quot;&quot;run code&quot;&quot;&quot;&#39;</span>, encoding<span style="color: #666666">=</span><span style="color: #BA2121">&quot;utf-8&quot;</span>)

    tests_dir <span style="color: #666666">=</span> tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;tests&quot;</span>
    tests_dir<span style="color: #666666">.</span>mkdir()
    (tests_dir <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;test_main.py&quot;</span>)<span style="color: #666666">.</span>write_text(<span style="color: #BA2121">&#39;&quot;&quot;&quot;run tests&quot;&quot;&quot;&#39;</span>, encoding<span style="color: #666666">=</span><span style="color: #BA2121">&quot;utf-8&quot;</span>)

    examples_dir <span style="color: #666666">=</span> tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;examples&quot;</span>
    examples_dir<span style="color: #666666">.</span>mkdir()
    (examples_dir <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;example.py&quot;</span>)<span style="color: #666666">.</span>write_text(<span style="color: #BA2121">&#39;&quot;&quot;&quot;run example&quot;&quot;&quot;&#39;</span>, encoding<span style="color: #666666">=</span><span style="color: #BA2121">&quot;utf-8&quot;</span>)

    monkeypatch<span style="color: #666666">.</span>setattr(explaincode, <span style="color: #BA2121">&quot;collect_docs&quot;</span>, <span style="color: #008000; font-weight: bold">lambda</span> base: [])
    result <span style="color: #666666">=</span> explaincode<span style="color: #666666">.</span>scan_code(
        tmp_path, [<span style="color: #BA2121">&quot;How to Run&quot;</span>], max_files<span style="color: #666666">=5</span>, time_budget<span style="color: #666666">=5</span>, max_bytes_per_file<span style="color: #666666">=1000</span>
    )

    how_to_run <span style="color: #666666">=</span> result<span style="color: #666666">.</span>get(<span style="color: #BA2121">&quot;How to Run&quot;</span>, {})
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #008000">set</span>(how_to_run<span style="color: #666666">.</span>keys()) <span style="color: #666666">==</span> {<span style="color: #BA2121">&quot;src/main.py&quot;</span>}
</code></pre>
<h3 id="test_scan_code_categorizes_snippets">test_scan_code_categorizes_snippets(tmp_path: Path, monkeypatch: pytest.MonkeyPatch) -&gt; None</h3>
<p>This function, `test_scan_code_categorizes_snippets`, tests the `scan_code` function in the `explaincode` module. It sets up a temporary directory with three Python files and uses monkeypatching to mock the `collect_docs`, `rank_code_files`, and `extract_snippets` functions from the same module. The mocked `extract_snippets` function returns predefined categories (&quot;Inputs&quot;, &quot;Outputs&quot;, &quot;How to Run&quot;) for each file based on their content. The test then calls `scan_code` with these files, specifying maximum file count, time budget, and bytes per file limit. It asserts that the returned dictionary categorizes the snippets correctly according to their contents.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">test_scan_code_categorizes_snippets</span>(
    tmp_path: Path, monkeypatch: pytest<span style="color: #666666">.</span>MonkeyPatch
) <span style="color: #666666">-&gt;</span> <span style="color: #008000; font-weight: bold">None</span>:
    paths <span style="color: #666666">=</span> [tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;a.py&quot;</span>, tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;b.py&quot;</span>, tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;c.py&quot;</span>]
    <span style="color: #008000; font-weight: bold">for</span> p <span style="color: #AA22FF; font-weight: bold">in</span> paths:
        p<span style="color: #666666">.</span>write_text(<span style="color: #BA2121">&quot;&quot;</span>, encoding<span style="color: #666666">=</span><span style="color: #BA2121">&quot;utf-8&quot;</span>)

    monkeypatch<span style="color: #666666">.</span>setattr(explaincode, <span style="color: #BA2121">&quot;collect_docs&quot;</span>, <span style="color: #008000; font-weight: bold">lambda</span> base: [])
    monkeypatch<span style="color: #666666">.</span>setattr(explaincode, <span style="color: #BA2121">&quot;rank_code_files&quot;</span>, <span style="color: #008000; font-weight: bold">lambda</span> base, patterns: paths)

    <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">fake_extract</span>(
        files: Iterable[Path], <span style="color: #666666">*</span>, max_files: <span style="color: #008000">int</span>, time_budget: <span style="color: #008000">int</span>, max_bytes: <span style="color: #008000">int</span>
    ) <span style="color: #666666">-&gt;</span> <span style="color: #008000">dict</span>[Path, <span style="color: #008000">str</span>]:
        <span style="color: #008000; font-weight: bold">return</span> {
            paths[<span style="color: #666666">0</span>]: <span style="color: #BA2121">&quot;read input from user&quot;</span>,
            paths[<span style="color: #666666">1</span>]: <span style="color: #BA2121">&quot;write output&quot;</span>,
            paths[<span style="color: #666666">2</span>]: <span style="color: #BA2121">&quot;run the tool&quot;</span>,
        }

    monkeypatch<span style="color: #666666">.</span>setattr(explaincode, <span style="color: #BA2121">&quot;extract_snippets&quot;</span>, fake_extract)

    result <span style="color: #666666">=</span> explaincode<span style="color: #666666">.</span>scan_code(
        tmp_path, [<span style="color: #BA2121">&quot;Inputs&quot;</span>, <span style="color: #BA2121">&quot;Outputs&quot;</span>, <span style="color: #BA2121">&quot;How to Run&quot;</span>], max_files<span style="color: #666666">=3</span>, time_budget<span style="color: #666666">=5</span>, max_bytes_per_file<span style="color: #666666">=1000</span>
    )
    <span style="color: #008000; font-weight: bold">assert</span> result[<span style="color: #BA2121">&quot;Inputs&quot;</span>] <span style="color: #666666">==</span> {<span style="color: #BA2121">&quot;a.py&quot;</span>: <span style="color: #BA2121">&quot;read input from user&quot;</span>}
    <span style="color: #008000; font-weight: bold">assert</span> result[<span style="color: #BA2121">&quot;Outputs&quot;</span>] <span style="color: #666666">==</span> {<span style="color: #BA2121">&quot;b.py&quot;</span>: <span style="color: #BA2121">&quot;write output&quot;</span>}
    <span style="color: #008000; font-weight: bold">assert</span> result[<span style="color: #BA2121">&quot;How to Run&quot;</span>] <span style="color: #666666">==</span> {<span style="color: #BA2121">&quot;c.py&quot;</span>: <span style="color: #BA2121">&quot;run the tool&quot;</span>}
</code></pre>
<details>
<summary>Subfunction: fake_extract(files: Iterable[Path], *, max_files: int, time_budget: int, max_bytes: int) -&gt; dict[Path, str]</summary>
<h4 id="fake_extract">fake_extract(files: Iterable[Path], *, max_files: int, time_budget: int, max_bytes: int) -&gt; dict[Path, str]</h4>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">fake_extract</span>(
        files: Iterable[Path], <span style="color: #666666">*</span>, max_files: <span style="color: #008000">int</span>, time_budget: <span style="color: #008000">int</span>, max_bytes: <span style="color: #008000">int</span>
    ) <span style="color: #666666">-&gt;</span> <span style="color: #008000">dict</span>[Path, <span style="color: #008000">str</span>]:
        <span style="color: #008000; font-weight: bold">return</span> {
            paths[<span style="color: #666666">0</span>]: <span style="color: #BA2121">&quot;read input from user&quot;</span>,
            paths[<span style="color: #666666">1</span>]: <span style="color: #BA2121">&quot;write output&quot;</span>,
            paths[<span style="color: #666666">2</span>]: <span style="color: #BA2121">&quot;run the tool&quot;</span>,
        }
</code></pre>
</details>
<h3 id="test_rank_code_files_supports_cpp_h_java">test_rank_code_files_supports_cpp_h_java(tmp_path: Path) -&gt; None</h3>
<p>The function `test_rank_code_files_supports_cpp_h_java` tests the `rank_code_files` function from the `explaincode` module to ensure it supports C++, header, and Java files. It creates a temporary directory with various file types, including Python, C++, header, and Java files, as well as an ignored text file. The function then ranks these files and asserts that only the supported file types are included in the ranking, while the ignored file is excluded.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">test_rank_code_files_supports_cpp_h_java</span>(tmp_path: Path) <span style="color: #666666">-&gt;</span> <span style="color: #008000; font-weight: bold">None</span>:
    files <span style="color: #666666">=</span> [
        tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;main.py&quot;</span>,
        tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;lib.cpp&quot;</span>,
        tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;lib.h&quot;</span>,
        tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;Main.java&quot;</span>,
        tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;ignore.txt&quot;</span>,
    ]
    <span style="color: #008000; font-weight: bold">for</span> f <span style="color: #AA22FF; font-weight: bold">in</span> files:
        f<span style="color: #666666">.</span>write_text(<span style="color: #BA2121">&quot;&quot;</span>, encoding<span style="color: #666666">=</span><span style="color: #BA2121">&quot;utf-8&quot;</span>)
    ranked <span style="color: #666666">=</span> explaincode<span style="color: #666666">.</span>rank_code_files(tmp_path, [])
    names <span style="color: #666666">=</span> {p<span style="color: #666666">.</span>name <span style="color: #008000; font-weight: bold">for</span> p <span style="color: #AA22FF; font-weight: bold">in</span> ranked}
    <span style="color: #008000; font-weight: bold">assert</span> {<span style="color: #BA2121">&quot;main.py&quot;</span>, <span style="color: #BA2121">&quot;lib.cpp&quot;</span>, <span style="color: #BA2121">&quot;lib.h&quot;</span>, <span style="color: #BA2121">&quot;Main.java&quot;</span>} <span style="color: #666666">&lt;=</span> names
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #BA2121">&quot;ignore.txt&quot;</span> <span style="color: #AA22FF; font-weight: bold">not</span> <span style="color: #AA22FF; font-weight: bold">in</span> names
</code></pre>
<h3 id="test_llm_fill_placeholders_per_section_logging">test_llm_fill_placeholders_per_section_logging(tmp_path: Path, caplog: pytest.LogCaptureFixture) -&gt; None</h3>
<p>This function tests the `llm_fill_placeholders` method by simulating its interaction with an LLM client and a response cache. It uses a dummy class to mimic the LLM&#x27;s behavior, capturing calls made to it. The test checks if placeholders in a manual string are correctly filled using data from evidence, ensuring that each placeholder is replaced with content from the corresponding file specified in the evidence. Additionally, it verifies that the function logs the process of filling each placeholder with the source code file used.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">test_llm_fill_placeholders_per_section_logging</span>(
    tmp_path: Path, caplog: pytest<span style="color: #666666">.</span>LogCaptureFixture
) <span style="color: #666666">-&gt;</span> <span style="color: #008000; font-weight: bold">None</span>:
    manual <span style="color: #666666">=</span> <span style="color: #BA2121">&quot;Inputs: [[NEEDS_INPUTS]]</span><span style="color: #AA5D1F; font-weight: bold">\n</span><span style="color: #BA2121">Outputs: [[NEEDS_OUTPUTS]]&quot;</span>
    evidence <span style="color: #666666">=</span> {
        <span style="color: #BA2121">&quot;Inputs&quot;</span>: {<span style="color: #BA2121">&quot;in.py&quot;</span>: <span style="color: #BA2121">&quot;input data&quot;</span>},
        <span style="color: #BA2121">&quot;Outputs&quot;</span>: {<span style="color: #BA2121">&quot;out.py&quot;</span>: <span style="color: #BA2121">&quot;output data&quot;</span>},
    }

    <span style="color: #008000; font-weight: bold">class</span> <span style="color: #0000FF; font-weight: bold">Dummy</span>:
        <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">__init__</span>(<span style="color: #008000">self</span>) <span style="color: #666666">-&gt;</span> <span style="color: #008000; font-weight: bold">None</span>:
            <span style="color: #008000">self</span><span style="color: #666666">.</span>calls: <span style="color: #008000">list</span>[<span style="color: #008000">str</span>] <span style="color: #666666">=</span> []

        <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">summarize</span>(
            <span style="color: #008000">self</span>, text: <span style="color: #008000">str</span>, prompt_type: <span style="color: #008000">str</span>, system_prompt: <span style="color: #008000">str</span> <span style="color: #666666">=</span> <span style="color: #BA2121">&quot;&quot;</span>
        ) <span style="color: #666666">-&gt;</span> <span style="color: #008000">str</span>:
            <span style="color: #008000">self</span><span style="color: #666666">.</span>calls<span style="color: #666666">.</span>append(text)
            manual_match <span style="color: #666666">=</span> re<span style="color: #666666">.</span>search(<span style="color: #BA2121">r&quot;Manual:\n(.*?)\n\nSection:&quot;</span>, text, re<span style="color: #666666">.</span>DOTALL)
            section_match <span style="color: #666666">=</span> re<span style="color: #666666">.</span>search(<span style="color: #BA2121">r&quot;Section: (.*?)\n&quot;</span>, text)
            manual_text <span style="color: #666666">=</span> manual_match<span style="color: #666666">.</span>group(<span style="color: #666666">1</span>)
            section <span style="color: #666666">=</span> section_match<span style="color: #666666">.</span>group(<span style="color: #666666">1</span>)
            token <span style="color: #666666">=</span> explaincode<span style="color: #666666">.</span>SECTION_PLACEHOLDERS[section]
            <span style="color: #008000; font-weight: bold">return</span> manual_text<span style="color: #666666">.</span>replace(token, <span style="color: #BA2121">f&quot;filled </span><span style="color: #A45A77; font-weight: bold">{</span>section<span style="color: #A45A77; font-weight: bold">}</span><span style="color: #BA2121">&quot;</span>)

    client <span style="color: #666666">=</span> Dummy()
    cache <span style="color: #666666">=</span> ResponseCache(<span style="color: #008000">str</span>(tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;cache.json&quot;</span>))
    caplog<span style="color: #666666">.</span>set_level(logging<span style="color: #666666">.</span>INFO)
    result <span style="color: #666666">=</span> explaincode<span style="color: #666666">.</span>llm_fill_placeholders(manual, evidence, client, cache)
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #BA2121">&quot;filled Inputs&quot;</span> <span style="color: #AA22FF; font-weight: bold">in</span> result <span style="color: #AA22FF; font-weight: bold">and</span> <span style="color: #BA2121">&quot;filled Outputs&quot;</span> <span style="color: #AA22FF; font-weight: bold">in</span> result
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #008000">len</span>(client<span style="color: #666666">.</span>calls) <span style="color: #666666">==</span> <span style="color: #666666">2</span>
    log <span style="color: #666666">=</span> caplog<span style="color: #666666">.</span>text
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #BA2121">&quot;Filled Inputs using code from: in.py&quot;</span> <span style="color: #AA22FF; font-weight: bold">in</span> log
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #BA2121">&quot;Filled Outputs using code from: out.py&quot;</span> <span style="color: #AA22FF; font-weight: bold">in</span> log
</code></pre>
<h3 id="test_full_docs_no_code_scan">test_full_docs_no_code_scan(tmp_path: Path, monkeypatch: pytest.MonkeyPatch, caplog: pytest.LogCaptureFixture) -&gt; None</h3>
<p>This function tests the generation of documentation without scanning code. It sets up a temporary path, creates a fixture, and uses monkeypatch to replace functions for ranking code files and extracting snippets with fake implementations that track calls. The test asserts that these functions are not called, logs indicate a successful document pass, and confirms that the code scan was skipped.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">test_full_docs_no_code_scan</span>(
    tmp_path: Path, monkeypatch: pytest<span style="color: #666666">.</span>MonkeyPatch, caplog: pytest<span style="color: #666666">.</span>LogCaptureFixture
) <span style="color: #666666">-&gt;</span> <span style="color: #008000; font-weight: bold">None</span>:
    _create_fixture(tmp_path)
    tracker <span style="color: #666666">=</span> {<span style="color: #BA2121">&quot;rank&quot;</span>: <span style="color: #666666">0</span>, <span style="color: #BA2121">&quot;extract&quot;</span>: <span style="color: #666666">0</span>}

    <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">fake_rank</span>(root: Path, patterns: <span style="color: #008000">list</span>[<span style="color: #008000">str</span>]) <span style="color: #666666">-&gt;</span> <span style="color: #008000">list</span>[Path]:
        tracker[<span style="color: #BA2121">&quot;rank&quot;</span>] <span style="color: #666666">+=</span> <span style="color: #666666">1</span>
        <span style="color: #008000; font-weight: bold">return</span> [tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;a.py&quot;</span>]

    <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">fake_extract</span>(
        files: Iterable[Path], <span style="color: #666666">*</span>, max_files: <span style="color: #008000">int</span>, time_budget: <span style="color: #008000">int</span>, max_bytes: <span style="color: #008000">int</span>
    ) <span style="color: #666666">-&gt;</span> <span style="color: #008000">dict</span>[Path, <span style="color: #008000">str</span>]:
        tracker[<span style="color: #BA2121">&quot;extract&quot;</span>] <span style="color: #666666">+=</span> <span style="color: #666666">1</span>
        <span style="color: #008000; font-weight: bold">return</span> {}

    monkeypatch<span style="color: #666666">.</span>setattr(explaincode, <span style="color: #BA2121">&quot;LLMClient&quot;</span>, _mock_llm_client)
    monkeypatch<span style="color: #666666">.</span>setattr(explaincode, <span style="color: #BA2121">&quot;rank_code_files&quot;</span>, fake_rank)
    monkeypatch<span style="color: #666666">.</span>setattr(explaincode, <span style="color: #BA2121">&quot;extract_snippets&quot;</span>, fake_extract)

    caplog<span style="color: #666666">.</span>set_level(logging<span style="color: #666666">.</span>INFO)
    main([<span style="color: #BA2121">&quot;--path&quot;</span>, <span style="color: #008000">str</span>(tmp_path), <span style="color: #BA2121">&quot;--scan-code-if-needed&quot;</span>])
    <span style="color: #008000; font-weight: bold">assert</span> tracker[<span style="color: #BA2121">&quot;rank&quot;</span>] <span style="color: #666666">==</span> <span style="color: #666666">0</span>
    <span style="color: #008000; font-weight: bold">assert</span> tracker[<span style="color: #BA2121">&quot;extract&quot;</span>] <span style="color: #666666">==</span> <span style="color: #666666">0</span>
    log <span style="color: #666666">=</span> caplog<span style="color: #666666">.</span>text
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #BA2121">&quot;DOC PASS&quot;</span> <span style="color: #AA22FF; font-weight: bold">in</span> log
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #BA2121">&quot;Code scan skipped&quot;</span> <span style="color: #AA22FF; font-weight: bold">in</span> log
</code></pre>
<details>
<summary>Subfunction: fake_rank(root: Path, patterns: list[str]) -&gt; list[Path]</summary>
<h4 id="fake_rank">fake_rank(root: Path, patterns: list[str]) -&gt; list[Path]</h4>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">fake_rank</span>(root: Path, patterns: <span style="color: #008000">list</span>[<span style="color: #008000">str</span>]) <span style="color: #666666">-&gt;</span> <span style="color: #008000">list</span>[Path]:
        tracker[<span style="color: #BA2121">&quot;rank&quot;</span>] <span style="color: #666666">+=</span> <span style="color: #666666">1</span>
        <span style="color: #008000; font-weight: bold">return</span> [tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;a.py&quot;</span>]
</code></pre>
</details>
<details>
<summary>Subfunction: fake_extract(files: Iterable[Path], *, max_files: int, time_budget: int, max_bytes: int) -&gt; dict[Path, str]</summary>
<h4 id="fake_extract">fake_extract(files: Iterable[Path], *, max_files: int, time_budget: int, max_bytes: int) -&gt; dict[Path, str]</h4>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">fake_extract</span>(
        files: Iterable[Path], <span style="color: #666666">*</span>, max_files: <span style="color: #008000">int</span>, time_budget: <span style="color: #008000">int</span>, max_bytes: <span style="color: #008000">int</span>
    ) <span style="color: #666666">-&gt;</span> <span style="color: #008000">dict</span>[Path, <span style="color: #008000">str</span>]:
        tracker[<span style="color: #BA2121">&quot;extract&quot;</span>] <span style="color: #666666">+=</span> <span style="color: #666666">1</span>
        <span style="color: #008000; font-weight: bold">return</span> {}
</code></pre>
</details>
<h3 id="test_missing_run_triggers_code_fallback_with_limits">test_missing_run_triggers_code_fallback_with_limits(tmp_path: Path, monkeypatch: pytest.MonkeyPatch, caplog: pytest.LogCaptureFixture) -&gt; None</h3>
<p>The function `test_missing_run_triggers_code_fallback_with_limits` is a unit test for a documentation generation tool. It simulates the scenario where the tool needs to generate documentation but encounters missing run instructions or sections. The test sets up a temporary directory with a README file and three Python files. It then mocks the LLMClient, rank_code_files, and extract_snippets functions to simulate the behavior of the tool during the testing process.

The test asserts that the tool correctly identifies missing run instructions and uses code from the source files to fill in these gaps. It also checks that the tool logs the appropriate messages indicating the progress and any issues encountered during the documentation generation process.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">test_missing_run_triggers_code_fallback_with_limits</span>(
    tmp_path: Path, monkeypatch: pytest<span style="color: #666666">.</span>MonkeyPatch, caplog: pytest<span style="color: #666666">.</span>LogCaptureFixture
) <span style="color: #666666">-&gt;</span> <span style="color: #008000; font-weight: bold">None</span>:
    (tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;README.md&quot;</span>)<span style="color: #666666">.</span>write_text(<span style="color: #BA2121">&quot;Only overview&quot;</span>, encoding<span style="color: #666666">=</span><span style="color: #BA2121">&quot;utf-8&quot;</span>)

    <span style="color: #008000; font-weight: bold">class</span> <span style="color: #0000FF; font-weight: bold">Dummy</span>:
        <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">summarize</span>(<span style="color: #008000">self</span>, text: <span style="color: #008000">str</span>, prompt_type: <span style="color: #008000">str</span>, system_prompt: <span style="color: #008000">str</span> <span style="color: #666666">=</span> <span style="color: #BA2121">&quot;&quot;</span>) <span style="color: #666666">-&gt;</span> <span style="color: #008000">str</span>:
            <span style="color: #008000; font-weight: bold">if</span> <span style="color: #BA2121">&quot;How to Run&quot;</span> <span style="color: #AA22FF; font-weight: bold">in</span> system_prompt:
                <span style="color: #008000; font-weight: bold">return</span> <span style="color: #BA2121">&quot;[[NEEDS_RUN_INSTRUCTIONS]]&quot;</span>
            <span style="color: #008000; font-weight: bold">if</span> <span style="color: #BA2121">&quot;enhancing a user manual&quot;</span> <span style="color: #AA22FF; font-weight: bold">in</span> system_prompt:
                manual_match <span style="color: #666666">=</span> re<span style="color: #666666">.</span>search(<span style="color: #BA2121">r&quot;Manual:\n(.*?)\n\nSection:&quot;</span>, text, re<span style="color: #666666">.</span>DOTALL)
                manual_text <span style="color: #666666">=</span> manual_match<span style="color: #666666">.</span>group(<span style="color: #666666">1</span>)
                <span style="color: #008000; font-weight: bold">return</span> manual_text<span style="color: #666666">.</span>replace(<span style="color: #BA2121">&quot;[[NEEDS_RUN_INSTRUCTIONS]]&quot;</span>, <span style="color: #BA2121">&quot;use it&quot;</span>)
            <span style="color: #008000; font-weight: bold">return</span> <span style="color: #BA2121">&quot;x&quot;</span>

    paths <span style="color: #666666">=</span> [tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">f&quot;f</span><span style="color: #A45A77; font-weight: bold">{</span>i<span style="color: #A45A77; font-weight: bold">}</span><span style="color: #BA2121">.py&quot;</span> <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(<span style="color: #666666">3</span>)]
    tracker: <span style="color: #008000">dict</span>[<span style="color: #008000">str</span>, <span style="color: #008000">object</span>] <span style="color: #666666">=</span> {<span style="color: #BA2121">&quot;rank&quot;</span>: <span style="color: #666666">0</span>, <span style="color: #BA2121">&quot;extract&quot;</span>: <span style="color: #666666">0</span>}

    <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">fake_rank</span>(root: Path, patterns: <span style="color: #008000">list</span>[<span style="color: #008000">str</span>]) <span style="color: #666666">-&gt;</span> <span style="color: #008000">list</span>[Path]:
        tracker[<span style="color: #BA2121">&quot;rank&quot;</span>] <span style="color: #666666">+=</span> <span style="color: #666666">1</span>
        <span style="color: #008000; font-weight: bold">return</span> paths

    <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">fake_extract</span>(
        files: Iterable[Path], <span style="color: #666666">*</span>, max_files: <span style="color: #008000">int</span>, time_budget: <span style="color: #008000">int</span>, max_bytes: <span style="color: #008000">int</span>
    ) <span style="color: #666666">-&gt;</span> <span style="color: #008000">dict</span>[Path, <span style="color: #008000">str</span>]:
        tracker[<span style="color: #BA2121">&quot;extract&quot;</span>] <span style="color: #666666">+=</span> <span style="color: #666666">1</span>
        lst <span style="color: #666666">=</span> <span style="color: #008000">list</span>(files)
        tracker[<span style="color: #BA2121">&quot;kwargs&quot;</span>] <span style="color: #666666">=</span> {<span style="color: #BA2121">&quot;max_files&quot;</span>: max_files, <span style="color: #BA2121">&quot;time_budget&quot;</span>: time_budget}
        tracker[<span style="color: #BA2121">&quot;scanned&quot;</span>] <span style="color: #666666">=</span> lst[:max_files]
        <span style="color: #008000; font-weight: bold">return</span> {p: <span style="color: #BA2121">&quot;run code&quot;</span> <span style="color: #008000; font-weight: bold">for</span> p <span style="color: #AA22FF; font-weight: bold">in</span> lst[:max_files]}

    monkeypatch<span style="color: #666666">.</span>setattr(explaincode, <span style="color: #BA2121">&quot;LLMClient&quot;</span>, <span style="color: #008000; font-weight: bold">lambda</span>: Dummy())
    monkeypatch<span style="color: #666666">.</span>setattr(explaincode, <span style="color: #BA2121">&quot;rank_code_files&quot;</span>, fake_rank)
    monkeypatch<span style="color: #666666">.</span>setattr(explaincode, <span style="color: #BA2121">&quot;extract_snippets&quot;</span>, fake_extract)

    caplog<span style="color: #666666">.</span>set_level(logging<span style="color: #666666">.</span>INFO)
    main(
        [
            <span style="color: #BA2121">&quot;--path&quot;</span>,
            <span style="color: #008000">str</span>(tmp_path),
            <span style="color: #BA2121">&quot;--scan-code-if-needed&quot;</span>,
            <span style="color: #BA2121">&quot;--max-code-files&quot;</span>,
            <span style="color: #BA2121">&quot;1&quot;</span>,
            <span style="color: #BA2121">&quot;--code-time-budget-seconds&quot;</span>,
            <span style="color: #BA2121">&quot;5&quot;</span>,
        ]
    )
    html <span style="color: #666666">=</span> (tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;user_manual.html&quot;</span>)<span style="color: #666666">.</span>read_text(encoding<span style="color: #666666">=</span><span style="color: #BA2121">&quot;utf-8&quot;</span>)
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #BA2121">&quot;NEEDS_RUN_INSTRUCTIONS&quot;</span> <span style="color: #AA22FF; font-weight: bold">not</span> <span style="color: #AA22FF; font-weight: bold">in</span> html
    <span style="color: #008000; font-weight: bold">assert</span> tracker[<span style="color: #BA2121">&quot;rank&quot;</span>] <span style="color: #666666">==</span> <span style="color: #666666">1</span>
    <span style="color: #008000; font-weight: bold">assert</span> tracker[<span style="color: #BA2121">&quot;extract&quot;</span>] <span style="color: #666666">==</span> <span style="color: #666666">1</span>
    <span style="color: #008000; font-weight: bold">assert</span> tracker[<span style="color: #BA2121">&quot;kwargs&quot;</span>] <span style="color: #666666">==</span> {<span style="color: #BA2121">&quot;max_files&quot;</span>: <span style="color: #666666">1</span>, <span style="color: #BA2121">&quot;time_budget&quot;</span>: <span style="color: #666666">5</span>}
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #008000">len</span>(tracker[<span style="color: #BA2121">&quot;scanned&quot;</span>]) <span style="color: #666666">==</span> <span style="color: #666666">1</span>
    log <span style="color: #666666">=</span> caplog<span style="color: #666666">.</span>text
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #BA2121">&quot;Pass 1 missing sections&quot;</span> <span style="color: #AA22FF; font-weight: bold">in</span> log
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #BA2121">&quot;How to Run&quot;</span> <span style="color: #AA22FF; font-weight: bold">in</span> log
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #BA2121">&quot;Filled How to Run using code from: f0.py&quot;</span> <span style="color: #AA22FF; font-weight: bold">in</span> log
</code></pre>
<details>
<summary>Subfunction: fake_rank(root: Path, patterns: list[str]) -&gt; list[Path]</summary>
<h4 id="fake_rank">fake_rank(root: Path, patterns: list[str]) -&gt; list[Path]</h4>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">fake_rank</span>(root: Path, patterns: <span style="color: #008000">list</span>[<span style="color: #008000">str</span>]) <span style="color: #666666">-&gt;</span> <span style="color: #008000">list</span>[Path]:
        tracker[<span style="color: #BA2121">&quot;rank&quot;</span>] <span style="color: #666666">+=</span> <span style="color: #666666">1</span>
        <span style="color: #008000; font-weight: bold">return</span> paths
</code></pre>
</details>
<details>
<summary>Subfunction: fake_extract(files: Iterable[Path], *, max_files: int, time_budget: int, max_bytes: int) -&gt; dict[Path, str]</summary>
<h4 id="fake_extract">fake_extract(files: Iterable[Path], *, max_files: int, time_budget: int, max_bytes: int) -&gt; dict[Path, str]</h4>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">fake_extract</span>(
        files: Iterable[Path], <span style="color: #666666">*</span>, max_files: <span style="color: #008000">int</span>, time_budget: <span style="color: #008000">int</span>, max_bytes: <span style="color: #008000">int</span>
    ) <span style="color: #666666">-&gt;</span> <span style="color: #008000">dict</span>[Path, <span style="color: #008000">str</span>]:
        tracker[<span style="color: #BA2121">&quot;extract&quot;</span>] <span style="color: #666666">+=</span> <span style="color: #666666">1</span>
        lst <span style="color: #666666">=</span> <span style="color: #008000">list</span>(files)
        tracker[<span style="color: #BA2121">&quot;kwargs&quot;</span>] <span style="color: #666666">=</span> {<span style="color: #BA2121">&quot;max_files&quot;</span>: max_files, <span style="color: #BA2121">&quot;time_budget&quot;</span>: time_budget}
        tracker[<span style="color: #BA2121">&quot;scanned&quot;</span>] <span style="color: #666666">=</span> lst[:max_files]
        <span style="color: #008000; font-weight: bold">return</span> {p: <span style="color: #BA2121">&quot;run code&quot;</span> <span style="color: #008000; font-weight: bold">for</span> p <span style="color: #AA22FF; font-weight: bold">in</span> lst[:max_files]}
</code></pre>
</details>
<h3 id="test_no_code_flag_skips_code_fallback">test_no_code_flag_skips_code_fallback(tmp_path: Path, monkeypatch: pytest.MonkeyPatch, caplog: pytest.LogCaptureFixture) -&gt; None</h3>
<p>This function tests the behavior of a documentation generation tool when the `--no-code` flag is used. It sets up a temporary directory with a README file and mocks out the LLMClient, rank_code_files, and extract_snippets functions to prevent actual code processing. The test asserts that these functions are not called when the `--no-code` flag is provided. It also checks that the log output indicates that the code scan was skipped due to the flag and that the &quot;How to Run&quot; section is included in the output.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">test_no_code_flag_skips_code_fallback</span>(
    tmp_path: Path, monkeypatch: pytest<span style="color: #666666">.</span>MonkeyPatch, caplog: pytest<span style="color: #666666">.</span>LogCaptureFixture
) <span style="color: #666666">-&gt;</span> <span style="color: #008000; font-weight: bold">None</span>:
    (tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;README.md&quot;</span>)<span style="color: #666666">.</span>write_text(<span style="color: #BA2121">&quot;Only overview&quot;</span>, encoding<span style="color: #666666">=</span><span style="color: #BA2121">&quot;utf-8&quot;</span>)

    <span style="color: #008000; font-weight: bold">class</span> <span style="color: #0000FF; font-weight: bold">Dummy</span>:
        <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">summarize</span>(
            <span style="color: #008000">self</span>, text: <span style="color: #008000">str</span>, prompt_type: <span style="color: #008000">str</span>, system_prompt: <span style="color: #008000">str</span> <span style="color: #666666">=</span> <span style="color: #BA2121">&quot;&quot;</span>
        ) <span style="color: #666666">-&gt;</span> <span style="color: #008000">str</span>:
            <span style="color: #008000; font-weight: bold">return</span> <span style="color: #BA2121">&quot;Overview: x</span><span style="color: #AA5D1F; font-weight: bold">\\</span><span style="color: #BA2121">nHow to Run: [[NEEDS_RUN_INSTRUCTIONS]]&quot;</span>

    tracker <span style="color: #666666">=</span> {<span style="color: #BA2121">&quot;rank&quot;</span>: <span style="color: #666666">0</span>, <span style="color: #BA2121">&quot;extract&quot;</span>: <span style="color: #666666">0</span>}

    <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">fake_rank</span>(root: Path, patterns: <span style="color: #008000">list</span>[<span style="color: #008000">str</span>]) <span style="color: #666666">-&gt;</span> <span style="color: #008000">list</span>[Path]:
        tracker[<span style="color: #BA2121">&quot;rank&quot;</span>] <span style="color: #666666">+=</span> <span style="color: #666666">1</span>
        <span style="color: #008000; font-weight: bold">return</span> []

    <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">fake_extract</span>(
        files: Iterable[Path], <span style="color: #666666">*</span>, max_files: <span style="color: #008000">int</span>, time_budget: <span style="color: #008000">int</span>, max_bytes: <span style="color: #008000">int</span>
    ) <span style="color: #666666">-&gt;</span> <span style="color: #008000">dict</span>[Path, <span style="color: #008000">str</span>]:
        tracker[<span style="color: #BA2121">&quot;extract&quot;</span>] <span style="color: #666666">+=</span> <span style="color: #666666">1</span>
        <span style="color: #008000; font-weight: bold">return</span> {}

    monkeypatch<span style="color: #666666">.</span>setattr(explaincode, <span style="color: #BA2121">&quot;LLMClient&quot;</span>, <span style="color: #008000; font-weight: bold">lambda</span>: Dummy())
    monkeypatch<span style="color: #666666">.</span>setattr(explaincode, <span style="color: #BA2121">&quot;rank_code_files&quot;</span>, fake_rank)
    monkeypatch<span style="color: #666666">.</span>setattr(explaincode, <span style="color: #BA2121">&quot;extract_snippets&quot;</span>, fake_extract)

    caplog<span style="color: #666666">.</span>set_level(logging<span style="color: #666666">.</span>INFO)
    main([<span style="color: #BA2121">&quot;--path&quot;</span>, <span style="color: #008000">str</span>(tmp_path), <span style="color: #BA2121">&quot;--scan-code-if-needed&quot;</span>, <span style="color: #BA2121">&quot;--no-code&quot;</span>])
    <span style="color: #008000; font-weight: bold">assert</span> tracker[<span style="color: #BA2121">&quot;rank&quot;</span>] <span style="color: #666666">==</span> <span style="color: #666666">0</span>
    <span style="color: #008000; font-weight: bold">assert</span> tracker[<span style="color: #BA2121">&quot;extract&quot;</span>] <span style="color: #666666">==</span> <span style="color: #666666">0</span>
    log <span style="color: #666666">=</span> caplog<span style="color: #666666">.</span>text
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #BA2121">&quot;Code scan skipped: --no-code specified&quot;</span> <span style="color: #AA22FF; font-weight: bold">in</span> log
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #BA2121">&quot;How to Run&quot;</span> <span style="color: #AA22FF; font-weight: bold">in</span> log
</code></pre>
<details>
<summary>Subfunction: fake_rank(root: Path, patterns: list[str]) -&gt; list[Path]</summary>
<h4 id="fake_rank">fake_rank(root: Path, patterns: list[str]) -&gt; list[Path]</h4>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">fake_rank</span>(root: Path, patterns: <span style="color: #008000">list</span>[<span style="color: #008000">str</span>]) <span style="color: #666666">-&gt;</span> <span style="color: #008000">list</span>[Path]:
        tracker[<span style="color: #BA2121">&quot;rank&quot;</span>] <span style="color: #666666">+=</span> <span style="color: #666666">1</span>
        <span style="color: #008000; font-weight: bold">return</span> []
</code></pre>
</details>
<details>
<summary>Subfunction: fake_extract(files: Iterable[Path], *, max_files: int, time_budget: int, max_bytes: int) -&gt; dict[Path, str]</summary>
<h4 id="fake_extract">fake_extract(files: Iterable[Path], *, max_files: int, time_budget: int, max_bytes: int) -&gt; dict[Path, str]</h4>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">fake_extract</span>(
        files: Iterable[Path], <span style="color: #666666">*</span>, max_files: <span style="color: #008000">int</span>, time_budget: <span style="color: #008000">int</span>, max_bytes: <span style="color: #008000">int</span>
    ) <span style="color: #666666">-&gt;</span> <span style="color: #008000">dict</span>[Path, <span style="color: #008000">str</span>]:
        tracker[<span style="color: #BA2121">&quot;extract&quot;</span>] <span style="color: #666666">+=</span> <span style="color: #666666">1</span>
        <span style="color: #008000; font-weight: bold">return</span> {}
</code></pre>
</details>
<h3 id="test_force_code_flag_triggers_code_fallback">test_force_code_flag_triggers_code_fallback(tmp_path: Path, monkeypatch: pytest.MonkeyPatch, caplog: pytest.LogCaptureFixture) -&gt; None</h3>
<p>This function tests the behavior of a code summarization tool when the `--force-code` flag is used. It sets up a temporary directory, mocks the LLM client and ranking/extracting functions, and captures logs. The test asserts that the ranking and extracting functions are called once, and that specific log messages indicating a code scan trigger and completion of the first pass are present in the captured logs.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">test_force_code_flag_triggers_code_fallback</span>(
    tmp_path: Path, monkeypatch: pytest<span style="color: #666666">.</span>MonkeyPatch, caplog: pytest<span style="color: #666666">.</span>LogCaptureFixture
) <span style="color: #666666">-&gt;</span> <span style="color: #008000; font-weight: bold">None</span>:
    _create_fixture(tmp_path)
    tracker <span style="color: #666666">=</span> {<span style="color: #BA2121">&quot;rank&quot;</span>: <span style="color: #666666">0</span>, <span style="color: #BA2121">&quot;extract&quot;</span>: <span style="color: #666666">0</span>}

    <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">fake_rank</span>(root: Path, patterns: <span style="color: #008000">list</span>[<span style="color: #008000">str</span>]) <span style="color: #666666">-&gt;</span> <span style="color: #008000">list</span>[Path]:
        tracker[<span style="color: #BA2121">&quot;rank&quot;</span>] <span style="color: #666666">+=</span> <span style="color: #666666">1</span>
        <span style="color: #008000; font-weight: bold">return</span> [tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;script.py&quot;</span>]

    <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">fake_extract</span>(
        files: Iterable[Path], <span style="color: #666666">*</span>, max_files: <span style="color: #008000">int</span>, time_budget: <span style="color: #008000">int</span>, max_bytes: <span style="color: #008000">int</span>
    ) <span style="color: #666666">-&gt;</span> <span style="color: #008000">dict</span>[Path, <span style="color: #008000">str</span>]:
        tracker[<span style="color: #BA2121">&quot;extract&quot;</span>] <span style="color: #666666">+=</span> <span style="color: #666666">1</span>
        <span style="color: #008000; font-weight: bold">return</span> {<span style="color: #008000">next</span>(<span style="color: #008000">iter</span>(files)): <span style="color: #BA2121">&quot;code&quot;</span>}

    monkeypatch<span style="color: #666666">.</span>setattr(explaincode, <span style="color: #BA2121">&quot;LLMClient&quot;</span>, _mock_llm_client)
    monkeypatch<span style="color: #666666">.</span>setattr(explaincode, <span style="color: #BA2121">&quot;rank_code_files&quot;</span>, fake_rank)
    monkeypatch<span style="color: #666666">.</span>setattr(explaincode, <span style="color: #BA2121">&quot;extract_snippets&quot;</span>, fake_extract)

    caplog<span style="color: #666666">.</span>set_level(logging<span style="color: #666666">.</span>INFO)
    main([<span style="color: #BA2121">&quot;--path&quot;</span>, <span style="color: #008000">str</span>(tmp_path), <span style="color: #BA2121">&quot;--force-code&quot;</span>])
    <span style="color: #008000; font-weight: bold">assert</span> tracker[<span style="color: #BA2121">&quot;rank&quot;</span>] <span style="color: #666666">==</span> <span style="color: #666666">1</span>
    <span style="color: #008000; font-weight: bold">assert</span> tracker[<span style="color: #BA2121">&quot;extract&quot;</span>] <span style="color: #666666">==</span> <span style="color: #666666">1</span>
    log <span style="color: #666666">=</span> caplog<span style="color: #666666">.</span>text
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #BA2121">&quot;Code scan triggered: --force-code enabled&quot;</span> <span style="color: #AA22FF; font-weight: bold">in</span> log
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #BA2121">&quot;Pass 1 complete: no sections missing&quot;</span> <span style="color: #AA22FF; font-weight: bold">in</span> log
</code></pre>
<details>
<summary>Subfunction: fake_rank(root: Path, patterns: list[str]) -&gt; list[Path]</summary>
<h4 id="fake_rank">fake_rank(root: Path, patterns: list[str]) -&gt; list[Path]</h4>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">fake_rank</span>(root: Path, patterns: <span style="color: #008000">list</span>[<span style="color: #008000">str</span>]) <span style="color: #666666">-&gt;</span> <span style="color: #008000">list</span>[Path]:
        tracker[<span style="color: #BA2121">&quot;rank&quot;</span>] <span style="color: #666666">+=</span> <span style="color: #666666">1</span>
        <span style="color: #008000; font-weight: bold">return</span> [tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;script.py&quot;</span>]
</code></pre>
</details>
<details>
<summary>Subfunction: fake_extract(files: Iterable[Path], *, max_files: int, time_budget: int, max_bytes: int) -&gt; dict[Path, str]</summary>
<h4 id="fake_extract">fake_extract(files: Iterable[Path], *, max_files: int, time_budget: int, max_bytes: int) -&gt; dict[Path, str]</h4>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">fake_extract</span>(
        files: Iterable[Path], <span style="color: #666666">*</span>, max_files: <span style="color: #008000">int</span>, time_budget: <span style="color: #008000">int</span>, max_bytes: <span style="color: #008000">int</span>
    ) <span style="color: #666666">-&gt;</span> <span style="color: #008000">dict</span>[Path, <span style="color: #008000">str</span>]:
        tracker[<span style="color: #BA2121">&quot;extract&quot;</span>] <span style="color: #666666">+=</span> <span style="color: #666666">1</span>
        <span style="color: #008000; font-weight: bold">return</span> {<span style="color: #008000">next</span>(<span style="color: #008000">iter</span>(files)): <span style="color: #BA2121">&quot;code&quot;</span>}
</code></pre>
</details>
<h3 id="test_custom_title_and_filename">test_custom_title_and_filename(tmp_path: Path, monkeypatch: pytest.MonkeyPatch) -&gt; None</h3>
<p>This function tests the generation of a custom title and filename for HTML documentation using the `explaincode` tool. It creates a temporary directory, sets up a mock LLM client, runs the main function with specified path and title, and asserts that the output file and evidence JSON exist. The output file should contain an `&lt;h1&gt;` tag with the text &quot;Fancy Guide&quot;.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">test_custom_title_and_filename</span>(tmp_path: Path, monkeypatch: pytest<span style="color: #666666">.</span>MonkeyPatch) <span style="color: #666666">-&gt;</span> <span style="color: #008000; font-weight: bold">None</span>:
    _create_fixture(tmp_path)
    monkeypatch<span style="color: #666666">.</span>setattr(explaincode, <span style="color: #BA2121">&quot;LLMClient&quot;</span>, _mock_llm_client)
    main([<span style="color: #BA2121">&quot;--path&quot;</span>, <span style="color: #008000">str</span>(tmp_path), <span style="color: #BA2121">&quot;--title&quot;</span>, <span style="color: #BA2121">&quot;Fancy Guide&quot;</span>])
    out_file <span style="color: #666666">=</span> tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;fancy_guide.html&quot;</span>
    evidence_file <span style="color: #666666">=</span> tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;fancy_guide_evidence.json&quot;</span>
    <span style="color: #008000; font-weight: bold">assert</span> out_file<span style="color: #666666">.</span>exists()
    <span style="color: #008000; font-weight: bold">assert</span> evidence_file<span style="color: #666666">.</span>exists()
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #BA2121">&quot;&lt;h1&gt;Fancy Guide&lt;/h1&gt;&quot;</span> <span style="color: #AA22FF; font-weight: bold">in</span> out_file<span style="color: #666666">.</span>read_text(encoding<span style="color: #666666">=</span><span style="color: #BA2121">&quot;utf-8&quot;</span>)
</code></pre>
<h3 id="test_insert_into_index">test_insert_into_index(tmp_path: Path, monkeypatch: pytest.MonkeyPatch) -&gt; None</h3>
<p>The function `test_insert_into_index` is a unit test for inserting links into an HTML index file. It uses the `tmp_path` fixture to create a temporary directory and the `monkeypatch` fixture to mock the `LLMClient` class from the `explaincode` module. The function creates an output directory, initializes an empty HTML index file, and then calls the `main` function with specific command-line arguments to insert links into the index. Finally, it asserts that a link for &quot;User Manual&quot; is present in the modified HTML content.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">test_insert_into_index</span>(tmp_path: Path, monkeypatch: pytest<span style="color: #666666">.</span>MonkeyPatch) <span style="color: #666666">-&gt;</span> <span style="color: #008000; font-weight: bold">None</span>:
    _create_fixture(tmp_path)
    out_dir <span style="color: #666666">=</span> tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;out&quot;</span>
    out_dir<span style="color: #666666">.</span>mkdir()
    index <span style="color: #666666">=</span> out_dir <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;index.html&quot;</span>
    index<span style="color: #666666">.</span>write_text(<span style="color: #BA2121">&quot;&lt;html&gt;&lt;body&gt;&lt;ul&gt;&lt;/ul&gt;&lt;/body&gt;&lt;/html&gt;&quot;</span>, encoding<span style="color: #666666">=</span><span style="color: #BA2121">&quot;utf-8&quot;</span>)
    monkeypatch<span style="color: #666666">.</span>setattr(explaincode, <span style="color: #BA2121">&quot;LLMClient&quot;</span>, _mock_llm_client)
    main([<span style="color: #BA2121">&quot;--path&quot;</span>, <span style="color: #008000">str</span>(tmp_path), <span style="color: #BA2121">&quot;--output&quot;</span>, <span style="color: #008000">str</span>(out_dir), <span style="color: #BA2121">&quot;--insert-into-index&quot;</span>])
    html <span style="color: #666666">=</span> index<span style="color: #666666">.</span>read_text(encoding<span style="color: #666666">=</span><span style="color: #BA2121">&quot;utf-8&quot;</span>)
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #BA2121">&#39;&lt;a href=&quot;user_manual.html&quot;&gt;User Manual&lt;/a&gt;&#39;</span> <span style="color: #AA22FF; font-weight: bold">in</span> html
</code></pre>
<h3 id="test_docs_index_default_and_injection">test_docs_index_default_and_injection(tmp_path: Path, monkeypatch: pytest.MonkeyPatch) -&gt; None</h3>
<p>This function `test_docs_index_default_and_injection` tests the creation of documentation index files and manual insertion. It uses a temporary directory, creates a mock LLM client, and runs the main function with specified parameters. The test checks if the user manual and evidence JSON files are created, and verifies that the navigation menu in the index.html file correctly links to the user manual.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">test_docs_index_default_and_injection</span>(
    tmp_path: Path, monkeypatch: pytest<span style="color: #666666">.</span>MonkeyPatch
) <span style="color: #666666">-&gt;</span> <span style="color: #008000; font-weight: bold">None</span>:
    _create_fixture(tmp_path)
    docs_dir <span style="color: #666666">=</span> tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;docs&quot;</span>
    docs_dir<span style="color: #666666">.</span>mkdir()
    (docs_dir <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;index.html&quot;</span>)<span style="color: #666666">.</span>write_text(<span style="color: #BA2121">&quot;&lt;html&gt;&lt;body&gt;&lt;nav&gt;&lt;/nav&gt;&lt;/body&gt;&lt;/html&gt;&quot;</span>, encoding<span style="color: #666666">=</span><span style="color: #BA2121">&quot;utf-8&quot;</span>)
    monkeypatch<span style="color: #666666">.</span>setattr(explaincode, <span style="color: #BA2121">&quot;LLMClient&quot;</span>, _mock_llm_client)
    main([<span style="color: #BA2121">&quot;--path&quot;</span>, <span style="color: #008000">str</span>(tmp_path), <span style="color: #BA2121">&quot;--insert-into-index&quot;</span>])
    manual <span style="color: #666666">=</span> docs_dir <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;user_manual.html&quot;</span>
    evidence <span style="color: #666666">=</span> docs_dir <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;user_manual_evidence.json&quot;</span>
    <span style="color: #008000; font-weight: bold">assert</span> manual<span style="color: #666666">.</span>exists()
    <span style="color: #008000; font-weight: bold">assert</span> evidence<span style="color: #666666">.</span>exists()
    soup <span style="color: #666666">=</span> BeautifulSoup((docs_dir <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;index.html&quot;</span>)<span style="color: #666666">.</span>read_text(encoding<span style="color: #666666">=</span><span style="color: #BA2121">&quot;utf-8&quot;</span>), <span style="color: #BA2121">&quot;html.parser&quot;</span>)
    nav <span style="color: #666666">=</span> soup<span style="color: #666666">.</span>find(<span style="color: #BA2121">&quot;nav&quot;</span>)
    <span style="color: #008000; font-weight: bold">assert</span> nav <span style="color: #AA22FF; font-weight: bold">is</span> <span style="color: #AA22FF; font-weight: bold">not</span> <span style="color: #008000; font-weight: bold">None</span>
    first <span style="color: #666666">=</span> nav<span style="color: #666666">.</span>find(<span style="color: #BA2121">&quot;a&quot;</span>)
    <span style="color: #008000; font-weight: bold">assert</span> first <span style="color: #AA22FF; font-weight: bold">and</span> first[<span style="color: #BA2121">&quot;href&quot;</span>] <span style="color: #666666">==</span> <span style="color: #BA2121">&quot;user_manual.html&quot;</span>
</code></pre>
<h3 id="test_insert_into_root_index">test_insert_into_root_index(tmp_path: Path, monkeypatch: pytest.MonkeyPatch) -&gt; None</h3>
<p>This function, `test_insert_into_root_index`, tests the functionality of inserting a generated documentation link into an existing HTML index file. It uses a temporary directory (`tmp_path`) to create a mock environment for testing. The function performs the following steps:

1. Creates a fixture using `_create_fixture(tmp_path)`.
2. Writes a basic HTML structure to `index.html` in the temporary directory.
3. Mocks the LLMClient using `monkeypatch.setattr(explaincode, &quot;LLMClient&quot;, _mock_llm_client)`.
4. Calls the `main` function with command-line arguments to insert documentation into the index file (`--path`, `str(tmp_path)`, `--insert-into-index`).
5. Verifies that the generated documentation files (`user_manual.html` and `user_manual_evidence.json`) exist in the `docs` directory.
6. Parses the modified `index.html` using BeautifulSoup to find the `&lt;nav&gt;` element.
7. Asserts that the `&lt;nav&gt;` element contains an anchor tag (`&lt;a&gt;`) with a `href` attribute pointing to the generated documentation file.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">test_insert_into_root_index</span>(tmp_path: Path, monkeypatch: pytest<span style="color: #666666">.</span>MonkeyPatch) <span style="color: #666666">-&gt;</span> <span style="color: #008000; font-weight: bold">None</span>:
    _create_fixture(tmp_path)
    (tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;index.html&quot;</span>)<span style="color: #666666">.</span>write_text(<span style="color: #BA2121">&quot;&lt;html&gt;&lt;body&gt;&lt;nav&gt;&lt;/nav&gt;&lt;/body&gt;&lt;/html&gt;&quot;</span>, encoding<span style="color: #666666">=</span><span style="color: #BA2121">&quot;utf-8&quot;</span>)
    monkeypatch<span style="color: #666666">.</span>setattr(explaincode, <span style="color: #BA2121">&quot;LLMClient&quot;</span>, _mock_llm_client)
    main([<span style="color: #BA2121">&quot;--path&quot;</span>, <span style="color: #008000">str</span>(tmp_path), <span style="color: #BA2121">&quot;--insert-into-index&quot;</span>])
    manual <span style="color: #666666">=</span> tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;docs&quot;</span> <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;user_manual.html&quot;</span>
    evidence <span style="color: #666666">=</span> tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;docs&quot;</span> <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;user_manual_evidence.json&quot;</span>
    <span style="color: #008000; font-weight: bold">assert</span> manual<span style="color: #666666">.</span>exists()
    <span style="color: #008000; font-weight: bold">assert</span> evidence<span style="color: #666666">.</span>exists()
    soup <span style="color: #666666">=</span> BeautifulSoup((tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;index.html&quot;</span>)<span style="color: #666666">.</span>read_text(encoding<span style="color: #666666">=</span><span style="color: #BA2121">&quot;utf-8&quot;</span>), <span style="color: #BA2121">&quot;html.parser&quot;</span>)
    nav <span style="color: #666666">=</span> soup<span style="color: #666666">.</span>find(<span style="color: #BA2121">&quot;nav&quot;</span>)
    <span style="color: #008000; font-weight: bold">assert</span> nav <span style="color: #AA22FF; font-weight: bold">is</span> <span style="color: #AA22FF; font-weight: bold">not</span> <span style="color: #008000; font-weight: bold">None</span>
    first <span style="color: #666666">=</span> nav<span style="color: #666666">.</span>find(<span style="color: #BA2121">&quot;a&quot;</span>)
    <span style="color: #008000; font-weight: bold">assert</span> first <span style="color: #AA22FF; font-weight: bold">and</span> first[<span style="color: #BA2121">&quot;href&quot;</span>] <span style="color: #666666">==</span> <span style="color: #BA2121">&quot;docs/user_manual.html&quot;</span>
</code></pre>
<h3 id="test_chunking_triggers_multiple_calls_and_logs">test_chunking_triggers_multiple_calls_and_logs(tmp_path: Path, capsys: pytest.CaptureFixture[str]) -&gt; None</h3>
<p>This function tests the chunking and summarization process for a given text. It creates a dummy client that records its calls to summarize text based on system prompts. The test provides two paragraphs of text, each repeated 2000 times. The function then uses `manual_utils._summarize_manual` with a dummy client, response cache, and auto-chunking enabled. The result is compared to &quot;final&quot;, indicating successful merging. The test asserts that the client was called three times: twice with chunk prompts and once with a merge prompt. It also checks that the merge call includes both paragraphs of text. Additionally, it verifies that debug logs are captured, confirming the chunking and merging steps.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">test_chunking_triggers_multiple_calls_and_logs</span>(
    tmp_path: Path, capsys: pytest<span style="color: #666666">.</span>CaptureFixture[<span style="color: #008000">str</span>]
) <span style="color: #666666">-&gt;</span> <span style="color: #008000; font-weight: bold">None</span>:
    paragraph1 <span style="color: #666666">=</span> <span style="color: #BA2121">&quot;aaa &quot;</span> <span style="color: #666666">*</span> <span style="color: #666666">2000</span>
    paragraph2 <span style="color: #666666">=</span> <span style="color: #BA2121">&quot;bbb &quot;</span> <span style="color: #666666">*</span> <span style="color: #666666">2000</span>
    text <span style="color: #666666">=</span> <span style="color: #BA2121">&quot;</span><span style="color: #AA5D1F; font-weight: bold">\n\n</span><span style="color: #BA2121">&quot;</span><span style="color: #666666">.</span>join([paragraph1, paragraph2])

    <span style="color: #008000; font-weight: bold">class</span> <span style="color: #0000FF; font-weight: bold">Dummy</span>:
        <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">__init__</span>(<span style="color: #008000">self</span>) <span style="color: #666666">-&gt;</span> <span style="color: #008000; font-weight: bold">None</span>:
            <span style="color: #008000">self</span><span style="color: #666666">.</span>calls: <span style="color: #008000">list</span>[<span style="color: #008000">dict</span>] <span style="color: #666666">=</span> []

        <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">summarize</span>(<span style="color: #008000">self</span>, text: <span style="color: #008000">str</span>, prompt_type: <span style="color: #008000">str</span>, system_prompt: <span style="color: #008000">str</span> <span style="color: #666666">=</span> <span style="color: #BA2121">&quot;&quot;</span>) <span style="color: #666666">-&gt;</span> <span style="color: #008000">str</span>:
            <span style="color: #008000">self</span><span style="color: #666666">.</span>calls<span style="color: #666666">.</span>append(
                {<span style="color: #BA2121">&quot;text&quot;</span>: text, <span style="color: #BA2121">&quot;prompt_type&quot;</span>: prompt_type, <span style="color: #BA2121">&quot;system_prompt&quot;</span>: system_prompt}
            )
            <span style="color: #008000; font-weight: bold">if</span> system_prompt <span style="color: #666666">==</span> explaincode<span style="color: #666666">.</span>MERGE_SYSTEM_PROMPT:
                <span style="color: #008000; font-weight: bold">return</span> <span style="color: #BA2121">&quot;final&quot;</span>
            <span style="color: #008000; font-weight: bold">return</span> text<span style="color: #666666">.</span>split()[<span style="color: #666666">0</span>]

    client <span style="color: #666666">=</span> Dummy()
    cache <span style="color: #666666">=</span> ResponseCache(<span style="color: #008000">str</span>(tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;cache.json&quot;</span>))
    logging<span style="color: #666666">.</span>basicConfig(stream<span style="color: #666666">=</span>sys<span style="color: #666666">.</span>stdout, level<span style="color: #666666">=</span>logging<span style="color: #666666">.</span>DEBUG, force<span style="color: #666666">=</span><span style="color: #008000; font-weight: bold">True</span>)
    result <span style="color: #666666">=</span> manual_utils<span style="color: #666666">.</span>_summarize_manual(
        client, cache, text, chunking<span style="color: #666666">=</span><span style="color: #BA2121">&quot;auto&quot;</span>, source<span style="color: #666666">=</span><span style="color: #BA2121">&quot;src&quot;</span>
    )

    <span style="color: #008000; font-weight: bold">assert</span> result <span style="color: #666666">==</span> <span style="color: #BA2121">&quot;final&quot;</span>
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #008000">len</span>(client<span style="color: #666666">.</span>calls) <span style="color: #666666">==</span> <span style="color: #666666">3</span>
    chunk_calls <span style="color: #666666">=</span> client<span style="color: #666666">.</span>calls[:<span style="color: #666666">-1</span>]
    merge_call <span style="color: #666666">=</span> client<span style="color: #666666">.</span>calls[<span style="color: #666666">-1</span>]
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #008000">all</span>(c[<span style="color: #BA2121">&quot;system_prompt&quot;</span>] <span style="color: #666666">==</span> explaincode<span style="color: #666666">.</span>CHUNK_SYSTEM_PROMPT <span style="color: #008000; font-weight: bold">for</span> c <span style="color: #AA22FF; font-weight: bold">in</span> chunk_calls)
    <span style="color: #008000; font-weight: bold">assert</span> merge_call[<span style="color: #BA2121">&quot;system_prompt&quot;</span>] <span style="color: #666666">==</span> explaincode<span style="color: #666666">.</span>MERGE_SYSTEM_PROMPT
    <span style="color: #008000; font-weight: bold">assert</span> merge_call[<span style="color: #BA2121">&quot;text&quot;</span>] <span style="color: #666666">==</span> <span style="color: #BA2121">&quot;aaa</span><span style="color: #AA5D1F; font-weight: bold">\n\n</span><span style="color: #BA2121">bbb&quot;</span>

    out <span style="color: #666666">=</span> capsys<span style="color: #666666">.</span>readouterr()<span style="color: #666666">.</span>out
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #BA2121">&quot;Chunk 1/2 from src&quot;</span> <span style="color: #AA22FF; font-weight: bold">in</span> out
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #BA2121">&quot;Merged LLM response length&quot;</span> <span style="color: #AA22FF; font-weight: bold">in</span> out
</code></pre>
<h3 id="test_chunk_edit_hook_applied">test_chunk_edit_hook_applied(tmp_path: Path) -&gt; None</h3>
<p>The function `test_chunk_edit_hook_applied` tests the `_summarize_manual` utility with a custom hook for chunk editing. It creates a dummy client to simulate LLM interactions and a cache to store responses. The text is split into chunks, each processed by the hook which converts them to uppercase. The final chunk is summarized using the dummy client&#x27;s `summarize` method, which handles a specific system prompt by returning &quot;final&quot;. The test asserts that the result matches the expected output and that the last call to the client&#x27;s `summarize` method has the modified text in uppercase.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">test_chunk_edit_hook_applied</span>(tmp_path: Path) <span style="color: #666666">-&gt;</span> <span style="color: #008000; font-weight: bold">None</span>:
    paragraph1 <span style="color: #666666">=</span> <span style="color: #BA2121">&quot;aaa &quot;</span> <span style="color: #666666">*</span> <span style="color: #666666">2000</span>
    paragraph2 <span style="color: #666666">=</span> <span style="color: #BA2121">&quot;bbb &quot;</span> <span style="color: #666666">*</span> <span style="color: #666666">2000</span>
    text <span style="color: #666666">=</span> <span style="color: #BA2121">&quot;</span><span style="color: #AA5D1F; font-weight: bold">\n\n</span><span style="color: #BA2121">&quot;</span><span style="color: #666666">.</span>join([paragraph1, paragraph2])

    <span style="color: #008000; font-weight: bold">class</span> <span style="color: #0000FF; font-weight: bold">Dummy</span>:
        <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">__init__</span>(<span style="color: #008000">self</span>) <span style="color: #666666">-&gt;</span> <span style="color: #008000; font-weight: bold">None</span>:
            <span style="color: #008000">self</span><span style="color: #666666">.</span>calls: <span style="color: #008000">list</span>[<span style="color: #008000">dict</span>] <span style="color: #666666">=</span> []

        <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">summarize</span>(<span style="color: #008000">self</span>, text: <span style="color: #008000">str</span>, prompt_type: <span style="color: #008000">str</span>, system_prompt: <span style="color: #008000">str</span> <span style="color: #666666">=</span> <span style="color: #BA2121">&quot;&quot;</span>) <span style="color: #666666">-&gt;</span> <span style="color: #008000">str</span>:
            <span style="color: #008000">self</span><span style="color: #666666">.</span>calls<span style="color: #666666">.</span>append(
                {<span style="color: #BA2121">&quot;text&quot;</span>: text, <span style="color: #BA2121">&quot;prompt_type&quot;</span>: prompt_type, <span style="color: #BA2121">&quot;system_prompt&quot;</span>: system_prompt}
            )
            <span style="color: #008000; font-weight: bold">if</span> system_prompt <span style="color: #666666">==</span> explaincode<span style="color: #666666">.</span>MERGE_SYSTEM_PROMPT:
                <span style="color: #008000; font-weight: bold">return</span> <span style="color: #BA2121">&quot;final&quot;</span>
            <span style="color: #008000; font-weight: bold">return</span> text<span style="color: #666666">.</span>split()[<span style="color: #666666">0</span>]

    <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">hook</span>(chunks: <span style="color: #008000">list</span>[<span style="color: #008000">str</span>]) <span style="color: #666666">-&gt;</span> <span style="color: #008000">list</span>[<span style="color: #008000">str</span>]:
        <span style="color: #008000; font-weight: bold">return</span> [c<span style="color: #666666">.</span>upper() <span style="color: #008000; font-weight: bold">for</span> c <span style="color: #AA22FF; font-weight: bold">in</span> chunks]

    client <span style="color: #666666">=</span> Dummy()
    cache <span style="color: #666666">=</span> ResponseCache(<span style="color: #008000">str</span>(tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;cache.json&quot;</span>))
    result <span style="color: #666666">=</span> manual_utils<span style="color: #666666">.</span>_summarize_manual(
        client, cache, text, chunking<span style="color: #666666">=</span><span style="color: #BA2121">&quot;auto&quot;</span>, source<span style="color: #666666">=</span><span style="color: #BA2121">&quot;src&quot;</span>, post_chunk_hook<span style="color: #666666">=</span>hook
    )

    <span style="color: #008000; font-weight: bold">assert</span> result <span style="color: #666666">==</span> <span style="color: #BA2121">&quot;final&quot;</span>
    <span style="color: #008000; font-weight: bold">assert</span> client<span style="color: #666666">.</span>calls[<span style="color: #666666">-1</span>][<span style="color: #BA2121">&quot;text&quot;</span>] <span style="color: #666666">==</span> <span style="color: #BA2121">&quot;AAA</span><span style="color: #AA5D1F; font-weight: bold">\n\n</span><span style="color: #BA2121">BBB&quot;</span>
</code></pre>
<details>
<summary>Subfunction: hook(chunks: list[str]) -&gt; list[str]</summary>
<h4 id="hook">hook(chunks: list[str]) -&gt; list[str]</h4>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">hook</span>(chunks: <span style="color: #008000">list</span>[<span style="color: #008000">str</span>]) <span style="color: #666666">-&gt;</span> <span style="color: #008000">list</span>[<span style="color: #008000">str</span>]:
        <span style="color: #008000; font-weight: bold">return</span> [c<span style="color: #666666">.</span>upper() <span style="color: #008000; font-weight: bold">for</span> c <span style="color: #AA22FF; font-weight: bold">in</span> chunks]
</code></pre>
</details>
<h3 id="test_parallel_chunk_summarization">test_parallel_chunk_summarization(tmp_path: Path) -&gt; None</h3>
<p>This function `test_parallel_chunk_summarization` tests the summarization of text in parallel using a mock client that simulates delays. It creates a large text by repeating a paragraph, then uses a custom client to summarize the text with a delay when a specific system prompt is encountered. The test measures the time taken to summarize the text and asserts that it is less than 1.5 times the simulated delay, indicating efficient parallel processing.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">test_parallel_chunk_summarization</span>(tmp_path: Path) <span style="color: #666666">-&gt;</span> <span style="color: #008000; font-weight: bold">None</span>:
    paragraph <span style="color: #666666">=</span> <span style="color: #BA2121">&quot;word &quot;</span> <span style="color: #666666">*</span> <span style="color: #666666">2000</span>
    text <span style="color: #666666">=</span> <span style="color: #BA2121">&quot;</span><span style="color: #AA5D1F; font-weight: bold">\n\n</span><span style="color: #BA2121">&quot;</span><span style="color: #666666">.</span>join([paragraph, paragraph])
    delay <span style="color: #666666">=</span> <span style="color: #666666">0.2</span>

    <span style="color: #008000; font-weight: bold">class</span> <span style="color: #0000FF; font-weight: bold">SlowClient</span>:
        <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">summarize</span>(<span style="color: #008000">self</span>, text: <span style="color: #008000">str</span>, prompt_type: <span style="color: #008000">str</span>, system_prompt: <span style="color: #008000">str</span> <span style="color: #666666">=</span> <span style="color: #BA2121">&quot;&quot;</span>) <span style="color: #666666">-&gt;</span> <span style="color: #008000">str</span>:
            <span style="color: #008000; font-weight: bold">if</span> system_prompt <span style="color: #666666">==</span> explaincode<span style="color: #666666">.</span>CHUNK_SYSTEM_PROMPT:
                time<span style="color: #666666">.</span>sleep(delay)
            <span style="color: #008000; font-weight: bold">return</span> <span style="color: #BA2121">&quot;ok&quot;</span>

    client <span style="color: #666666">=</span> SlowClient()
    cache <span style="color: #666666">=</span> ResponseCache(<span style="color: #008000">str</span>(tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;cache.json&quot;</span>))
    start <span style="color: #666666">=</span> time<span style="color: #666666">.</span>perf_counter()
    manual_utils<span style="color: #666666">.</span>_summarize_manual(client, cache, text, chunking<span style="color: #666666">=</span><span style="color: #BA2121">&quot;auto&quot;</span>, source<span style="color: #666666">=</span><span style="color: #BA2121">&quot;src&quot;</span>)
    duration <span style="color: #666666">=</span> time<span style="color: #666666">.</span>perf_counter() <span style="color: #666666">-</span> start
    <span style="color: #008000; font-weight: bold">assert</span> duration <span style="color: #666666">&lt;</span> delay <span style="color: #666666">*</span> <span style="color: #666666">1.5</span>
</code></pre>
<h3 id="test_hierarchical_merge_logged">test_hierarchical_merge_logged(tmp_path: Path, capsys: pytest.CaptureFixture[str]) -&gt; None</h3>
<p>This function `test_hierarchical_merge_logged` tests the hierarchical merging process for summarizing text using an LLM client. It creates a dummy client that returns a large response initially and then a short response after two calls. The function uses a temporary path for caching responses, sets up logging to capture output, and summarizes a large text by chunking it automatically. The test asserts that the final result is &quot;short&quot;, that more than three calls were made to the client, and that the log output contains the phrase &quot;Hierarchical merge pass&quot;.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">test_hierarchical_merge_logged</span>(
    tmp_path: Path, capsys: pytest<span style="color: #666666">.</span>CaptureFixture[<span style="color: #008000">str</span>]
) <span style="color: #666666">-&gt;</span> <span style="color: #008000; font-weight: bold">None</span>:
    big <span style="color: #666666">=</span> <span style="color: #BA2121">&quot;word &quot;</span> <span style="color: #666666">*</span> <span style="color: #666666">5000</span>
    text <span style="color: #666666">=</span> <span style="color: #BA2121">&quot;</span><span style="color: #AA5D1F; font-weight: bold">\n\n</span><span style="color: #BA2121">&quot;</span><span style="color: #666666">.</span>join([big, big])

    <span style="color: #008000; font-weight: bold">class</span> <span style="color: #0000FF; font-weight: bold">Dummy</span>:
        <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">__init__</span>(<span style="color: #008000">self</span>) <span style="color: #666666">-&gt;</span> <span style="color: #008000; font-weight: bold">None</span>:
            <span style="color: #008000">self</span><span style="color: #666666">.</span>calls: <span style="color: #008000">list</span>[<span style="color: #008000">dict</span>] <span style="color: #666666">=</span> []

        <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">summarize</span>(<span style="color: #008000">self</span>, text: <span style="color: #008000">str</span>, prompt_type: <span style="color: #008000">str</span>, system_prompt: <span style="color: #008000">str</span> <span style="color: #666666">=</span> <span style="color: #BA2121">&quot;&quot;</span>) <span style="color: #666666">-&gt;</span> <span style="color: #008000">str</span>:
            <span style="color: #008000">self</span><span style="color: #666666">.</span>calls<span style="color: #666666">.</span>append(
                {<span style="color: #BA2121">&quot;text&quot;</span>: text, <span style="color: #BA2121">&quot;prompt_type&quot;</span>: prompt_type, <span style="color: #BA2121">&quot;system_prompt&quot;</span>: system_prompt}
            )
            <span style="color: #008000; font-weight: bold">if</span> <span style="color: #008000">len</span>(<span style="color: #008000">self</span><span style="color: #666666">.</span>calls) <span style="color: #666666">&lt;=</span> <span style="color: #666666">2</span>:
                <span style="color: #008000; font-weight: bold">return</span> big
            <span style="color: #008000; font-weight: bold">return</span> <span style="color: #BA2121">&quot;short&quot;</span>

    client <span style="color: #666666">=</span> Dummy()
    cache <span style="color: #666666">=</span> ResponseCache(<span style="color: #008000">str</span>(tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;cache.json&quot;</span>))
    logging<span style="color: #666666">.</span>basicConfig(stream<span style="color: #666666">=</span>sys<span style="color: #666666">.</span>stdout, level<span style="color: #666666">=</span>logging<span style="color: #666666">.</span>DEBUG, force<span style="color: #666666">=</span><span style="color: #008000; font-weight: bold">True</span>)
    result <span style="color: #666666">=</span> manual_utils<span style="color: #666666">.</span>_summarize_manual(
        client, cache, text, chunking<span style="color: #666666">=</span><span style="color: #BA2121">&quot;auto&quot;</span>, source<span style="color: #666666">=</span><span style="color: #BA2121">&quot;src&quot;</span>
    )

    <span style="color: #008000; font-weight: bold">assert</span> result <span style="color: #666666">==</span> <span style="color: #BA2121">&quot;short&quot;</span>
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #008000">len</span>(client<span style="color: #666666">.</span>calls) <span style="color: #666666">&gt;</span> <span style="color: #666666">3</span>
    out <span style="color: #666666">=</span> capsys<span style="color: #666666">.</span>readouterr()<span style="color: #666666">.</span>out
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #BA2121">&quot;Hierarchical merge pass&quot;</span> <span style="color: #AA22FF; font-weight: bold">in</span> out
</code></pre>
<h3 id="test_cached_chunks_reused">test_cached_chunks_reused(tmp_path: Path) -&gt; None</h3>
<p>This function tests the reuse of cached chunks when summarizing text. It creates a dummy class `Dummy` with a `summarize` method that records its calls and returns a response based on the call count. The function then uses a `ResponseCache` to cache responses. It first summarizes a large text using `manual_utils._summarize_manual` with a `Dummy` client, which results in three calls to `summarize`. When summarizing the same text again, it reuses the cached response instead of making additional calls, as evidenced by the assertion that `len(client2.calls)` is 0.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">test_cached_chunks_reused</span>(tmp_path: Path) <span style="color: #666666">-&gt;</span> <span style="color: #008000; font-weight: bold">None</span>:
    paragraph <span style="color: #666666">=</span> <span style="color: #BA2121">&quot;word &quot;</span> <span style="color: #666666">*</span> <span style="color: #666666">2000</span>
    text <span style="color: #666666">=</span> <span style="color: #BA2121">&quot;</span><span style="color: #AA5D1F; font-weight: bold">\n\n</span><span style="color: #BA2121">&quot;</span><span style="color: #666666">.</span>join([paragraph, paragraph])

    <span style="color: #008000; font-weight: bold">class</span> <span style="color: #0000FF; font-weight: bold">Dummy</span>:
        <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">__init__</span>(<span style="color: #008000">self</span>) <span style="color: #666666">-&gt;</span> <span style="color: #008000; font-weight: bold">None</span>:
            <span style="color: #008000">self</span><span style="color: #666666">.</span>calls: <span style="color: #008000">list</span>[<span style="color: #008000">dict</span>] <span style="color: #666666">=</span> []

        <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">summarize</span>(<span style="color: #008000">self</span>, text: <span style="color: #008000">str</span>, prompt_type: <span style="color: #008000">str</span>, system_prompt: <span style="color: #008000">str</span> <span style="color: #666666">=</span> <span style="color: #BA2121">&quot;&quot;</span>) <span style="color: #666666">-&gt;</span> <span style="color: #008000">str</span>:
            <span style="color: #008000">self</span><span style="color: #666666">.</span>calls<span style="color: #666666">.</span>append(
                {<span style="color: #BA2121">&quot;text&quot;</span>: text, <span style="color: #BA2121">&quot;prompt_type&quot;</span>: prompt_type, <span style="color: #BA2121">&quot;system_prompt&quot;</span>: system_prompt}
            )
            <span style="color: #008000; font-weight: bold">return</span> <span style="color: #BA2121">f&quot;resp</span><span style="color: #A45A77; font-weight: bold">{</span><span style="color: #008000">len</span>(<span style="color: #008000">self</span><span style="color: #666666">.</span>calls)<span style="color: #A45A77; font-weight: bold">}</span><span style="color: #BA2121">&quot;</span>

    cache_file <span style="color: #666666">=</span> tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;cache.json&quot;</span>
    cache <span style="color: #666666">=</span> ResponseCache(<span style="color: #008000">str</span>(cache_file))
    client1 <span style="color: #666666">=</span> Dummy()
    result1 <span style="color: #666666">=</span> manual_utils<span style="color: #666666">.</span>_summarize_manual(
        client1, cache, text, chunking<span style="color: #666666">=</span><span style="color: #BA2121">&quot;auto&quot;</span>, source<span style="color: #666666">=</span><span style="color: #BA2121">&quot;src&quot;</span>
    )
    <span style="color: #008000; font-weight: bold">assert</span> result1 <span style="color: #666666">==</span> <span style="color: #BA2121">&quot;resp3&quot;</span>
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #008000">len</span>(client1<span style="color: #666666">.</span>calls) <span style="color: #666666">==</span> <span style="color: #666666">3</span>

    client2 <span style="color: #666666">=</span> Dummy()
    cache2 <span style="color: #666666">=</span> ResponseCache(<span style="color: #008000">str</span>(cache_file))
    result2 <span style="color: #666666">=</span> manual_utils<span style="color: #666666">.</span>_summarize_manual(
        client2, cache2, text, chunking<span style="color: #666666">=</span><span style="color: #BA2121">&quot;auto&quot;</span>, source<span style="color: #666666">=</span><span style="color: #BA2121">&quot;src&quot;</span>
    )
    <span style="color: #008000; font-weight: bold">assert</span> result2 <span style="color: #666666">==</span> <span style="color: #BA2121">&quot;resp3&quot;</span>
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #008000">len</span>(client2<span style="color: #666666">.</span>calls) <span style="color: #666666">==</span> <span style="color: #666666">0</span>
</code></pre>
<h3 id="test_chunking_none_no_llm_calls">test_chunking_none_no_llm_calls(tmp_path: Path, monkeypatch: pytest.MonkeyPatch) -&gt; None</h3>
<p>This function tests the behavior of a code summarization tool when chunking is disabled and no LLM calls are expected. It creates a large text file, sets up a mock LLM client that records its calls, and runs the main function with specific arguments. The test asserts that the LLM client was called five times and that the first call includes &quot;Overview&quot; in the system prompt.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">test_chunking_none_no_llm_calls</span>(tmp_path: Path, monkeypatch: pytest<span style="color: #666666">.</span>MonkeyPatch) <span style="color: #666666">-&gt;</span> <span style="color: #008000; font-weight: bold">None</span>:
    big_text <span style="color: #666666">=</span> <span style="color: #BA2121">&quot;data &quot;</span> <span style="color: #666666">*</span> <span style="color: #666666">5000</span>
    (tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;README.md&quot;</span>)<span style="color: #666666">.</span>write_text(<span style="color: #BA2121">&quot;# Overview</span><span style="color: #AA5D1F; font-weight: bold">\n</span><span style="color: #BA2121">&quot;</span> <span style="color: #666666">+</span> big_text, encoding<span style="color: #666666">=</span><span style="color: #BA2121">&quot;utf-8&quot;</span>)

    <span style="color: #008000; font-weight: bold">class</span> <span style="color: #0000FF; font-weight: bold">Dummy</span>:
        <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">__init__</span>(<span style="color: #008000">self</span>) <span style="color: #666666">-&gt;</span> <span style="color: #008000; font-weight: bold">None</span>:
            <span style="color: #008000">self</span><span style="color: #666666">.</span>calls: <span style="color: #008000">list</span>[<span style="color: #008000">dict</span>] <span style="color: #666666">=</span> []

        <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">summarize</span>(<span style="color: #008000">self</span>, text: <span style="color: #008000">str</span>, prompt_type: <span style="color: #008000">str</span>, system_prompt: <span style="color: #008000">str</span> <span style="color: #666666">=</span> <span style="color: #BA2121">&quot;&quot;</span>) <span style="color: #666666">-&gt;</span> <span style="color: #008000">str</span>:
            <span style="color: #008000">self</span><span style="color: #666666">.</span>calls<span style="color: #666666">.</span>append(
                {<span style="color: #BA2121">&quot;text&quot;</span>: text, <span style="color: #BA2121">&quot;prompt_type&quot;</span>: prompt_type, <span style="color: #BA2121">&quot;system_prompt&quot;</span>: system_prompt}
            )
            <span style="color: #008000; font-weight: bold">return</span> <span style="color: #BA2121">&quot;done&quot;</span>

    dummy <span style="color: #666666">=</span> Dummy()
    monkeypatch<span style="color: #666666">.</span>setattr(explaincode, <span style="color: #BA2121">&quot;LLMClient&quot;</span>, <span style="color: #008000; font-weight: bold">lambda</span>: dummy)
    main([<span style="color: #BA2121">&quot;--path&quot;</span>, <span style="color: #008000">str</span>(tmp_path), <span style="color: #BA2121">&quot;--chunking&quot;</span>, <span style="color: #BA2121">&quot;none&quot;</span>])

    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #008000">len</span>(dummy<span style="color: #666666">.</span>calls) <span style="color: #666666">==</span> <span style="color: #666666">5</span>
    call <span style="color: #666666">=</span> dummy<span style="color: #666666">.</span>calls[<span style="color: #666666">0</span>]
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #BA2121">&quot;Overview&quot;</span> <span style="color: #AA22FF; font-weight: bold">in</span> call[<span style="color: #BA2121">&quot;system_prompt&quot;</span>]
</code></pre>
    </div>
    <script src="static/toggle.js"></script>
</body>
</html>
