<!-- Generated by DocGen-LM -->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>test_explaincode</title>
    <link rel="stylesheet" href="static/style.css">
</head>
<body>
    <button id="sidebar-toggle">Menu</button>
    <div class="sidebar">
        <h2>Navigation</h2>
        <ul><li><a href="index.html"><strong>üè† Project Overview</strong></a></li><li><a href="cache.html">cache</a></li><li><a href="chunk_utils.html">chunk_utils</a></li><li><a href="docgenerator.html">docgenerator</a></li><li><a href="explaincode.html">explaincode</a></li><li><a href="gui_wrapper.html">gui_wrapper</a></li><li><a href="html_writer.html">html_writer</a></li><li><a href="llm_client.html">llm_client</a></li><li><a href="manual_utils.html">manual_utils</a></li><li><a href="parser_cpp.html">parser_cpp</a></li><li><a href="parser_java.html">parser_java</a></li><li><a href="parser_matlab.html">parser_matlab</a></li><li><a href="parser_python.html">parser_python</a></li><li><a href="retrofit_sidebar.html">retrofit_sidebar</a></li><li><a href="reviewer.html">reviewer</a></li><li><a href="sanitize_docs.html">sanitize_docs</a></li><li><a href="scanner.html">scanner</a></li><li><a href="setup.html">setup</a></li><li><a href="summarize_utils.html">summarize_utils</a></li><li><details><summary>tests</summary><ul><li><a href="test_cache.html">test_cache</a></li><li><a href="test_chunk_utils.html">test_chunk_utils</a></li><li><a href="test_docgenerator.html">test_docgenerator</a></li><li><a href="test_docgenerator_subclasses.html">test_docgenerator_subclasses</a></li><li><a href="test_explaincode.html">test_explaincode</a></li><li><a href="test_html_writer.html">test_html_writer</a></li><li><a href="test_integration.html">test_integration</a></li><li><a href="test_llm_client.html">test_llm_client</a></li><li><a href="test_manual_utils.html">test_manual_utils</a></li><li><a href="test_parser_cpp.html">test_parser_cpp</a></li><li><a href="test_parser_java.html">test_parser_java</a></li><li><a href="test_parser_matlab.html">test_parser_matlab</a></li><li><a href="test_parser_python.html">test_parser_python</a></li><li><a href="test_resume_progress.html">test_resume_progress</a></li><li><a href="test_retrofit_sidebar.html">test_retrofit_sidebar</a></li><li><a href="test_reviewer.html">test_reviewer</a></li><li><a href="test_sanitize_docs.html">test_sanitize_docs</a></li><li><a href="test_scanner.html">test_scanner</a></li></ul></details></li></ul>
    </div>
    <div class="content">
        <h1>test_explaincode</h1>
        <p>This module defines a comprehensive test suite for a documentation generation tool, covering functionality across multiple document formats including markdown, HTML, DOCX, and Python files. The tests validate text extraction while preserving formatting, heading preservation in DOCX documents, HTML rendering with table of contents and sources, manual summary creation with LLM integration, PDF output generation, and graceful handling of missing dependencies. Key test areas include document collection with filtering, evidence mapping with priority and limits, placeholder detection, manual parsing with inferred sections, reference validation, section inference logic, snippet extraction with size limits, and code scanning that skips non-source directories. The test suite employs mocked LLM clients, temporary file structures, and various file formats while utilizing fixtures for creating test data and mocking external dependencies. Additional tests focus on code documentation generation functionality including snippet categorization, file ranking with language-specific patterns, LLM placeholder filling with logging, code scanning behavior with different flags, manual generation with fallback mechanisms, and output file handling such as index insertion. The suite also verifies automatic chunking and summarization logic in manual documentation generation, confirming multiple LLM calls during chunking, proper system prompts for chunk and merge operations, logging of chunking steps, application of post-processing hooks, parallel execution of chunk summaries, hierarchical merging with</p>
<h2>Functions</h2>
<h3 id="_create_fixture">_create_fixture(tmp_path: Path) -&gt; None</h3>
<p>Creates a test fixture directory structure with nested subdirectories and sample files. The function generates a nested directory path, creates an HTML file containing a basic HTML document with a heading, writes a README.md file with structured documentation content including sections for overview, purpose, usage, inputs, outputs, requirements, and examples, and creates a sample JSON file with basic data. All files are written using UTF-8 encoding within the specified temporary path structure.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">_create_fixture</span>(tmp_path: Path) <span style="color: #666666">-&gt;</span> <span style="color: #008000; font-weight: bold">None</span>:
    nested <span style="color: #666666">=</span> tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;subdir&quot;</span> <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;nested&quot;</span>
    nested<span style="color: #666666">.</span>mkdir(parents<span style="color: #666666">=</span><span style="color: #008000; font-weight: bold">True</span>)
    (nested <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;page.html&quot;</span>)<span style="color: #666666">.</span>write_text(
        <span style="color: #BA2121">&quot;&lt;html&gt;&lt;body&gt;&lt;h1&gt;Overview&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;&quot;</span>, encoding<span style="color: #666666">=</span><span style="color: #BA2121">&quot;utf-8&quot;</span>
    )
    content <span style="color: #666666">=</span> textwrap<span style="color: #666666">.</span>dedent(
<span style="color: #bbbbbb">        </span><span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;</span>
<span style="color: #BA2121; font-style: italic">        # Overview</span>
<span style="color: #BA2121; font-style: italic">        Demo project</span>

<span style="color: #BA2121; font-style: italic">        # Purpose &amp; Problem Solving</span>
<span style="color: #BA2121; font-style: italic">        Solves a problem</span>

<span style="color: #BA2121; font-style: italic">        # How to Run</span>
<span style="color: #BA2121; font-style: italic">        Usage: run it</span>

<span style="color: #BA2121; font-style: italic">        # Inputs</span>
<span style="color: #BA2121; font-style: italic">        Input data</span>

<span style="color: #BA2121; font-style: italic">        # Outputs</span>
<span style="color: #BA2121; font-style: italic">        Output data</span>

<span style="color: #BA2121; font-style: italic">        # System Requirements</span>
<span style="color: #BA2121; font-style: italic">        None</span>

<span style="color: #BA2121; font-style: italic">        # Examples</span>
<span style="color: #BA2121; font-style: italic">        Example usage</span>
<span style="color: #BA2121; font-style: italic">        &quot;&quot;&quot;</span>
    )<span style="color: #666666">.</span>strip()
    (tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;README.md&quot;</span>)<span style="color: #666666">.</span>write_text(content, encoding<span style="color: #666666">=</span><span style="color: #BA2121">&quot;utf-8&quot;</span>)
    (tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;sample.json&quot;</span>)<span style="color: #666666">.</span>write_text(<span style="color: #BA2121">&quot;{</span><span style="color: #AA5D1F; font-weight: bold">\&quot;</span><span style="color: #BA2121">input</span><span style="color: #AA5D1F; font-weight: bold">\&quot;</span><span style="color: #BA2121">: </span><span style="color: #AA5D1F; font-weight: bold">\&quot;</span><span style="color: #BA2121">data</span><span style="color: #AA5D1F; font-weight: bold">\&quot;</span><span style="color: #BA2121">}&quot;</span>, encoding<span style="color: #666666">=</span><span style="color: #BA2121">&quot;utf-8&quot;</span>)
</code></pre>
<h3 id="_mock_llm_client">_mock_llm_client() -&gt; object</h3>
<p>The function `_mock_llm_client` returns a dummy object that simulates an LLM client for testing purposes. The returned object implements a `summarize` method which takes a text string, a prompt type, and an optional system prompt, and returns a fixed, formatted summary string. This stub implementation is used to avoid actual LLM calls during testing or development.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">_mock_llm_client</span>() <span style="color: #666666">-&gt;</span> <span style="color: #008000">object</span>:
    <span style="color: #008000; font-weight: bold">class</span> <span style="color: #0000FF; font-weight: bold">Dummy</span>:
        <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">summarize</span>(<span style="color: #008000">self</span>, text: <span style="color: #008000">str</span>, prompt_type: <span style="color: #008000">str</span>, system_prompt: <span style="color: #008000">str</span> <span style="color: #666666">=</span> <span style="color: #BA2121">&quot;&quot;</span>) <span style="color: #666666">-&gt;</span> <span style="color: #008000">str</span>:  <span style="color: #3D7B7B; font-style: italic"># pragma: no cover - simple stub</span>
            <span style="color: #008000; font-weight: bold">return</span> textwrap<span style="color: #666666">.</span>dedent(
<span style="color: #bbbbbb">                </span><span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;</span>
<span style="color: #BA2121; font-style: italic">                Overview: Demo project</span>
<span style="color: #BA2121; font-style: italic">                Purpose &amp; Problem Solving: Solves a problem</span>
<span style="color: #BA2121; font-style: italic">                How to Run: Execute it</span>
<span style="color: #BA2121; font-style: italic">                Inputs: Input data</span>
<span style="color: #BA2121; font-style: italic">                Outputs: Output data</span>
<span style="color: #BA2121; font-style: italic">                System Requirements: None</span>
<span style="color: #BA2121; font-style: italic">                Examples: Example usage</span>
<span style="color: #BA2121; font-style: italic">                &quot;&quot;&quot;</span>
            )<span style="color: #666666">.</span>strip()

    <span style="color: #008000; font-weight: bold">return</span> Dummy()
</code></pre>
<h3 id="test_extract_text_markdown_preserves_headings_and_code">test_extract_text_markdown_preserves_headings_and_code(tmp_path: Path) -&gt; None</h3>
<p>This function tests that the `extract_text` function correctly preserves Markdown headings and code blocks when extracting text from a Markdown file. It creates a temporary Markdown file with a heading, some text, and a Python code block, then verifies that the extracted text contains the original heading and code block.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">test_extract_text_markdown_preserves_headings_and_code</span>(tmp_path: Path) <span style="color: #666666">-&gt;</span> <span style="color: #008000; font-weight: bold">None</span>:
    content <span style="color: #666666">=</span> <span style="color: #BA2121">&quot;&quot;&quot;</span>
<span style="color: #BA2121"># Title</span>

<span style="color: #BA2121">Text</span>

<span style="color: #BA2121">```python</span>
<span style="color: #BA2121">print(&#39;hi&#39;)</span>
<span style="color: #BA2121">```</span>
<span style="color: #BA2121">&quot;&quot;&quot;</span>
    md <span style="color: #666666">=</span> tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;readme.md&quot;</span>
    md<span style="color: #666666">.</span>write_text(content, encoding<span style="color: #666666">=</span><span style="color: #BA2121">&quot;utf-8&quot;</span>)
    text <span style="color: #666666">=</span> explaincode<span style="color: #666666">.</span>extract_text(md)
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #BA2121">&quot;# Title&quot;</span> <span style="color: #AA22FF; font-weight: bold">in</span> text
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #BA2121">&quot;```python&quot;</span> <span style="color: #AA22FF; font-weight: bold">in</span> text
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #BA2121">&quot;print(&#39;hi&#39;)&quot;</span> <span style="color: #AA22FF; font-weight: bold">in</span> text
</code></pre>
<h3 id="test_extract_text_html_preserves_headings_and_code">test_extract_text_html_preserves_headings_and_code(tmp_path: Path) -&gt; None</h3>
<p>This function tests the `extract_text` function from the `explaincode` module. It creates a temporary HTML file containing headings and code elements, then verifies that the extracted text preserves the heading structure (using Markdown-style headers) and formats code blocks with backticks. The test checks that the extracted text contains the expected heading markers and code block indicators.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">test_extract_text_html_preserves_headings_and_code</span>(tmp_path: Path) <span style="color: #666666">-&gt;</span> <span style="color: #008000; font-weight: bold">None</span>:
    html <span style="color: #666666">=</span> (
        <span style="color: #BA2121">&quot;&lt;html&gt;&lt;body&gt;&lt;h1&gt;Main&lt;/h1&gt;&lt;p&gt;Intro&lt;/p&gt;&quot;</span>
        <span style="color: #BA2121">&quot;&lt;h2&gt;Section&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;print(&#39;hi&#39;)&lt;/code&gt;&lt;/pre&gt;&lt;/body&gt;&lt;/html&gt;&quot;</span>
    )
    page <span style="color: #666666">=</span> tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;page.html&quot;</span>
    page<span style="color: #666666">.</span>write_text(html, encoding<span style="color: #666666">=</span><span style="color: #BA2121">&quot;utf-8&quot;</span>)
    text <span style="color: #666666">=</span> explaincode<span style="color: #666666">.</span>extract_text(page)
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #BA2121">&quot;# Main&quot;</span> <span style="color: #AA22FF; font-weight: bold">in</span> text
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #BA2121">&quot;## Section&quot;</span> <span style="color: #AA22FF; font-weight: bold">in</span> text
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #BA2121">&quot;```&quot;</span> <span style="color: #AA22FF; font-weight: bold">in</span> text <span style="color: #AA22FF; font-weight: bold">and</span> <span style="color: #BA2121">&quot;print(&#39;hi&#39;)&quot;</span> <span style="color: #AA22FF; font-weight: bold">in</span> text
</code></pre>
<h3 id="test_extract_text_docx_preserves_headings">test_extract_text_docx_preserves_headings(tmp_path: Path) -&gt; None</h3>
<p>This function tests that the `extract_text` function correctly preserves headings when extracting text from a `.docx` file. It creates a Word document with a level 1 heading and a paragraph of text, saves it to a temporary path, extracts the text using `explaincode.extract_text`, and verifies that the extracted text starts with &quot;# Title&quot; (indicating the heading was properly converted) and that the paragraph text is present in the output. The test skips execution if the `python-docx` dependency is not installed.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">test_extract_text_docx_preserves_headings</span>(tmp_path: Path) <span style="color: #666666">-&gt;</span> <span style="color: #008000; font-weight: bold">None</span>:
    <span style="color: #008000; font-weight: bold">try</span>:
        <span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">docx</span> <span style="color: #008000; font-weight: bold">import</span> Document
    <span style="color: #008000; font-weight: bold">except</span> <span style="color: #CB3F38; font-weight: bold">Exception</span>:  <span style="color: #3D7B7B; font-style: italic"># pragma: no cover - dependency missing</span>
        pytest<span style="color: #666666">.</span>skip(<span style="color: #BA2121">&quot;python-docx not installed&quot;</span>)

    doc <span style="color: #666666">=</span> Document()
    doc<span style="color: #666666">.</span>add_heading(<span style="color: #BA2121">&quot;Title&quot;</span>, level<span style="color: #666666">=1</span>)
    doc<span style="color: #666666">.</span>add_paragraph(<span style="color: #BA2121">&quot;Text&quot;</span>)
    path <span style="color: #666666">=</span> tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;doc.docx&quot;</span>
    doc<span style="color: #666666">.</span>save(path)
    text <span style="color: #666666">=</span> explaincode<span style="color: #666666">.</span>extract_text(path)
    <span style="color: #008000; font-weight: bold">assert</span> text<span style="color: #666666">.</span>splitlines()[<span style="color: #666666">0</span>] <span style="color: #666666">==</span> <span style="color: #BA2121">&quot;# Title&quot;</span>
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #BA2121">&quot;Text&quot;</span> <span style="color: #AA22FF; font-weight: bold">in</span> text
</code></pre>
<h3 id="test_render_html_renders_markdown_headings_and_code">test_render_html_renders_markdown_headings_and_code() -&gt; None</h3>
<p>This function tests the rendering of HTML output containing Markdown headings and code blocks. It creates a dictionary with a section titled &quot;Intro&quot; that includes a Markdown title and a Python code block. The `explaincode.render_html` function processes this input into HTML format. A BeautifulSoup parser then examines the resulting HTML to verify that an `&lt;h1&gt;` element with the text &quot;Title&quot; is present and that a code block containing `print(&#x27;hi&#x27;)` is correctly rendered within `&lt;pre&gt;` and `&lt;code&gt;` tags. The test ensures proper conversion of Markdown elements to HTML structure.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">test_render_html_renders_markdown_headings_and_code</span>() <span style="color: #666666">-&gt;</span> <span style="color: #008000; font-weight: bold">None</span>:
    sections <span style="color: #666666">=</span> {
        <span style="color: #BA2121">&quot;Intro&quot;</span>: <span style="color: #BA2121">&quot;# Title</span><span style="color: #AA5D1F; font-weight: bold">\n\n</span><span style="color: #BA2121">```python</span><span style="color: #AA5D1F; font-weight: bold">\n</span><span style="color: #BA2121">print(&#39;hi&#39;)</span><span style="color: #AA5D1F; font-weight: bold">\n</span><span style="color: #BA2121">```&quot;</span>,
    }
    html <span style="color: #666666">=</span> explaincode<span style="color: #666666">.</span>render_html(sections, <span style="color: #BA2121">&quot;Manual&quot;</span>)
    soup <span style="color: #666666">=</span> BeautifulSoup(html, <span style="color: #BA2121">&quot;html.parser&quot;</span>)
    <span style="color: #008000; font-weight: bold">assert</span> soup<span style="color: #666666">.</span>find(<span style="color: #BA2121">&quot;h1&quot;</span>, string<span style="color: #666666">=</span><span style="color: #BA2121">&quot;Title&quot;</span>) <span style="color: #AA22FF; font-weight: bold">is</span> <span style="color: #AA22FF; font-weight: bold">not</span> <span style="color: #008000; font-weight: bold">None</span>
    code <span style="color: #666666">=</span> soup<span style="color: #666666">.</span>find(<span style="color: #BA2121">&quot;pre&quot;</span>)<span style="color: #666666">.</span>find(<span style="color: #BA2121">&quot;code&quot;</span>)
    <span style="color: #008000; font-weight: bold">assert</span> code <span style="color: #AA22FF; font-weight: bold">is</span> <span style="color: #AA22FF; font-weight: bold">not</span> <span style="color: #008000; font-weight: bold">None</span> <span style="color: #AA22FF; font-weight: bold">and</span> <span style="color: #BA2121">&quot;print(&#39;hi&#39;)&quot;</span> <span style="color: #AA22FF; font-weight: bold">in</span> code<span style="color: #666666">.</span>text
</code></pre>
<h3 id="test_render_html_includes_toc_and_sources_block">test_render_html_includes_toc_and_sources_block() -&gt; None</h3>
<p>The function `test_render_html_includes_toc_and_sources_block` tests the `render_html` function from the `explaincode` module. It verifies that the generated HTML includes a table of contents (TOC) with links to section headers and source code blocks referencing files mentioned in the evidence. The test creates mock data for sections and evidence, calls `render_html`, parses the resulting HTML using BeautifulSoup, checks for the presence of navigation links and sources blocks, and asserts that specific file names are included in the sources text.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">test_render_html_includes_toc_and_sources_block</span>() <span style="color: #666666">-&gt;</span> <span style="color: #008000; font-weight: bold">None</span>:
    sections <span style="color: #666666">=</span> {<span style="color: #BA2121">&quot;Overview&quot;</span>: <span style="color: #BA2121">&quot;&quot;</span>, <span style="color: #BA2121">&quot;How to Run&quot;</span>: <span style="color: #BA2121">&quot;&quot;</span>}
    evidence <span style="color: #666666">=</span> {
        <span style="color: #BA2121">&quot;Overview&quot;</span>: {<span style="color: #BA2121">&quot;evidence&quot;</span>: [{<span style="color: #BA2121">&quot;snippet&quot;</span>: <span style="color: #BA2121">&quot;info&quot;</span>, <span style="color: #BA2121">&quot;file&quot;</span>: <span style="color: #BA2121">&quot;readme.md&quot;</span>}]},
        <span style="color: #BA2121">&quot;How to Run&quot;</span>: {<span style="color: #BA2121">&quot;evidence&quot;</span>: [{<span style="color: #BA2121">&quot;snippet&quot;</span>: <span style="color: #BA2121">&quot;run&quot;</span>, <span style="color: #BA2121">&quot;file&quot;</span>: <span style="color: #BA2121">&quot;run.py&quot;</span>}]},
    }
    html <span style="color: #666666">=</span> explaincode<span style="color: #666666">.</span>render_html(sections, <span style="color: #BA2121">&quot;Manual&quot;</span>, evidence)
    soup <span style="color: #666666">=</span> BeautifulSoup(html, <span style="color: #BA2121">&quot;html.parser&quot;</span>)
    nav <span style="color: #666666">=</span> soup<span style="color: #666666">.</span>find(<span style="color: #BA2121">&quot;nav&quot;</span>)
    <span style="color: #008000; font-weight: bold">assert</span> nav <span style="color: #AA22FF; font-weight: bold">is</span> <span style="color: #AA22FF; font-weight: bold">not</span> <span style="color: #008000; font-weight: bold">None</span> <span style="color: #AA22FF; font-weight: bold">and</span> nav<span style="color: #666666">.</span>find(<span style="color: #BA2121">&quot;a&quot;</span>, href<span style="color: #666666">=</span><span style="color: #BA2121">&quot;#overview&quot;</span>) <span style="color: #AA22FF; font-weight: bold">is</span> <span style="color: #AA22FF; font-weight: bold">not</span> <span style="color: #008000; font-weight: bold">None</span>
    sources_blocks <span style="color: #666666">=</span> soup<span style="color: #666666">.</span>find_all(<span style="color: #BA2121">&quot;div&quot;</span>, class_<span style="color: #666666">=</span><span style="color: #BA2121">&quot;sources&quot;</span>)
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #008000">any</span>(<span style="color: #BA2121">&quot;readme.md&quot;</span> <span style="color: #AA22FF; font-weight: bold">in</span> block<span style="color: #666666">.</span>text <span style="color: #008000; font-weight: bold">for</span> block <span style="color: #AA22FF; font-weight: bold">in</span> sources_blocks)
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #008000">any</span>(<span style="color: #BA2121">&quot;run.py&quot;</span> <span style="color: #AA22FF; font-weight: bold">in</span> block<span style="color: #666666">.</span>text <span style="color: #008000; font-weight: bold">for</span> block <span style="color: #AA22FF; font-weight: bold">in</span> sources_blocks)
</code></pre>
<h3 id="test_html_summary_creation">test_html_summary_creation(tmp_path: Path, monkeypatch: pytest.MonkeyPatch) -&gt; None</h3>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">test_html_summary_creation</span>(tmp_path: Path, monkeypatch: pytest<span style="color: #666666">.</span>MonkeyPatch) <span style="color: #666666">-&gt;</span> <span style="color: #008000; font-weight: bold">None</span>:
    _create_fixture(tmp_path)
    monkeypatch<span style="color: #666666">.</span>setattr(explaincode, <span style="color: #BA2121">&quot;LLMClient&quot;</span>, _mock_llm_client)
    main([<span style="color: #BA2121">&quot;--path&quot;</span>, <span style="color: #008000">str</span>(tmp_path)])
    manual <span style="color: #666666">=</span> tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;user_manual.html&quot;</span>
    evidence <span style="color: #666666">=</span> tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;user_manual_evidence.json&quot;</span>
    <span style="color: #008000; font-weight: bold">assert</span> manual<span style="color: #666666">.</span>exists()
    <span style="color: #008000; font-weight: bold">assert</span> evidence<span style="color: #666666">.</span>exists()
    data <span style="color: #666666">=</span> json<span style="color: #666666">.</span>loads(evidence<span style="color: #666666">.</span>read_text(encoding<span style="color: #666666">=</span><span style="color: #BA2121">&quot;utf-8&quot;</span>))
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #BA2121">&quot;Overview&quot;</span> <span style="color: #AA22FF; font-weight: bold">in</span> data
    <span style="color: #008000; font-weight: bold">assert</span> data[<span style="color: #BA2121">&quot;Overview&quot;</span>][<span style="color: #BA2121">&quot;evidence&quot;</span>]
    html_text <span style="color: #666666">=</span> manual<span style="color: #666666">.</span>read_text(encoding<span style="color: #666666">=</span><span style="color: #BA2121">&quot;utf-8&quot;</span>)
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #BA2121">&quot;No information provided.&quot;</span> <span style="color: #AA22FF; font-weight: bold">not</span> <span style="color: #AA22FF; font-weight: bold">in</span> html_text
    soup <span style="color: #666666">=</span> BeautifulSoup(html_text, <span style="color: #BA2121">&quot;html.parser&quot;</span>)
    nav <span style="color: #666666">=</span> soup<span style="color: #666666">.</span>find(<span style="color: #BA2121">&quot;nav&quot;</span>)
    <span style="color: #008000; font-weight: bold">assert</span> nav <span style="color: #AA22FF; font-weight: bold">is</span> <span style="color: #AA22FF; font-weight: bold">not</span> <span style="color: #008000; font-weight: bold">None</span> <span style="color: #AA22FF; font-weight: bold">and</span> nav<span style="color: #666666">.</span>find(<span style="color: #BA2121">&quot;a&quot;</span>, href<span style="color: #666666">=</span><span style="color: #BA2121">&quot;#overview&quot;</span>) <span style="color: #AA22FF; font-weight: bold">is</span> <span style="color: #AA22FF; font-weight: bold">not</span> <span style="color: #008000; font-weight: bold">None</span>
</code></pre>
<h3 id="test_pdf_summary_creation">test_pdf_summary_creation(tmp_path: Path, monkeypatch: pytest.MonkeyPatch) -&gt; None</h3>
<p>This function tests the creation of a PDF summary by verifying that the `reportlab` library is available, setting up a temporary directory with fixture data, mocking an LLM client, and executing the main documentation generation process with the PDF output format. It asserts that both the generated PDF file and an associated evidence JSON file are created in the specified output directory.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">test_pdf_summary_creation</span>(tmp_path: Path, monkeypatch: pytest<span style="color: #666666">.</span>MonkeyPatch) <span style="color: #666666">-&gt;</span> <span style="color: #008000; font-weight: bold">None</span>:
    <span style="color: #008000; font-weight: bold">if</span> importlib<span style="color: #666666">.</span>util<span style="color: #666666">.</span>find_spec(<span style="color: #BA2121">&quot;reportlab&quot;</span>) <span style="color: #AA22FF; font-weight: bold">is</span> <span style="color: #008000; font-weight: bold">None</span>:
        pytest<span style="color: #666666">.</span>skip(<span style="color: #BA2121">&quot;reportlab not installed&quot;</span>)
    _create_fixture(tmp_path)
    monkeypatch<span style="color: #666666">.</span>setattr(explaincode, <span style="color: #BA2121">&quot;LLMClient&quot;</span>, _mock_llm_client)
    main([<span style="color: #BA2121">&quot;--path&quot;</span>, <span style="color: #008000">str</span>(tmp_path), <span style="color: #BA2121">&quot;--output-format&quot;</span>, <span style="color: #BA2121">&quot;pdf&quot;</span>])
    <span style="color: #008000; font-weight: bold">assert</span> (tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;user_manual.pdf&quot;</span>)<span style="color: #666666">.</span>exists()
    <span style="color: #008000; font-weight: bold">assert</span> (tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;user_manual_evidence.json&quot;</span>)<span style="color: #666666">.</span>exists()
</code></pre>
<h3 id="test_graceful_missing_docx">test_graceful_missing_docx(monkeypatch: pytest.MonkeyPatch, tmp_path: Path) -&gt; None</h3>
<p>This function tests the graceful handling of a missing `docx` dependency during documentation generation. It creates a temporary fixture directory, attempts to create and save a `.docx` file if the `python-docx` library is available, then patches the `explaincode` module to simulate the absence of the `Document` class and replaces `LLMClient` with a mock implementation. After invoking the main documentation generation process with the temporary path, it verifies that the expected HTML manual and evidence JSON files are created in the directory.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">test_graceful_missing_docx</span>(monkeypatch: pytest<span style="color: #666666">.</span>MonkeyPatch, tmp_path: Path) <span style="color: #666666">-&gt;</span> <span style="color: #008000; font-weight: bold">None</span>:
    _create_fixture(tmp_path)
    <span style="color: #008000; font-weight: bold">try</span>:
        <span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">docx</span> <span style="color: #008000; font-weight: bold">import</span> Document
    <span style="color: #008000; font-weight: bold">except</span> <span style="color: #CB3F38; font-weight: bold">Exception</span>:  <span style="color: #3D7B7B; font-style: italic"># pragma: no cover - dependency missing</span>
        Document <span style="color: #666666">=</span> <span style="color: #008000; font-weight: bold">None</span>  <span style="color: #3D7B7B; font-style: italic"># type: ignore</span>
    <span style="color: #008000; font-weight: bold">if</span> Document:
        doc <span style="color: #666666">=</span> Document()
        doc<span style="color: #666666">.</span>add_paragraph(<span style="color: #BA2121">&quot;hi&quot;</span>)
        doc<span style="color: #666666">.</span>save(tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;guide.docx&quot;</span>)
    monkeypatch<span style="color: #666666">.</span>setattr(explaincode, <span style="color: #BA2121">&quot;Document&quot;</span>, <span style="color: #008000; font-weight: bold">None</span>)
    monkeypatch<span style="color: #666666">.</span>setattr(explaincode, <span style="color: #BA2121">&quot;LLMClient&quot;</span>, _mock_llm_client)
    main([<span style="color: #BA2121">&quot;--path&quot;</span>, <span style="color: #008000">str</span>(tmp_path)])
    <span style="color: #008000; font-weight: bold">assert</span> (tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;user_manual.html&quot;</span>)<span style="color: #666666">.</span>exists()
    <span style="color: #008000; font-weight: bold">assert</span> (tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;user_manual_evidence.json&quot;</span>)<span style="color: #666666">.</span>exists()
</code></pre>
<h3 id="test_custom_output_directory">test_custom_output_directory(tmp_path: Path, monkeypatch: pytest.MonkeyPatch) -&gt; None</h3>
<p>This function tests the functionality of generating documentation to a custom output directory. It creates a temporary test fixture, configures the LLM client to use a mock implementation, and invokes the main documentation generation process with specified input and output paths. The test verifies that the expected output files (`user_manual.html` and `user_manual_evidence.json`) are created in the designated output directory.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">test_custom_output_directory</span>(tmp_path: Path, monkeypatch: pytest<span style="color: #666666">.</span>MonkeyPatch) <span style="color: #666666">-&gt;</span> <span style="color: #008000; font-weight: bold">None</span>:
    _create_fixture(tmp_path)
    out_dir <span style="color: #666666">=</span> tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;dist&quot;</span>
    monkeypatch<span style="color: #666666">.</span>setattr(explaincode, <span style="color: #BA2121">&quot;LLMClient&quot;</span>, _mock_llm_client)
    main([<span style="color: #BA2121">&quot;--path&quot;</span>, <span style="color: #008000">str</span>(tmp_path), <span style="color: #BA2121">&quot;--output&quot;</span>, <span style="color: #008000">str</span>(out_dir)])
    <span style="color: #008000; font-weight: bold">assert</span> (out_dir <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;user_manual.html&quot;</span>)<span style="color: #666666">.</span>exists()
    <span style="color: #008000; font-weight: bold">assert</span> (out_dir <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;user_manual_evidence.json&quot;</span>)<span style="color: #666666">.</span>exists()
</code></pre>
<h3 id="test_collect_docs_filters">test_collect_docs_filters(tmp_path: Path) -&gt; None</h3>
<p>The function `test_collect_docs_filters` tests the `explaincode.collect_docs` functionality by creating a temporary directory structure with multiple files, including markdown and text files. It verifies that only files with the `.md` extension are collected while excluding those with other extensions, such as `.txt`. The test confirms that the collection process correctly filters files based on their extensions.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">test_collect_docs_filters</span>(tmp_path: Path) <span style="color: #666666">-&gt;</span> <span style="color: #008000; font-weight: bold">None</span>:
    (tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;docs&quot;</span>)<span style="color: #666666">.</span>mkdir()
    (tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;docs&quot;</span> <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;keep.md&quot;</span>)<span style="color: #666666">.</span>write_text(<span style="color: #BA2121">&quot;hi&quot;</span>, encoding<span style="color: #666666">=</span><span style="color: #BA2121">&quot;utf-8&quot;</span>)
    (tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;docs&quot;</span> <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;skip.txt&quot;</span>)<span style="color: #666666">.</span>write_text(<span style="color: #BA2121">&quot;no&quot;</span>, encoding<span style="color: #666666">=</span><span style="color: #BA2121">&quot;utf-8&quot;</span>)
    (tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;README.md&quot;</span>)<span style="color: #666666">.</span>write_text(<span style="color: #BA2121">&quot;readme&quot;</span>, encoding<span style="color: #666666">=</span><span style="color: #BA2121">&quot;utf-8&quot;</span>)
    (tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;extra.md&quot;</span>)<span style="color: #666666">.</span>write_text(<span style="color: #BA2121">&quot;extra&quot;</span>, encoding<span style="color: #666666">=</span><span style="color: #BA2121">&quot;utf-8&quot;</span>)
    files <span style="color: #666666">=</span> explaincode<span style="color: #666666">.</span>collect_docs(tmp_path)
    names <span style="color: #666666">=</span> {f<span style="color: #666666">.</span>name <span style="color: #008000; font-weight: bold">for</span> f <span style="color: #AA22FF; font-weight: bold">in</span> files}
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #BA2121">&quot;keep.md&quot;</span> <span style="color: #AA22FF; font-weight: bold">in</span> names <span style="color: #AA22FF; font-weight: bold">and</span> <span style="color: #BA2121">&quot;skip.txt&quot;</span> <span style="color: #AA22FF; font-weight: bold">not</span> <span style="color: #AA22FF; font-weight: bold">in</span> names
</code></pre>
<h3 id="test_map_evidence_overview_priority_and_filters">test_map_evidence_overview_priority_and_filters() -&gt; None</h3>
<p>The function `test_map_evidence_overview_priority_and_filters` tests the behavior of `explaincode.map_evidence_to_sections` by evaluating how it processes a dictionary of markdown files and organizes their content under the &quot;Overview&quot; section. It verifies that certain files, such as those in test, example, and fixture directories, are excluded from the results, while files in README, docs, and src directories are included. The test ensures proper prioritization and filtering of documentation sources based on directory paths.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">test_map_evidence_overview_priority_and_filters</span>() <span style="color: #666666">-&gt;</span> <span style="color: #008000; font-weight: bold">None</span>:
    docs <span style="color: #666666">=</span> {
        Path(<span style="color: #BA2121">&quot;README.md&quot;</span>): <span style="color: #BA2121">&quot;# Overview</span><span style="color: #AA5D1F; font-weight: bold">\n</span><span style="color: #BA2121">readme info&quot;</span>,
        Path(<span style="color: #BA2121">&quot;docs/guide.md&quot;</span>): <span style="color: #BA2121">&quot;# Overview</span><span style="color: #AA5D1F; font-weight: bold">\n</span><span style="color: #BA2121">docs info&quot;</span>,
        Path(<span style="color: #BA2121">&quot;src/other.md&quot;</span>): <span style="color: #BA2121">&quot;# Overview</span><span style="color: #AA5D1F; font-weight: bold">\n</span><span style="color: #BA2121">other info&quot;</span>,
        Path(<span style="color: #BA2121">&quot;tests/ignore.md&quot;</span>): <span style="color: #BA2121">&quot;# Overview</span><span style="color: #AA5D1F; font-weight: bold">\n</span><span style="color: #BA2121">test info&quot;</span>,
        Path(<span style="color: #BA2121">&quot;examples/ignore.md&quot;</span>): <span style="color: #BA2121">&quot;# Overview</span><span style="color: #AA5D1F; font-weight: bold">\n</span><span style="color: #BA2121">example info&quot;</span>,
        Path(<span style="color: #BA2121">&quot;fixtures/ignore.md&quot;</span>): <span style="color: #BA2121">&quot;# Overview</span><span style="color: #AA5D1F; font-weight: bold">\n</span><span style="color: #BA2121">fixture info&quot;</span>,
    }
    section_map, _ <span style="color: #666666">=</span> explaincode<span style="color: #666666">.</span>map_evidence_to_sections(docs)
    sources <span style="color: #666666">=</span> [p<span style="color: #666666">.</span>as_posix() <span style="color: #008000; font-weight: bold">for</span> p, _ <span style="color: #AA22FF; font-weight: bold">in</span> section_map[<span style="color: #BA2121">&quot;Overview&quot;</span>]]
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #BA2121">&quot;tests/ignore.md&quot;</span> <span style="color: #AA22FF; font-weight: bold">not</span> <span style="color: #AA22FF; font-weight: bold">in</span> sources
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #BA2121">&quot;examples/ignore.md&quot;</span> <span style="color: #AA22FF; font-weight: bold">not</span> <span style="color: #AA22FF; font-weight: bold">in</span> sources
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #BA2121">&quot;fixtures/ignore.md&quot;</span> <span style="color: #AA22FF; font-weight: bold">not</span> <span style="color: #AA22FF; font-weight: bold">in</span> sources
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #008000">set</span>(sources[:<span style="color: #666666">2</span>]) <span style="color: #666666">==</span> {<span style="color: #BA2121">&quot;README.md&quot;</span>, <span style="color: #BA2121">&quot;docs/guide.md&quot;</span>}
    <span style="color: #008000; font-weight: bold">assert</span> sources[<span style="color: #666666">2</span>] <span style="color: #666666">==</span> <span style="color: #BA2121">&quot;src/other.md&quot;</span>
</code></pre>
<h3 id="test_map_evidence_snippet_limits">test_map_evidence_snippet_limits() -&gt; None</h3>
<p>The function `test_map_evidence_snippet_limits` tests the behavior of the `map_evidence_to_sections` function when processing documentation files with content that exceeds a maximum line limit. It creates two mock documentation files (`src/long.md` and `tests/short.md`) containing a specified number of lines, then processes them to verify that the resulting snippets respect the maximum line limit defined by `explaincode.MAX_SNIPPET_LINES`. The test ensures that lines beyond the limit are excluded from the output snippet for `src/long.md`, while the last allowed line is included, and that the `tests/short.md` file&#x27;s snippet contains only the header &quot;# Inputs&quot;.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">test_map_evidence_snippet_limits</span>() <span style="color: #666666">-&gt;</span> <span style="color: #008000; font-weight: bold">None</span>:
    long_content <span style="color: #666666">=</span> <span style="color: #BA2121">&quot;# Inputs</span><span style="color: #AA5D1F; font-weight: bold">\n</span><span style="color: #BA2121">&quot;</span> <span style="color: #666666">+</span> <span style="color: #BA2121">&quot;</span><span style="color: #AA5D1F; font-weight: bold">\n</span><span style="color: #BA2121">&quot;</span><span style="color: #666666">.</span>join(
        <span style="color: #BA2121">f&quot;line </span><span style="color: #A45A77; font-weight: bold">{</span>i<span style="color: #A45A77; font-weight: bold">}</span><span style="color: #BA2121">&quot;</span> <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(<span style="color: #666666">1</span>, explaincode<span style="color: #666666">.</span>MAX_SNIPPET_LINES <span style="color: #666666">+</span> <span style="color: #666666">10</span>)
    )
    docs <span style="color: #666666">=</span> {
        Path(<span style="color: #BA2121">&quot;src/long.md&quot;</span>): long_content,
        Path(<span style="color: #BA2121">&quot;tests/short.md&quot;</span>): long_content,
    }
    section_map, _ <span style="color: #666666">=</span> explaincode<span style="color: #666666">.</span>map_evidence_to_sections(docs)
    snippets <span style="color: #666666">=</span> {p<span style="color: #666666">.</span>as_posix(): snip <span style="color: #008000; font-weight: bold">for</span> p, snip <span style="color: #AA22FF; font-weight: bold">in</span> section_map[<span style="color: #BA2121">&quot;Inputs&quot;</span>]}
    <span style="color: #008000; font-weight: bold">assert</span> (
        <span style="color: #BA2121">f&quot;line </span><span style="color: #A45A77; font-weight: bold">{</span>explaincode<span style="color: #666666">.</span>MAX_SNIPPET_LINES<span style="color: #bbbbbb"> </span><span style="color: #666666">+</span><span style="color: #bbbbbb"> </span><span style="color: #666666">1</span><span style="color: #A45A77; font-weight: bold">}</span><span style="color: #BA2121">&quot;</span> <span style="color: #AA22FF; font-weight: bold">not</span> <span style="color: #AA22FF; font-weight: bold">in</span> snippets[<span style="color: #BA2121">&quot;src/long.md&quot;</span>]
    )
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #BA2121">f&quot;line </span><span style="color: #A45A77; font-weight: bold">{</span>explaincode<span style="color: #666666">.</span>MAX_SNIPPET_LINES<span style="color: #A45A77; font-weight: bold">}</span><span style="color: #BA2121">&quot;</span> <span style="color: #AA22FF; font-weight: bold">in</span> snippets[<span style="color: #BA2121">&quot;src/long.md&quot;</span>]
    <span style="color: #008000; font-weight: bold">assert</span> snippets[<span style="color: #BA2121">&quot;tests/short.md&quot;</span>] <span style="color: #666666">==</span> <span style="color: #BA2121">&quot;# Inputs&quot;</span>
</code></pre>
<h3 id="test_detect_placeholders">test_detect_placeholders() -&gt; None</h3>
<p>The function `test_detect_placeholders` tests the `detect_placeholders` function from the `explaincode` module. It verifies that the function correctly identifies placeholder strings in a given text, specifically detecting &quot;Overview&quot; and &quot;Outputs&quot; as missing sections from placeholders formatted as `[[NEEDS_&lt;SECTION&gt;]]`. The test ensures that the detected placeholders are returned as a set containing these two section names.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">test_detect_placeholders</span>() <span style="color: #666666">-&gt;</span> <span style="color: #008000; font-weight: bold">None</span>:
    text <span style="color: #666666">=</span> <span style="color: #BA2121">&quot;Overview: [[NEEDS_OVERVIEW]]</span><span style="color: #AA5D1F; font-weight: bold">\n</span><span style="color: #BA2121">Inputs: data</span><span style="color: #AA5D1F; font-weight: bold">\n</span><span style="color: #BA2121">Outputs: [[NEEDS_OUTPUTS]]&quot;</span>
    missing <span style="color: #666666">=</span> explaincode<span style="color: #666666">.</span>detect_placeholders(text)
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #008000">set</span>(missing) <span style="color: #666666">==</span> {<span style="color: #BA2121">&quot;Overview&quot;</span>, <span style="color: #BA2121">&quot;Outputs&quot;</span>}
</code></pre>
<h3 id="test_parse_manual_infers_missing_sections">test_parse_manual_infers_missing_sections() -&gt; None</h3>
<p>The function `test_parse_manual_infers_missing_sections` tests the behavior of the `explaincode.parse_manual` function when parsing a string with missing sections. It creates a stub client that returns a fixed summary, then calls `parse_manual` with the input &quot;Overview: hi&quot;. The test verifies that the parsed result correctly extracts &quot;hi&quot; as the value for the &quot;Overview&quot; section, infers a &quot;Inputs&quot; section ending with &quot;(inferred)&quot;, and ensures that &quot;No information provided.&quot; does not appear in the &quot;Inputs&quot; section.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">test_parse_manual_infers_missing_sections</span>() <span style="color: #666666">-&gt;</span> <span style="color: #008000; font-weight: bold">None</span>:
    <span style="color: #008000; font-weight: bold">class</span> <span style="color: #0000FF; font-weight: bold">Stub</span>:
        <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">summarize</span>(<span style="color: #008000">self</span>, prompt: <span style="color: #008000">str</span>, prompt_type: <span style="color: #008000">str</span>, system_prompt: <span style="color: #008000">str</span> <span style="color: #666666">=</span> <span style="color: #BA2121">&quot;&quot;</span>) <span style="color: #666666">-&gt;</span> <span style="color: #008000">str</span>:
            <span style="color: #008000; font-weight: bold">return</span> <span style="color: #BA2121">&quot;guessed&quot;</span>

    client <span style="color: #666666">=</span> Stub()
    parsed <span style="color: #666666">=</span> explaincode<span style="color: #666666">.</span>parse_manual(<span style="color: #BA2121">&quot;Overview: hi&quot;</span>, client<span style="color: #666666">=</span>client)
    <span style="color: #008000; font-weight: bold">assert</span> parsed[<span style="color: #BA2121">&quot;Overview&quot;</span>] <span style="color: #666666">==</span> <span style="color: #BA2121">&quot;hi&quot;</span>
    <span style="color: #008000; font-weight: bold">assert</span> parsed[<span style="color: #BA2121">&quot;Inputs&quot;</span>]<span style="color: #666666">.</span>endswith(<span style="color: #BA2121">&quot;(inferred)&quot;</span>)
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #BA2121">&quot;No information provided.&quot;</span> <span style="color: #AA22FF; font-weight: bold">not</span> <span style="color: #AA22FF; font-weight: bold">in</span> parsed[<span style="color: #BA2121">&quot;Inputs&quot;</span>]
</code></pre>
<h3 id="test_validate_manual_references_flags_missing">test_validate_manual_references_flags_missing(tmp_path: Path) -&gt; None</h3>
<p>The function `test_validate_manual_references_flags_missing` tests the behavior of `validate_manual_references` when processing documentation sections that reference Python files. It creates a temporary directory with a file named &quot;exists.py&quot; and defines a section containing references to both existing and missing files. The function calls `validate_manual_references` to update the section text and evidence dictionary based on the existence of referenced files. The test verifies that the existing file reference remains unchanged, the missing file reference is appended with &quot;[missing]&quot;, and the evidence dictionary correctly records the missing reference.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">test_validate_manual_references_flags_missing</span>(tmp_path: Path) <span style="color: #666666">-&gt;</span> <span style="color: #008000; font-weight: bold">None</span>:
    (tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;exists.py&quot;</span>)<span style="color: #666666">.</span>write_text(<span style="color: #BA2121">&quot;pass&quot;</span>, encoding<span style="color: #666666">=</span><span style="color: #BA2121">&quot;utf-8&quot;</span>)
    sections <span style="color: #666666">=</span> {<span style="color: #BA2121">&quot;Overview&quot;</span>: <span style="color: #BA2121">&quot;See exists.py and missing.py for details&quot;</span>}
    evidence: <span style="color: #008000">dict</span>[<span style="color: #008000">str</span>, <span style="color: #008000">dict</span>[<span style="color: #008000">str</span>, <span style="color: #008000">object</span>]] <span style="color: #666666">=</span> {}
    explaincode<span style="color: #666666">.</span>validate_manual_references(sections, tmp_path, evidence)
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #BA2121">&quot;exists.py&quot;</span> <span style="color: #AA22FF; font-weight: bold">in</span> sections[<span style="color: #BA2121">&quot;Overview&quot;</span>]
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #BA2121">&quot;missing.py [missing]&quot;</span> <span style="color: #AA22FF; font-weight: bold">in</span> sections[<span style="color: #BA2121">&quot;Overview&quot;</span>]
    <span style="color: #008000; font-weight: bold">assert</span> evidence[<span style="color: #BA2121">&quot;Overview&quot;</span>][<span style="color: #BA2121">&quot;missing_references&quot;</span>] <span style="color: #666666">==</span> [<span style="color: #BA2121">&quot;missing.py&quot;</span>]
</code></pre>
<h3 id="test_infer_sections_infers_entries">test_infer_sections_infers_entries() -&gt; None</h3>
<p>The function `test_infer_sections_infers_entries` tests the `infer_sections` function from the `explaincode` module. It verifies that when given a context string, the function returns a dictionary of sections where the &quot;Overview&quot; section contains the exact context string, and all required sections (defined in `explaincode.REQUIRED_SECTIONS`) have values ending with &quot;(inferred)&quot;, except for &quot;Overview&quot;. The test also ensures that the placeholder text &quot;No information provided.&quot; does not appear in any of the section values.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">test_infer_sections_infers_entries</span>() <span style="color: #666666">-&gt;</span> <span style="color: #008000; font-weight: bold">None</span>:
    sections <span style="color: #666666">=</span> explaincode<span style="color: #666666">.</span>infer_sections(<span style="color: #BA2121">&quot;Some context&quot;</span>)
    <span style="color: #008000; font-weight: bold">assert</span> sections[<span style="color: #BA2121">&quot;Overview&quot;</span>] <span style="color: #666666">==</span> <span style="color: #BA2121">&quot;Some context&quot;</span>
    <span style="color: #008000; font-weight: bold">for</span> key <span style="color: #AA22FF; font-weight: bold">in</span> explaincode<span style="color: #666666">.</span>REQUIRED_SECTIONS:
        <span style="color: #008000; font-weight: bold">if</span> key <span style="color: #666666">!=</span> <span style="color: #BA2121">&quot;Overview&quot;</span>:
            <span style="color: #008000; font-weight: bold">assert</span> sections[key]<span style="color: #666666">.</span>endswith(<span style="color: #BA2121">&quot;(inferred)&quot;</span>)
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #BA2121">&quot;No information provided.&quot;</span> <span style="color: #AA22FF; font-weight: bold">not</span> <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #BA2121">&quot;&quot;</span><span style="color: #666666">.</span>join(sections<span style="color: #666666">.</span>values())
</code></pre>
<h3 id="test_infer_sections_no_context_defaults">test_infer_sections_no_context_defaults() -&gt; None</h3>
<p>The function `test_infer_sections_no_context_defaults` tests the behavior of the `explaincode.infer_sections` function when called with an empty string. It verifies that all values in the returned dictionary from `infer_sections(&quot;&quot;)` are set to the default value &quot;No information provided.&quot; This assertion ensures that the function handles empty input by returning a consistent default message for all sections.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">test_infer_sections_no_context_defaults</span>() <span style="color: #666666">-&gt;</span> <span style="color: #008000; font-weight: bold">None</span>:
    sections <span style="color: #666666">=</span> explaincode<span style="color: #666666">.</span>infer_sections(<span style="color: #BA2121">&quot;&quot;</span>)
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #008000">all</span>(v <span style="color: #666666">==</span> <span style="color: #BA2121">&quot;No information provided.&quot;</span> <span style="color: #008000; font-weight: bold">for</span> v <span style="color: #AA22FF; font-weight: bold">in</span> sections<span style="color: #666666">.</span>values())
</code></pre>
<h3 id="test_extract_snippets_skips_large_file">test_extract_snippets_skips_large_file(tmp_path: Path, caplog: pytest.LogCaptureFixture) -&gt; None</h3>
<p>The function `test_extract_snippets_skips_large_file` tests the behavior of `explaincode.extract_snippets` when processing a file that exceeds a specified size limit. It creates a large Python file filled with 210,000 bytes of data, then calls `extract_snippets` with parameters that limit the maximum file size to 200,000 bytes. The test verifies that the large file is excluded from the returned snippets and that an appropriate log message indicating the file size exceeded the limit is generated. The test uses pytest&#x27;s `tmp_path` fixture to create a temporary directory and `caplog` to capture log output for validation.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">test_extract_snippets_skips_large_file</span>(
    tmp_path: Path, caplog: pytest<span style="color: #666666">.</span>LogCaptureFixture
) <span style="color: #666666">-&gt;</span> <span style="color: #008000; font-weight: bold">None</span>:
    big_file <span style="color: #666666">=</span> tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;big.py&quot;</span>
    big_file<span style="color: #666666">.</span>write_bytes(<span style="color: #BA2121">b&quot;a&quot;</span> <span style="color: #666666">*</span> <span style="color: #666666">210_000</span>)
    caplog<span style="color: #666666">.</span>set_level(logging<span style="color: #666666">.</span>INFO)
    snippets <span style="color: #666666">=</span> explaincode<span style="color: #666666">.</span>extract_snippets(
        [big_file], max_files<span style="color: #666666">=1</span>, time_budget<span style="color: #666666">=5</span>, max_bytes<span style="color: #666666">=200_000</span>
    )
    <span style="color: #008000; font-weight: bold">assert</span> big_file <span style="color: #AA22FF; font-weight: bold">not</span> <span style="color: #AA22FF; font-weight: bold">in</span> snippets
    log <span style="color: #666666">=</span> caplog<span style="color: #666666">.</span>text
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #BA2121">&quot;file size&quot;</span> <span style="color: #AA22FF; font-weight: bold">in</span> log <span style="color: #AA22FF; font-weight: bold">and</span> <span style="color: #BA2121">&quot;exceeds limit&quot;</span> <span style="color: #AA22FF; font-weight: bold">in</span> log
</code></pre>
<h3 id="test_scan_code_skips_non_source_dirs">test_scan_code_skips_non_source_dirs(tmp_path: Path, monkeypatch: pytest.MonkeyPatch) -&gt; None</h3>
<p>The function `test_scan_code_skips_non_source_dirs` tests that the `scan_code` function correctly ignores non-source directories (such as `tests` and `examples`) when scanning for code files. It creates a temporary directory structure with source, test, and example directories, writes sample Python files to each, and patches the `collect_docs` function to return an empty list. The test then calls `scan_code` with specific parameters and verifies that only the file from the `src` directory is included in the result under the &quot;How to Run&quot; key, confirming that non-source directories are skipped during the scanning process.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">test_scan_code_skips_non_source_dirs</span>(
    tmp_path: Path, monkeypatch: pytest<span style="color: #666666">.</span>MonkeyPatch
) <span style="color: #666666">-&gt;</span> <span style="color: #008000; font-weight: bold">None</span>:
    src <span style="color: #666666">=</span> tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;src&quot;</span>
    src<span style="color: #666666">.</span>mkdir()
    (src <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;main.py&quot;</span>)<span style="color: #666666">.</span>write_text(<span style="color: #BA2121">&#39;&quot;&quot;&quot;run code&quot;&quot;&quot;&#39;</span>, encoding<span style="color: #666666">=</span><span style="color: #BA2121">&quot;utf-8&quot;</span>)

    tests_dir <span style="color: #666666">=</span> tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;tests&quot;</span>
    tests_dir<span style="color: #666666">.</span>mkdir()
    (tests_dir <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;test_main.py&quot;</span>)<span style="color: #666666">.</span>write_text(<span style="color: #BA2121">&#39;&quot;&quot;&quot;run tests&quot;&quot;&quot;&#39;</span>, encoding<span style="color: #666666">=</span><span style="color: #BA2121">&quot;utf-8&quot;</span>)

    examples_dir <span style="color: #666666">=</span> tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;examples&quot;</span>
    examples_dir<span style="color: #666666">.</span>mkdir()
    (examples_dir <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;example.py&quot;</span>)<span style="color: #666666">.</span>write_text(<span style="color: #BA2121">&#39;&quot;&quot;&quot;run example&quot;&quot;&quot;&#39;</span>, encoding<span style="color: #666666">=</span><span style="color: #BA2121">&quot;utf-8&quot;</span>)

    monkeypatch<span style="color: #666666">.</span>setattr(explaincode, <span style="color: #BA2121">&quot;collect_docs&quot;</span>, <span style="color: #008000; font-weight: bold">lambda</span> base: [])
    result <span style="color: #666666">=</span> explaincode<span style="color: #666666">.</span>scan_code(
        tmp_path, [<span style="color: #BA2121">&quot;How to Run&quot;</span>], max_files<span style="color: #666666">=5</span>, time_budget<span style="color: #666666">=5</span>, max_bytes_per_file<span style="color: #666666">=1000</span>
    )

    how_to_run <span style="color: #666666">=</span> result<span style="color: #666666">.</span>get(<span style="color: #BA2121">&quot;How to Run&quot;</span>, {})
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #008000">set</span>(how_to_run<span style="color: #666666">.</span>keys()) <span style="color: #666666">==</span> {<span style="color: #BA2121">&quot;src/main.py&quot;</span>}
</code></pre>
<h3 id="test_scan_code_categorizes_snippets">test_scan_code_categorizes_snippets(tmp_path: Path, monkeypatch: pytest.MonkeyPatch) -&gt; None</h3>
<p>This function tests the `scan_code` function&#x27;s ability to categorize code snippets into specified categories. It creates temporary Python files, patches several functions in the `explaincode` module to simulate behavior, and then calls `scan_code` with specific parameters. The test verifies that the returned dictionary correctly maps each category to the corresponding file and its extracted snippet content.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">test_scan_code_categorizes_snippets</span>(
    tmp_path: Path, monkeypatch: pytest<span style="color: #666666">.</span>MonkeyPatch
) <span style="color: #666666">-&gt;</span> <span style="color: #008000; font-weight: bold">None</span>:
    paths <span style="color: #666666">=</span> [tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;a.py&quot;</span>, tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;b.py&quot;</span>, tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;c.py&quot;</span>]
    <span style="color: #008000; font-weight: bold">for</span> p <span style="color: #AA22FF; font-weight: bold">in</span> paths:
        p<span style="color: #666666">.</span>write_text(<span style="color: #BA2121">&quot;&quot;</span>, encoding<span style="color: #666666">=</span><span style="color: #BA2121">&quot;utf-8&quot;</span>)

    monkeypatch<span style="color: #666666">.</span>setattr(explaincode, <span style="color: #BA2121">&quot;collect_docs&quot;</span>, <span style="color: #008000; font-weight: bold">lambda</span> base: [])
    monkeypatch<span style="color: #666666">.</span>setattr(explaincode, <span style="color: #BA2121">&quot;rank_code_files&quot;</span>, <span style="color: #008000; font-weight: bold">lambda</span> base, patterns: paths)

    <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">fake_extract</span>(
        files: Iterable[Path], <span style="color: #666666">*</span>, max_files: <span style="color: #008000">int</span>, time_budget: <span style="color: #008000">int</span>, max_bytes: <span style="color: #008000">int</span>
    ) <span style="color: #666666">-&gt;</span> <span style="color: #008000">dict</span>[Path, <span style="color: #008000">str</span>]:
        <span style="color: #008000; font-weight: bold">return</span> {
            paths[<span style="color: #666666">0</span>]: <span style="color: #BA2121">&quot;read input from user&quot;</span>,
            paths[<span style="color: #666666">1</span>]: <span style="color: #BA2121">&quot;write output&quot;</span>,
            paths[<span style="color: #666666">2</span>]: <span style="color: #BA2121">&quot;run the tool&quot;</span>,
        }

    monkeypatch<span style="color: #666666">.</span>setattr(explaincode, <span style="color: #BA2121">&quot;extract_snippets&quot;</span>, fake_extract)

    result <span style="color: #666666">=</span> explaincode<span style="color: #666666">.</span>scan_code(
        tmp_path, [<span style="color: #BA2121">&quot;Inputs&quot;</span>, <span style="color: #BA2121">&quot;Outputs&quot;</span>, <span style="color: #BA2121">&quot;How to Run&quot;</span>], max_files<span style="color: #666666">=3</span>, time_budget<span style="color: #666666">=5</span>, max_bytes_per_file<span style="color: #666666">=1000</span>
    )
    <span style="color: #008000; font-weight: bold">assert</span> result[<span style="color: #BA2121">&quot;Inputs&quot;</span>] <span style="color: #666666">==</span> {<span style="color: #BA2121">&quot;a.py&quot;</span>: <span style="color: #BA2121">&quot;read input from user&quot;</span>}
    <span style="color: #008000; font-weight: bold">assert</span> result[<span style="color: #BA2121">&quot;Outputs&quot;</span>] <span style="color: #666666">==</span> {<span style="color: #BA2121">&quot;b.py&quot;</span>: <span style="color: #BA2121">&quot;write output&quot;</span>}
    <span style="color: #008000; font-weight: bold">assert</span> result[<span style="color: #BA2121">&quot;How to Run&quot;</span>] <span style="color: #666666">==</span> {<span style="color: #BA2121">&quot;c.py&quot;</span>: <span style="color: #BA2121">&quot;run the tool&quot;</span>}
</code></pre>
<details>
<summary>Subfunction: fake_extract(files: Iterable[Path], *, max_files: int, time_budget: int, max_bytes: int) -&gt; dict[Path, str]</summary>
<h4 id="fake_extract">fake_extract(files: Iterable[Path], *, max_files: int, time_budget: int, max_bytes: int) -&gt; dict[Path, str]</h4>
<p>The function `fake_extract` takes an iterable of file paths and several configuration parameters, then returns a dictionary mapping the first three paths to predefined string descriptions. The parameters `max_files`, `time_budget`, and `max_bytes` are unused in the implementation. The returned dictionary maps each of the first three paths to a fixed description: &quot;read input from user&quot;, &quot;write output&quot;, and &quot;run the tool&quot;.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">fake_extract</span>(
        files: Iterable[Path], <span style="color: #666666">*</span>, max_files: <span style="color: #008000">int</span>, time_budget: <span style="color: #008000">int</span>, max_bytes: <span style="color: #008000">int</span>
    ) <span style="color: #666666">-&gt;</span> <span style="color: #008000">dict</span>[Path, <span style="color: #008000">str</span>]:
        <span style="color: #008000; font-weight: bold">return</span> {
            paths[<span style="color: #666666">0</span>]: <span style="color: #BA2121">&quot;read input from user&quot;</span>,
            paths[<span style="color: #666666">1</span>]: <span style="color: #BA2121">&quot;write output&quot;</span>,
            paths[<span style="color: #666666">2</span>]: <span style="color: #BA2121">&quot;run the tool&quot;</span>,
        }
</code></pre>
</details>
<h3 id="test_rank_code_files_supports_cpp_h_java">test_rank_code_files_supports_cpp_h_java(tmp_path: Path) -&gt; None</h3>
<p>The function `test_rank_code_files_supports_cpp_h_java` tests the capability of the `explaincode.rank_code_files` function to identify and rank source code files with specific extensions (`.cpp`, `.h`, `.java`) within a given directory. It creates a temporary directory containing files with various extensions, including Python, C++, C++ header, Java, and a text file. The test verifies that `rank_code_files` correctly identifies and includes only the relevant code files in its output, excluding non-code files like the text file. The assertion confirms that the ranked list contains the expected code file names while ensuring the text file is excluded.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">test_rank_code_files_supports_cpp_h_java</span>(tmp_path: Path) <span style="color: #666666">-&gt;</span> <span style="color: #008000; font-weight: bold">None</span>:
    files <span style="color: #666666">=</span> [
        tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;main.py&quot;</span>,
        tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;lib.cpp&quot;</span>,
        tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;lib.h&quot;</span>,
        tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;Main.java&quot;</span>,
        tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;ignore.txt&quot;</span>,
    ]
    <span style="color: #008000; font-weight: bold">for</span> f <span style="color: #AA22FF; font-weight: bold">in</span> files:
        f<span style="color: #666666">.</span>write_text(<span style="color: #BA2121">&quot;&quot;</span>, encoding<span style="color: #666666">=</span><span style="color: #BA2121">&quot;utf-8&quot;</span>)
    ranked <span style="color: #666666">=</span> explaincode<span style="color: #666666">.</span>rank_code_files(tmp_path, [])
    names <span style="color: #666666">=</span> {p<span style="color: #666666">.</span>name <span style="color: #008000; font-weight: bold">for</span> p <span style="color: #AA22FF; font-weight: bold">in</span> ranked}
    <span style="color: #008000; font-weight: bold">assert</span> {<span style="color: #BA2121">&quot;main.py&quot;</span>, <span style="color: #BA2121">&quot;lib.cpp&quot;</span>, <span style="color: #BA2121">&quot;lib.h&quot;</span>, <span style="color: #BA2121">&quot;Main.java&quot;</span>} <span style="color: #666666">&lt;=</span> names
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #BA2121">&quot;ignore.txt&quot;</span> <span style="color: #AA22FF; font-weight: bold">not</span> <span style="color: #AA22FF; font-weight: bold">in</span> names
</code></pre>
<h3 id="test_llm_fill_placeholders_per_section_logging">test_llm_fill_placeholders_per_section_logging(tmp_path: Path, caplog: pytest.LogCaptureFixture) -&gt; None</h3>
<p>The function `test_llm_fill_placeholders_per_section_logging` tests the behavior of `explaincode.llm_fill_placeholders` by simulating an LLM client and verifying that placeholders in a manual text are correctly replaced with content derived from evidence. It uses a dummy class to simulate LLM responses, checks that the correct number of calls are made, and verifies that log messages are generated indicating which sections were filled using specific code files. The test ensures that section-specific placeholders are replaced and that logging occurs as expected during the placeholder-filling process.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">test_llm_fill_placeholders_per_section_logging</span>(
    tmp_path: Path, caplog: pytest<span style="color: #666666">.</span>LogCaptureFixture
) <span style="color: #666666">-&gt;</span> <span style="color: #008000; font-weight: bold">None</span>:
    manual <span style="color: #666666">=</span> <span style="color: #BA2121">&quot;Inputs: [[NEEDS_INPUTS]]</span><span style="color: #AA5D1F; font-weight: bold">\n</span><span style="color: #BA2121">Outputs: [[NEEDS_OUTPUTS]]&quot;</span>
    evidence <span style="color: #666666">=</span> {
        <span style="color: #BA2121">&quot;Inputs&quot;</span>: {<span style="color: #BA2121">&quot;in.py&quot;</span>: <span style="color: #BA2121">&quot;input data&quot;</span>},
        <span style="color: #BA2121">&quot;Outputs&quot;</span>: {<span style="color: #BA2121">&quot;out.py&quot;</span>: <span style="color: #BA2121">&quot;output data&quot;</span>},
    }

    <span style="color: #008000; font-weight: bold">class</span> <span style="color: #0000FF; font-weight: bold">Dummy</span>:
        <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">__init__</span>(<span style="color: #008000">self</span>) <span style="color: #666666">-&gt;</span> <span style="color: #008000; font-weight: bold">None</span>:
            <span style="color: #008000">self</span><span style="color: #666666">.</span>calls: <span style="color: #008000">list</span>[<span style="color: #008000">str</span>] <span style="color: #666666">=</span> []

        <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">summarize</span>(
            <span style="color: #008000">self</span>, text: <span style="color: #008000">str</span>, prompt_type: <span style="color: #008000">str</span>, system_prompt: <span style="color: #008000">str</span> <span style="color: #666666">=</span> <span style="color: #BA2121">&quot;&quot;</span>
        ) <span style="color: #666666">-&gt;</span> <span style="color: #008000">str</span>:
            <span style="color: #008000">self</span><span style="color: #666666">.</span>calls<span style="color: #666666">.</span>append(text)
            manual_match <span style="color: #666666">=</span> re<span style="color: #666666">.</span>search(<span style="color: #BA2121">r&quot;Manual:\n(.*?)\n\nSection:&quot;</span>, text, re<span style="color: #666666">.</span>DOTALL)
            section_match <span style="color: #666666">=</span> re<span style="color: #666666">.</span>search(<span style="color: #BA2121">r&quot;Section: (.*?)\n&quot;</span>, text)
            manual_text <span style="color: #666666">=</span> manual_match<span style="color: #666666">.</span>group(<span style="color: #666666">1</span>)
            section <span style="color: #666666">=</span> section_match<span style="color: #666666">.</span>group(<span style="color: #666666">1</span>)
            token <span style="color: #666666">=</span> explaincode<span style="color: #666666">.</span>SECTION_PLACEHOLDERS[section]
            <span style="color: #008000; font-weight: bold">return</span> manual_text<span style="color: #666666">.</span>replace(token, <span style="color: #BA2121">f&quot;filled </span><span style="color: #A45A77; font-weight: bold">{</span>section<span style="color: #A45A77; font-weight: bold">}</span><span style="color: #BA2121">&quot;</span>)

    client <span style="color: #666666">=</span> Dummy()
    cache <span style="color: #666666">=</span> ResponseCache(<span style="color: #008000">str</span>(tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;cache.json&quot;</span>))
    caplog<span style="color: #666666">.</span>set_level(logging<span style="color: #666666">.</span>INFO)
    result <span style="color: #666666">=</span> explaincode<span style="color: #666666">.</span>llm_fill_placeholders(manual, evidence, client, cache)
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #BA2121">&quot;filled Inputs&quot;</span> <span style="color: #AA22FF; font-weight: bold">in</span> result <span style="color: #AA22FF; font-weight: bold">and</span> <span style="color: #BA2121">&quot;filled Outputs&quot;</span> <span style="color: #AA22FF; font-weight: bold">in</span> result
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #008000">len</span>(client<span style="color: #666666">.</span>calls) <span style="color: #666666">==</span> <span style="color: #666666">2</span>
    log <span style="color: #666666">=</span> caplog<span style="color: #666666">.</span>text
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #BA2121">&quot;Filled Inputs using code from: in.py&quot;</span> <span style="color: #AA22FF; font-weight: bold">in</span> log
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #BA2121">&quot;Filled Outputs using code from: out.py&quot;</span> <span style="color: #AA22FF; font-weight: bold">in</span> log
</code></pre>
<h3 id="test_full_docs_no_code_scan">test_full_docs_no_code_scan(tmp_path: Path, monkeypatch: pytest.MonkeyPatch, caplog: pytest.LogCaptureFixture) -&gt; None</h3>
<p>This function tests the behavior of the documentation generation process when code scanning is explicitly disabled. It sets up a temporary directory with fixture files, patches functions responsible for ranking code files and extracting snippets to track their invocation, and configures logging to capture output. The test verifies that neither the ranking nor extraction functions are called when the `--scan-code-if-needed` flag is used, confirming that code scanning is skipped. It also checks that specific log messages indicating &quot;DOC PASS&quot; and &quot;Code scan skipped&quot; appear in the captured logs.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">test_full_docs_no_code_scan</span>(
    tmp_path: Path, monkeypatch: pytest<span style="color: #666666">.</span>MonkeyPatch, caplog: pytest<span style="color: #666666">.</span>LogCaptureFixture
) <span style="color: #666666">-&gt;</span> <span style="color: #008000; font-weight: bold">None</span>:
    _create_fixture(tmp_path)
    tracker <span style="color: #666666">=</span> {<span style="color: #BA2121">&quot;rank&quot;</span>: <span style="color: #666666">0</span>, <span style="color: #BA2121">&quot;extract&quot;</span>: <span style="color: #666666">0</span>}

    <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">fake_rank</span>(root: Path, patterns: <span style="color: #008000">list</span>[<span style="color: #008000">str</span>]) <span style="color: #666666">-&gt;</span> <span style="color: #008000">list</span>[Path]:
        tracker[<span style="color: #BA2121">&quot;rank&quot;</span>] <span style="color: #666666">+=</span> <span style="color: #666666">1</span>
        <span style="color: #008000; font-weight: bold">return</span> [tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;a.py&quot;</span>]

    <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">fake_extract</span>(
        files: Iterable[Path], <span style="color: #666666">*</span>, max_files: <span style="color: #008000">int</span>, time_budget: <span style="color: #008000">int</span>, max_bytes: <span style="color: #008000">int</span>
    ) <span style="color: #666666">-&gt;</span> <span style="color: #008000">dict</span>[Path, <span style="color: #008000">str</span>]:
        tracker[<span style="color: #BA2121">&quot;extract&quot;</span>] <span style="color: #666666">+=</span> <span style="color: #666666">1</span>
        <span style="color: #008000; font-weight: bold">return</span> {}

    monkeypatch<span style="color: #666666">.</span>setattr(explaincode, <span style="color: #BA2121">&quot;LLMClient&quot;</span>, _mock_llm_client)
    monkeypatch<span style="color: #666666">.</span>setattr(explaincode, <span style="color: #BA2121">&quot;rank_code_files&quot;</span>, fake_rank)
    monkeypatch<span style="color: #666666">.</span>setattr(explaincode, <span style="color: #BA2121">&quot;extract_snippets&quot;</span>, fake_extract)

    caplog<span style="color: #666666">.</span>set_level(logging<span style="color: #666666">.</span>INFO)
    main([<span style="color: #BA2121">&quot;--path&quot;</span>, <span style="color: #008000">str</span>(tmp_path), <span style="color: #BA2121">&quot;--scan-code-if-needed&quot;</span>])
    <span style="color: #008000; font-weight: bold">assert</span> tracker[<span style="color: #BA2121">&quot;rank&quot;</span>] <span style="color: #666666">==</span> <span style="color: #666666">0</span>
    <span style="color: #008000; font-weight: bold">assert</span> tracker[<span style="color: #BA2121">&quot;extract&quot;</span>] <span style="color: #666666">==</span> <span style="color: #666666">0</span>
    log <span style="color: #666666">=</span> caplog<span style="color: #666666">.</span>text
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #BA2121">&quot;DOC PASS&quot;</span> <span style="color: #AA22FF; font-weight: bold">in</span> log
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #BA2121">&quot;Code scan skipped&quot;</span> <span style="color: #AA22FF; font-weight: bold">in</span> log
</code></pre>
<details>
<summary>Subfunction: fake_rank(root: Path, patterns: list[str]) -&gt; list[Path]</summary>
<h4 id="fake_rank">fake_rank(root: Path, patterns: list[str]) -&gt; list[Path]</h4>
<p>The function `fake_rank` takes a root path and a list of patterns as input parameters. It increments a global or shared counter `tracker[&quot;rank&quot;]` by one, then returns a list containing a single Path object pointing to a file named &quot;a.py&quot; located within a temporary directory `tmp_path`. The function appears to be a placeholder or mock implementation, as it does not utilize the provided `root` or `patterns` parameters in its logic.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">fake_rank</span>(root: Path, patterns: <span style="color: #008000">list</span>[<span style="color: #008000">str</span>]) <span style="color: #666666">-&gt;</span> <span style="color: #008000">list</span>[Path]:
        tracker[<span style="color: #BA2121">&quot;rank&quot;</span>] <span style="color: #666666">+=</span> <span style="color: #666666">1</span>
        <span style="color: #008000; font-weight: bold">return</span> [tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;a.py&quot;</span>]
</code></pre>
</details>
<details>
<summary>Subfunction: fake_extract(files: Iterable[Path], *, max_files: int, time_budget: int, max_bytes: int) -&gt; dict[Path, str]</summary>
<h4 id="fake_extract">fake_extract(files: Iterable[Path], *, max_files: int, time_budget: int, max_bytes: int) -&gt; dict[Path, str]</h4>
<p>The function `fake_extract` takes an iterable of file paths and several configuration parameters, then increments a counter in a global `tracker` dictionary under the key &quot;extract&quot; and returns an empty dictionary. It does not perform any actual file extraction or processing.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">fake_extract</span>(
        files: Iterable[Path], <span style="color: #666666">*</span>, max_files: <span style="color: #008000">int</span>, time_budget: <span style="color: #008000">int</span>, max_bytes: <span style="color: #008000">int</span>
    ) <span style="color: #666666">-&gt;</span> <span style="color: #008000">dict</span>[Path, <span style="color: #008000">str</span>]:
        tracker[<span style="color: #BA2121">&quot;extract&quot;</span>] <span style="color: #666666">+=</span> <span style="color: #666666">1</span>
        <span style="color: #008000; font-weight: bold">return</span> {}
</code></pre>
</details>
<h3 id="test_missing_run_triggers_code_fallback_with_limits">test_missing_run_triggers_code_fallback_with_limits(tmp_path: Path, monkeypatch: pytest.MonkeyPatch, caplog: pytest.LogCaptureFixture) -&gt; None</h3>
<p>This function tests the behavior of the documentation generation process when run instructions are missing, ensuring that a fallback mechanism uses code snippets to fill in the missing information. It verifies that the system correctly identifies missing run instructions, extracts relevant code snippets, and substitutes placeholders in the generated manual with actual code-based content. The test confirms that the system respects configured limits on the number of files scanned and time budget, and logs appropriate messages during the process. It also checks that the final HTML output does not contain unresolved placeholders and that the internal tracking mechanisms function as expected.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">test_missing_run_triggers_code_fallback_with_limits</span>(
    tmp_path: Path, monkeypatch: pytest<span style="color: #666666">.</span>MonkeyPatch, caplog: pytest<span style="color: #666666">.</span>LogCaptureFixture
) <span style="color: #666666">-&gt;</span> <span style="color: #008000; font-weight: bold">None</span>:
    (tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;README.md&quot;</span>)<span style="color: #666666">.</span>write_text(<span style="color: #BA2121">&quot;Only overview&quot;</span>, encoding<span style="color: #666666">=</span><span style="color: #BA2121">&quot;utf-8&quot;</span>)

    <span style="color: #008000; font-weight: bold">class</span> <span style="color: #0000FF; font-weight: bold">Dummy</span>:
        <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">summarize</span>(<span style="color: #008000">self</span>, text: <span style="color: #008000">str</span>, prompt_type: <span style="color: #008000">str</span>, system_prompt: <span style="color: #008000">str</span> <span style="color: #666666">=</span> <span style="color: #BA2121">&quot;&quot;</span>) <span style="color: #666666">-&gt;</span> <span style="color: #008000">str</span>:
            <span style="color: #008000; font-weight: bold">if</span> <span style="color: #BA2121">&quot;How to Run&quot;</span> <span style="color: #AA22FF; font-weight: bold">in</span> system_prompt:
                <span style="color: #008000; font-weight: bold">return</span> <span style="color: #BA2121">&quot;[[NEEDS_RUN_INSTRUCTIONS]]&quot;</span>
            <span style="color: #008000; font-weight: bold">if</span> <span style="color: #BA2121">&quot;enhancing a user manual&quot;</span> <span style="color: #AA22FF; font-weight: bold">in</span> system_prompt:
                manual_match <span style="color: #666666">=</span> re<span style="color: #666666">.</span>search(<span style="color: #BA2121">r&quot;Manual:\n(.*?)\n\nSection:&quot;</span>, text, re<span style="color: #666666">.</span>DOTALL)
                manual_text <span style="color: #666666">=</span> manual_match<span style="color: #666666">.</span>group(<span style="color: #666666">1</span>)
                <span style="color: #008000; font-weight: bold">return</span> manual_text<span style="color: #666666">.</span>replace(<span style="color: #BA2121">&quot;[[NEEDS_RUN_INSTRUCTIONS]]&quot;</span>, <span style="color: #BA2121">&quot;use it&quot;</span>)
            <span style="color: #008000; font-weight: bold">return</span> <span style="color: #BA2121">&quot;x&quot;</span>

    paths <span style="color: #666666">=</span> [tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">f&quot;f</span><span style="color: #A45A77; font-weight: bold">{</span>i<span style="color: #A45A77; font-weight: bold">}</span><span style="color: #BA2121">.py&quot;</span> <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(<span style="color: #666666">3</span>)]
    tracker: <span style="color: #008000">dict</span>[<span style="color: #008000">str</span>, <span style="color: #008000">object</span>] <span style="color: #666666">=</span> {<span style="color: #BA2121">&quot;rank&quot;</span>: <span style="color: #666666">0</span>, <span style="color: #BA2121">&quot;extract&quot;</span>: <span style="color: #666666">0</span>}

    <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">fake_rank</span>(root: Path, patterns: <span style="color: #008000">list</span>[<span style="color: #008000">str</span>]) <span style="color: #666666">-&gt;</span> <span style="color: #008000">list</span>[Path]:
        tracker[<span style="color: #BA2121">&quot;rank&quot;</span>] <span style="color: #666666">+=</span> <span style="color: #666666">1</span>
        <span style="color: #008000; font-weight: bold">return</span> paths

    <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">fake_extract</span>(
        files: Iterable[Path], <span style="color: #666666">*</span>, max_files: <span style="color: #008000">int</span>, time_budget: <span style="color: #008000">int</span>, max_bytes: <span style="color: #008000">int</span>
    ) <span style="color: #666666">-&gt;</span> <span style="color: #008000">dict</span>[Path, <span style="color: #008000">str</span>]:
        tracker[<span style="color: #BA2121">&quot;extract&quot;</span>] <span style="color: #666666">+=</span> <span style="color: #666666">1</span>
        lst <span style="color: #666666">=</span> <span style="color: #008000">list</span>(files)
        tracker[<span style="color: #BA2121">&quot;kwargs&quot;</span>] <span style="color: #666666">=</span> {<span style="color: #BA2121">&quot;max_files&quot;</span>: max_files, <span style="color: #BA2121">&quot;time_budget&quot;</span>: time_budget}
        tracker[<span style="color: #BA2121">&quot;scanned&quot;</span>] <span style="color: #666666">=</span> lst[:max_files]
        <span style="color: #008000; font-weight: bold">return</span> {p: <span style="color: #BA2121">&quot;run code&quot;</span> <span style="color: #008000; font-weight: bold">for</span> p <span style="color: #AA22FF; font-weight: bold">in</span> lst[:max_files]}

    monkeypatch<span style="color: #666666">.</span>setattr(explaincode, <span style="color: #BA2121">&quot;LLMClient&quot;</span>, <span style="color: #008000; font-weight: bold">lambda</span>: Dummy())
    monkeypatch<span style="color: #666666">.</span>setattr(explaincode, <span style="color: #BA2121">&quot;rank_code_files&quot;</span>, fake_rank)
    monkeypatch<span style="color: #666666">.</span>setattr(explaincode, <span style="color: #BA2121">&quot;extract_snippets&quot;</span>, fake_extract)

    caplog<span style="color: #666666">.</span>set_level(logging<span style="color: #666666">.</span>INFO)
    main(
        [
            <span style="color: #BA2121">&quot;--path&quot;</span>,
            <span style="color: #008000">str</span>(tmp_path),
            <span style="color: #BA2121">&quot;--scan-code-if-needed&quot;</span>,
            <span style="color: #BA2121">&quot;--max-code-files&quot;</span>,
            <span style="color: #BA2121">&quot;1&quot;</span>,
            <span style="color: #BA2121">&quot;--code-time-budget-seconds&quot;</span>,
            <span style="color: #BA2121">&quot;5&quot;</span>,
        ]
    )
    html <span style="color: #666666">=</span> (tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;user_manual.html&quot;</span>)<span style="color: #666666">.</span>read_text(encoding<span style="color: #666666">=</span><span style="color: #BA2121">&quot;utf-8&quot;</span>)
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #BA2121">&quot;NEEDS_RUN_INSTRUCTIONS&quot;</span> <span style="color: #AA22FF; font-weight: bold">not</span> <span style="color: #AA22FF; font-weight: bold">in</span> html
    <span style="color: #008000; font-weight: bold">assert</span> tracker[<span style="color: #BA2121">&quot;rank&quot;</span>] <span style="color: #666666">==</span> <span style="color: #666666">1</span>
    <span style="color: #008000; font-weight: bold">assert</span> tracker[<span style="color: #BA2121">&quot;extract&quot;</span>] <span style="color: #666666">==</span> <span style="color: #666666">1</span>
    <span style="color: #008000; font-weight: bold">assert</span> tracker[<span style="color: #BA2121">&quot;kwargs&quot;</span>] <span style="color: #666666">==</span> {<span style="color: #BA2121">&quot;max_files&quot;</span>: <span style="color: #666666">1</span>, <span style="color: #BA2121">&quot;time_budget&quot;</span>: <span style="color: #666666">5</span>}
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #008000">len</span>(tracker[<span style="color: #BA2121">&quot;scanned&quot;</span>]) <span style="color: #666666">==</span> <span style="color: #666666">1</span>
    log <span style="color: #666666">=</span> caplog<span style="color: #666666">.</span>text
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #BA2121">&quot;Pass 1 missing sections&quot;</span> <span style="color: #AA22FF; font-weight: bold">in</span> log
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #BA2121">&quot;How to Run&quot;</span> <span style="color: #AA22FF; font-weight: bold">in</span> log
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #BA2121">&quot;Filled How to Run using code from: f0.py&quot;</span> <span style="color: #AA22FF; font-weight: bold">in</span> log
</code></pre>
<details>
<summary>Subfunction: fake_rank(root: Path, patterns: list[str]) -&gt; list[Path]</summary>
<h4 id="fake_rank">fake_rank(root: Path, patterns: list[str]) -&gt; list[Path]</h4>
<p>The function `fake_rank` takes a root path and a list of patterns as input, increments a global or shared `tracker` dictionary&#x27;s &quot;rank&quot; key by one, and returns a list of paths. The function appears to be a placeholder or mock implementation, as it does not utilize the provided `root` or `patterns` parameters in its logic.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">fake_rank</span>(root: Path, patterns: <span style="color: #008000">list</span>[<span style="color: #008000">str</span>]) <span style="color: #666666">-&gt;</span> <span style="color: #008000">list</span>[Path]:
        tracker[<span style="color: #BA2121">&quot;rank&quot;</span>] <span style="color: #666666">+=</span> <span style="color: #666666">1</span>
        <span style="color: #008000; font-weight: bold">return</span> paths
</code></pre>
</details>
<details>
<summary>Subfunction: fake_extract(files: Iterable[Path], *, max_files: int, time_budget: int, max_bytes: int) -&gt; dict[Path, str]</summary>
<h4 id="fake_extract">fake_extract(files: Iterable[Path], *, max_files: int, time_budget: int, max_bytes: int) -&gt; dict[Path, str]</h4>
<p>The function `fake_extract` takes an iterable of file paths and returns a dictionary mapping each file path to the string &quot;run code&quot;. It updates a global `tracker` object with extraction statistics, including the number of extractions, provided keyword arguments, and a list of scanned files up to the specified maximum. The function processes only the first `max_files` items from the input iterable, regardless of the total number of files provided.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">fake_extract</span>(
        files: Iterable[Path], <span style="color: #666666">*</span>, max_files: <span style="color: #008000">int</span>, time_budget: <span style="color: #008000">int</span>, max_bytes: <span style="color: #008000">int</span>
    ) <span style="color: #666666">-&gt;</span> <span style="color: #008000">dict</span>[Path, <span style="color: #008000">str</span>]:
        tracker[<span style="color: #BA2121">&quot;extract&quot;</span>] <span style="color: #666666">+=</span> <span style="color: #666666">1</span>
        lst <span style="color: #666666">=</span> <span style="color: #008000">list</span>(files)
        tracker[<span style="color: #BA2121">&quot;kwargs&quot;</span>] <span style="color: #666666">=</span> {<span style="color: #BA2121">&quot;max_files&quot;</span>: max_files, <span style="color: #BA2121">&quot;time_budget&quot;</span>: time_budget}
        tracker[<span style="color: #BA2121">&quot;scanned&quot;</span>] <span style="color: #666666">=</span> lst[:max_files]
        <span style="color: #008000; font-weight: bold">return</span> {p: <span style="color: #BA2121">&quot;run code&quot;</span> <span style="color: #008000; font-weight: bold">for</span> p <span style="color: #AA22FF; font-weight: bold">in</span> lst[:max_files]}
</code></pre>
</details>
<h3 id="test_no_code_flag_skips_code_fallback">test_no_code_flag_skips_code_fallback(tmp_path: Path, monkeypatch: pytest.MonkeyPatch, caplog: pytest.LogCaptureFixture) -&gt; None</h3>
<p>The function `test_no_code_flag_skips_code_fallback` tests that the `--no-code` flag prevents code scanning and extraction during documentation generation. It sets up a temporary directory with a README file, mocks the `LLMClient`, `rank_code_files`, and `extract_snippets` functions to track their invocation, and verifies that these functions are not called when the `--no-code` flag is used. The test also confirms that a log message indicating the code scan was skipped is present and that the output contains expected content such as &quot;How to Run&quot;. The test ensures the correct behavior of the documentation generation process when code processing is explicitly disabled.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">test_no_code_flag_skips_code_fallback</span>(
    tmp_path: Path, monkeypatch: pytest<span style="color: #666666">.</span>MonkeyPatch, caplog: pytest<span style="color: #666666">.</span>LogCaptureFixture
) <span style="color: #666666">-&gt;</span> <span style="color: #008000; font-weight: bold">None</span>:
    (tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;README.md&quot;</span>)<span style="color: #666666">.</span>write_text(<span style="color: #BA2121">&quot;Only overview&quot;</span>, encoding<span style="color: #666666">=</span><span style="color: #BA2121">&quot;utf-8&quot;</span>)

    <span style="color: #008000; font-weight: bold">class</span> <span style="color: #0000FF; font-weight: bold">Dummy</span>:
        <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">summarize</span>(
            <span style="color: #008000">self</span>, text: <span style="color: #008000">str</span>, prompt_type: <span style="color: #008000">str</span>, system_prompt: <span style="color: #008000">str</span> <span style="color: #666666">=</span> <span style="color: #BA2121">&quot;&quot;</span>
        ) <span style="color: #666666">-&gt;</span> <span style="color: #008000">str</span>:
            <span style="color: #008000; font-weight: bold">return</span> <span style="color: #BA2121">&quot;Overview: x</span><span style="color: #AA5D1F; font-weight: bold">\\</span><span style="color: #BA2121">nHow to Run: [[NEEDS_RUN_INSTRUCTIONS]]&quot;</span>

    tracker <span style="color: #666666">=</span> {<span style="color: #BA2121">&quot;rank&quot;</span>: <span style="color: #666666">0</span>, <span style="color: #BA2121">&quot;extract&quot;</span>: <span style="color: #666666">0</span>}

    <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">fake_rank</span>(root: Path, patterns: <span style="color: #008000">list</span>[<span style="color: #008000">str</span>]) <span style="color: #666666">-&gt;</span> <span style="color: #008000">list</span>[Path]:
        tracker[<span style="color: #BA2121">&quot;rank&quot;</span>] <span style="color: #666666">+=</span> <span style="color: #666666">1</span>
        <span style="color: #008000; font-weight: bold">return</span> []

    <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">fake_extract</span>(
        files: Iterable[Path], <span style="color: #666666">*</span>, max_files: <span style="color: #008000">int</span>, time_budget: <span style="color: #008000">int</span>, max_bytes: <span style="color: #008000">int</span>
    ) <span style="color: #666666">-&gt;</span> <span style="color: #008000">dict</span>[Path, <span style="color: #008000">str</span>]:
        tracker[<span style="color: #BA2121">&quot;extract&quot;</span>] <span style="color: #666666">+=</span> <span style="color: #666666">1</span>
        <span style="color: #008000; font-weight: bold">return</span> {}

    monkeypatch<span style="color: #666666">.</span>setattr(explaincode, <span style="color: #BA2121">&quot;LLMClient&quot;</span>, <span style="color: #008000; font-weight: bold">lambda</span>: Dummy())
    monkeypatch<span style="color: #666666">.</span>setattr(explaincode, <span style="color: #BA2121">&quot;rank_code_files&quot;</span>, fake_rank)
    monkeypatch<span style="color: #666666">.</span>setattr(explaincode, <span style="color: #BA2121">&quot;extract_snippets&quot;</span>, fake_extract)

    caplog<span style="color: #666666">.</span>set_level(logging<span style="color: #666666">.</span>INFO)
    main([<span style="color: #BA2121">&quot;--path&quot;</span>, <span style="color: #008000">str</span>(tmp_path), <span style="color: #BA2121">&quot;--scan-code-if-needed&quot;</span>, <span style="color: #BA2121">&quot;--no-code&quot;</span>])
    <span style="color: #008000; font-weight: bold">assert</span> tracker[<span style="color: #BA2121">&quot;rank&quot;</span>] <span style="color: #666666">==</span> <span style="color: #666666">0</span>
    <span style="color: #008000; font-weight: bold">assert</span> tracker[<span style="color: #BA2121">&quot;extract&quot;</span>] <span style="color: #666666">==</span> <span style="color: #666666">0</span>
    log <span style="color: #666666">=</span> caplog<span style="color: #666666">.</span>text
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #BA2121">&quot;Code scan skipped: --no-code specified&quot;</span> <span style="color: #AA22FF; font-weight: bold">in</span> log
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #BA2121">&quot;How to Run&quot;</span> <span style="color: #AA22FF; font-weight: bold">in</span> log
</code></pre>
<details>
<summary>Subfunction: fake_rank(root: Path, patterns: list[str]) -&gt; list[Path]</summary>
<h4 id="fake_rank">fake_rank(root: Path, patterns: list[str]) -&gt; list[Path]</h4>
<p>The function `fake_rank` takes a `Path` object representing a root directory and a list of string patterns. It increments a global or shared counter variable `tracker[&quot;rank&quot;]` by one and returns an empty list of `Path` objects. The function appears to be a placeholder or mock implementation, as it does not perform any actual ranking or filtering of files based on the provided patterns.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">fake_rank</span>(root: Path, patterns: <span style="color: #008000">list</span>[<span style="color: #008000">str</span>]) <span style="color: #666666">-&gt;</span> <span style="color: #008000">list</span>[Path]:
        tracker[<span style="color: #BA2121">&quot;rank&quot;</span>] <span style="color: #666666">+=</span> <span style="color: #666666">1</span>
        <span style="color: #008000; font-weight: bold">return</span> []
</code></pre>
</details>
<details>
<summary>Subfunction: fake_extract(files: Iterable[Path], *, max_files: int, time_budget: int, max_bytes: int) -&gt; dict[Path, str]</summary>
<h4 id="fake_extract">fake_extract(files: Iterable[Path], *, max_files: int, time_budget: int, max_bytes: int) -&gt; dict[Path, str]</h4>
<p>The function `fake_extract` takes an iterable of file paths and several configuration parameters, then increments a counter in a global `tracker` dictionary under the key &quot;extract&quot; and returns an empty dictionary. It does not perform any actual file extraction or processing.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">fake_extract</span>(
        files: Iterable[Path], <span style="color: #666666">*</span>, max_files: <span style="color: #008000">int</span>, time_budget: <span style="color: #008000">int</span>, max_bytes: <span style="color: #008000">int</span>
    ) <span style="color: #666666">-&gt;</span> <span style="color: #008000">dict</span>[Path, <span style="color: #008000">str</span>]:
        tracker[<span style="color: #BA2121">&quot;extract&quot;</span>] <span style="color: #666666">+=</span> <span style="color: #666666">1</span>
        <span style="color: #008000; font-weight: bold">return</span> {}
</code></pre>
</details>
<h3 id="test_force_code_flag_triggers_code_fallback">test_force_code_flag_triggers_code_fallback(tmp_path: Path, monkeypatch: pytest.MonkeyPatch, caplog: pytest.LogCaptureFixture) -&gt; None</h3>
<p>This function tests that the `--force-code` flag correctly triggers a code fallback during documentation generation. It sets up a temporary test environment, patches functions to track execution, and verifies that the code scanning logic is invoked when the flag is used. The test ensures the correct logging messages are produced and that the expected number of file ranking and extraction operations occur.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">test_force_code_flag_triggers_code_fallback</span>(
    tmp_path: Path, monkeypatch: pytest<span style="color: #666666">.</span>MonkeyPatch, caplog: pytest<span style="color: #666666">.</span>LogCaptureFixture
) <span style="color: #666666">-&gt;</span> <span style="color: #008000; font-weight: bold">None</span>:
    _create_fixture(tmp_path)
    tracker <span style="color: #666666">=</span> {<span style="color: #BA2121">&quot;rank&quot;</span>: <span style="color: #666666">0</span>, <span style="color: #BA2121">&quot;extract&quot;</span>: <span style="color: #666666">0</span>}

    <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">fake_rank</span>(root: Path, patterns: <span style="color: #008000">list</span>[<span style="color: #008000">str</span>]) <span style="color: #666666">-&gt;</span> <span style="color: #008000">list</span>[Path]:
        tracker[<span style="color: #BA2121">&quot;rank&quot;</span>] <span style="color: #666666">+=</span> <span style="color: #666666">1</span>
        <span style="color: #008000; font-weight: bold">return</span> [tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;script.py&quot;</span>]

    <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">fake_extract</span>(
        files: Iterable[Path], <span style="color: #666666">*</span>, max_files: <span style="color: #008000">int</span>, time_budget: <span style="color: #008000">int</span>, max_bytes: <span style="color: #008000">int</span>
    ) <span style="color: #666666">-&gt;</span> <span style="color: #008000">dict</span>[Path, <span style="color: #008000">str</span>]:
        tracker[<span style="color: #BA2121">&quot;extract&quot;</span>] <span style="color: #666666">+=</span> <span style="color: #666666">1</span>
        <span style="color: #008000; font-weight: bold">return</span> {<span style="color: #008000">next</span>(<span style="color: #008000">iter</span>(files)): <span style="color: #BA2121">&quot;code&quot;</span>}

    monkeypatch<span style="color: #666666">.</span>setattr(explaincode, <span style="color: #BA2121">&quot;LLMClient&quot;</span>, _mock_llm_client)
    monkeypatch<span style="color: #666666">.</span>setattr(explaincode, <span style="color: #BA2121">&quot;rank_code_files&quot;</span>, fake_rank)
    monkeypatch<span style="color: #666666">.</span>setattr(explaincode, <span style="color: #BA2121">&quot;extract_snippets&quot;</span>, fake_extract)

    caplog<span style="color: #666666">.</span>set_level(logging<span style="color: #666666">.</span>INFO)
    main([<span style="color: #BA2121">&quot;--path&quot;</span>, <span style="color: #008000">str</span>(tmp_path), <span style="color: #BA2121">&quot;--force-code&quot;</span>])
    <span style="color: #008000; font-weight: bold">assert</span> tracker[<span style="color: #BA2121">&quot;rank&quot;</span>] <span style="color: #666666">==</span> <span style="color: #666666">1</span>
    <span style="color: #008000; font-weight: bold">assert</span> tracker[<span style="color: #BA2121">&quot;extract&quot;</span>] <span style="color: #666666">==</span> <span style="color: #666666">1</span>
    log <span style="color: #666666">=</span> caplog<span style="color: #666666">.</span>text
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #BA2121">&quot;Code scan triggered: --force-code enabled&quot;</span> <span style="color: #AA22FF; font-weight: bold">in</span> log
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #BA2121">&quot;Pass 1 complete: no sections missing&quot;</span> <span style="color: #AA22FF; font-weight: bold">in</span> log
</code></pre>
<details>
<summary>Subfunction: fake_rank(root: Path, patterns: list[str]) -&gt; list[Path]</summary>
<h4 id="fake_rank">fake_rank(root: Path, patterns: list[str]) -&gt; list[Path]</h4>
<p>The function `fake_rank` takes a root path and a list of patterns as input parameters. It increments a global or shared counter tracked by `tracker[&quot;rank&quot;]` and returns a list containing a single Path object pointing to a file named &quot;script.py&quot; located within a temporary directory identified by `tmp_path`. The function appears to be a placeholder or mock implementation, likely used for testing or demonstration purposes, as it does not utilize the input parameters in its logic.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">fake_rank</span>(root: Path, patterns: <span style="color: #008000">list</span>[<span style="color: #008000">str</span>]) <span style="color: #666666">-&gt;</span> <span style="color: #008000">list</span>[Path]:
        tracker[<span style="color: #BA2121">&quot;rank&quot;</span>] <span style="color: #666666">+=</span> <span style="color: #666666">1</span>
        <span style="color: #008000; font-weight: bold">return</span> [tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;script.py&quot;</span>]
</code></pre>
</details>
<details>
<summary>Subfunction: fake_extract(files: Iterable[Path], *, max_files: int, time_budget: int, max_bytes: int) -&gt; dict[Path, str]</summary>
<h4 id="fake_extract">fake_extract(files: Iterable[Path], *, max_files: int, time_budget: int, max_bytes: int) -&gt; dict[Path, str]</h4>
<p>The function `fake_extract` takes an iterable of file paths, along with parameters limiting the number of files, time budget, and maximum bytes. It increments a counter in the global `tracker` dictionary under the key &quot;extract&quot;, then returns a dictionary mapping the first file in the input iterable to the string &quot;code&quot;. The function does not actually process or read the files; it provides a placeholder implementation for extraction.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">fake_extract</span>(
        files: Iterable[Path], <span style="color: #666666">*</span>, max_files: <span style="color: #008000">int</span>, time_budget: <span style="color: #008000">int</span>, max_bytes: <span style="color: #008000">int</span>
    ) <span style="color: #666666">-&gt;</span> <span style="color: #008000">dict</span>[Path, <span style="color: #008000">str</span>]:
        tracker[<span style="color: #BA2121">&quot;extract&quot;</span>] <span style="color: #666666">+=</span> <span style="color: #666666">1</span>
        <span style="color: #008000; font-weight: bold">return</span> {<span style="color: #008000">next</span>(<span style="color: #008000">iter</span>(files)): <span style="color: #BA2121">&quot;code&quot;</span>}
</code></pre>
</details>
<h3 id="test_custom_title_and_filename">test_custom_title_and_filename(tmp_path: Path, monkeypatch: pytest.MonkeyPatch) -&gt; None</h3>
<p>This function tests the generation of documentation with a custom title and filename. It creates a temporary test fixture, mocks the LLM client, and invokes the main documentation generation process with a specified title &quot;Fancy Guide&quot;. It then verifies that the output HTML file and evidence JSON file are created in the temporary path, and checks that the generated HTML contains the expected heading tag with the custom title.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">test_custom_title_and_filename</span>(tmp_path: Path, monkeypatch: pytest<span style="color: #666666">.</span>MonkeyPatch) <span style="color: #666666">-&gt;</span> <span style="color: #008000; font-weight: bold">None</span>:
    _create_fixture(tmp_path)
    monkeypatch<span style="color: #666666">.</span>setattr(explaincode, <span style="color: #BA2121">&quot;LLMClient&quot;</span>, _mock_llm_client)
    main([<span style="color: #BA2121">&quot;--path&quot;</span>, <span style="color: #008000">str</span>(tmp_path), <span style="color: #BA2121">&quot;--title&quot;</span>, <span style="color: #BA2121">&quot;Fancy Guide&quot;</span>])
    out_file <span style="color: #666666">=</span> tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;fancy_guide.html&quot;</span>
    evidence_file <span style="color: #666666">=</span> tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;fancy_guide_evidence.json&quot;</span>
    <span style="color: #008000; font-weight: bold">assert</span> out_file<span style="color: #666666">.</span>exists()
    <span style="color: #008000; font-weight: bold">assert</span> evidence_file<span style="color: #666666">.</span>exists()
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #BA2121">&quot;&lt;h1&gt;Fancy Guide&lt;/h1&gt;&quot;</span> <span style="color: #AA22FF; font-weight: bold">in</span> out_file<span style="color: #666666">.</span>read_text(encoding<span style="color: #666666">=</span><span style="color: #BA2121">&quot;utf-8&quot;</span>)
</code></pre>
<h3 id="test_insert_into_index">test_insert_into_index(tmp_path: Path, monkeypatch: pytest.MonkeyPatch) -&gt; None</h3>
<p>The function `test_insert_into_index` tests the functionality of inserting a link into an existing HTML index file during documentation generation. It creates a temporary directory structure with fixture files, initializes an output directory, and sets up a mock LLM client. The test then runs the main documentation generation process with the `--insert-into-index` flag, which should modify the index.html file to include a link to &quot;user_manual.html&quot;. Finally, it verifies that the expected link is present in the modified HTML content.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">test_insert_into_index</span>(tmp_path: Path, monkeypatch: pytest<span style="color: #666666">.</span>MonkeyPatch) <span style="color: #666666">-&gt;</span> <span style="color: #008000; font-weight: bold">None</span>:
    _create_fixture(tmp_path)
    out_dir <span style="color: #666666">=</span> tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;out&quot;</span>
    out_dir<span style="color: #666666">.</span>mkdir()
    index <span style="color: #666666">=</span> out_dir <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;index.html&quot;</span>
    index<span style="color: #666666">.</span>write_text(<span style="color: #BA2121">&quot;&lt;html&gt;&lt;body&gt;&lt;ul&gt;&lt;/ul&gt;&lt;/body&gt;&lt;/html&gt;&quot;</span>, encoding<span style="color: #666666">=</span><span style="color: #BA2121">&quot;utf-8&quot;</span>)
    monkeypatch<span style="color: #666666">.</span>setattr(explaincode, <span style="color: #BA2121">&quot;LLMClient&quot;</span>, _mock_llm_client)
    main([<span style="color: #BA2121">&quot;--path&quot;</span>, <span style="color: #008000">str</span>(tmp_path), <span style="color: #BA2121">&quot;--output&quot;</span>, <span style="color: #008000">str</span>(out_dir), <span style="color: #BA2121">&quot;--insert-into-index&quot;</span>])
    html <span style="color: #666666">=</span> index<span style="color: #666666">.</span>read_text(encoding<span style="color: #666666">=</span><span style="color: #BA2121">&quot;utf-8&quot;</span>)
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #BA2121">&#39;&lt;a href=&quot;user_manual.html&quot;&gt;User Manual&lt;/a&gt;&#39;</span> <span style="color: #AA22FF; font-weight: bold">in</span> html
</code></pre>
<h3 id="test_docs_index_default_and_injection">test_docs_index_default_and_injection(tmp_path: Path, monkeypatch: pytest.MonkeyPatch) -&gt; None</h3>
<p>This function tests the default behavior and injection functionality of documentation indexing. It creates a temporary directory structure with a fixture, sets up an HTML index file with a navigation element, and mocks the LLM client. After running the main documentation generation process with the `--insert-into-index` flag, it verifies that the generated manual HTML file and evidence JSON file are created. The test also checks that the navigation element in the index file contains a link to the generated manual file.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">test_docs_index_default_and_injection</span>(
    tmp_path: Path, monkeypatch: pytest<span style="color: #666666">.</span>MonkeyPatch
) <span style="color: #666666">-&gt;</span> <span style="color: #008000; font-weight: bold">None</span>:
    _create_fixture(tmp_path)
    docs_dir <span style="color: #666666">=</span> tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;docs&quot;</span>
    docs_dir<span style="color: #666666">.</span>mkdir()
    (docs_dir <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;index.html&quot;</span>)<span style="color: #666666">.</span>write_text(<span style="color: #BA2121">&quot;&lt;html&gt;&lt;body&gt;&lt;nav&gt;&lt;/nav&gt;&lt;/body&gt;&lt;/html&gt;&quot;</span>, encoding<span style="color: #666666">=</span><span style="color: #BA2121">&quot;utf-8&quot;</span>)
    monkeypatch<span style="color: #666666">.</span>setattr(explaincode, <span style="color: #BA2121">&quot;LLMClient&quot;</span>, _mock_llm_client)
    main([<span style="color: #BA2121">&quot;--path&quot;</span>, <span style="color: #008000">str</span>(tmp_path), <span style="color: #BA2121">&quot;--insert-into-index&quot;</span>])
    manual <span style="color: #666666">=</span> docs_dir <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;user_manual.html&quot;</span>
    evidence <span style="color: #666666">=</span> docs_dir <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;user_manual_evidence.json&quot;</span>
    <span style="color: #008000; font-weight: bold">assert</span> manual<span style="color: #666666">.</span>exists()
    <span style="color: #008000; font-weight: bold">assert</span> evidence<span style="color: #666666">.</span>exists()
    soup <span style="color: #666666">=</span> BeautifulSoup((docs_dir <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;index.html&quot;</span>)<span style="color: #666666">.</span>read_text(encoding<span style="color: #666666">=</span><span style="color: #BA2121">&quot;utf-8&quot;</span>), <span style="color: #BA2121">&quot;html.parser&quot;</span>)
    nav <span style="color: #666666">=</span> soup<span style="color: #666666">.</span>find(<span style="color: #BA2121">&quot;nav&quot;</span>)
    <span style="color: #008000; font-weight: bold">assert</span> nav <span style="color: #AA22FF; font-weight: bold">is</span> <span style="color: #AA22FF; font-weight: bold">not</span> <span style="color: #008000; font-weight: bold">None</span>
    first <span style="color: #666666">=</span> nav<span style="color: #666666">.</span>find(<span style="color: #BA2121">&quot;a&quot;</span>)
    <span style="color: #008000; font-weight: bold">assert</span> first <span style="color: #AA22FF; font-weight: bold">and</span> first[<span style="color: #BA2121">&quot;href&quot;</span>] <span style="color: #666666">==</span> <span style="color: #BA2121">&quot;user_manual.html&quot;</span>
</code></pre>
<h3 id="test_insert_into_root_index">test_insert_into_root_index(tmp_path: Path, monkeypatch: pytest.MonkeyPatch) -&gt; None</h3>
<p>Tests the functionality of inserting a generated documentation file into the root index.html file. It creates a test fixture, sets up a mock LLM client, runs the main function with the --insert-into-index flag, and verifies that the user manual HTML and evidence files are created. It also checks that the navigation element in the index.html file contains a link to the generated documentation file.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">test_insert_into_root_index</span>(tmp_path: Path, monkeypatch: pytest<span style="color: #666666">.</span>MonkeyPatch) <span style="color: #666666">-&gt;</span> <span style="color: #008000; font-weight: bold">None</span>:
    _create_fixture(tmp_path)
    (tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;index.html&quot;</span>)<span style="color: #666666">.</span>write_text(<span style="color: #BA2121">&quot;&lt;html&gt;&lt;body&gt;&lt;nav&gt;&lt;/nav&gt;&lt;/body&gt;&lt;/html&gt;&quot;</span>, encoding<span style="color: #666666">=</span><span style="color: #BA2121">&quot;utf-8&quot;</span>)
    monkeypatch<span style="color: #666666">.</span>setattr(explaincode, <span style="color: #BA2121">&quot;LLMClient&quot;</span>, _mock_llm_client)
    main([<span style="color: #BA2121">&quot;--path&quot;</span>, <span style="color: #008000">str</span>(tmp_path), <span style="color: #BA2121">&quot;--insert-into-index&quot;</span>])
    manual <span style="color: #666666">=</span> tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;docs&quot;</span> <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;user_manual.html&quot;</span>
    evidence <span style="color: #666666">=</span> tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;docs&quot;</span> <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;user_manual_evidence.json&quot;</span>
    <span style="color: #008000; font-weight: bold">assert</span> manual<span style="color: #666666">.</span>exists()
    <span style="color: #008000; font-weight: bold">assert</span> evidence<span style="color: #666666">.</span>exists()
    soup <span style="color: #666666">=</span> BeautifulSoup((tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;index.html&quot;</span>)<span style="color: #666666">.</span>read_text(encoding<span style="color: #666666">=</span><span style="color: #BA2121">&quot;utf-8&quot;</span>), <span style="color: #BA2121">&quot;html.parser&quot;</span>)
    nav <span style="color: #666666">=</span> soup<span style="color: #666666">.</span>find(<span style="color: #BA2121">&quot;nav&quot;</span>)
    <span style="color: #008000; font-weight: bold">assert</span> nav <span style="color: #AA22FF; font-weight: bold">is</span> <span style="color: #AA22FF; font-weight: bold">not</span> <span style="color: #008000; font-weight: bold">None</span>
    first <span style="color: #666666">=</span> nav<span style="color: #666666">.</span>find(<span style="color: #BA2121">&quot;a&quot;</span>)
    <span style="color: #008000; font-weight: bold">assert</span> first <span style="color: #AA22FF; font-weight: bold">and</span> first[<span style="color: #BA2121">&quot;href&quot;</span>] <span style="color: #666666">==</span> <span style="color: #BA2121">&quot;docs/user_manual.html&quot;</span>
</code></pre>
<h3 id="test_chunking_triggers_multiple_calls_and_logs">test_chunking_triggers_multiple_calls_and_logs(tmp_path: Path, capsys: pytest.CaptureFixture[str]) -&gt; None</h3>
<p>This function tests the behavior of automatic chunking during manual summarization, ensuring that multiple calls are made to the LLM when text is split into chunks. It verifies that the correct system prompts are used for both chunking and merging operations, checks that the final result is correctly assembled, and confirms that logging messages are generated to indicate chunking and merging progress. The test uses a dummy client to simulate LLM interactions and a response cache to store results. It validates the sequence of calls, the content and prompts used in each call, and the output logged during the process.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">test_chunking_triggers_multiple_calls_and_logs</span>(
    tmp_path: Path, capsys: pytest<span style="color: #666666">.</span>CaptureFixture[<span style="color: #008000">str</span>]
) <span style="color: #666666">-&gt;</span> <span style="color: #008000; font-weight: bold">None</span>:
    paragraph1 <span style="color: #666666">=</span> <span style="color: #BA2121">&quot;aaa &quot;</span> <span style="color: #666666">*</span> <span style="color: #666666">2000</span>
    paragraph2 <span style="color: #666666">=</span> <span style="color: #BA2121">&quot;bbb &quot;</span> <span style="color: #666666">*</span> <span style="color: #666666">2000</span>
    text <span style="color: #666666">=</span> <span style="color: #BA2121">&quot;</span><span style="color: #AA5D1F; font-weight: bold">\n\n</span><span style="color: #BA2121">&quot;</span><span style="color: #666666">.</span>join([paragraph1, paragraph2])

    <span style="color: #008000; font-weight: bold">class</span> <span style="color: #0000FF; font-weight: bold">Dummy</span>:
        <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">__init__</span>(<span style="color: #008000">self</span>) <span style="color: #666666">-&gt;</span> <span style="color: #008000; font-weight: bold">None</span>:
            <span style="color: #008000">self</span><span style="color: #666666">.</span>calls: <span style="color: #008000">list</span>[<span style="color: #008000">dict</span>] <span style="color: #666666">=</span> []

        <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">summarize</span>(<span style="color: #008000">self</span>, text: <span style="color: #008000">str</span>, prompt_type: <span style="color: #008000">str</span>, system_prompt: <span style="color: #008000">str</span> <span style="color: #666666">=</span> <span style="color: #BA2121">&quot;&quot;</span>) <span style="color: #666666">-&gt;</span> <span style="color: #008000">str</span>:
            <span style="color: #008000">self</span><span style="color: #666666">.</span>calls<span style="color: #666666">.</span>append(
                {<span style="color: #BA2121">&quot;text&quot;</span>: text, <span style="color: #BA2121">&quot;prompt_type&quot;</span>: prompt_type, <span style="color: #BA2121">&quot;system_prompt&quot;</span>: system_prompt}
            )
            <span style="color: #008000; font-weight: bold">if</span> system_prompt <span style="color: #666666">==</span> explaincode<span style="color: #666666">.</span>MERGE_SYSTEM_PROMPT:
                <span style="color: #008000; font-weight: bold">return</span> <span style="color: #BA2121">&quot;final&quot;</span>
            <span style="color: #008000; font-weight: bold">return</span> text<span style="color: #666666">.</span>split()[<span style="color: #666666">0</span>]

    client <span style="color: #666666">=</span> Dummy()
    cache <span style="color: #666666">=</span> ResponseCache(<span style="color: #008000">str</span>(tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;cache.json&quot;</span>))
    logging<span style="color: #666666">.</span>basicConfig(stream<span style="color: #666666">=</span>sys<span style="color: #666666">.</span>stdout, level<span style="color: #666666">=</span>logging<span style="color: #666666">.</span>DEBUG, force<span style="color: #666666">=</span><span style="color: #008000; font-weight: bold">True</span>)
    result <span style="color: #666666">=</span> manual_utils<span style="color: #666666">.</span>_summarize_manual(
        client, cache, text, chunking<span style="color: #666666">=</span><span style="color: #BA2121">&quot;auto&quot;</span>, source<span style="color: #666666">=</span><span style="color: #BA2121">&quot;src&quot;</span>
    )

    <span style="color: #008000; font-weight: bold">assert</span> result <span style="color: #666666">==</span> <span style="color: #BA2121">&quot;final&quot;</span>
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #008000">len</span>(client<span style="color: #666666">.</span>calls) <span style="color: #666666">==</span> <span style="color: #666666">3</span>
    chunk_calls <span style="color: #666666">=</span> client<span style="color: #666666">.</span>calls[:<span style="color: #666666">-1</span>]
    merge_call <span style="color: #666666">=</span> client<span style="color: #666666">.</span>calls[<span style="color: #666666">-1</span>]
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #008000">all</span>(c[<span style="color: #BA2121">&quot;system_prompt&quot;</span>] <span style="color: #666666">==</span> explaincode<span style="color: #666666">.</span>CHUNK_SYSTEM_PROMPT <span style="color: #008000; font-weight: bold">for</span> c <span style="color: #AA22FF; font-weight: bold">in</span> chunk_calls)
    <span style="color: #008000; font-weight: bold">assert</span> merge_call[<span style="color: #BA2121">&quot;system_prompt&quot;</span>] <span style="color: #666666">==</span> explaincode<span style="color: #666666">.</span>MERGE_SYSTEM_PROMPT
    <span style="color: #008000; font-weight: bold">assert</span> merge_call[<span style="color: #BA2121">&quot;text&quot;</span>] <span style="color: #666666">==</span> <span style="color: #BA2121">&quot;aaa</span><span style="color: #AA5D1F; font-weight: bold">\n\n</span><span style="color: #BA2121">bbb&quot;</span>

    out <span style="color: #666666">=</span> capsys<span style="color: #666666">.</span>readouterr()<span style="color: #666666">.</span>out
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #BA2121">&quot;Chunk 1/2 from src&quot;</span> <span style="color: #AA22FF; font-weight: bold">in</span> out
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #BA2121">&quot;Merged LLM response length&quot;</span> <span style="color: #AA22FF; font-weight: bold">in</span> out
</code></pre>
<h3 id="test_chunk_edit_hook_applied">test_chunk_edit_hook_applied(tmp_path: Path) -&gt; None</h3>
<p>This function tests the application of a chunk editing hook during manual summarization. It creates a test scenario with two long paragraphs of text, then defines a dummy client that tracks calls made during summarization. A hook function is defined to convert chunks to uppercase. The test invokes the `_summarize_manual` utility with automatic chunking and the defined hook, expecting the final result to be &quot;final&quot; and the last call&#x27;s text to be &quot;AAA\n\nBBB&quot; after processing. The test verifies both the correct application of the hook and the expected output of the summarization process.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">test_chunk_edit_hook_applied</span>(tmp_path: Path) <span style="color: #666666">-&gt;</span> <span style="color: #008000; font-weight: bold">None</span>:
    paragraph1 <span style="color: #666666">=</span> <span style="color: #BA2121">&quot;aaa &quot;</span> <span style="color: #666666">*</span> <span style="color: #666666">2000</span>
    paragraph2 <span style="color: #666666">=</span> <span style="color: #BA2121">&quot;bbb &quot;</span> <span style="color: #666666">*</span> <span style="color: #666666">2000</span>
    text <span style="color: #666666">=</span> <span style="color: #BA2121">&quot;</span><span style="color: #AA5D1F; font-weight: bold">\n\n</span><span style="color: #BA2121">&quot;</span><span style="color: #666666">.</span>join([paragraph1, paragraph2])

    <span style="color: #008000; font-weight: bold">class</span> <span style="color: #0000FF; font-weight: bold">Dummy</span>:
        <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">__init__</span>(<span style="color: #008000">self</span>) <span style="color: #666666">-&gt;</span> <span style="color: #008000; font-weight: bold">None</span>:
            <span style="color: #008000">self</span><span style="color: #666666">.</span>calls: <span style="color: #008000">list</span>[<span style="color: #008000">dict</span>] <span style="color: #666666">=</span> []

        <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">summarize</span>(<span style="color: #008000">self</span>, text: <span style="color: #008000">str</span>, prompt_type: <span style="color: #008000">str</span>, system_prompt: <span style="color: #008000">str</span> <span style="color: #666666">=</span> <span style="color: #BA2121">&quot;&quot;</span>) <span style="color: #666666">-&gt;</span> <span style="color: #008000">str</span>:
            <span style="color: #008000">self</span><span style="color: #666666">.</span>calls<span style="color: #666666">.</span>append(
                {<span style="color: #BA2121">&quot;text&quot;</span>: text, <span style="color: #BA2121">&quot;prompt_type&quot;</span>: prompt_type, <span style="color: #BA2121">&quot;system_prompt&quot;</span>: system_prompt}
            )
            <span style="color: #008000; font-weight: bold">if</span> system_prompt <span style="color: #666666">==</span> explaincode<span style="color: #666666">.</span>MERGE_SYSTEM_PROMPT:
                <span style="color: #008000; font-weight: bold">return</span> <span style="color: #BA2121">&quot;final&quot;</span>
            <span style="color: #008000; font-weight: bold">return</span> text<span style="color: #666666">.</span>split()[<span style="color: #666666">0</span>]

    <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">hook</span>(chunks: <span style="color: #008000">list</span>[<span style="color: #008000">str</span>]) <span style="color: #666666">-&gt;</span> <span style="color: #008000">list</span>[<span style="color: #008000">str</span>]:
        <span style="color: #008000; font-weight: bold">return</span> [c<span style="color: #666666">.</span>upper() <span style="color: #008000; font-weight: bold">for</span> c <span style="color: #AA22FF; font-weight: bold">in</span> chunks]

    client <span style="color: #666666">=</span> Dummy()
    cache <span style="color: #666666">=</span> ResponseCache(<span style="color: #008000">str</span>(tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;cache.json&quot;</span>))
    result <span style="color: #666666">=</span> manual_utils<span style="color: #666666">.</span>_summarize_manual(
        client, cache, text, chunking<span style="color: #666666">=</span><span style="color: #BA2121">&quot;auto&quot;</span>, source<span style="color: #666666">=</span><span style="color: #BA2121">&quot;src&quot;</span>, post_chunk_hook<span style="color: #666666">=</span>hook
    )

    <span style="color: #008000; font-weight: bold">assert</span> result <span style="color: #666666">==</span> <span style="color: #BA2121">&quot;final&quot;</span>
    <span style="color: #008000; font-weight: bold">assert</span> client<span style="color: #666666">.</span>calls[<span style="color: #666666">-1</span>][<span style="color: #BA2121">&quot;text&quot;</span>] <span style="color: #666666">==</span> <span style="color: #BA2121">&quot;AAA</span><span style="color: #AA5D1F; font-weight: bold">\n\n</span><span style="color: #BA2121">BBB&quot;</span>
</code></pre>
<details>
<summary>Subfunction: hook(chunks: list[str]) -&gt; list[str]</summary>
<h4 id="hook">hook(chunks: list[str]) -&gt; list[str]</h4>
<p>The function `hook` takes a list of strings as input and returns a new list where each string has been converted to uppercase. It applies the `upper()` method to each element in the input list using a list comprehension.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">hook</span>(chunks: <span style="color: #008000">list</span>[<span style="color: #008000">str</span>]) <span style="color: #666666">-&gt;</span> <span style="color: #008000">list</span>[<span style="color: #008000">str</span>]:
        <span style="color: #008000; font-weight: bold">return</span> [c<span style="color: #666666">.</span>upper() <span style="color: #008000; font-weight: bold">for</span> c <span style="color: #AA22FF; font-weight: bold">in</span> chunks]
</code></pre>
</details>
<h3 id="test_parallel_chunk_summarization">test_parallel_chunk_summarization(tmp_path: Path) -&gt; None</h3>
<p>This function tests the parallel chunk summarization functionality by creating a slow client that introduces a delay during summarization. It uses a large text input with repeated paragraphs and verifies that the summarization completes within a specified time threshold, ensuring that parallel processing is functioning correctly. The test checks that the duration of the summarization process is less than 1.5 times the delay introduced by the slow client, confirming that chunks are processed in parallel rather than sequentially. It utilizes a response cache and the `manual_utils._summarize_manual` function to perform the summarization with automatic chunking.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">test_parallel_chunk_summarization</span>(tmp_path: Path) <span style="color: #666666">-&gt;</span> <span style="color: #008000; font-weight: bold">None</span>:
    paragraph <span style="color: #666666">=</span> <span style="color: #BA2121">&quot;word &quot;</span> <span style="color: #666666">*</span> <span style="color: #666666">2000</span>
    text <span style="color: #666666">=</span> <span style="color: #BA2121">&quot;</span><span style="color: #AA5D1F; font-weight: bold">\n\n</span><span style="color: #BA2121">&quot;</span><span style="color: #666666">.</span>join([paragraph, paragraph])
    delay <span style="color: #666666">=</span> <span style="color: #666666">0.2</span>

    <span style="color: #008000; font-weight: bold">class</span> <span style="color: #0000FF; font-weight: bold">SlowClient</span>:
        <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">summarize</span>(<span style="color: #008000">self</span>, text: <span style="color: #008000">str</span>, prompt_type: <span style="color: #008000">str</span>, system_prompt: <span style="color: #008000">str</span> <span style="color: #666666">=</span> <span style="color: #BA2121">&quot;&quot;</span>) <span style="color: #666666">-&gt;</span> <span style="color: #008000">str</span>:
            <span style="color: #008000; font-weight: bold">if</span> system_prompt <span style="color: #666666">==</span> explaincode<span style="color: #666666">.</span>CHUNK_SYSTEM_PROMPT:
                time<span style="color: #666666">.</span>sleep(delay)
            <span style="color: #008000; font-weight: bold">return</span> <span style="color: #BA2121">&quot;ok&quot;</span>

    client <span style="color: #666666">=</span> SlowClient()
    cache <span style="color: #666666">=</span> ResponseCache(<span style="color: #008000">str</span>(tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;cache.json&quot;</span>))
    start <span style="color: #666666">=</span> time<span style="color: #666666">.</span>perf_counter()
    manual_utils<span style="color: #666666">.</span>_summarize_manual(client, cache, text, chunking<span style="color: #666666">=</span><span style="color: #BA2121">&quot;auto&quot;</span>, source<span style="color: #666666">=</span><span style="color: #BA2121">&quot;src&quot;</span>)
    duration <span style="color: #666666">=</span> time<span style="color: #666666">.</span>perf_counter() <span style="color: #666666">-</span> start
    <span style="color: #008000; font-weight: bold">assert</span> duration <span style="color: #666666">&lt;</span> delay <span style="color: #666666">*</span> <span style="color: #666666">1.5</span>
</code></pre>
<h3 id="test_hierarchical_merge_logged">test_hierarchical_merge_logged(tmp_path: Path, capsys: pytest.CaptureFixture[str]) -&gt; None</h3>
<p>The function `test_hierarchical_merge_logged` tests the hierarchical merging behavior of a manual summarization process. It creates a large text input composed of repeated content, then defines a dummy client class that tracks calls made during summarization. The test uses a `ResponseCache` to store and retrieve responses, configures logging to capture debug output, and invokes the `_summarize_manual` utility with automatic chunking. The test verifies that the final result is &quot;short&quot;, indicating successful hierarchical merging, confirms multiple client calls were made, and ensures that the log output contains the phrase &quot;Hierarchical merge pass&quot;.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">test_hierarchical_merge_logged</span>(
    tmp_path: Path, capsys: pytest<span style="color: #666666">.</span>CaptureFixture[<span style="color: #008000">str</span>]
) <span style="color: #666666">-&gt;</span> <span style="color: #008000; font-weight: bold">None</span>:
    big <span style="color: #666666">=</span> <span style="color: #BA2121">&quot;word &quot;</span> <span style="color: #666666">*</span> <span style="color: #666666">5000</span>
    text <span style="color: #666666">=</span> <span style="color: #BA2121">&quot;</span><span style="color: #AA5D1F; font-weight: bold">\n\n</span><span style="color: #BA2121">&quot;</span><span style="color: #666666">.</span>join([big, big])

    <span style="color: #008000; font-weight: bold">class</span> <span style="color: #0000FF; font-weight: bold">Dummy</span>:
        <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">__init__</span>(<span style="color: #008000">self</span>) <span style="color: #666666">-&gt;</span> <span style="color: #008000; font-weight: bold">None</span>:
            <span style="color: #008000">self</span><span style="color: #666666">.</span>calls: <span style="color: #008000">list</span>[<span style="color: #008000">dict</span>] <span style="color: #666666">=</span> []

        <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">summarize</span>(<span style="color: #008000">self</span>, text: <span style="color: #008000">str</span>, prompt_type: <span style="color: #008000">str</span>, system_prompt: <span style="color: #008000">str</span> <span style="color: #666666">=</span> <span style="color: #BA2121">&quot;&quot;</span>) <span style="color: #666666">-&gt;</span> <span style="color: #008000">str</span>:
            <span style="color: #008000">self</span><span style="color: #666666">.</span>calls<span style="color: #666666">.</span>append(
                {<span style="color: #BA2121">&quot;text&quot;</span>: text, <span style="color: #BA2121">&quot;prompt_type&quot;</span>: prompt_type, <span style="color: #BA2121">&quot;system_prompt&quot;</span>: system_prompt}
            )
            <span style="color: #008000; font-weight: bold">if</span> <span style="color: #008000">len</span>(<span style="color: #008000">self</span><span style="color: #666666">.</span>calls) <span style="color: #666666">&lt;=</span> <span style="color: #666666">2</span>:
                <span style="color: #008000; font-weight: bold">return</span> big
            <span style="color: #008000; font-weight: bold">return</span> <span style="color: #BA2121">&quot;short&quot;</span>

    client <span style="color: #666666">=</span> Dummy()
    cache <span style="color: #666666">=</span> ResponseCache(<span style="color: #008000">str</span>(tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;cache.json&quot;</span>))
    logging<span style="color: #666666">.</span>basicConfig(stream<span style="color: #666666">=</span>sys<span style="color: #666666">.</span>stdout, level<span style="color: #666666">=</span>logging<span style="color: #666666">.</span>DEBUG, force<span style="color: #666666">=</span><span style="color: #008000; font-weight: bold">True</span>)
    result <span style="color: #666666">=</span> manual_utils<span style="color: #666666">.</span>_summarize_manual(
        client, cache, text, chunking<span style="color: #666666">=</span><span style="color: #BA2121">&quot;auto&quot;</span>, source<span style="color: #666666">=</span><span style="color: #BA2121">&quot;src&quot;</span>
    )

    <span style="color: #008000; font-weight: bold">assert</span> result <span style="color: #666666">==</span> <span style="color: #BA2121">&quot;short&quot;</span>
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #008000">len</span>(client<span style="color: #666666">.</span>calls) <span style="color: #666666">&gt;</span> <span style="color: #666666">3</span>
    out <span style="color: #666666">=</span> capsys<span style="color: #666666">.</span>readouterr()<span style="color: #666666">.</span>out
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #BA2121">&quot;Hierarchical merge pass&quot;</span> <span style="color: #AA22FF; font-weight: bold">in</span> out
</code></pre>
<h3 id="test_cached_chunks_reused">test_cached_chunks_reused(tmp_path: Path) -&gt; None</h3>
<p>The function `test_cached_chunks_reused` tests the reuse of cached chunks during manual summarization. It creates a large text consisting of repeated paragraphs and uses a dummy client that tracks calls to a summarization method. The test verifies that when the same text is summarized twice with caching enabled, the second call reuses cached results and does not make additional calls to the summarization method. The test ensures that the `ResponseCache` correctly stores and retrieves responses, preventing redundant processing of identical input chunks. It confirms that the first summarization makes three calls and the second, using the cache, makes zero additional calls.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">test_cached_chunks_reused</span>(tmp_path: Path) <span style="color: #666666">-&gt;</span> <span style="color: #008000; font-weight: bold">None</span>:
    paragraph <span style="color: #666666">=</span> <span style="color: #BA2121">&quot;word &quot;</span> <span style="color: #666666">*</span> <span style="color: #666666">2000</span>
    text <span style="color: #666666">=</span> <span style="color: #BA2121">&quot;</span><span style="color: #AA5D1F; font-weight: bold">\n\n</span><span style="color: #BA2121">&quot;</span><span style="color: #666666">.</span>join([paragraph, paragraph])

    <span style="color: #008000; font-weight: bold">class</span> <span style="color: #0000FF; font-weight: bold">Dummy</span>:
        <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">__init__</span>(<span style="color: #008000">self</span>) <span style="color: #666666">-&gt;</span> <span style="color: #008000; font-weight: bold">None</span>:
            <span style="color: #008000">self</span><span style="color: #666666">.</span>calls: <span style="color: #008000">list</span>[<span style="color: #008000">dict</span>] <span style="color: #666666">=</span> []

        <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">summarize</span>(<span style="color: #008000">self</span>, text: <span style="color: #008000">str</span>, prompt_type: <span style="color: #008000">str</span>, system_prompt: <span style="color: #008000">str</span> <span style="color: #666666">=</span> <span style="color: #BA2121">&quot;&quot;</span>) <span style="color: #666666">-&gt;</span> <span style="color: #008000">str</span>:
            <span style="color: #008000">self</span><span style="color: #666666">.</span>calls<span style="color: #666666">.</span>append(
                {<span style="color: #BA2121">&quot;text&quot;</span>: text, <span style="color: #BA2121">&quot;prompt_type&quot;</span>: prompt_type, <span style="color: #BA2121">&quot;system_prompt&quot;</span>: system_prompt}
            )
            <span style="color: #008000; font-weight: bold">return</span> <span style="color: #BA2121">f&quot;resp</span><span style="color: #A45A77; font-weight: bold">{</span><span style="color: #008000">len</span>(<span style="color: #008000">self</span><span style="color: #666666">.</span>calls)<span style="color: #A45A77; font-weight: bold">}</span><span style="color: #BA2121">&quot;</span>

    cache_file <span style="color: #666666">=</span> tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;cache.json&quot;</span>
    cache <span style="color: #666666">=</span> ResponseCache(<span style="color: #008000">str</span>(cache_file))
    client1 <span style="color: #666666">=</span> Dummy()
    result1 <span style="color: #666666">=</span> manual_utils<span style="color: #666666">.</span>_summarize_manual(
        client1, cache, text, chunking<span style="color: #666666">=</span><span style="color: #BA2121">&quot;auto&quot;</span>, source<span style="color: #666666">=</span><span style="color: #BA2121">&quot;src&quot;</span>
    )
    <span style="color: #008000; font-weight: bold">assert</span> result1 <span style="color: #666666">==</span> <span style="color: #BA2121">&quot;resp3&quot;</span>
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #008000">len</span>(client1<span style="color: #666666">.</span>calls) <span style="color: #666666">==</span> <span style="color: #666666">3</span>

    client2 <span style="color: #666666">=</span> Dummy()
    cache2 <span style="color: #666666">=</span> ResponseCache(<span style="color: #008000">str</span>(cache_file))
    result2 <span style="color: #666666">=</span> manual_utils<span style="color: #666666">.</span>_summarize_manual(
        client2, cache2, text, chunking<span style="color: #666666">=</span><span style="color: #BA2121">&quot;auto&quot;</span>, source<span style="color: #666666">=</span><span style="color: #BA2121">&quot;src&quot;</span>
    )
    <span style="color: #008000; font-weight: bold">assert</span> result2 <span style="color: #666666">==</span> <span style="color: #BA2121">&quot;resp3&quot;</span>
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #008000">len</span>(client2<span style="color: #666666">.</span>calls) <span style="color: #666666">==</span> <span style="color: #666666">0</span>
</code></pre>
<h3 id="test_chunking_none_no_llm_calls">test_chunking_none_no_llm_calls(tmp_path: Path, monkeypatch: pytest.MonkeyPatch) -&gt; None</h3>
<p>This function tests the chunking behavior of the documentation generation process when set to &quot;none&quot; and ensures no LLM calls are made. It creates a large text file, patches the `LLMClient` to capture calls, and verifies that the system prompt contains &quot;Overview&quot; in the first call. The test confirms that with `--chunking none`, the tool processes the content without invoking the language model.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">test_chunking_none_no_llm_calls</span>(tmp_path: Path, monkeypatch: pytest<span style="color: #666666">.</span>MonkeyPatch) <span style="color: #666666">-&gt;</span> <span style="color: #008000; font-weight: bold">None</span>:
    big_text <span style="color: #666666">=</span> <span style="color: #BA2121">&quot;data &quot;</span> <span style="color: #666666">*</span> <span style="color: #666666">5000</span>
    (tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;README.md&quot;</span>)<span style="color: #666666">.</span>write_text(<span style="color: #BA2121">&quot;# Overview</span><span style="color: #AA5D1F; font-weight: bold">\n</span><span style="color: #BA2121">&quot;</span> <span style="color: #666666">+</span> big_text, encoding<span style="color: #666666">=</span><span style="color: #BA2121">&quot;utf-8&quot;</span>)

    <span style="color: #008000; font-weight: bold">class</span> <span style="color: #0000FF; font-weight: bold">Dummy</span>:
        <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">__init__</span>(<span style="color: #008000">self</span>) <span style="color: #666666">-&gt;</span> <span style="color: #008000; font-weight: bold">None</span>:
            <span style="color: #008000">self</span><span style="color: #666666">.</span>calls: <span style="color: #008000">list</span>[<span style="color: #008000">dict</span>] <span style="color: #666666">=</span> []

        <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">summarize</span>(<span style="color: #008000">self</span>, text: <span style="color: #008000">str</span>, prompt_type: <span style="color: #008000">str</span>, system_prompt: <span style="color: #008000">str</span> <span style="color: #666666">=</span> <span style="color: #BA2121">&quot;&quot;</span>) <span style="color: #666666">-&gt;</span> <span style="color: #008000">str</span>:
            <span style="color: #008000">self</span><span style="color: #666666">.</span>calls<span style="color: #666666">.</span>append(
                {<span style="color: #BA2121">&quot;text&quot;</span>: text, <span style="color: #BA2121">&quot;prompt_type&quot;</span>: prompt_type, <span style="color: #BA2121">&quot;system_prompt&quot;</span>: system_prompt}
            )
            <span style="color: #008000; font-weight: bold">return</span> <span style="color: #BA2121">&quot;done&quot;</span>

    dummy <span style="color: #666666">=</span> Dummy()
    monkeypatch<span style="color: #666666">.</span>setattr(explaincode, <span style="color: #BA2121">&quot;LLMClient&quot;</span>, <span style="color: #008000; font-weight: bold">lambda</span>: dummy)
    main([<span style="color: #BA2121">&quot;--path&quot;</span>, <span style="color: #008000">str</span>(tmp_path), <span style="color: #BA2121">&quot;--chunking&quot;</span>, <span style="color: #BA2121">&quot;none&quot;</span>])

    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #008000">len</span>(dummy<span style="color: #666666">.</span>calls) <span style="color: #666666">==</span> <span style="color: #666666">5</span>
    call <span style="color: #666666">=</span> dummy<span style="color: #666666">.</span>calls[<span style="color: #666666">0</span>]
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #BA2121">&quot;Overview&quot;</span> <span style="color: #AA22FF; font-weight: bold">in</span> call[<span style="color: #BA2121">&quot;system_prompt&quot;</span>]
</code></pre>
<h3 id="test_llm_generate_manual_sanitizes_and_caches">test_llm_generate_manual_sanitizes_and_caches(tmp_path: Path, monkeypatch: pytest.MonkeyPatch) -&gt; None</h3>
<p>The function `test_llm_generate_manual_sanitizes_and_caches` tests the behavior of the `llm_generate_manual` function in the `explaincode` module. It verifies that the output from the LLM is sanitized by removing specific phrases and that the results are properly cached.

The test sets up a mock environment with:


The test then calls `llm_generate_manual` with these parameters, checks that the returned manual text does not contain the unwanted phrases, and verifies that:
1. The output is sanitized by ensuring the phrases are absent from the result
2. The generated prompt is correctly constructed for mapping evidence to sections
3. The response is cached using a key derived from the section name and prompt
4. The cached entry exists and also does not contain the unwanted phrases

The test ensures that both sanitization and caching functionality work as expected in the documentation generation pipeline.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">test_llm_generate_manual_sanitizes_and_caches</span>(tmp_path: Path, monkeypatch: pytest<span style="color: #666666">.</span>MonkeyPatch) <span style="color: #666666">-&gt;</span> <span style="color: #008000; font-weight: bold">None</span>:
    docs <span style="color: #666666">=</span> {Path(<span style="color: #BA2121">&quot;readme.md&quot;</span>): <span style="color: #BA2121">&quot;# Overview</span><span style="color: #AA5D1F; font-weight: bold">\n</span><span style="color: #BA2121">Example&quot;</span>}
    cache <span style="color: #666666">=</span> ResponseCache(<span style="color: #008000">str</span>(tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;cache.json&quot;</span>))
    client <span style="color: #666666">=</span> explaincode<span style="color: #666666">.</span>LLMClient(<span style="color: #BA2121">&quot;http://fake&quot;</span>)

    <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">fake_summarize</span>(prompt: <span style="color: #008000">str</span>, prompt_type: <span style="color: #008000">str</span>, system_prompt: <span style="color: #008000">str</span> <span style="color: #666666">=</span> <span style="color: #BA2121">&quot;&quot;</span>) <span style="color: #666666">-&gt;</span> <span style="color: #008000">str</span>:
        <span style="color: #008000; font-weight: bold">return</span> (
            <span style="color: #BA2121">&quot;You are a documentation engine. Summarize the following.</span><span style="color: #AA5D1F; font-weight: bold">\n</span><span style="color: #BA2121">&quot;</span>
            <span style="color: #BA2121">&quot;It prints output.&quot;</span>
        )

    monkeypatch<span style="color: #666666">.</span>setattr(client, <span style="color: #BA2121">&quot;summarize&quot;</span>, fake_summarize)
    manual, _, _ <span style="color: #666666">=</span> explaincode<span style="color: #666666">.</span>llm_generate_manual(docs, client, cache, chunking<span style="color: #666666">=</span><span style="color: #BA2121">&quot;none&quot;</span>)
    lower <span style="color: #666666">=</span> manual<span style="color: #666666">.</span>lower()
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #BA2121">&quot;documentation engine&quot;</span> <span style="color: #AA22FF; font-weight: bold">not</span> <span style="color: #AA22FF; font-weight: bold">in</span> lower
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #BA2121">&quot;summarize the following&quot;</span> <span style="color: #AA22FF; font-weight: bold">not</span> <span style="color: #AA22FF; font-weight: bold">in</span> lower

    section_map, _ <span style="color: #666666">=</span> explaincode<span style="color: #666666">.</span>map_evidence_to_sections(docs)
    entries <span style="color: #666666">=</span> section_map[<span style="color: #BA2121">&quot;Overview&quot;</span>]
    context <span style="color: #666666">=</span> <span style="color: #BA2121">&quot;</span><span style="color: #AA5D1F; font-weight: bold">\n\n</span><span style="color: #BA2121">&quot;</span><span style="color: #666666">.</span>join(snippet <span style="color: #008000; font-weight: bold">for</span> _, snippet <span style="color: #AA22FF; font-weight: bold">in</span> entries)
    prompt <span style="color: #666666">=</span> (
        <span style="color: #BA2121">&quot;Write the &#39;Overview&#39; section of a user manual using the &quot;</span>
        <span style="color: #BA2121">&quot;following documentation snippets.</span><span style="color: #AA5D1F; font-weight: bold">\n\n</span><span style="color: #BA2121">&quot;</span> <span style="color: #666666">+</span> context
    )
    key <span style="color: #666666">=</span> ResponseCache<span style="color: #666666">.</span>make_key(<span style="color: #BA2121">&quot;section:Overview&quot;</span>, prompt)
    cached <span style="color: #666666">=</span> cache<span style="color: #666666">.</span>get(key)
    <span style="color: #008000; font-weight: bold">assert</span> cached <span style="color: #AA22FF; font-weight: bold">is</span> <span style="color: #AA22FF; font-weight: bold">not</span> <span style="color: #008000; font-weight: bold">None</span>
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #BA2121">&quot;documentation engine&quot;</span> <span style="color: #AA22FF; font-weight: bold">not</span> <span style="color: #AA22FF; font-weight: bold">in</span> cached<span style="color: #666666">.</span>lower()
</code></pre>
<details>
<summary>Subfunction: fake_summarize(prompt: str, prompt_type: str, system_prompt: str=&#x27;&#x27;) -&gt; str</summary>
<h4 id="fake_summarize">fake_summarize(prompt: str, prompt_type: str, system_prompt: str=&#x27;&#x27;) -&gt; str</h4>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">fake_summarize</span>(prompt: <span style="color: #008000">str</span>, prompt_type: <span style="color: #008000">str</span>, system_prompt: <span style="color: #008000">str</span> <span style="color: #666666">=</span> <span style="color: #BA2121">&quot;&quot;</span>) <span style="color: #666666">-&gt;</span> <span style="color: #008000">str</span>:
        <span style="color: #008000; font-weight: bold">return</span> (
            <span style="color: #BA2121">&quot;You are a documentation engine. Summarize the following.</span><span style="color: #AA5D1F; font-weight: bold">\n</span><span style="color: #BA2121">&quot;</span>
            <span style="color: #BA2121">&quot;It prints output.&quot;</span>
        )
</code></pre>
</details>
    </div>
    <script src="static/toggle.js"></script>
</body>
</html>
