<!-- Generated by DocGen-LM -->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>test_explaincode</title>
    <link rel="stylesheet" href="static/style.css">
</head>
<body>
    <button id="sidebar-toggle">Menu</button>
    <div class="sidebar">
        <h2>Navigation</h2>
        <ul><li><a href="index.html"><strong>üè† Project Overview</strong></a></li><li><a href="cache.html">cache</a></li><li><a href="chunk_utils.html">chunk_utils</a></li><li><a href="docgenerator.html">docgenerator</a></li><li><a href="explaincode.html">explaincode</a></li><li><a href="gui_wrapper.html">gui_wrapper</a></li><li><a href="html_writer.html">html_writer</a></li><li><a href="llm_client.html">llm_client</a></li><li><a href="manual_utils.html">manual_utils</a></li><li><a href="parser_cpp.html">parser_cpp</a></li><li><a href="parser_java.html">parser_java</a></li><li><a href="parser_matlab.html">parser_matlab</a></li><li><a href="parser_python.html">parser_python</a></li><li><a href="retrofit_sidebar.html">retrofit_sidebar</a></li><li><a href="reviewer.html">reviewer</a></li><li><a href="sanitize_docs.html">sanitize_docs</a></li><li><a href="scanner.html">scanner</a></li><li><a href="setup.html">setup</a></li><li><a href="summarize_utils.html">summarize_utils</a></li><li><details><summary>tests</summary><ul><li><a href="test_cache.html">test_cache</a></li><li><a href="test_chunk_utils.html">test_chunk_utils</a></li><li><a href="test_docgenerator.html">test_docgenerator</a></li><li><a href="test_docgenerator_subclasses.html">test_docgenerator_subclasses</a></li><li><a href="test_explaincode.html">test_explaincode</a></li><li><a href="test_html_writer.html">test_html_writer</a></li><li><a href="test_integration.html">test_integration</a></li><li><a href="test_llm_client.html">test_llm_client</a></li><li><a href="test_manual_utils.html">test_manual_utils</a></li><li><a href="test_parser_cpp.html">test_parser_cpp</a></li><li><a href="test_parser_java.html">test_parser_java</a></li><li><a href="test_parser_matlab.html">test_parser_matlab</a></li><li><a href="test_parser_python.html">test_parser_python</a></li><li><a href="test_resume_progress.html">test_resume_progress</a></li><li><a href="test_reviewer.html">test_reviewer</a></li><li><a href="test_sanitize_docs.html">test_sanitize_docs</a></li><li><a href="test_scanner.html">test_scanner</a></li></ul></details></li></ul>
    </div>
    <div class="content">
        <h1>test_explaincode</h1>
        <p>The module provides functions for creating test fixtures, mocking an LLM client, and running tests related to text extraction, HTML rendering, and document processing. It includes tests for extracting text from Markdown, HTML, and DOCX files, rendering HTML with sections and evidence, creating user manuals in both HTML and PDF formats, handling missing dependencies gracefully, and inferring section content when information is missing. Additionally, the module contains test functions for a code documentation tool named `explaincode`, covering aspects such as categorizing code snippets, ranking code files, filling placeholders, skipping code scanning, fallback mechanisms based on flags, and handling large texts through chunking, merging, caching, and logging.</p>
<h2>Functions</h2>
<h3 id="_create_fixture">_create_fixture(tmp_path: Path) -&gt; None</h3>
<p>This function `_create_fixture` creates a temporary directory structure with nested subdirectories and files. It generates an HTML file within the nested directory and writes specific content to a README.md file and a sample JSON file in the root of the temporary path. The HTML file contains basic HTML structure with a heading, while the README.md file includes sections for overview, purpose, problem solving, how to run, inputs, outputs, system requirements, and examples. Additionally, it creates a sample JSON file with some input data.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">_create_fixture</span>(tmp_path: Path) <span style="color: #666666">-&gt;</span> <span style="color: #008000; font-weight: bold">None</span>:
    nested <span style="color: #666666">=</span> tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;subdir&quot;</span> <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;nested&quot;</span>
    nested<span style="color: #666666">.</span>mkdir(parents<span style="color: #666666">=</span><span style="color: #008000; font-weight: bold">True</span>)
    (nested <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;page.html&quot;</span>)<span style="color: #666666">.</span>write_text(
        <span style="color: #BA2121">&quot;&lt;html&gt;&lt;body&gt;&lt;h1&gt;Overview&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;&quot;</span>, encoding<span style="color: #666666">=</span><span style="color: #BA2121">&quot;utf-8&quot;</span>
    )
    content <span style="color: #666666">=</span> textwrap<span style="color: #666666">.</span>dedent(
<span style="color: #bbbbbb">        </span><span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;</span>
<span style="color: #BA2121; font-style: italic">        # Overview</span>
<span style="color: #BA2121; font-style: italic">        Demo project</span>

<span style="color: #BA2121; font-style: italic">        # Purpose &amp; Problem Solving</span>
<span style="color: #BA2121; font-style: italic">        Solves a problem</span>

<span style="color: #BA2121; font-style: italic">        # How to Run</span>
<span style="color: #BA2121; font-style: italic">        Usage: run it</span>

<span style="color: #BA2121; font-style: italic">        # Inputs</span>
<span style="color: #BA2121; font-style: italic">        Input data</span>

<span style="color: #BA2121; font-style: italic">        # Outputs</span>
<span style="color: #BA2121; font-style: italic">        Output data</span>

<span style="color: #BA2121; font-style: italic">        # System Requirements</span>
<span style="color: #BA2121; font-style: italic">        None</span>

<span style="color: #BA2121; font-style: italic">        # Examples</span>
<span style="color: #BA2121; font-style: italic">        Example usage</span>
<span style="color: #BA2121; font-style: italic">        &quot;&quot;&quot;</span>
    )<span style="color: #666666">.</span>strip()
    (tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;README.md&quot;</span>)<span style="color: #666666">.</span>write_text(content, encoding<span style="color: #666666">=</span><span style="color: #BA2121">&quot;utf-8&quot;</span>)
    (tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;sample.json&quot;</span>)<span style="color: #666666">.</span>write_text(<span style="color: #BA2121">&quot;{</span><span style="color: #AA5D1F; font-weight: bold">\&quot;</span><span style="color: #BA2121">input</span><span style="color: #AA5D1F; font-weight: bold">\&quot;</span><span style="color: #BA2121">: </span><span style="color: #AA5D1F; font-weight: bold">\&quot;</span><span style="color: #BA2121">data</span><span style="color: #AA5D1F; font-weight: bold">\&quot;</span><span style="color: #BA2121">}&quot;</span>, encoding<span style="color: #666666">=</span><span style="color: #BA2121">&quot;utf-8&quot;</span>)
</code></pre>
<h3 id="_mock_llm_client">_mock_llm_client() -&gt; object</h3>
<p>The `_mock_llm_client` function returns an instance of a `Dummy` class, which simulates the behavior of an LLM client. This mock object has a `summarize` method that takes three parameters: `text`, `prompt_type`, and `system_prompt`. The `summarize` method returns a predefined string formatted with a simple overview of a demo project, including its purpose, problem-solving approach, execution instructions, inputs, outputs, system requirements, examples, and disclaimer.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">_mock_llm_client</span>() <span style="color: #666666">-&gt;</span> <span style="color: #008000">object</span>:
    <span style="color: #008000; font-weight: bold">class</span> <span style="color: #0000FF; font-weight: bold">Dummy</span>:
        <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">summarize</span>(<span style="color: #008000">self</span>, text: <span style="color: #008000">str</span>, prompt_type: <span style="color: #008000">str</span>, system_prompt: <span style="color: #008000">str</span> <span style="color: #666666">=</span> <span style="color: #BA2121">&quot;&quot;</span>) <span style="color: #666666">-&gt;</span> <span style="color: #008000">str</span>:  <span style="color: #3D7B7B; font-style: italic"># pragma: no cover - simple stub</span>
            <span style="color: #008000; font-weight: bold">return</span> textwrap<span style="color: #666666">.</span>dedent(
<span style="color: #bbbbbb">                </span><span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;</span>
<span style="color: #BA2121; font-style: italic">                Overview: Demo project</span>
<span style="color: #BA2121; font-style: italic">                Purpose &amp; Problem Solving: Solves a problem</span>
<span style="color: #BA2121; font-style: italic">                How to Run: Execute it</span>
<span style="color: #BA2121; font-style: italic">                Inputs: Input data</span>
<span style="color: #BA2121; font-style: italic">                Outputs: Output data</span>
<span style="color: #BA2121; font-style: italic">                System Requirements: None</span>
<span style="color: #BA2121; font-style: italic">                Examples: Example usage</span>
<span style="color: #BA2121; font-style: italic">                &quot;&quot;&quot;</span>
            )<span style="color: #666666">.</span>strip()

    <span style="color: #008000; font-weight: bold">return</span> Dummy()
</code></pre>
<h3 id="test_extract_text_markdown_preserves_headings_and_code">test_extract_text_markdown_preserves_headings_and_code(tmp_path: Path) -&gt; None</h3>
<p>The function `test_extract_text_markdown_preserves_headings_and_code` tests the ability of the `extract_text` function from the `explaincode.py` module to correctly extract and preserve headings and code blocks from a Markdown file. It creates a temporary Markdown file with a title, some text, and a Python code block, then asserts that these elements are present in the extracted text.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">test_extract_text_markdown_preserves_headings_and_code</span>(tmp_path: Path) <span style="color: #666666">-&gt;</span> <span style="color: #008000; font-weight: bold">None</span>:
    content <span style="color: #666666">=</span> <span style="color: #BA2121">&quot;&quot;&quot;</span>
<span style="color: #BA2121"># Title</span>

<span style="color: #BA2121">Text</span>

<span style="color: #BA2121">```python</span>
<span style="color: #BA2121">print(&#39;hi&#39;)</span>
<span style="color: #BA2121">```</span>
<span style="color: #BA2121">&quot;&quot;&quot;</span>
    md <span style="color: #666666">=</span> tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;readme.md&quot;</span>
    md<span style="color: #666666">.</span>write_text(content, encoding<span style="color: #666666">=</span><span style="color: #BA2121">&quot;utf-8&quot;</span>)
    text <span style="color: #666666">=</span> explaincode<span style="color: #666666">.</span>extract_text(md)
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #BA2121">&quot;# Title&quot;</span> <span style="color: #AA22FF; font-weight: bold">in</span> text
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #BA2121">&quot;```python&quot;</span> <span style="color: #AA22FF; font-weight: bold">in</span> text
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #BA2121">&quot;print(&#39;hi&#39;)&quot;</span> <span style="color: #AA22FF; font-weight: bold">in</span> text
</code></pre>
<h3 id="test_extract_text_html_preserves_headings_and_code">test_extract_text_html_preserves_headings_and_code(tmp_path: Path) -&gt; None</h3>
<p>This function `test_extract_text_html_preserves_headings_and_code` is designed to test the ability of the `extract_text` function from the `explaincode.py` module to preserve headings and code blocks when extracting text from HTML files. It creates a temporary HTML file with headings (`&lt;h1&gt;`, `&lt;h2&gt;`) and a code block (`&lt;pre&gt;&lt;code&gt;`). The function then reads this HTML file, extracts the text using `extract_text`, and asserts that the extracted text contains the preserved headings and code block.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">test_extract_text_html_preserves_headings_and_code</span>(tmp_path: Path) <span style="color: #666666">-&gt;</span> <span style="color: #008000; font-weight: bold">None</span>:
    html <span style="color: #666666">=</span> (
        <span style="color: #BA2121">&quot;&lt;html&gt;&lt;body&gt;&lt;h1&gt;Main&lt;/h1&gt;&lt;p&gt;Intro&lt;/p&gt;&quot;</span>
        <span style="color: #BA2121">&quot;&lt;h2&gt;Section&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;print(&#39;hi&#39;)&lt;/code&gt;&lt;/pre&gt;&lt;/body&gt;&lt;/html&gt;&quot;</span>
    )
    page <span style="color: #666666">=</span> tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;page.html&quot;</span>
    page<span style="color: #666666">.</span>write_text(html, encoding<span style="color: #666666">=</span><span style="color: #BA2121">&quot;utf-8&quot;</span>)
    text <span style="color: #666666">=</span> explaincode<span style="color: #666666">.</span>extract_text(page)
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #BA2121">&quot;# Main&quot;</span> <span style="color: #AA22FF; font-weight: bold">in</span> text
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #BA2121">&quot;## Section&quot;</span> <span style="color: #AA22FF; font-weight: bold">in</span> text
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #BA2121">&quot;```&quot;</span> <span style="color: #AA22FF; font-weight: bold">in</span> text <span style="color: #AA22FF; font-weight: bold">and</span> <span style="color: #BA2121">&quot;print(&#39;hi&#39;)&quot;</span> <span style="color: #AA22FF; font-weight: bold">in</span> text
</code></pre>
<h3 id="test_extract_text_docx_preserves_headings">test_extract_text_docx_preserves_headings(tmp_path: Path) -&gt; None</h3>
<p>The function `test_extract_text_docx_preserves_headings` is a unit test for the `extract_text` function from the `explaincode` module. It checks that headings are preserved when extracting text from a DOCX file. The test creates a temporary DOCX file with a heading and a paragraph, saves it to a specified path, and then uses the `extract_text` function to read the content. The extracted text is split into lines, and the first line (which should be the heading) is compared to the expected Markdown format (`# Title`). Additionally, the test verifies that the paragraph text (&quot;Text&quot;) is present in the extracted content.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">test_extract_text_docx_preserves_headings</span>(tmp_path: Path) <span style="color: #666666">-&gt;</span> <span style="color: #008000; font-weight: bold">None</span>:
    <span style="color: #008000; font-weight: bold">try</span>:
        <span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">docx</span> <span style="color: #008000; font-weight: bold">import</span> Document
    <span style="color: #008000; font-weight: bold">except</span> <span style="color: #CB3F38; font-weight: bold">Exception</span>:  <span style="color: #3D7B7B; font-style: italic"># pragma: no cover - dependency missing</span>
        pytest<span style="color: #666666">.</span>skip(<span style="color: #BA2121">&quot;python-docx not installed&quot;</span>)

    doc <span style="color: #666666">=</span> Document()
    doc<span style="color: #666666">.</span>add_heading(<span style="color: #BA2121">&quot;Title&quot;</span>, level<span style="color: #666666">=1</span>)
    doc<span style="color: #666666">.</span>add_paragraph(<span style="color: #BA2121">&quot;Text&quot;</span>)
    path <span style="color: #666666">=</span> tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;doc.docx&quot;</span>
    doc<span style="color: #666666">.</span>save(path)
    text <span style="color: #666666">=</span> explaincode<span style="color: #666666">.</span>extract_text(path)
    <span style="color: #008000; font-weight: bold">assert</span> text<span style="color: #666666">.</span>splitlines()[<span style="color: #666666">0</span>] <span style="color: #666666">==</span> <span style="color: #BA2121">&quot;# Title&quot;</span>
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #BA2121">&quot;Text&quot;</span> <span style="color: #AA22FF; font-weight: bold">in</span> text
</code></pre>
<h3 id="test_render_html_renders_markdown_headings_and_code">test_render_html_renders_markdown_headings_and_code() -&gt; None</h3>
<p>The function `test_render_html_renders_markdown_headings_and_code` tests the rendering of HTML from Markdown headings and code blocks. It creates a dictionary with a section titled &quot;Intro&quot; containing a Markdown heading and a Python code block. The function then uses the `explaincode.render_html` method to generate HTML from this dictionary, specifying &quot;Manual&quot; as the document title. Using BeautifulSoup, it asserts that an `&lt;h1&gt;` element with the text &quot;Title&quot; is present in the rendered HTML. Additionally, it checks that a `&lt;pre&gt;` tag containing a `&lt;code&gt;` block with the text &quot;print(&#x27;hi&#x27;)&quot; exists within the HTML.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">test_render_html_renders_markdown_headings_and_code</span>() <span style="color: #666666">-&gt;</span> <span style="color: #008000; font-weight: bold">None</span>:
    sections <span style="color: #666666">=</span> {
        <span style="color: #BA2121">&quot;Intro&quot;</span>: <span style="color: #BA2121">&quot;# Title</span><span style="color: #AA5D1F; font-weight: bold">\n\n</span><span style="color: #BA2121">```python</span><span style="color: #AA5D1F; font-weight: bold">\n</span><span style="color: #BA2121">print(&#39;hi&#39;)</span><span style="color: #AA5D1F; font-weight: bold">\n</span><span style="color: #BA2121">```&quot;</span>,
    }
    html <span style="color: #666666">=</span> explaincode<span style="color: #666666">.</span>render_html(sections, <span style="color: #BA2121">&quot;Manual&quot;</span>)
    soup <span style="color: #666666">=</span> BeautifulSoup(html, <span style="color: #BA2121">&quot;html.parser&quot;</span>)
    <span style="color: #008000; font-weight: bold">assert</span> soup<span style="color: #666666">.</span>find(<span style="color: #BA2121">&quot;h1&quot;</span>, string<span style="color: #666666">=</span><span style="color: #BA2121">&quot;Title&quot;</span>) <span style="color: #AA22FF; font-weight: bold">is</span> <span style="color: #AA22FF; font-weight: bold">not</span> <span style="color: #008000; font-weight: bold">None</span>
    code <span style="color: #666666">=</span> soup<span style="color: #666666">.</span>find(<span style="color: #BA2121">&quot;pre&quot;</span>)<span style="color: #666666">.</span>find(<span style="color: #BA2121">&quot;code&quot;</span>)
    <span style="color: #008000; font-weight: bold">assert</span> code <span style="color: #AA22FF; font-weight: bold">is</span> <span style="color: #AA22FF; font-weight: bold">not</span> <span style="color: #008000; font-weight: bold">None</span> <span style="color: #AA22FF; font-weight: bold">and</span> <span style="color: #BA2121">&quot;print(&#39;hi&#39;)&quot;</span> <span style="color: #AA22FF; font-weight: bold">in</span> code<span style="color: #666666">.</span>text
</code></pre>
<h3 id="test_render_html_includes_toc_and_sources_block">test_render_html_includes_toc_and_sources_block() -&gt; None</h3>
<p>The function `test_render_html_includes_toc_and_sources_block` is designed to test the HTML rendering process used by the `explaincode` module. It checks if the rendered HTML includes a table of contents (TOC) and a sources block.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">test_render_html_includes_toc_and_sources_block</span>() <span style="color: #666666">-&gt;</span> <span style="color: #008000; font-weight: bold">None</span>:
    sections <span style="color: #666666">=</span> {<span style="color: #BA2121">&quot;Overview&quot;</span>: <span style="color: #BA2121">&quot;&quot;</span>, <span style="color: #BA2121">&quot;How to Run&quot;</span>: <span style="color: #BA2121">&quot;&quot;</span>}
    evidence <span style="color: #666666">=</span> {
        <span style="color: #BA2121">&quot;Overview&quot;</span>: {<span style="color: #BA2121">&quot;evidence&quot;</span>: [{<span style="color: #BA2121">&quot;snippet&quot;</span>: <span style="color: #BA2121">&quot;info&quot;</span>, <span style="color: #BA2121">&quot;file&quot;</span>: <span style="color: #BA2121">&quot;readme.md&quot;</span>}]},
        <span style="color: #BA2121">&quot;How to Run&quot;</span>: {<span style="color: #BA2121">&quot;evidence&quot;</span>: [{<span style="color: #BA2121">&quot;snippet&quot;</span>: <span style="color: #BA2121">&quot;run&quot;</span>, <span style="color: #BA2121">&quot;file&quot;</span>: <span style="color: #BA2121">&quot;run.py&quot;</span>}]},
    }
    html <span style="color: #666666">=</span> explaincode<span style="color: #666666">.</span>render_html(sections, <span style="color: #BA2121">&quot;Manual&quot;</span>, evidence)
    soup <span style="color: #666666">=</span> BeautifulSoup(html, <span style="color: #BA2121">&quot;html.parser&quot;</span>)
    nav <span style="color: #666666">=</span> soup<span style="color: #666666">.</span>find(<span style="color: #BA2121">&quot;nav&quot;</span>)
    <span style="color: #008000; font-weight: bold">assert</span> nav <span style="color: #AA22FF; font-weight: bold">is</span> <span style="color: #AA22FF; font-weight: bold">not</span> <span style="color: #008000; font-weight: bold">None</span> <span style="color: #AA22FF; font-weight: bold">and</span> nav<span style="color: #666666">.</span>find(<span style="color: #BA2121">&quot;a&quot;</span>, href<span style="color: #666666">=</span><span style="color: #BA2121">&quot;#overview&quot;</span>) <span style="color: #AA22FF; font-weight: bold">is</span> <span style="color: #AA22FF; font-weight: bold">not</span> <span style="color: #008000; font-weight: bold">None</span>
    sources_blocks <span style="color: #666666">=</span> soup<span style="color: #666666">.</span>find_all(<span style="color: #BA2121">&quot;div&quot;</span>, class_<span style="color: #666666">=</span><span style="color: #BA2121">&quot;sources&quot;</span>)
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #008000">any</span>(<span style="color: #BA2121">&quot;readme.md&quot;</span> <span style="color: #AA22FF; font-weight: bold">in</span> block<span style="color: #666666">.</span>text <span style="color: #008000; font-weight: bold">for</span> block <span style="color: #AA22FF; font-weight: bold">in</span> sources_blocks)
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #008000">any</span>(<span style="color: #BA2121">&quot;run.py&quot;</span> <span style="color: #AA22FF; font-weight: bold">in</span> block<span style="color: #666666">.</span>text <span style="color: #008000; font-weight: bold">for</span> block <span style="color: #AA22FF; font-weight: bold">in</span> sources_blocks)
</code></pre>
<h3 id="test_html_summary_creation">test_html_summary_creation(tmp_path: Path, monkeypatch: pytest.MonkeyPatch) -&gt; None</h3>
<p>This function `test_html_summary_creation` tests the creation of HTML summaries for a project. It uses a temporary path to create fixtures, mocks an LLM client, runs the main function with specified arguments, and then checks the existence of generated files. The function asserts that a user manual and evidence file are created in the temporary path. It also verifies that the evidence file contains data under the &quot;Overview&quot; key with associated evidence. Additionally, it reads the HTML content from the user manual, ensures that no placeholder text is present, and uses BeautifulSoup to check for the presence of a navigation section with an anchor linking to the overview.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">test_html_summary_creation</span>(tmp_path: Path, monkeypatch: pytest<span style="color: #666666">.</span>MonkeyPatch) <span style="color: #666666">-&gt;</span> <span style="color: #008000; font-weight: bold">None</span>:
    _create_fixture(tmp_path)
    monkeypatch<span style="color: #666666">.</span>setattr(explaincode, <span style="color: #BA2121">&quot;LLMClient&quot;</span>, _mock_llm_client)
    main([<span style="color: #BA2121">&quot;--path&quot;</span>, <span style="color: #008000">str</span>(tmp_path)])
    manual <span style="color: #666666">=</span> tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;user_manual.html&quot;</span>
    evidence <span style="color: #666666">=</span> tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;user_manual_evidence.json&quot;</span>
    <span style="color: #008000; font-weight: bold">assert</span> manual<span style="color: #666666">.</span>exists()
    <span style="color: #008000; font-weight: bold">assert</span> evidence<span style="color: #666666">.</span>exists()
    data <span style="color: #666666">=</span> json<span style="color: #666666">.</span>loads(evidence<span style="color: #666666">.</span>read_text(encoding<span style="color: #666666">=</span><span style="color: #BA2121">&quot;utf-8&quot;</span>))
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #BA2121">&quot;Overview&quot;</span> <span style="color: #AA22FF; font-weight: bold">in</span> data
    <span style="color: #008000; font-weight: bold">assert</span> data[<span style="color: #BA2121">&quot;Overview&quot;</span>][<span style="color: #BA2121">&quot;evidence&quot;</span>]
    html_text <span style="color: #666666">=</span> manual<span style="color: #666666">.</span>read_text(encoding<span style="color: #666666">=</span><span style="color: #BA2121">&quot;utf-8&quot;</span>)
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #BA2121">&quot;No information provided.&quot;</span> <span style="color: #AA22FF; font-weight: bold">not</span> <span style="color: #AA22FF; font-weight: bold">in</span> html_text
    soup <span style="color: #666666">=</span> BeautifulSoup(html_text, <span style="color: #BA2121">&quot;html.parser&quot;</span>)
    nav <span style="color: #666666">=</span> soup<span style="color: #666666">.</span>find(<span style="color: #BA2121">&quot;nav&quot;</span>)
    <span style="color: #008000; font-weight: bold">assert</span> nav <span style="color: #AA22FF; font-weight: bold">is</span> <span style="color: #AA22FF; font-weight: bold">not</span> <span style="color: #008000; font-weight: bold">None</span> <span style="color: #AA22FF; font-weight: bold">and</span> nav<span style="color: #666666">.</span>find(<span style="color: #BA2121">&quot;a&quot;</span>, href<span style="color: #666666">=</span><span style="color: #BA2121">&quot;#overview&quot;</span>) <span style="color: #AA22FF; font-weight: bold">is</span> <span style="color: #AA22FF; font-weight: bold">not</span> <span style="color: #008000; font-weight: bold">None</span>
</code></pre>
<h3 id="test_pdf_summary_creation">test_pdf_summary_creation(tmp_path: Path, monkeypatch: pytest.MonkeyPatch) -&gt; None</h3>
<p>This function `test_pdf_summary_creation` is a test case designed to verify the creation of a PDF summary for a project. It uses the `pytest` framework and requires the `reportlab` library to be installed, which is used for generating PDF files.

The function performs the following steps:
1. Checks if the `reportlab` library is installed using `importlib.util.find_spec`. If it&#x27;s not installed, the test case skips execution.
2. Calls `_create_fixture(tmp_path)` to set up a temporary directory with necessary files and configurations.
3. Uses `monkeypatch.setattr` to replace the `LLMClient` class in the `explaincode` module with a mock client (`_mock_llm_client`). This is likely used for testing purposes, such as mocking API responses or behavior.
4. Calls the `main` function with command-line arguments specifying the path to the temporary directory and the output format as &quot;pdf&quot;.
5. Asserts that two files are created in the temporary directory: `user_manual.pdf` and `user_manual_evidence.json`. The presence of these files confirms that the PDF summary creation process was successful.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">test_pdf_summary_creation</span>(tmp_path: Path, monkeypatch: pytest<span style="color: #666666">.</span>MonkeyPatch) <span style="color: #666666">-&gt;</span> <span style="color: #008000; font-weight: bold">None</span>:
    <span style="color: #008000; font-weight: bold">if</span> importlib<span style="color: #666666">.</span>util<span style="color: #666666">.</span>find_spec(<span style="color: #BA2121">&quot;reportlab&quot;</span>) <span style="color: #AA22FF; font-weight: bold">is</span> <span style="color: #008000; font-weight: bold">None</span>:
        pytest<span style="color: #666666">.</span>skip(<span style="color: #BA2121">&quot;reportlab not installed&quot;</span>)
    _create_fixture(tmp_path)
    monkeypatch<span style="color: #666666">.</span>setattr(explaincode, <span style="color: #BA2121">&quot;LLMClient&quot;</span>, _mock_llm_client)
    main([<span style="color: #BA2121">&quot;--path&quot;</span>, <span style="color: #008000">str</span>(tmp_path), <span style="color: #BA2121">&quot;--output-format&quot;</span>, <span style="color: #BA2121">&quot;pdf&quot;</span>])
    <span style="color: #008000; font-weight: bold">assert</span> (tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;user_manual.pdf&quot;</span>)<span style="color: #666666">.</span>exists()
    <span style="color: #008000; font-weight: bold">assert</span> (tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;user_manual_evidence.json&quot;</span>)<span style="color: #666666">.</span>exists()
</code></pre>
<h3 id="test_graceful_missing_docx">test_graceful_missing_docx(monkeypatch: pytest.MonkeyPatch, tmp_path: Path) -&gt; None</h3>
<p>This function `test_graceful_missing_docx` is a test case designed to verify the behavior of the code summarization tool when the `python-docx` library, which is used for creating and manipulating Word documents, is missing. The function uses `monkeypatch` to simulate the absence of the `Document` class from the `docx` module and sets up a mock LLM client using `_mock_llm_client`. It then runs the main function with a specified path and asserts that the output files (`user_manual.html` and `user_manual_evidence.json`) are created successfully in the temporary directory.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">test_graceful_missing_docx</span>(monkeypatch: pytest<span style="color: #666666">.</span>MonkeyPatch, tmp_path: Path) <span style="color: #666666">-&gt;</span> <span style="color: #008000; font-weight: bold">None</span>:
    _create_fixture(tmp_path)
    <span style="color: #008000; font-weight: bold">try</span>:
        <span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">docx</span> <span style="color: #008000; font-weight: bold">import</span> Document
    <span style="color: #008000; font-weight: bold">except</span> <span style="color: #CB3F38; font-weight: bold">Exception</span>:  <span style="color: #3D7B7B; font-style: italic"># pragma: no cover - dependency missing</span>
        Document <span style="color: #666666">=</span> <span style="color: #008000; font-weight: bold">None</span>  <span style="color: #3D7B7B; font-style: italic"># type: ignore</span>
    <span style="color: #008000; font-weight: bold">if</span> Document:
        doc <span style="color: #666666">=</span> Document()
        doc<span style="color: #666666">.</span>add_paragraph(<span style="color: #BA2121">&quot;hi&quot;</span>)
        doc<span style="color: #666666">.</span>save(tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;guide.docx&quot;</span>)
    monkeypatch<span style="color: #666666">.</span>setattr(explaincode, <span style="color: #BA2121">&quot;Document&quot;</span>, <span style="color: #008000; font-weight: bold">None</span>)
    monkeypatch<span style="color: #666666">.</span>setattr(explaincode, <span style="color: #BA2121">&quot;LLMClient&quot;</span>, _mock_llm_client)
    main([<span style="color: #BA2121">&quot;--path&quot;</span>, <span style="color: #008000">str</span>(tmp_path)])
    <span style="color: #008000; font-weight: bold">assert</span> (tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;user_manual.html&quot;</span>)<span style="color: #666666">.</span>exists()
    <span style="color: #008000; font-weight: bold">assert</span> (tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;user_manual_evidence.json&quot;</span>)<span style="color: #666666">.</span>exists()
</code></pre>
<h3 id="test_custom_output_directory">test_custom_output_directory(tmp_path: Path, monkeypatch: pytest.MonkeyPatch) -&gt; None</h3>
<p>The function `test_custom_output_directory` is a unit test for the code summarization tool. It creates a fixture using `_create_fixture`, sets up a mock LLM client with `_mock_llm_client`, and then runs the main function of the `explaincode` module with custom output directory specified by `--output`. The test asserts that two files, &quot;user_manual.html&quot; and &quot;user_manual_evidence.json&quot;, are created in the specified output directory.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">test_custom_output_directory</span>(tmp_path: Path, monkeypatch: pytest<span style="color: #666666">.</span>MonkeyPatch) <span style="color: #666666">-&gt;</span> <span style="color: #008000; font-weight: bold">None</span>:
    _create_fixture(tmp_path)
    out_dir <span style="color: #666666">=</span> tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;dist&quot;</span>
    monkeypatch<span style="color: #666666">.</span>setattr(explaincode, <span style="color: #BA2121">&quot;LLMClient&quot;</span>, _mock_llm_client)
    main([<span style="color: #BA2121">&quot;--path&quot;</span>, <span style="color: #008000">str</span>(tmp_path), <span style="color: #BA2121">&quot;--output&quot;</span>, <span style="color: #008000">str</span>(out_dir)])
    <span style="color: #008000; font-weight: bold">assert</span> (out_dir <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;user_manual.html&quot;</span>)<span style="color: #666666">.</span>exists()
    <span style="color: #008000; font-weight: bold">assert</span> (out_dir <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;user_manual_evidence.json&quot;</span>)<span style="color: #666666">.</span>exists()
</code></pre>
<h3 id="test_collect_docs_filters">test_collect_docs_filters(tmp_path: Path) -&gt; None</h3>
<p>The function `test_collect_docs_filters` tests the `collect_docs` function from the `explaincode.py` module. It creates a temporary directory with various files, including Markdown and text files. The `collect_docs` function is expected to filter out non-Markdown files (like `.txt`) and return only Markdown files in the specified directory. The test asserts that &quot;keep.md&quot; is included in the returned files and that &quot;skip.txt&quot; is excluded.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">test_collect_docs_filters</span>(tmp_path: Path) <span style="color: #666666">-&gt;</span> <span style="color: #008000; font-weight: bold">None</span>:
    (tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;docs&quot;</span>)<span style="color: #666666">.</span>mkdir()
    (tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;docs&quot;</span> <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;keep.md&quot;</span>)<span style="color: #666666">.</span>write_text(<span style="color: #BA2121">&quot;hi&quot;</span>, encoding<span style="color: #666666">=</span><span style="color: #BA2121">&quot;utf-8&quot;</span>)
    (tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;docs&quot;</span> <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;skip.txt&quot;</span>)<span style="color: #666666">.</span>write_text(<span style="color: #BA2121">&quot;no&quot;</span>, encoding<span style="color: #666666">=</span><span style="color: #BA2121">&quot;utf-8&quot;</span>)
    (tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;README.md&quot;</span>)<span style="color: #666666">.</span>write_text(<span style="color: #BA2121">&quot;readme&quot;</span>, encoding<span style="color: #666666">=</span><span style="color: #BA2121">&quot;utf-8&quot;</span>)
    (tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;extra.md&quot;</span>)<span style="color: #666666">.</span>write_text(<span style="color: #BA2121">&quot;extra&quot;</span>, encoding<span style="color: #666666">=</span><span style="color: #BA2121">&quot;utf-8&quot;</span>)
    files <span style="color: #666666">=</span> explaincode<span style="color: #666666">.</span>collect_docs(tmp_path)
    names <span style="color: #666666">=</span> {f<span style="color: #666666">.</span>name <span style="color: #008000; font-weight: bold">for</span> f <span style="color: #AA22FF; font-weight: bold">in</span> files}
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #BA2121">&quot;keep.md&quot;</span> <span style="color: #AA22FF; font-weight: bold">in</span> names <span style="color: #AA22FF; font-weight: bold">and</span> <span style="color: #BA2121">&quot;skip.txt&quot;</span> <span style="color: #AA22FF; font-weight: bold">not</span> <span style="color: #AA22FF; font-weight: bold">in</span> names
</code></pre>
<h3 id="test_map_evidence_overview_priority_and_filters">test_map_evidence_overview_priority_and_filters() -&gt; None</h3>
<p>The function `test_map_evidence_overview_priority_and_filters` tests the `map_evidence_to_sections` function from the `explaincode.py` module. It creates a dictionary of documentation files with their paths and content, including some that should be ignored. The function maps these documents to sections based on their content. The test asserts that certain files are not included in the &quot;Overview&quot; section, while others are correctly prioritized and ordered.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">test_map_evidence_overview_priority_and_filters</span>() <span style="color: #666666">-&gt;</span> <span style="color: #008000; font-weight: bold">None</span>:
    docs <span style="color: #666666">=</span> {
        Path(<span style="color: #BA2121">&quot;README.md&quot;</span>): <span style="color: #BA2121">&quot;# Overview</span><span style="color: #AA5D1F; font-weight: bold">\n</span><span style="color: #BA2121">readme info&quot;</span>,
        Path(<span style="color: #BA2121">&quot;docs/guide.md&quot;</span>): <span style="color: #BA2121">&quot;# Overview</span><span style="color: #AA5D1F; font-weight: bold">\n</span><span style="color: #BA2121">docs info&quot;</span>,
        Path(<span style="color: #BA2121">&quot;src/other.md&quot;</span>): <span style="color: #BA2121">&quot;# Overview</span><span style="color: #AA5D1F; font-weight: bold">\n</span><span style="color: #BA2121">other info&quot;</span>,
        Path(<span style="color: #BA2121">&quot;tests/ignore.md&quot;</span>): <span style="color: #BA2121">&quot;# Overview</span><span style="color: #AA5D1F; font-weight: bold">\n</span><span style="color: #BA2121">test info&quot;</span>,
        Path(<span style="color: #BA2121">&quot;examples/ignore.md&quot;</span>): <span style="color: #BA2121">&quot;# Overview</span><span style="color: #AA5D1F; font-weight: bold">\n</span><span style="color: #BA2121">example info&quot;</span>,
        Path(<span style="color: #BA2121">&quot;fixtures/ignore.md&quot;</span>): <span style="color: #BA2121">&quot;# Overview</span><span style="color: #AA5D1F; font-weight: bold">\n</span><span style="color: #BA2121">fixture info&quot;</span>,
    }
    section_map, _ <span style="color: #666666">=</span> explaincode<span style="color: #666666">.</span>map_evidence_to_sections(docs)
    sources <span style="color: #666666">=</span> [p<span style="color: #666666">.</span>as_posix() <span style="color: #008000; font-weight: bold">for</span> p, _ <span style="color: #AA22FF; font-weight: bold">in</span> section_map[<span style="color: #BA2121">&quot;Overview&quot;</span>]]
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #BA2121">&quot;tests/ignore.md&quot;</span> <span style="color: #AA22FF; font-weight: bold">not</span> <span style="color: #AA22FF; font-weight: bold">in</span> sources
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #BA2121">&quot;examples/ignore.md&quot;</span> <span style="color: #AA22FF; font-weight: bold">not</span> <span style="color: #AA22FF; font-weight: bold">in</span> sources
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #BA2121">&quot;fixtures/ignore.md&quot;</span> <span style="color: #AA22FF; font-weight: bold">not</span> <span style="color: #AA22FF; font-weight: bold">in</span> sources
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #008000">set</span>(sources[:<span style="color: #666666">2</span>]) <span style="color: #666666">==</span> {<span style="color: #BA2121">&quot;README.md&quot;</span>, <span style="color: #BA2121">&quot;docs/guide.md&quot;</span>}
    <span style="color: #008000; font-weight: bold">assert</span> sources[<span style="color: #666666">2</span>] <span style="color: #666666">==</span> <span style="color: #BA2121">&quot;src/other.md&quot;</span>
</code></pre>
<h3 id="test_map_evidence_snippet_limits">test_map_evidence_snippet_limits() -&gt; None</h3>
<p>The function `test_map_evidence_snippet_limits` tests the functionality of mapping evidence to sections, specifically focusing on snippet limits. It creates a dictionary of document paths and their contents, simulating long and short documents. The function then maps evidence to sections using `explaincode.map_evidence_to_sections`. It asserts that lines beyond the maximum allowed snippet length are not included in the snippets for the long document, while lines within the limit are included. Additionally, it checks that the short document&#x27;s snippet is correctly identified as only containing the &quot;# Inputs&quot; header.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">test_map_evidence_snippet_limits</span>() <span style="color: #666666">-&gt;</span> <span style="color: #008000; font-weight: bold">None</span>:
    long_content <span style="color: #666666">=</span> <span style="color: #BA2121">&quot;# Inputs</span><span style="color: #AA5D1F; font-weight: bold">\n</span><span style="color: #BA2121">&quot;</span> <span style="color: #666666">+</span> <span style="color: #BA2121">&quot;</span><span style="color: #AA5D1F; font-weight: bold">\n</span><span style="color: #BA2121">&quot;</span><span style="color: #666666">.</span>join(
        <span style="color: #BA2121">f&quot;line </span><span style="color: #A45A77; font-weight: bold">{</span>i<span style="color: #A45A77; font-weight: bold">}</span><span style="color: #BA2121">&quot;</span> <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(<span style="color: #666666">1</span>, explaincode<span style="color: #666666">.</span>MAX_SNIPPET_LINES <span style="color: #666666">+</span> <span style="color: #666666">10</span>)
    )
    docs <span style="color: #666666">=</span> {
        Path(<span style="color: #BA2121">&quot;src/long.md&quot;</span>): long_content,
        Path(<span style="color: #BA2121">&quot;tests/short.md&quot;</span>): long_content,
    }
    section_map, _ <span style="color: #666666">=</span> explaincode<span style="color: #666666">.</span>map_evidence_to_sections(docs)
    snippets <span style="color: #666666">=</span> {p<span style="color: #666666">.</span>as_posix(): snip <span style="color: #008000; font-weight: bold">for</span> p, snip <span style="color: #AA22FF; font-weight: bold">in</span> section_map[<span style="color: #BA2121">&quot;Inputs&quot;</span>]}
    <span style="color: #008000; font-weight: bold">assert</span> (
        <span style="color: #BA2121">f&quot;line </span><span style="color: #A45A77; font-weight: bold">{</span>explaincode<span style="color: #666666">.</span>MAX_SNIPPET_LINES<span style="color: #bbbbbb"> </span><span style="color: #666666">+</span><span style="color: #bbbbbb"> </span><span style="color: #666666">1</span><span style="color: #A45A77; font-weight: bold">}</span><span style="color: #BA2121">&quot;</span> <span style="color: #AA22FF; font-weight: bold">not</span> <span style="color: #AA22FF; font-weight: bold">in</span> snippets[<span style="color: #BA2121">&quot;src/long.md&quot;</span>]
    )
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #BA2121">f&quot;line </span><span style="color: #A45A77; font-weight: bold">{</span>explaincode<span style="color: #666666">.</span>MAX_SNIPPET_LINES<span style="color: #A45A77; font-weight: bold">}</span><span style="color: #BA2121">&quot;</span> <span style="color: #AA22FF; font-weight: bold">in</span> snippets[<span style="color: #BA2121">&quot;src/long.md&quot;</span>]
    <span style="color: #008000; font-weight: bold">assert</span> snippets[<span style="color: #BA2121">&quot;tests/short.md&quot;</span>] <span style="color: #666666">==</span> <span style="color: #BA2121">&quot;# Inputs&quot;</span>
</code></pre>
<h3 id="test_detect_placeholders">test_detect_placeholders() -&gt; None</h3>
<p>The function `test_detect_placeholders` tests the `detect_placeholders` method from the `explaincode.py` module. It provides a string containing placeholders for an overview and outputs, and asserts that the detected missing placeholders are &quot;Overview&quot; and &quot;Outputs&quot;.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">test_detect_placeholders</span>() <span style="color: #666666">-&gt;</span> <span style="color: #008000; font-weight: bold">None</span>:
    text <span style="color: #666666">=</span> <span style="color: #BA2121">&quot;Overview: [[NEEDS_OVERVIEW]]</span><span style="color: #AA5D1F; font-weight: bold">\n</span><span style="color: #BA2121">Inputs: data</span><span style="color: #AA5D1F; font-weight: bold">\n</span><span style="color: #BA2121">Outputs: [[NEEDS_OUTPUTS]]&quot;</span>
    missing <span style="color: #666666">=</span> explaincode<span style="color: #666666">.</span>detect_placeholders(text)
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #008000">set</span>(missing) <span style="color: #666666">==</span> {<span style="color: #BA2121">&quot;Overview&quot;</span>, <span style="color: #BA2121">&quot;Outputs&quot;</span>}
</code></pre>
<h3 id="test_parse_manual_infers_missing_sections">test_parse_manual_infers_missing_sections() -&gt; None</h3>
<p>The function `test_parse_manual_infers_missing_sections` tests the `parse_manual` function from the `explaincode` module. It uses a stub class to simulate the behavior of an LLM client, which returns a guessed summary when called. The test asserts that the &quot;Overview&quot; section is correctly parsed and that the &quot;Inputs&quot; section, which was not provided in the input, is inferred and marked as such.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">test_parse_manual_infers_missing_sections</span>() <span style="color: #666666">-&gt;</span> <span style="color: #008000; font-weight: bold">None</span>:
    <span style="color: #008000; font-weight: bold">class</span> <span style="color: #0000FF; font-weight: bold">Stub</span>:
        <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">summarize</span>(<span style="color: #008000">self</span>, prompt: <span style="color: #008000">str</span>, prompt_type: <span style="color: #008000">str</span>, system_prompt: <span style="color: #008000">str</span> <span style="color: #666666">=</span> <span style="color: #BA2121">&quot;&quot;</span>) <span style="color: #666666">-&gt;</span> <span style="color: #008000">str</span>:
            <span style="color: #008000; font-weight: bold">return</span> <span style="color: #BA2121">&quot;guessed&quot;</span>

    client <span style="color: #666666">=</span> Stub()
    parsed <span style="color: #666666">=</span> explaincode<span style="color: #666666">.</span>parse_manual(<span style="color: #BA2121">&quot;Overview: hi&quot;</span>, client<span style="color: #666666">=</span>client)
    <span style="color: #008000; font-weight: bold">assert</span> parsed[<span style="color: #BA2121">&quot;Overview&quot;</span>] <span style="color: #666666">==</span> <span style="color: #BA2121">&quot;hi&quot;</span>
    <span style="color: #008000; font-weight: bold">assert</span> parsed[<span style="color: #BA2121">&quot;Inputs&quot;</span>]<span style="color: #666666">.</span>endswith(<span style="color: #BA2121">&quot;(inferred)&quot;</span>)
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #BA2121">&quot;No information provided.&quot;</span> <span style="color: #AA22FF; font-weight: bold">not</span> <span style="color: #AA22FF; font-weight: bold">in</span> parsed[<span style="color: #BA2121">&quot;Inputs&quot;</span>]
</code></pre>
<h3 id="test_validate_manual_references_flags_missing">test_validate_manual_references_flags_missing(tmp_path: Path) -&gt; None</h3>
<p>The function `test_validate_manual_references_flags_missing` tests the validation of manual references within documentation sections. It creates a temporary directory, writes a Python file named &quot;exists.py&quot; with content &quot;pass&quot;, and sets up a dictionary `sections` containing an overview section that references both &quot;exists.py&quot; and another non-existent file &quot;missing.py&quot;. The function calls `explaincode.validate_manual_references` to validate the references in the sections. After validation, it asserts that &quot;exists.py&quot; remains unchanged in the overview section, while &quot;missing.py [missing]&quot; is added to indicate a missing reference. It also checks that the evidence dictionary contains a list of missing references [&quot;missing.py&quot;] under the overview section.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">test_validate_manual_references_flags_missing</span>(tmp_path: Path) <span style="color: #666666">-&gt;</span> <span style="color: #008000; font-weight: bold">None</span>:
    (tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;exists.py&quot;</span>)<span style="color: #666666">.</span>write_text(<span style="color: #BA2121">&quot;pass&quot;</span>, encoding<span style="color: #666666">=</span><span style="color: #BA2121">&quot;utf-8&quot;</span>)
    sections <span style="color: #666666">=</span> {<span style="color: #BA2121">&quot;Overview&quot;</span>: <span style="color: #BA2121">&quot;See exists.py and missing.py for details&quot;</span>}
    evidence: <span style="color: #008000">dict</span>[<span style="color: #008000">str</span>, <span style="color: #008000">dict</span>[<span style="color: #008000">str</span>, <span style="color: #008000">object</span>]] <span style="color: #666666">=</span> {}
    explaincode<span style="color: #666666">.</span>validate_manual_references(sections, tmp_path, evidence)
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #BA2121">&quot;exists.py&quot;</span> <span style="color: #AA22FF; font-weight: bold">in</span> sections[<span style="color: #BA2121">&quot;Overview&quot;</span>]
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #BA2121">&quot;missing.py [missing]&quot;</span> <span style="color: #AA22FF; font-weight: bold">in</span> sections[<span style="color: #BA2121">&quot;Overview&quot;</span>]
    <span style="color: #008000; font-weight: bold">assert</span> evidence[<span style="color: #BA2121">&quot;Overview&quot;</span>][<span style="color: #BA2121">&quot;missing_references&quot;</span>] <span style="color: #666666">==</span> [<span style="color: #BA2121">&quot;missing.py&quot;</span>]
</code></pre>
<h3 id="test_infer_sections_infers_entries">test_infer_sections_infers_entries() -&gt; None</h3>
<p>The function `test_infer_sections_infers_entries` tests the `infer_sections` function from the `explaincode` module. It asserts that the returned dictionary contains an &quot;Overview&quot; key with the value &quot;Some context&quot;. For all other keys defined in `REQUIRED_SECTIONS`, it checks that their values end with &quot;(inferred)&quot;. Finally, it ensures that the string &quot;No information provided.&quot; is not present in any of the section values combined.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">test_infer_sections_infers_entries</span>() <span style="color: #666666">-&gt;</span> <span style="color: #008000; font-weight: bold">None</span>:
    sections <span style="color: #666666">=</span> explaincode<span style="color: #666666">.</span>infer_sections(<span style="color: #BA2121">&quot;Some context&quot;</span>)
    <span style="color: #008000; font-weight: bold">assert</span> sections[<span style="color: #BA2121">&quot;Overview&quot;</span>] <span style="color: #666666">==</span> <span style="color: #BA2121">&quot;Some context&quot;</span>
    <span style="color: #008000; font-weight: bold">for</span> key <span style="color: #AA22FF; font-weight: bold">in</span> explaincode<span style="color: #666666">.</span>REQUIRED_SECTIONS:
        <span style="color: #008000; font-weight: bold">if</span> key <span style="color: #666666">!=</span> <span style="color: #BA2121">&quot;Overview&quot;</span>:
            <span style="color: #008000; font-weight: bold">assert</span> sections[key]<span style="color: #666666">.</span>endswith(<span style="color: #BA2121">&quot;(inferred)&quot;</span>)
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #BA2121">&quot;No information provided.&quot;</span> <span style="color: #AA22FF; font-weight: bold">not</span> <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #BA2121">&quot;&quot;</span><span style="color: #666666">.</span>join(sections<span style="color: #666666">.</span>values())
</code></pre>
<h3 id="test_infer_sections_no_context_defaults">test_infer_sections_no_context_defaults() -&gt; None</h3>
<p>The function `test_infer_sections_no_context_defaults` is a unit test that checks the behavior of the `infer_sections` function from the `explaincode.py` module when no context is provided. The test asserts that if an empty string is passed to `infer_sections`, it returns a dictionary where all values are set to &quot;No information provided.&quot;</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">test_infer_sections_no_context_defaults</span>() <span style="color: #666666">-&gt;</span> <span style="color: #008000; font-weight: bold">None</span>:
    sections <span style="color: #666666">=</span> explaincode<span style="color: #666666">.</span>infer_sections(<span style="color: #BA2121">&quot;&quot;</span>)
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #008000">all</span>(v <span style="color: #666666">==</span> <span style="color: #BA2121">&quot;No information provided.&quot;</span> <span style="color: #008000; font-weight: bold">for</span> v <span style="color: #AA22FF; font-weight: bold">in</span> sections<span style="color: #666666">.</span>values())
</code></pre>
<h3 id="test_extract_snippets_skips_large_file">test_extract_snippets_skips_large_file(tmp_path: Path, caplog: pytest.LogCaptureFixture) -&gt; None</h3>
<p>This function tests the `extract_snippets` method from the `explaincode.py` module. It creates a large file (`big.py`) with 210,000 bytes of data and attempts to extract snippets using the `extract_snippets` function with specified parameters: `max_files=1`, `time_budget=5`, and `max_bytes=200,000`. The test asserts that the large file is not included in the returned snippets list. Additionally, it checks if a log message indicating that the file size exceeds the limit is present in the captured logs.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">test_extract_snippets_skips_large_file</span>(
    tmp_path: Path, caplog: pytest<span style="color: #666666">.</span>LogCaptureFixture
) <span style="color: #666666">-&gt;</span> <span style="color: #008000; font-weight: bold">None</span>:
    big_file <span style="color: #666666">=</span> tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;big.py&quot;</span>
    big_file<span style="color: #666666">.</span>write_bytes(<span style="color: #BA2121">b&quot;a&quot;</span> <span style="color: #666666">*</span> <span style="color: #666666">210_000</span>)
    caplog<span style="color: #666666">.</span>set_level(logging<span style="color: #666666">.</span>INFO)
    snippets <span style="color: #666666">=</span> explaincode<span style="color: #666666">.</span>extract_snippets(
        [big_file], max_files<span style="color: #666666">=1</span>, time_budget<span style="color: #666666">=5</span>, max_bytes<span style="color: #666666">=200_000</span>
    )
    <span style="color: #008000; font-weight: bold">assert</span> big_file <span style="color: #AA22FF; font-weight: bold">not</span> <span style="color: #AA22FF; font-weight: bold">in</span> snippets
    log <span style="color: #666666">=</span> caplog<span style="color: #666666">.</span>text
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #BA2121">&quot;file size&quot;</span> <span style="color: #AA22FF; font-weight: bold">in</span> log <span style="color: #AA22FF; font-weight: bold">and</span> <span style="color: #BA2121">&quot;exceeds limit&quot;</span> <span style="color: #AA22FF; font-weight: bold">in</span> log
</code></pre>
<h3 id="test_scan_code_skips_non_source_dirs">test_scan_code_skips_non_source_dirs(tmp_path: Path, monkeypatch: pytest.MonkeyPatch) -&gt; None</h3>
<p>The function `test_scan_code_skips_non_source_dirs` tests the behavior of the `scan_code` function from the `explaincode` module when it encounters non-source directories. It sets up a temporary directory structure with source, test, and example directories, each containing a Python file. The `collect_docs` method is monkeypatched to return an empty list for any base directory, simulating that no documentation is collected. The function then scans the temporary path for &quot;How to Run&quot; with specified parameters. It asserts that only the `src/main.py` file is included in the result under the &quot;How to Run&quot; key.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">test_scan_code_skips_non_source_dirs</span>(
    tmp_path: Path, monkeypatch: pytest<span style="color: #666666">.</span>MonkeyPatch
) <span style="color: #666666">-&gt;</span> <span style="color: #008000; font-weight: bold">None</span>:
    src <span style="color: #666666">=</span> tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;src&quot;</span>
    src<span style="color: #666666">.</span>mkdir()
    (src <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;main.py&quot;</span>)<span style="color: #666666">.</span>write_text(<span style="color: #BA2121">&#39;&quot;&quot;&quot;run code&quot;&quot;&quot;&#39;</span>, encoding<span style="color: #666666">=</span><span style="color: #BA2121">&quot;utf-8&quot;</span>)

    tests_dir <span style="color: #666666">=</span> tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;tests&quot;</span>
    tests_dir<span style="color: #666666">.</span>mkdir()
    (tests_dir <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;test_main.py&quot;</span>)<span style="color: #666666">.</span>write_text(<span style="color: #BA2121">&#39;&quot;&quot;&quot;run tests&quot;&quot;&quot;&#39;</span>, encoding<span style="color: #666666">=</span><span style="color: #BA2121">&quot;utf-8&quot;</span>)

    examples_dir <span style="color: #666666">=</span> tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;examples&quot;</span>
    examples_dir<span style="color: #666666">.</span>mkdir()
    (examples_dir <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;example.py&quot;</span>)<span style="color: #666666">.</span>write_text(<span style="color: #BA2121">&#39;&quot;&quot;&quot;run example&quot;&quot;&quot;&#39;</span>, encoding<span style="color: #666666">=</span><span style="color: #BA2121">&quot;utf-8&quot;</span>)

    monkeypatch<span style="color: #666666">.</span>setattr(explaincode, <span style="color: #BA2121">&quot;collect_docs&quot;</span>, <span style="color: #008000; font-weight: bold">lambda</span> base: [])
    result <span style="color: #666666">=</span> explaincode<span style="color: #666666">.</span>scan_code(
        tmp_path, [<span style="color: #BA2121">&quot;How to Run&quot;</span>], max_files<span style="color: #666666">=5</span>, time_budget<span style="color: #666666">=5</span>, max_bytes_per_file<span style="color: #666666">=1000</span>
    )

    how_to_run <span style="color: #666666">=</span> result<span style="color: #666666">.</span>get(<span style="color: #BA2121">&quot;How to Run&quot;</span>, {})
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #008000">set</span>(how_to_run<span style="color: #666666">.</span>keys()) <span style="color: #666666">==</span> {<span style="color: #BA2121">&quot;src/main.py&quot;</span>}
</code></pre>
<h3 id="test_scan_code_categorizes_snippets">test_scan_code_categorizes_snippets(tmp_path: Path, monkeypatch: pytest.MonkeyPatch) -&gt; None</h3>
<p>This function tests the `scan_code` method in the `explaincode` module. It sets up temporary files and uses monkeypatching to mock the `collect_docs`, `rank_code_files`, and `extract_snippets` functions. The test asserts that the extracted snippets are categorized correctly into &quot;Inputs&quot;, &quot;Outputs&quot;, and &quot;How to Run&quot;.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">test_scan_code_categorizes_snippets</span>(
    tmp_path: Path, monkeypatch: pytest<span style="color: #666666">.</span>MonkeyPatch
) <span style="color: #666666">-&gt;</span> <span style="color: #008000; font-weight: bold">None</span>:
    paths <span style="color: #666666">=</span> [tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;a.py&quot;</span>, tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;b.py&quot;</span>, tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;c.py&quot;</span>]
    <span style="color: #008000; font-weight: bold">for</span> p <span style="color: #AA22FF; font-weight: bold">in</span> paths:
        p<span style="color: #666666">.</span>write_text(<span style="color: #BA2121">&quot;&quot;</span>, encoding<span style="color: #666666">=</span><span style="color: #BA2121">&quot;utf-8&quot;</span>)

    monkeypatch<span style="color: #666666">.</span>setattr(explaincode, <span style="color: #BA2121">&quot;collect_docs&quot;</span>, <span style="color: #008000; font-weight: bold">lambda</span> base: [])
    monkeypatch<span style="color: #666666">.</span>setattr(explaincode, <span style="color: #BA2121">&quot;rank_code_files&quot;</span>, <span style="color: #008000; font-weight: bold">lambda</span> base, patterns: paths)

    <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">fake_extract</span>(
        files: Iterable[Path], <span style="color: #666666">*</span>, max_files: <span style="color: #008000">int</span>, time_budget: <span style="color: #008000">int</span>, max_bytes: <span style="color: #008000">int</span>
    ) <span style="color: #666666">-&gt;</span> <span style="color: #008000">dict</span>[Path, <span style="color: #008000">str</span>]:
        <span style="color: #008000; font-weight: bold">return</span> {
            paths[<span style="color: #666666">0</span>]: <span style="color: #BA2121">&quot;read input from user&quot;</span>,
            paths[<span style="color: #666666">1</span>]: <span style="color: #BA2121">&quot;write output&quot;</span>,
            paths[<span style="color: #666666">2</span>]: <span style="color: #BA2121">&quot;run the tool&quot;</span>,
        }

    monkeypatch<span style="color: #666666">.</span>setattr(explaincode, <span style="color: #BA2121">&quot;extract_snippets&quot;</span>, fake_extract)

    result <span style="color: #666666">=</span> explaincode<span style="color: #666666">.</span>scan_code(
        tmp_path, [<span style="color: #BA2121">&quot;Inputs&quot;</span>, <span style="color: #BA2121">&quot;Outputs&quot;</span>, <span style="color: #BA2121">&quot;How to Run&quot;</span>], max_files<span style="color: #666666">=3</span>, time_budget<span style="color: #666666">=5</span>, max_bytes_per_file<span style="color: #666666">=1000</span>
    )
    <span style="color: #008000; font-weight: bold">assert</span> result[<span style="color: #BA2121">&quot;Inputs&quot;</span>] <span style="color: #666666">==</span> {<span style="color: #BA2121">&quot;a.py&quot;</span>: <span style="color: #BA2121">&quot;read input from user&quot;</span>}
    <span style="color: #008000; font-weight: bold">assert</span> result[<span style="color: #BA2121">&quot;Outputs&quot;</span>] <span style="color: #666666">==</span> {<span style="color: #BA2121">&quot;b.py&quot;</span>: <span style="color: #BA2121">&quot;write output&quot;</span>}
    <span style="color: #008000; font-weight: bold">assert</span> result[<span style="color: #BA2121">&quot;How to Run&quot;</span>] <span style="color: #666666">==</span> {<span style="color: #BA2121">&quot;c.py&quot;</span>: <span style="color: #BA2121">&quot;run the tool&quot;</span>}
</code></pre>
<details>
<summary>Subfunction: fake_extract(files: Iterable[Path], *, max_files: int, time_budget: int, max_bytes: int) -&gt; dict[Path, str]</summary>
<h4 id="fake_extract">fake_extract(files: Iterable[Path], *, max_files: int, time_budget: int, max_bytes: int) -&gt; dict[Path, str]</h4>
<p>The `fake_extract` function takes an iterable of file paths and optional parameters for maximum files, time budget, and maximum bytes. It returns a dictionary with keys as file paths and values as strings describing actions related to reading input from users, writing output, and running the tool.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">fake_extract</span>(
        files: Iterable[Path], <span style="color: #666666">*</span>, max_files: <span style="color: #008000">int</span>, time_budget: <span style="color: #008000">int</span>, max_bytes: <span style="color: #008000">int</span>
    ) <span style="color: #666666">-&gt;</span> <span style="color: #008000">dict</span>[Path, <span style="color: #008000">str</span>]:
        <span style="color: #008000; font-weight: bold">return</span> {
            paths[<span style="color: #666666">0</span>]: <span style="color: #BA2121">&quot;read input from user&quot;</span>,
            paths[<span style="color: #666666">1</span>]: <span style="color: #BA2121">&quot;write output&quot;</span>,
            paths[<span style="color: #666666">2</span>]: <span style="color: #BA2121">&quot;run the tool&quot;</span>,
        }
</code></pre>
</details>
<h3 id="test_rank_code_files_supports_cpp_h_java">test_rank_code_files_supports_cpp_h_java(tmp_path: Path) -&gt; None</h3>
<p>The function `test_rank_code_files_supports_cpp_h_java` tests the functionality of ranking code files using the `explaincode.rank_code_files` method. It creates a temporary directory with various file types, including Python, C++, and Java source files, as well as an ignored text file. The function then ranks these files and asserts that only the relevant programming files (Python, C++, and Java) are included in the ranking, while the ignored text file is excluded.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">test_rank_code_files_supports_cpp_h_java</span>(tmp_path: Path) <span style="color: #666666">-&gt;</span> <span style="color: #008000; font-weight: bold">None</span>:
    files <span style="color: #666666">=</span> [
        tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;main.py&quot;</span>,
        tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;lib.cpp&quot;</span>,
        tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;lib.h&quot;</span>,
        tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;Main.java&quot;</span>,
        tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;ignore.txt&quot;</span>,
    ]
    <span style="color: #008000; font-weight: bold">for</span> f <span style="color: #AA22FF; font-weight: bold">in</span> files:
        f<span style="color: #666666">.</span>write_text(<span style="color: #BA2121">&quot;&quot;</span>, encoding<span style="color: #666666">=</span><span style="color: #BA2121">&quot;utf-8&quot;</span>)
    ranked <span style="color: #666666">=</span> explaincode<span style="color: #666666">.</span>rank_code_files(tmp_path, [])
    names <span style="color: #666666">=</span> {p<span style="color: #666666">.</span>name <span style="color: #008000; font-weight: bold">for</span> p <span style="color: #AA22FF; font-weight: bold">in</span> ranked}
    <span style="color: #008000; font-weight: bold">assert</span> {<span style="color: #BA2121">&quot;main.py&quot;</span>, <span style="color: #BA2121">&quot;lib.cpp&quot;</span>, <span style="color: #BA2121">&quot;lib.h&quot;</span>, <span style="color: #BA2121">&quot;Main.java&quot;</span>} <span style="color: #666666">&lt;=</span> names
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #BA2121">&quot;ignore.txt&quot;</span> <span style="color: #AA22FF; font-weight: bold">not</span> <span style="color: #AA22FF; font-weight: bold">in</span> names
</code></pre>
<h3 id="test_llm_fill_placeholders_per_section_logging">test_llm_fill_placeholders_per_section_logging(tmp_path: Path, caplog: pytest.LogCaptureFixture) -&gt; None</h3>
<p>The function `test_llm_fill_placeholders_per_section_logging` tests the `llm_fill_placeholders` function from the `explaincode` module. It sets up a mock client that simulates an LLM response, replaces placeholders in a manual with code snippets from evidence, and logs the process. The test checks if the placeholders are correctly replaced and if the logging captures the correct information about which sections were filled using which files.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">test_llm_fill_placeholders_per_section_logging</span>(
    tmp_path: Path, caplog: pytest<span style="color: #666666">.</span>LogCaptureFixture
) <span style="color: #666666">-&gt;</span> <span style="color: #008000; font-weight: bold">None</span>:
    manual <span style="color: #666666">=</span> <span style="color: #BA2121">&quot;Inputs: [[NEEDS_INPUTS]]</span><span style="color: #AA5D1F; font-weight: bold">\n</span><span style="color: #BA2121">Outputs: [[NEEDS_OUTPUTS]]&quot;</span>
    evidence <span style="color: #666666">=</span> {
        <span style="color: #BA2121">&quot;Inputs&quot;</span>: {<span style="color: #BA2121">&quot;in.py&quot;</span>: <span style="color: #BA2121">&quot;input data&quot;</span>},
        <span style="color: #BA2121">&quot;Outputs&quot;</span>: {<span style="color: #BA2121">&quot;out.py&quot;</span>: <span style="color: #BA2121">&quot;output data&quot;</span>},
    }

    <span style="color: #008000; font-weight: bold">class</span> <span style="color: #0000FF; font-weight: bold">Dummy</span>:
        <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">__init__</span>(<span style="color: #008000">self</span>) <span style="color: #666666">-&gt;</span> <span style="color: #008000; font-weight: bold">None</span>:
            <span style="color: #008000">self</span><span style="color: #666666">.</span>calls: <span style="color: #008000">list</span>[<span style="color: #008000">str</span>] <span style="color: #666666">=</span> []

        <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">summarize</span>(
            <span style="color: #008000">self</span>, text: <span style="color: #008000">str</span>, prompt_type: <span style="color: #008000">str</span>, system_prompt: <span style="color: #008000">str</span> <span style="color: #666666">=</span> <span style="color: #BA2121">&quot;&quot;</span>
        ) <span style="color: #666666">-&gt;</span> <span style="color: #008000">str</span>:
            <span style="color: #008000">self</span><span style="color: #666666">.</span>calls<span style="color: #666666">.</span>append(text)
            manual_match <span style="color: #666666">=</span> re<span style="color: #666666">.</span>search(<span style="color: #BA2121">r&quot;Manual:\n(.*?)\n\nSection:&quot;</span>, text, re<span style="color: #666666">.</span>DOTALL)
            section_match <span style="color: #666666">=</span> re<span style="color: #666666">.</span>search(<span style="color: #BA2121">r&quot;Section: (.*?)\n&quot;</span>, text)
            manual_text <span style="color: #666666">=</span> manual_match<span style="color: #666666">.</span>group(<span style="color: #666666">1</span>)
            section <span style="color: #666666">=</span> section_match<span style="color: #666666">.</span>group(<span style="color: #666666">1</span>)
            token <span style="color: #666666">=</span> explaincode<span style="color: #666666">.</span>SECTION_PLACEHOLDERS[section]
            <span style="color: #008000; font-weight: bold">return</span> manual_text<span style="color: #666666">.</span>replace(token, <span style="color: #BA2121">f&quot;filled </span><span style="color: #A45A77; font-weight: bold">{</span>section<span style="color: #A45A77; font-weight: bold">}</span><span style="color: #BA2121">&quot;</span>)

    client <span style="color: #666666">=</span> Dummy()
    cache <span style="color: #666666">=</span> ResponseCache(<span style="color: #008000">str</span>(tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;cache.json&quot;</span>))
    caplog<span style="color: #666666">.</span>set_level(logging<span style="color: #666666">.</span>INFO)
    result <span style="color: #666666">=</span> explaincode<span style="color: #666666">.</span>llm_fill_placeholders(manual, evidence, client, cache)
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #BA2121">&quot;filled Inputs&quot;</span> <span style="color: #AA22FF; font-weight: bold">in</span> result <span style="color: #AA22FF; font-weight: bold">and</span> <span style="color: #BA2121">&quot;filled Outputs&quot;</span> <span style="color: #AA22FF; font-weight: bold">in</span> result
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #008000">len</span>(client<span style="color: #666666">.</span>calls) <span style="color: #666666">==</span> <span style="color: #666666">2</span>
    log <span style="color: #666666">=</span> caplog<span style="color: #666666">.</span>text
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #BA2121">&quot;Filled Inputs using code from: in.py&quot;</span> <span style="color: #AA22FF; font-weight: bold">in</span> log
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #BA2121">&quot;Filled Outputs using code from: out.py&quot;</span> <span style="color: #AA22FF; font-weight: bold">in</span> log
</code></pre>
<h3 id="test_full_docs_no_code_scan">test_full_docs_no_code_scan(tmp_path: Path, monkeypatch: pytest.MonkeyPatch, caplog: pytest.LogCaptureFixture) -&gt; None</h3>
<p>The function `test_full_docs_no_code_scan` is a pytest test case designed to verify the behavior of a code documentation generation process when no code scanning is required. It sets up a temporary directory, mocks certain functions from the `explaincode` module to control their behavior during the test, and then runs the main function with specific command-line arguments.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">test_full_docs_no_code_scan</span>(
    tmp_path: Path, monkeypatch: pytest<span style="color: #666666">.</span>MonkeyPatch, caplog: pytest<span style="color: #666666">.</span>LogCaptureFixture
) <span style="color: #666666">-&gt;</span> <span style="color: #008000; font-weight: bold">None</span>:
    _create_fixture(tmp_path)
    tracker <span style="color: #666666">=</span> {<span style="color: #BA2121">&quot;rank&quot;</span>: <span style="color: #666666">0</span>, <span style="color: #BA2121">&quot;extract&quot;</span>: <span style="color: #666666">0</span>}

    <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">fake_rank</span>(root: Path, patterns: <span style="color: #008000">list</span>[<span style="color: #008000">str</span>]) <span style="color: #666666">-&gt;</span> <span style="color: #008000">list</span>[Path]:
        tracker[<span style="color: #BA2121">&quot;rank&quot;</span>] <span style="color: #666666">+=</span> <span style="color: #666666">1</span>
        <span style="color: #008000; font-weight: bold">return</span> [tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;a.py&quot;</span>]

    <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">fake_extract</span>(
        files: Iterable[Path], <span style="color: #666666">*</span>, max_files: <span style="color: #008000">int</span>, time_budget: <span style="color: #008000">int</span>, max_bytes: <span style="color: #008000">int</span>
    ) <span style="color: #666666">-&gt;</span> <span style="color: #008000">dict</span>[Path, <span style="color: #008000">str</span>]:
        tracker[<span style="color: #BA2121">&quot;extract&quot;</span>] <span style="color: #666666">+=</span> <span style="color: #666666">1</span>
        <span style="color: #008000; font-weight: bold">return</span> {}

    monkeypatch<span style="color: #666666">.</span>setattr(explaincode, <span style="color: #BA2121">&quot;LLMClient&quot;</span>, _mock_llm_client)
    monkeypatch<span style="color: #666666">.</span>setattr(explaincode, <span style="color: #BA2121">&quot;rank_code_files&quot;</span>, fake_rank)
    monkeypatch<span style="color: #666666">.</span>setattr(explaincode, <span style="color: #BA2121">&quot;extract_snippets&quot;</span>, fake_extract)

    caplog<span style="color: #666666">.</span>set_level(logging<span style="color: #666666">.</span>INFO)
    main([<span style="color: #BA2121">&quot;--path&quot;</span>, <span style="color: #008000">str</span>(tmp_path), <span style="color: #BA2121">&quot;--scan-code-if-needed&quot;</span>])
    <span style="color: #008000; font-weight: bold">assert</span> tracker[<span style="color: #BA2121">&quot;rank&quot;</span>] <span style="color: #666666">==</span> <span style="color: #666666">0</span>
    <span style="color: #008000; font-weight: bold">assert</span> tracker[<span style="color: #BA2121">&quot;extract&quot;</span>] <span style="color: #666666">==</span> <span style="color: #666666">0</span>
    log <span style="color: #666666">=</span> caplog<span style="color: #666666">.</span>text
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #BA2121">&quot;DOC PASS&quot;</span> <span style="color: #AA22FF; font-weight: bold">in</span> log
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #BA2121">&quot;Code scan skipped&quot;</span> <span style="color: #AA22FF; font-weight: bold">in</span> log
</code></pre>
<details>
<summary>Subfunction: fake_rank(root: Path, patterns: list[str]) -&gt; list[Path]</summary>
<h4 id="fake_rank">fake_rank(root: Path, patterns: list[str]) -&gt; list[Path]</h4>
<p>This function `fake_rank` takes a directory path (`root`) and a list of file patterns as input. It increments a global variable `tracker[&quot;rank&quot;]` by one and returns a list containing the path to a temporary file named &quot;a.py&quot; located in the specified directory.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">fake_rank</span>(root: Path, patterns: <span style="color: #008000">list</span>[<span style="color: #008000">str</span>]) <span style="color: #666666">-&gt;</span> <span style="color: #008000">list</span>[Path]:
        tracker[<span style="color: #BA2121">&quot;rank&quot;</span>] <span style="color: #666666">+=</span> <span style="color: #666666">1</span>
        <span style="color: #008000; font-weight: bold">return</span> [tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;a.py&quot;</span>]
</code></pre>
</details>
<details>
<summary>Subfunction: fake_extract(files: Iterable[Path], *, max_files: int, time_budget: int, max_bytes: int) -&gt; dict[Path, str]</summary>
<h4 id="fake_extract">fake_extract(files: Iterable[Path], *, max_files: int, time_budget: int, max_bytes: int) -&gt; dict[Path, str]</h4>
<p>The function `fake_extract` takes an iterable of file paths and optional parameters for maximum files, time budget, and maximum bytes. It increments a tracker entry for &quot;extract&quot; by one and returns an empty dictionary mapping file paths to strings.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">fake_extract</span>(
        files: Iterable[Path], <span style="color: #666666">*</span>, max_files: <span style="color: #008000">int</span>, time_budget: <span style="color: #008000">int</span>, max_bytes: <span style="color: #008000">int</span>
    ) <span style="color: #666666">-&gt;</span> <span style="color: #008000">dict</span>[Path, <span style="color: #008000">str</span>]:
        tracker[<span style="color: #BA2121">&quot;extract&quot;</span>] <span style="color: #666666">+=</span> <span style="color: #666666">1</span>
        <span style="color: #008000; font-weight: bold">return</span> {}
</code></pre>
</details>
<h3 id="test_missing_run_triggers_code_fallback_with_limits">test_missing_run_triggers_code_fallback_with_limits(tmp_path: Path, monkeypatch: pytest.MonkeyPatch, caplog: pytest.LogCaptureFixture) -&gt; None</h3>
<p>This function, `test_missing_run_triggers_code_fallback_with_limits`, is a test case designed to verify the behavior of a code summarization system when it encounters missing run instructions in a user manual. The test sets up a temporary directory with a README file and three Python files, simulates the behavior of an LLM client that provides summaries based on system prompts, and mocks functions related to ranking and extracting code snippets.

The function uses `monkeypatch` to replace the actual LLMClient class with a dummy implementation that returns specific responses based on the content of the system prompt. It also replaces the `rank_code_files` and `extract_snippets` functions with fake versions that track their calls and return predefined results.

When the test is run, it invokes the main function with various command-line arguments to simulate scanning code files and generating a user manual. The test asserts that the generated HTML does not contain the placeholder text &quot;[[NEEDS_RUN_INSTRUCTIONS]]&quot;, indicating that the missing instructions have been filled using code from the scanned files.

The test also checks that the fake functions were called as expected, with the correct arguments, and verifies that the log output contains specific messages indicating the progress of the summarization process.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">test_missing_run_triggers_code_fallback_with_limits</span>(
    tmp_path: Path, monkeypatch: pytest<span style="color: #666666">.</span>MonkeyPatch, caplog: pytest<span style="color: #666666">.</span>LogCaptureFixture
) <span style="color: #666666">-&gt;</span> <span style="color: #008000; font-weight: bold">None</span>:
    (tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;README.md&quot;</span>)<span style="color: #666666">.</span>write_text(<span style="color: #BA2121">&quot;Only overview&quot;</span>, encoding<span style="color: #666666">=</span><span style="color: #BA2121">&quot;utf-8&quot;</span>)

    <span style="color: #008000; font-weight: bold">class</span> <span style="color: #0000FF; font-weight: bold">Dummy</span>:
        <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">summarize</span>(<span style="color: #008000">self</span>, text: <span style="color: #008000">str</span>, prompt_type: <span style="color: #008000">str</span>, system_prompt: <span style="color: #008000">str</span> <span style="color: #666666">=</span> <span style="color: #BA2121">&quot;&quot;</span>) <span style="color: #666666">-&gt;</span> <span style="color: #008000">str</span>:
            <span style="color: #008000; font-weight: bold">if</span> <span style="color: #BA2121">&quot;How to Run&quot;</span> <span style="color: #AA22FF; font-weight: bold">in</span> system_prompt:
                <span style="color: #008000; font-weight: bold">return</span> <span style="color: #BA2121">&quot;[[NEEDS_RUN_INSTRUCTIONS]]&quot;</span>
            <span style="color: #008000; font-weight: bold">if</span> <span style="color: #BA2121">&quot;enhancing a user manual&quot;</span> <span style="color: #AA22FF; font-weight: bold">in</span> system_prompt:
                manual_match <span style="color: #666666">=</span> re<span style="color: #666666">.</span>search(<span style="color: #BA2121">r&quot;Manual:\n(.*?)\n\nSection:&quot;</span>, text, re<span style="color: #666666">.</span>DOTALL)
                manual_text <span style="color: #666666">=</span> manual_match<span style="color: #666666">.</span>group(<span style="color: #666666">1</span>)
                <span style="color: #008000; font-weight: bold">return</span> manual_text<span style="color: #666666">.</span>replace(<span style="color: #BA2121">&quot;[[NEEDS_RUN_INSTRUCTIONS]]&quot;</span>, <span style="color: #BA2121">&quot;use it&quot;</span>)
            <span style="color: #008000; font-weight: bold">return</span> <span style="color: #BA2121">&quot;x&quot;</span>

    paths <span style="color: #666666">=</span> [tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">f&quot;f</span><span style="color: #A45A77; font-weight: bold">{</span>i<span style="color: #A45A77; font-weight: bold">}</span><span style="color: #BA2121">.py&quot;</span> <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(<span style="color: #666666">3</span>)]
    tracker: <span style="color: #008000">dict</span>[<span style="color: #008000">str</span>, <span style="color: #008000">object</span>] <span style="color: #666666">=</span> {<span style="color: #BA2121">&quot;rank&quot;</span>: <span style="color: #666666">0</span>, <span style="color: #BA2121">&quot;extract&quot;</span>: <span style="color: #666666">0</span>}

    <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">fake_rank</span>(root: Path, patterns: <span style="color: #008000">list</span>[<span style="color: #008000">str</span>]) <span style="color: #666666">-&gt;</span> <span style="color: #008000">list</span>[Path]:
        tracker[<span style="color: #BA2121">&quot;rank&quot;</span>] <span style="color: #666666">+=</span> <span style="color: #666666">1</span>
        <span style="color: #008000; font-weight: bold">return</span> paths

    <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">fake_extract</span>(
        files: Iterable[Path], <span style="color: #666666">*</span>, max_files: <span style="color: #008000">int</span>, time_budget: <span style="color: #008000">int</span>, max_bytes: <span style="color: #008000">int</span>
    ) <span style="color: #666666">-&gt;</span> <span style="color: #008000">dict</span>[Path, <span style="color: #008000">str</span>]:
        tracker[<span style="color: #BA2121">&quot;extract&quot;</span>] <span style="color: #666666">+=</span> <span style="color: #666666">1</span>
        lst <span style="color: #666666">=</span> <span style="color: #008000">list</span>(files)
        tracker[<span style="color: #BA2121">&quot;kwargs&quot;</span>] <span style="color: #666666">=</span> {<span style="color: #BA2121">&quot;max_files&quot;</span>: max_files, <span style="color: #BA2121">&quot;time_budget&quot;</span>: time_budget}
        tracker[<span style="color: #BA2121">&quot;scanned&quot;</span>] <span style="color: #666666">=</span> lst[:max_files]
        <span style="color: #008000; font-weight: bold">return</span> {p: <span style="color: #BA2121">&quot;run code&quot;</span> <span style="color: #008000; font-weight: bold">for</span> p <span style="color: #AA22FF; font-weight: bold">in</span> lst[:max_files]}

    monkeypatch<span style="color: #666666">.</span>setattr(explaincode, <span style="color: #BA2121">&quot;LLMClient&quot;</span>, <span style="color: #008000; font-weight: bold">lambda</span>: Dummy())
    monkeypatch<span style="color: #666666">.</span>setattr(explaincode, <span style="color: #BA2121">&quot;rank_code_files&quot;</span>, fake_rank)
    monkeypatch<span style="color: #666666">.</span>setattr(explaincode, <span style="color: #BA2121">&quot;extract_snippets&quot;</span>, fake_extract)

    caplog<span style="color: #666666">.</span>set_level(logging<span style="color: #666666">.</span>INFO)
    main(
        [
            <span style="color: #BA2121">&quot;--path&quot;</span>,
            <span style="color: #008000">str</span>(tmp_path),
            <span style="color: #BA2121">&quot;--scan-code-if-needed&quot;</span>,
            <span style="color: #BA2121">&quot;--max-code-files&quot;</span>,
            <span style="color: #BA2121">&quot;1&quot;</span>,
            <span style="color: #BA2121">&quot;--code-time-budget-seconds&quot;</span>,
            <span style="color: #BA2121">&quot;5&quot;</span>,
        ]
    )
    html <span style="color: #666666">=</span> (tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;user_manual.html&quot;</span>)<span style="color: #666666">.</span>read_text(encoding<span style="color: #666666">=</span><span style="color: #BA2121">&quot;utf-8&quot;</span>)
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #BA2121">&quot;NEEDS_RUN_INSTRUCTIONS&quot;</span> <span style="color: #AA22FF; font-weight: bold">not</span> <span style="color: #AA22FF; font-weight: bold">in</span> html
    <span style="color: #008000; font-weight: bold">assert</span> tracker[<span style="color: #BA2121">&quot;rank&quot;</span>] <span style="color: #666666">==</span> <span style="color: #666666">1</span>
    <span style="color: #008000; font-weight: bold">assert</span> tracker[<span style="color: #BA2121">&quot;extract&quot;</span>] <span style="color: #666666">==</span> <span style="color: #666666">1</span>
    <span style="color: #008000; font-weight: bold">assert</span> tracker[<span style="color: #BA2121">&quot;kwargs&quot;</span>] <span style="color: #666666">==</span> {<span style="color: #BA2121">&quot;max_files&quot;</span>: <span style="color: #666666">1</span>, <span style="color: #BA2121">&quot;time_budget&quot;</span>: <span style="color: #666666">5</span>}
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #008000">len</span>(tracker[<span style="color: #BA2121">&quot;scanned&quot;</span>]) <span style="color: #666666">==</span> <span style="color: #666666">1</span>
    log <span style="color: #666666">=</span> caplog<span style="color: #666666">.</span>text
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #BA2121">&quot;Pass 1 missing sections&quot;</span> <span style="color: #AA22FF; font-weight: bold">in</span> log
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #BA2121">&quot;How to Run&quot;</span> <span style="color: #AA22FF; font-weight: bold">in</span> log
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #BA2121">&quot;Filled How to Run using code from: f0.py&quot;</span> <span style="color: #AA22FF; font-weight: bold">in</span> log
</code></pre>
<details>
<summary>Subfunction: fake_rank(root: Path, patterns: list[str]) -&gt; list[Path]</summary>
<h4 id="fake_rank">fake_rank(root: Path, patterns: list[str]) -&gt; list[Path]</h4>
<p>The function `fake_rank` takes a `root` directory path and a list of file name patterns as input. It increments a global variable `tracker[&quot;rank&quot;]` by one and returns a list of file paths that match the given patterns.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">fake_rank</span>(root: Path, patterns: <span style="color: #008000">list</span>[<span style="color: #008000">str</span>]) <span style="color: #666666">-&gt;</span> <span style="color: #008000">list</span>[Path]:
        tracker[<span style="color: #BA2121">&quot;rank&quot;</span>] <span style="color: #666666">+=</span> <span style="color: #666666">1</span>
        <span style="color: #008000; font-weight: bold">return</span> paths
</code></pre>
</details>
<details>
<summary>Subfunction: fake_extract(files: Iterable[Path], *, max_files: int, time_budget: int, max_bytes: int) -&gt; dict[Path, str]</summary>
<h4 id="fake_extract">fake_extract(files: Iterable[Path], *, max_files: int, time_budget: int, max_bytes: int) -&gt; dict[Path, str]</h4>
<p>The function `fake_extract` processes a list of files and returns a dictionary mapping each file to the string &quot;run code&quot;. It takes an iterable of `Path` objects representing the files, along with optional parameters `max_files`, `time_budget`, and `max_bytes`. The function updates a tracker dictionary with the number of extract operations performed, the keyword arguments used, and the list of scanned files. It then returns a dictionary where each file path is associated with the string &quot;run code&quot;.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">fake_extract</span>(
        files: Iterable[Path], <span style="color: #666666">*</span>, max_files: <span style="color: #008000">int</span>, time_budget: <span style="color: #008000">int</span>, max_bytes: <span style="color: #008000">int</span>
    ) <span style="color: #666666">-&gt;</span> <span style="color: #008000">dict</span>[Path, <span style="color: #008000">str</span>]:
        tracker[<span style="color: #BA2121">&quot;extract&quot;</span>] <span style="color: #666666">+=</span> <span style="color: #666666">1</span>
        lst <span style="color: #666666">=</span> <span style="color: #008000">list</span>(files)
        tracker[<span style="color: #BA2121">&quot;kwargs&quot;</span>] <span style="color: #666666">=</span> {<span style="color: #BA2121">&quot;max_files&quot;</span>: max_files, <span style="color: #BA2121">&quot;time_budget&quot;</span>: time_budget}
        tracker[<span style="color: #BA2121">&quot;scanned&quot;</span>] <span style="color: #666666">=</span> lst[:max_files]
        <span style="color: #008000; font-weight: bold">return</span> {p: <span style="color: #BA2121">&quot;run code&quot;</span> <span style="color: #008000; font-weight: bold">for</span> p <span style="color: #AA22FF; font-weight: bold">in</span> lst[:max_files]}
</code></pre>
</details>
<h3 id="test_no_code_flag_skips_code_fallback">test_no_code_flag_skips_code_fallback(tmp_path: Path, monkeypatch: pytest.MonkeyPatch, caplog: pytest.LogCaptureFixture) -&gt; None</h3>
<p>This function, `test_no_code_flag_skips_code_fallback`, is a test case for the behavior of a code summarization tool when the `--no-code` flag is used. It sets up a temporary directory with a README file containing only an overview text. The function then mocks several components of the code summarization process, including the LLMClient, rank_code_files, and extract_snippets functions. These are replaced with dummy implementations that track calls and return predefined values.

The test case asserts that when the `--no-code` flag is specified during a call to the main function, the code scanning processes (rank_code_files and extract_snippets) are not called, as indicated by the tracker dictionary. It also checks that an informational log message is generated indicating that the code scan was skipped due to the `--no-code` flag being specified.

The test further verifies that the expected output (&quot;How to Run&quot;) is present in the log, suggesting that the summary generation process still proceeds without attempting to analyze the code, and instead uses a fallback mechanism based on the existing README content.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">test_no_code_flag_skips_code_fallback</span>(
    tmp_path: Path, monkeypatch: pytest<span style="color: #666666">.</span>MonkeyPatch, caplog: pytest<span style="color: #666666">.</span>LogCaptureFixture
) <span style="color: #666666">-&gt;</span> <span style="color: #008000; font-weight: bold">None</span>:
    (tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;README.md&quot;</span>)<span style="color: #666666">.</span>write_text(<span style="color: #BA2121">&quot;Only overview&quot;</span>, encoding<span style="color: #666666">=</span><span style="color: #BA2121">&quot;utf-8&quot;</span>)

    <span style="color: #008000; font-weight: bold">class</span> <span style="color: #0000FF; font-weight: bold">Dummy</span>:
        <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">summarize</span>(
            <span style="color: #008000">self</span>, text: <span style="color: #008000">str</span>, prompt_type: <span style="color: #008000">str</span>, system_prompt: <span style="color: #008000">str</span> <span style="color: #666666">=</span> <span style="color: #BA2121">&quot;&quot;</span>
        ) <span style="color: #666666">-&gt;</span> <span style="color: #008000">str</span>:
            <span style="color: #008000; font-weight: bold">return</span> <span style="color: #BA2121">&quot;Overview: x</span><span style="color: #AA5D1F; font-weight: bold">\\</span><span style="color: #BA2121">nHow to Run: [[NEEDS_RUN_INSTRUCTIONS]]&quot;</span>

    tracker <span style="color: #666666">=</span> {<span style="color: #BA2121">&quot;rank&quot;</span>: <span style="color: #666666">0</span>, <span style="color: #BA2121">&quot;extract&quot;</span>: <span style="color: #666666">0</span>}

    <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">fake_rank</span>(root: Path, patterns: <span style="color: #008000">list</span>[<span style="color: #008000">str</span>]) <span style="color: #666666">-&gt;</span> <span style="color: #008000">list</span>[Path]:
        tracker[<span style="color: #BA2121">&quot;rank&quot;</span>] <span style="color: #666666">+=</span> <span style="color: #666666">1</span>
        <span style="color: #008000; font-weight: bold">return</span> []

    <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">fake_extract</span>(
        files: Iterable[Path], <span style="color: #666666">*</span>, max_files: <span style="color: #008000">int</span>, time_budget: <span style="color: #008000">int</span>, max_bytes: <span style="color: #008000">int</span>
    ) <span style="color: #666666">-&gt;</span> <span style="color: #008000">dict</span>[Path, <span style="color: #008000">str</span>]:
        tracker[<span style="color: #BA2121">&quot;extract&quot;</span>] <span style="color: #666666">+=</span> <span style="color: #666666">1</span>
        <span style="color: #008000; font-weight: bold">return</span> {}

    monkeypatch<span style="color: #666666">.</span>setattr(explaincode, <span style="color: #BA2121">&quot;LLMClient&quot;</span>, <span style="color: #008000; font-weight: bold">lambda</span>: Dummy())
    monkeypatch<span style="color: #666666">.</span>setattr(explaincode, <span style="color: #BA2121">&quot;rank_code_files&quot;</span>, fake_rank)
    monkeypatch<span style="color: #666666">.</span>setattr(explaincode, <span style="color: #BA2121">&quot;extract_snippets&quot;</span>, fake_extract)

    caplog<span style="color: #666666">.</span>set_level(logging<span style="color: #666666">.</span>INFO)
    main([<span style="color: #BA2121">&quot;--path&quot;</span>, <span style="color: #008000">str</span>(tmp_path), <span style="color: #BA2121">&quot;--scan-code-if-needed&quot;</span>, <span style="color: #BA2121">&quot;--no-code&quot;</span>])
    <span style="color: #008000; font-weight: bold">assert</span> tracker[<span style="color: #BA2121">&quot;rank&quot;</span>] <span style="color: #666666">==</span> <span style="color: #666666">0</span>
    <span style="color: #008000; font-weight: bold">assert</span> tracker[<span style="color: #BA2121">&quot;extract&quot;</span>] <span style="color: #666666">==</span> <span style="color: #666666">0</span>
    log <span style="color: #666666">=</span> caplog<span style="color: #666666">.</span>text
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #BA2121">&quot;Code scan skipped: --no-code specified&quot;</span> <span style="color: #AA22FF; font-weight: bold">in</span> log
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #BA2121">&quot;How to Run&quot;</span> <span style="color: #AA22FF; font-weight: bold">in</span> log
</code></pre>
<details>
<summary>Subfunction: fake_rank(root: Path, patterns: list[str]) -&gt; list[Path]</summary>
<h4 id="fake_rank">fake_rank(root: Path, patterns: list[str]) -&gt; list[Path]</h4>
<p>The function `fake_rank` takes a `root` directory path and a list of `patterns` as input. It increments a global variable `tracker[&quot;rank&quot;]` by 1 and returns an empty list of paths.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">fake_rank</span>(root: Path, patterns: <span style="color: #008000">list</span>[<span style="color: #008000">str</span>]) <span style="color: #666666">-&gt;</span> <span style="color: #008000">list</span>[Path]:
        tracker[<span style="color: #BA2121">&quot;rank&quot;</span>] <span style="color: #666666">+=</span> <span style="color: #666666">1</span>
        <span style="color: #008000; font-weight: bold">return</span> []
</code></pre>
</details>
<details>
<summary>Subfunction: fake_extract(files: Iterable[Path], *, max_files: int, time_budget: int, max_bytes: int) -&gt; dict[Path, str]</summary>
<h4 id="fake_extract">fake_extract(files: Iterable[Path], *, max_files: int, time_budget: int, max_bytes: int) -&gt; dict[Path, str]</h4>
<p>The function `fake_extract` takes an iterable of file paths and optional parameters for maximum files, time budget, and maximum bytes. It increments a tracker entry for &quot;extract&quot; by one and returns an empty dictionary mapping file paths to strings.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">fake_extract</span>(
        files: Iterable[Path], <span style="color: #666666">*</span>, max_files: <span style="color: #008000">int</span>, time_budget: <span style="color: #008000">int</span>, max_bytes: <span style="color: #008000">int</span>
    ) <span style="color: #666666">-&gt;</span> <span style="color: #008000">dict</span>[Path, <span style="color: #008000">str</span>]:
        tracker[<span style="color: #BA2121">&quot;extract&quot;</span>] <span style="color: #666666">+=</span> <span style="color: #666666">1</span>
        <span style="color: #008000; font-weight: bold">return</span> {}
</code></pre>
</details>
<h3 id="test_force_code_flag_triggers_code_fallback">test_force_code_flag_triggers_code_fallback(tmp_path: Path, monkeypatch: pytest.MonkeyPatch, caplog: pytest.LogCaptureFixture) -&gt; None</h3>
<p>This function `test_force_code_flag_triggers_code_fallback` is a unit test for the functionality that triggers code fallback when the `--force-code` flag is used. It uses fixtures and monkeypatching to mock certain behaviors of the `explaincode` module, specifically the `LLMClient`, `rank_code_files`, and `extract_snippets` functions. The test asserts that these functions are called exactly once each and checks if the appropriate log messages are generated when the `--force-code` flag is enabled.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">test_force_code_flag_triggers_code_fallback</span>(
    tmp_path: Path, monkeypatch: pytest<span style="color: #666666">.</span>MonkeyPatch, caplog: pytest<span style="color: #666666">.</span>LogCaptureFixture
) <span style="color: #666666">-&gt;</span> <span style="color: #008000; font-weight: bold">None</span>:
    _create_fixture(tmp_path)
    tracker <span style="color: #666666">=</span> {<span style="color: #BA2121">&quot;rank&quot;</span>: <span style="color: #666666">0</span>, <span style="color: #BA2121">&quot;extract&quot;</span>: <span style="color: #666666">0</span>}

    <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">fake_rank</span>(root: Path, patterns: <span style="color: #008000">list</span>[<span style="color: #008000">str</span>]) <span style="color: #666666">-&gt;</span> <span style="color: #008000">list</span>[Path]:
        tracker[<span style="color: #BA2121">&quot;rank&quot;</span>] <span style="color: #666666">+=</span> <span style="color: #666666">1</span>
        <span style="color: #008000; font-weight: bold">return</span> [tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;script.py&quot;</span>]

    <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">fake_extract</span>(
        files: Iterable[Path], <span style="color: #666666">*</span>, max_files: <span style="color: #008000">int</span>, time_budget: <span style="color: #008000">int</span>, max_bytes: <span style="color: #008000">int</span>
    ) <span style="color: #666666">-&gt;</span> <span style="color: #008000">dict</span>[Path, <span style="color: #008000">str</span>]:
        tracker[<span style="color: #BA2121">&quot;extract&quot;</span>] <span style="color: #666666">+=</span> <span style="color: #666666">1</span>
        <span style="color: #008000; font-weight: bold">return</span> {<span style="color: #008000">next</span>(<span style="color: #008000">iter</span>(files)): <span style="color: #BA2121">&quot;code&quot;</span>}

    monkeypatch<span style="color: #666666">.</span>setattr(explaincode, <span style="color: #BA2121">&quot;LLMClient&quot;</span>, _mock_llm_client)
    monkeypatch<span style="color: #666666">.</span>setattr(explaincode, <span style="color: #BA2121">&quot;rank_code_files&quot;</span>, fake_rank)
    monkeypatch<span style="color: #666666">.</span>setattr(explaincode, <span style="color: #BA2121">&quot;extract_snippets&quot;</span>, fake_extract)

    caplog<span style="color: #666666">.</span>set_level(logging<span style="color: #666666">.</span>INFO)
    main([<span style="color: #BA2121">&quot;--path&quot;</span>, <span style="color: #008000">str</span>(tmp_path), <span style="color: #BA2121">&quot;--force-code&quot;</span>])
    <span style="color: #008000; font-weight: bold">assert</span> tracker[<span style="color: #BA2121">&quot;rank&quot;</span>] <span style="color: #666666">==</span> <span style="color: #666666">1</span>
    <span style="color: #008000; font-weight: bold">assert</span> tracker[<span style="color: #BA2121">&quot;extract&quot;</span>] <span style="color: #666666">==</span> <span style="color: #666666">1</span>
    log <span style="color: #666666">=</span> caplog<span style="color: #666666">.</span>text
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #BA2121">&quot;Code scan triggered: --force-code enabled&quot;</span> <span style="color: #AA22FF; font-weight: bold">in</span> log
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #BA2121">&quot;Pass 1 complete: no sections missing&quot;</span> <span style="color: #AA22FF; font-weight: bold">in</span> log
</code></pre>
<details>
<summary>Subfunction: fake_rank(root: Path, patterns: list[str]) -&gt; list[Path]</summary>
<h4 id="fake_rank">fake_rank(root: Path, patterns: list[str]) -&gt; list[Path]</h4>
<p>The function `fake_rank` takes a directory path (`root`) and a list of file patterns as arguments. It increments a global counter `tracker[&quot;rank&quot;]` by one and returns a list containing the path to a temporary script file named &quot;script.py&quot; located in a subdirectory named after the current rank value, which is derived from the incremented tracker count.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">fake_rank</span>(root: Path, patterns: <span style="color: #008000">list</span>[<span style="color: #008000">str</span>]) <span style="color: #666666">-&gt;</span> <span style="color: #008000">list</span>[Path]:
        tracker[<span style="color: #BA2121">&quot;rank&quot;</span>] <span style="color: #666666">+=</span> <span style="color: #666666">1</span>
        <span style="color: #008000; font-weight: bold">return</span> [tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;script.py&quot;</span>]
</code></pre>
</details>
<details>
<summary>Subfunction: fake_extract(files: Iterable[Path], *, max_files: int, time_budget: int, max_bytes: int) -&gt; dict[Path, str]</summary>
<h4 id="fake_extract">fake_extract(files: Iterable[Path], *, max_files: int, time_budget: int, max_bytes: int) -&gt; dict[Path, str]</h4>
<p>The `fake_extract` function takes an iterable of file paths and extracts code from them. It returns a dictionary where each key is a file path and the corresponding value is the extracted code. The function uses a tracker to increment the count of extract operations.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">fake_extract</span>(
        files: Iterable[Path], <span style="color: #666666">*</span>, max_files: <span style="color: #008000">int</span>, time_budget: <span style="color: #008000">int</span>, max_bytes: <span style="color: #008000">int</span>
    ) <span style="color: #666666">-&gt;</span> <span style="color: #008000">dict</span>[Path, <span style="color: #008000">str</span>]:
        tracker[<span style="color: #BA2121">&quot;extract&quot;</span>] <span style="color: #666666">+=</span> <span style="color: #666666">1</span>
        <span style="color: #008000; font-weight: bold">return</span> {<span style="color: #008000">next</span>(<span style="color: #008000">iter</span>(files)): <span style="color: #BA2121">&quot;code&quot;</span>}
</code></pre>
</details>
<h3 id="test_custom_title_and_filename">test_custom_title_and_filename(tmp_path: Path, monkeypatch: pytest.MonkeyPatch) -&gt; None</h3>
<p>The function `test_custom_title_and_filename` is designed to test the functionality of generating a custom title and filename for HTML documentation. It uses a temporary path (`tmp_path`) and a mock LLM client (`_mock_llm_client`) provided by `monkeypatch`. The function calls the `main` function with specified arguments, including the path to the temporary directory and a custom title &quot;Fancy Guide&quot;. After executing the main function, it checks for the existence of an output HTML file and an evidence JSON file in the temporary directory. It also verifies that the generated HTML file contains the expected `&lt;h1&gt;` tag with the text &quot;Fancy Guide&quot;.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">test_custom_title_and_filename</span>(tmp_path: Path, monkeypatch: pytest<span style="color: #666666">.</span>MonkeyPatch) <span style="color: #666666">-&gt;</span> <span style="color: #008000; font-weight: bold">None</span>:
    _create_fixture(tmp_path)
    monkeypatch<span style="color: #666666">.</span>setattr(explaincode, <span style="color: #BA2121">&quot;LLMClient&quot;</span>, _mock_llm_client)
    main([<span style="color: #BA2121">&quot;--path&quot;</span>, <span style="color: #008000">str</span>(tmp_path), <span style="color: #BA2121">&quot;--title&quot;</span>, <span style="color: #BA2121">&quot;Fancy Guide&quot;</span>])
    out_file <span style="color: #666666">=</span> tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;fancy_guide.html&quot;</span>
    evidence_file <span style="color: #666666">=</span> tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;fancy_guide_evidence.json&quot;</span>
    <span style="color: #008000; font-weight: bold">assert</span> out_file<span style="color: #666666">.</span>exists()
    <span style="color: #008000; font-weight: bold">assert</span> evidence_file<span style="color: #666666">.</span>exists()
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #BA2121">&quot;&lt;h1&gt;Fancy Guide&lt;/h1&gt;&quot;</span> <span style="color: #AA22FF; font-weight: bold">in</span> out_file<span style="color: #666666">.</span>read_text(encoding<span style="color: #666666">=</span><span style="color: #BA2121">&quot;utf-8&quot;</span>)
</code></pre>
<h3 id="test_insert_into_index">test_insert_into_index(tmp_path: Path, monkeypatch: pytest.MonkeyPatch) -&gt; None</h3>
<p>This function, `test_insert_into_index`, is designed to test the functionality of inserting a link into an HTML index file. It performs the following steps:

1. Creates a temporary directory and sets up a fixture using `_create_fixture`.
2. Creates an output directory within the temporary directory.
3. Initializes an `index.html` file in the output directory with basic HTML structure containing an unordered list (`&lt;ul&gt;`).
4. Uses `monkeypatch` to replace the `LLMClient` attribute of the `explaincode` module with `_mock_llm_client`.
5. Calls the `main` function with specific command-line arguments to simulate running a code summarization tool, directing it to insert links into the index file.
6. Reads the updated `index.html` file and asserts that a link to &quot;user_manual.html&quot; is present in the HTML content.

This test ensures that the code insertion functionality works as expected when generating documentation for Python projects using the DocGen-LM tool.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">test_insert_into_index</span>(tmp_path: Path, monkeypatch: pytest<span style="color: #666666">.</span>MonkeyPatch) <span style="color: #666666">-&gt;</span> <span style="color: #008000; font-weight: bold">None</span>:
    _create_fixture(tmp_path)
    out_dir <span style="color: #666666">=</span> tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;out&quot;</span>
    out_dir<span style="color: #666666">.</span>mkdir()
    index <span style="color: #666666">=</span> out_dir <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;index.html&quot;</span>
    index<span style="color: #666666">.</span>write_text(<span style="color: #BA2121">&quot;&lt;html&gt;&lt;body&gt;&lt;ul&gt;&lt;/ul&gt;&lt;/body&gt;&lt;/html&gt;&quot;</span>, encoding<span style="color: #666666">=</span><span style="color: #BA2121">&quot;utf-8&quot;</span>)
    monkeypatch<span style="color: #666666">.</span>setattr(explaincode, <span style="color: #BA2121">&quot;LLMClient&quot;</span>, _mock_llm_client)
    main([<span style="color: #BA2121">&quot;--path&quot;</span>, <span style="color: #008000">str</span>(tmp_path), <span style="color: #BA2121">&quot;--output&quot;</span>, <span style="color: #008000">str</span>(out_dir), <span style="color: #BA2121">&quot;--insert-into-index&quot;</span>])
    html <span style="color: #666666">=</span> index<span style="color: #666666">.</span>read_text(encoding<span style="color: #666666">=</span><span style="color: #BA2121">&quot;utf-8&quot;</span>)
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #BA2121">&#39;&lt;a href=&quot;user_manual.html&quot;&gt;User Manual&lt;/a&gt;&#39;</span> <span style="color: #AA22FF; font-weight: bold">in</span> html
</code></pre>
<h3 id="test_docs_index_default_and_injection">test_docs_index_default_and_injection(tmp_path: Path, monkeypatch: pytest.MonkeyPatch) -&gt; None</h3>
<p>This function `test_docs_index_default_and_injection` tests the functionality of inserting a user manual into an index file. It uses a temporary path for testing, creates a mock LLM client, and invokes the main function with specific arguments to generate documentation. The test checks if the user manual and evidence files are created, and verifies that the navigation menu in the index file correctly links to the user manual.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">test_docs_index_default_and_injection</span>(
    tmp_path: Path, monkeypatch: pytest<span style="color: #666666">.</span>MonkeyPatch
) <span style="color: #666666">-&gt;</span> <span style="color: #008000; font-weight: bold">None</span>:
    _create_fixture(tmp_path)
    docs_dir <span style="color: #666666">=</span> tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;docs&quot;</span>
    docs_dir<span style="color: #666666">.</span>mkdir()
    (docs_dir <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;index.html&quot;</span>)<span style="color: #666666">.</span>write_text(<span style="color: #BA2121">&quot;&lt;html&gt;&lt;body&gt;&lt;nav&gt;&lt;/nav&gt;&lt;/body&gt;&lt;/html&gt;&quot;</span>, encoding<span style="color: #666666">=</span><span style="color: #BA2121">&quot;utf-8&quot;</span>)
    monkeypatch<span style="color: #666666">.</span>setattr(explaincode, <span style="color: #BA2121">&quot;LLMClient&quot;</span>, _mock_llm_client)
    main([<span style="color: #BA2121">&quot;--path&quot;</span>, <span style="color: #008000">str</span>(tmp_path), <span style="color: #BA2121">&quot;--insert-into-index&quot;</span>])
    manual <span style="color: #666666">=</span> docs_dir <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;user_manual.html&quot;</span>
    evidence <span style="color: #666666">=</span> docs_dir <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;user_manual_evidence.json&quot;</span>
    <span style="color: #008000; font-weight: bold">assert</span> manual<span style="color: #666666">.</span>exists()
    <span style="color: #008000; font-weight: bold">assert</span> evidence<span style="color: #666666">.</span>exists()
    soup <span style="color: #666666">=</span> BeautifulSoup((docs_dir <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;index.html&quot;</span>)<span style="color: #666666">.</span>read_text(encoding<span style="color: #666666">=</span><span style="color: #BA2121">&quot;utf-8&quot;</span>), <span style="color: #BA2121">&quot;html.parser&quot;</span>)
    nav <span style="color: #666666">=</span> soup<span style="color: #666666">.</span>find(<span style="color: #BA2121">&quot;nav&quot;</span>)
    <span style="color: #008000; font-weight: bold">assert</span> nav <span style="color: #AA22FF; font-weight: bold">is</span> <span style="color: #AA22FF; font-weight: bold">not</span> <span style="color: #008000; font-weight: bold">None</span>
    first <span style="color: #666666">=</span> nav<span style="color: #666666">.</span>find(<span style="color: #BA2121">&quot;a&quot;</span>)
    <span style="color: #008000; font-weight: bold">assert</span> first <span style="color: #AA22FF; font-weight: bold">and</span> first[<span style="color: #BA2121">&quot;href&quot;</span>] <span style="color: #666666">==</span> <span style="color: #BA2121">&quot;user_manual.html&quot;</span>
</code></pre>
<h3 id="test_insert_into_root_index">test_insert_into_root_index(tmp_path: Path, monkeypatch: pytest.MonkeyPatch) -&gt; None</h3>
<p>This function `test_insert_into_root_index` is a test case designed to verify the functionality of inserting a user manual into an HTML index file. It uses the `pytest` framework for testing and leverages `monkeypatch` to mock the `LLMClient` from the `explaincode` module with `_mock_llm_client`. The function performs the following steps:

1. Creates a temporary directory using `tmp_path`.
2. Writes an initial HTML structure to `index.html` in the temporary directory.
3. Mocks the `LLMClient` to simulate its behavior during the test.
4. Calls the `main` function with specific arguments to insert a user manual into the index file.
5. Verifies that the user manual and evidence files are created in the `docs` subdirectory of the temporary path.
6. Parses the modified `index.html` using `BeautifulSoup`.
7. Asserts that the `&lt;nav&gt;` element exists within the HTML structure.
8. Checks that the first link (`&lt;a&gt;`) inside the `&lt;nav&gt;` element has an `href` attribute pointing to the user manual file.

This test ensures that the process of inserting a user manual into the index file works as expected, including creating necessary files and updating the navigation structure</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">test_insert_into_root_index</span>(tmp_path: Path, monkeypatch: pytest<span style="color: #666666">.</span>MonkeyPatch) <span style="color: #666666">-&gt;</span> <span style="color: #008000; font-weight: bold">None</span>:
    _create_fixture(tmp_path)
    (tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;index.html&quot;</span>)<span style="color: #666666">.</span>write_text(<span style="color: #BA2121">&quot;&lt;html&gt;&lt;body&gt;&lt;nav&gt;&lt;/nav&gt;&lt;/body&gt;&lt;/html&gt;&quot;</span>, encoding<span style="color: #666666">=</span><span style="color: #BA2121">&quot;utf-8&quot;</span>)
    monkeypatch<span style="color: #666666">.</span>setattr(explaincode, <span style="color: #BA2121">&quot;LLMClient&quot;</span>, _mock_llm_client)
    main([<span style="color: #BA2121">&quot;--path&quot;</span>, <span style="color: #008000">str</span>(tmp_path), <span style="color: #BA2121">&quot;--insert-into-index&quot;</span>])
    manual <span style="color: #666666">=</span> tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;docs&quot;</span> <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;user_manual.html&quot;</span>
    evidence <span style="color: #666666">=</span> tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;docs&quot;</span> <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;user_manual_evidence.json&quot;</span>
    <span style="color: #008000; font-weight: bold">assert</span> manual<span style="color: #666666">.</span>exists()
    <span style="color: #008000; font-weight: bold">assert</span> evidence<span style="color: #666666">.</span>exists()
    soup <span style="color: #666666">=</span> BeautifulSoup((tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;index.html&quot;</span>)<span style="color: #666666">.</span>read_text(encoding<span style="color: #666666">=</span><span style="color: #BA2121">&quot;utf-8&quot;</span>), <span style="color: #BA2121">&quot;html.parser&quot;</span>)
    nav <span style="color: #666666">=</span> soup<span style="color: #666666">.</span>find(<span style="color: #BA2121">&quot;nav&quot;</span>)
    <span style="color: #008000; font-weight: bold">assert</span> nav <span style="color: #AA22FF; font-weight: bold">is</span> <span style="color: #AA22FF; font-weight: bold">not</span> <span style="color: #008000; font-weight: bold">None</span>
    first <span style="color: #666666">=</span> nav<span style="color: #666666">.</span>find(<span style="color: #BA2121">&quot;a&quot;</span>)
    <span style="color: #008000; font-weight: bold">assert</span> first <span style="color: #AA22FF; font-weight: bold">and</span> first[<span style="color: #BA2121">&quot;href&quot;</span>] <span style="color: #666666">==</span> <span style="color: #BA2121">&quot;docs/user_manual.html&quot;</span>
</code></pre>
<h3 id="test_chunking_triggers_multiple_calls_and_logs">test_chunking_triggers_multiple_calls_and_logs(tmp_path: Path, capsys: pytest.CaptureFixture[str]) -&gt; None</h3>
<p>The function `test_chunking_triggers_multiple_calls_and_logs` tests the behavior of a summarization process that involves chunking and merging text. It uses a dummy client to simulate the summarization calls, a temporary path for caching, and a capture fixture to capture output.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">test_chunking_triggers_multiple_calls_and_logs</span>(
    tmp_path: Path, capsys: pytest<span style="color: #666666">.</span>CaptureFixture[<span style="color: #008000">str</span>]
) <span style="color: #666666">-&gt;</span> <span style="color: #008000; font-weight: bold">None</span>:
    paragraph1 <span style="color: #666666">=</span> <span style="color: #BA2121">&quot;aaa &quot;</span> <span style="color: #666666">*</span> <span style="color: #666666">2000</span>
    paragraph2 <span style="color: #666666">=</span> <span style="color: #BA2121">&quot;bbb &quot;</span> <span style="color: #666666">*</span> <span style="color: #666666">2000</span>
    text <span style="color: #666666">=</span> <span style="color: #BA2121">&quot;</span><span style="color: #AA5D1F; font-weight: bold">\n\n</span><span style="color: #BA2121">&quot;</span><span style="color: #666666">.</span>join([paragraph1, paragraph2])

    <span style="color: #008000; font-weight: bold">class</span> <span style="color: #0000FF; font-weight: bold">Dummy</span>:
        <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">__init__</span>(<span style="color: #008000">self</span>) <span style="color: #666666">-&gt;</span> <span style="color: #008000; font-weight: bold">None</span>:
            <span style="color: #008000">self</span><span style="color: #666666">.</span>calls: <span style="color: #008000">list</span>[<span style="color: #008000">dict</span>] <span style="color: #666666">=</span> []

        <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">summarize</span>(<span style="color: #008000">self</span>, text: <span style="color: #008000">str</span>, prompt_type: <span style="color: #008000">str</span>, system_prompt: <span style="color: #008000">str</span> <span style="color: #666666">=</span> <span style="color: #BA2121">&quot;&quot;</span>) <span style="color: #666666">-&gt;</span> <span style="color: #008000">str</span>:
            <span style="color: #008000">self</span><span style="color: #666666">.</span>calls<span style="color: #666666">.</span>append(
                {<span style="color: #BA2121">&quot;text&quot;</span>: text, <span style="color: #BA2121">&quot;prompt_type&quot;</span>: prompt_type, <span style="color: #BA2121">&quot;system_prompt&quot;</span>: system_prompt}
            )
            <span style="color: #008000; font-weight: bold">if</span> system_prompt <span style="color: #666666">==</span> explaincode<span style="color: #666666">.</span>MERGE_SYSTEM_PROMPT:
                <span style="color: #008000; font-weight: bold">return</span> <span style="color: #BA2121">&quot;final&quot;</span>
            <span style="color: #008000; font-weight: bold">return</span> text<span style="color: #666666">.</span>split()[<span style="color: #666666">0</span>]

    client <span style="color: #666666">=</span> Dummy()
    cache <span style="color: #666666">=</span> ResponseCache(<span style="color: #008000">str</span>(tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;cache.json&quot;</span>))
    logging<span style="color: #666666">.</span>basicConfig(stream<span style="color: #666666">=</span>sys<span style="color: #666666">.</span>stdout, level<span style="color: #666666">=</span>logging<span style="color: #666666">.</span>DEBUG, force<span style="color: #666666">=</span><span style="color: #008000; font-weight: bold">True</span>)
    result <span style="color: #666666">=</span> manual_utils<span style="color: #666666">.</span>_summarize_manual(
        client, cache, text, chunking<span style="color: #666666">=</span><span style="color: #BA2121">&quot;auto&quot;</span>, source<span style="color: #666666">=</span><span style="color: #BA2121">&quot;src&quot;</span>
    )

    <span style="color: #008000; font-weight: bold">assert</span> result <span style="color: #666666">==</span> <span style="color: #BA2121">&quot;final&quot;</span>
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #008000">len</span>(client<span style="color: #666666">.</span>calls) <span style="color: #666666">==</span> <span style="color: #666666">3</span>
    chunk_calls <span style="color: #666666">=</span> client<span style="color: #666666">.</span>calls[:<span style="color: #666666">-1</span>]
    merge_call <span style="color: #666666">=</span> client<span style="color: #666666">.</span>calls[<span style="color: #666666">-1</span>]
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #008000">all</span>(c[<span style="color: #BA2121">&quot;system_prompt&quot;</span>] <span style="color: #666666">==</span> explaincode<span style="color: #666666">.</span>CHUNK_SYSTEM_PROMPT <span style="color: #008000; font-weight: bold">for</span> c <span style="color: #AA22FF; font-weight: bold">in</span> chunk_calls)
    <span style="color: #008000; font-weight: bold">assert</span> merge_call[<span style="color: #BA2121">&quot;system_prompt&quot;</span>] <span style="color: #666666">==</span> explaincode<span style="color: #666666">.</span>MERGE_SYSTEM_PROMPT
    <span style="color: #008000; font-weight: bold">assert</span> merge_call[<span style="color: #BA2121">&quot;text&quot;</span>] <span style="color: #666666">==</span> <span style="color: #BA2121">&quot;aaa</span><span style="color: #AA5D1F; font-weight: bold">\n\n</span><span style="color: #BA2121">bbb&quot;</span>

    out <span style="color: #666666">=</span> capsys<span style="color: #666666">.</span>readouterr()<span style="color: #666666">.</span>out
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #BA2121">&quot;Chunk 1/2 from src&quot;</span> <span style="color: #AA22FF; font-weight: bold">in</span> out
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #BA2121">&quot;Merged LLM response length&quot;</span> <span style="color: #AA22FF; font-weight: bold">in</span> out
</code></pre>
<h3 id="test_chunk_edit_hook_applied">test_chunk_edit_hook_applied(tmp_path: Path) -&gt; None</h3>
<p>The function `test_chunk_edit_hook_applied` tests the application of a chunk editing hook during the summarization process. It creates a dummy class `Dummy` with a `summarize` method that records calls and modifies text based on the system prompt. The `hook` function converts each chunk to uppercase. The test uses a temporary path for caching, initializes a `Dummy` client, and applies the `_summarize_manual` function with the `post_chunk_hook` set to the `hook`. It asserts that the final result is &quot;final&quot; and that the last call to `summarize` has its text converted to uppercase.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">test_chunk_edit_hook_applied</span>(tmp_path: Path) <span style="color: #666666">-&gt;</span> <span style="color: #008000; font-weight: bold">None</span>:
    paragraph1 <span style="color: #666666">=</span> <span style="color: #BA2121">&quot;aaa &quot;</span> <span style="color: #666666">*</span> <span style="color: #666666">2000</span>
    paragraph2 <span style="color: #666666">=</span> <span style="color: #BA2121">&quot;bbb &quot;</span> <span style="color: #666666">*</span> <span style="color: #666666">2000</span>
    text <span style="color: #666666">=</span> <span style="color: #BA2121">&quot;</span><span style="color: #AA5D1F; font-weight: bold">\n\n</span><span style="color: #BA2121">&quot;</span><span style="color: #666666">.</span>join([paragraph1, paragraph2])

    <span style="color: #008000; font-weight: bold">class</span> <span style="color: #0000FF; font-weight: bold">Dummy</span>:
        <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">__init__</span>(<span style="color: #008000">self</span>) <span style="color: #666666">-&gt;</span> <span style="color: #008000; font-weight: bold">None</span>:
            <span style="color: #008000">self</span><span style="color: #666666">.</span>calls: <span style="color: #008000">list</span>[<span style="color: #008000">dict</span>] <span style="color: #666666">=</span> []

        <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">summarize</span>(<span style="color: #008000">self</span>, text: <span style="color: #008000">str</span>, prompt_type: <span style="color: #008000">str</span>, system_prompt: <span style="color: #008000">str</span> <span style="color: #666666">=</span> <span style="color: #BA2121">&quot;&quot;</span>) <span style="color: #666666">-&gt;</span> <span style="color: #008000">str</span>:
            <span style="color: #008000">self</span><span style="color: #666666">.</span>calls<span style="color: #666666">.</span>append(
                {<span style="color: #BA2121">&quot;text&quot;</span>: text, <span style="color: #BA2121">&quot;prompt_type&quot;</span>: prompt_type, <span style="color: #BA2121">&quot;system_prompt&quot;</span>: system_prompt}
            )
            <span style="color: #008000; font-weight: bold">if</span> system_prompt <span style="color: #666666">==</span> explaincode<span style="color: #666666">.</span>MERGE_SYSTEM_PROMPT:
                <span style="color: #008000; font-weight: bold">return</span> <span style="color: #BA2121">&quot;final&quot;</span>
            <span style="color: #008000; font-weight: bold">return</span> text<span style="color: #666666">.</span>split()[<span style="color: #666666">0</span>]

    <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">hook</span>(chunks: <span style="color: #008000">list</span>[<span style="color: #008000">str</span>]) <span style="color: #666666">-&gt;</span> <span style="color: #008000">list</span>[<span style="color: #008000">str</span>]:
        <span style="color: #008000; font-weight: bold">return</span> [c<span style="color: #666666">.</span>upper() <span style="color: #008000; font-weight: bold">for</span> c <span style="color: #AA22FF; font-weight: bold">in</span> chunks]

    client <span style="color: #666666">=</span> Dummy()
    cache <span style="color: #666666">=</span> ResponseCache(<span style="color: #008000">str</span>(tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;cache.json&quot;</span>))
    result <span style="color: #666666">=</span> manual_utils<span style="color: #666666">.</span>_summarize_manual(
        client, cache, text, chunking<span style="color: #666666">=</span><span style="color: #BA2121">&quot;auto&quot;</span>, source<span style="color: #666666">=</span><span style="color: #BA2121">&quot;src&quot;</span>, post_chunk_hook<span style="color: #666666">=</span>hook
    )

    <span style="color: #008000; font-weight: bold">assert</span> result <span style="color: #666666">==</span> <span style="color: #BA2121">&quot;final&quot;</span>
    <span style="color: #008000; font-weight: bold">assert</span> client<span style="color: #666666">.</span>calls[<span style="color: #666666">-1</span>][<span style="color: #BA2121">&quot;text&quot;</span>] <span style="color: #666666">==</span> <span style="color: #BA2121">&quot;AAA</span><span style="color: #AA5D1F; font-weight: bold">\n\n</span><span style="color: #BA2121">BBB&quot;</span>
</code></pre>
<details>
<summary>Subfunction: hook(chunks: list[str]) -&gt; list[str]</summary>
<h4 id="hook">hook(chunks: list[str]) -&gt; list[str]</h4>
<p>The `hook` function takes a list of strings (`chunks`) as input and returns a new list where each string is converted to uppercase.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">hook</span>(chunks: <span style="color: #008000">list</span>[<span style="color: #008000">str</span>]) <span style="color: #666666">-&gt;</span> <span style="color: #008000">list</span>[<span style="color: #008000">str</span>]:
        <span style="color: #008000; font-weight: bold">return</span> [c<span style="color: #666666">.</span>upper() <span style="color: #008000; font-weight: bold">for</span> c <span style="color: #AA22FF; font-weight: bold">in</span> chunks]
</code></pre>
</details>
<h3 id="test_parallel_chunk_summarization">test_parallel_chunk_summarization(tmp_path: Path) -&gt; None</h3>
<p>The function `test_parallel_chunk_summarization` tests the parallel chunk summarization functionality using a mock client and a response cache. It creates a large text by repeating a paragraph multiple times, simulates a slow client that delays responses based on system prompts, and measures the time taken to summarize the text using manual utilities. The test asserts that the total duration is less than 1.5 times the delay, indicating that the summarization process is efficient despite the simulated slowness of the client.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">test_parallel_chunk_summarization</span>(tmp_path: Path) <span style="color: #666666">-&gt;</span> <span style="color: #008000; font-weight: bold">None</span>:
    paragraph <span style="color: #666666">=</span> <span style="color: #BA2121">&quot;word &quot;</span> <span style="color: #666666">*</span> <span style="color: #666666">2000</span>
    text <span style="color: #666666">=</span> <span style="color: #BA2121">&quot;</span><span style="color: #AA5D1F; font-weight: bold">\n\n</span><span style="color: #BA2121">&quot;</span><span style="color: #666666">.</span>join([paragraph, paragraph])
    delay <span style="color: #666666">=</span> <span style="color: #666666">0.2</span>

    <span style="color: #008000; font-weight: bold">class</span> <span style="color: #0000FF; font-weight: bold">SlowClient</span>:
        <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">summarize</span>(<span style="color: #008000">self</span>, text: <span style="color: #008000">str</span>, prompt_type: <span style="color: #008000">str</span>, system_prompt: <span style="color: #008000">str</span> <span style="color: #666666">=</span> <span style="color: #BA2121">&quot;&quot;</span>) <span style="color: #666666">-&gt;</span> <span style="color: #008000">str</span>:
            <span style="color: #008000; font-weight: bold">if</span> system_prompt <span style="color: #666666">==</span> explaincode<span style="color: #666666">.</span>CHUNK_SYSTEM_PROMPT:
                time<span style="color: #666666">.</span>sleep(delay)
            <span style="color: #008000; font-weight: bold">return</span> <span style="color: #BA2121">&quot;ok&quot;</span>

    client <span style="color: #666666">=</span> SlowClient()
    cache <span style="color: #666666">=</span> ResponseCache(<span style="color: #008000">str</span>(tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;cache.json&quot;</span>))
    start <span style="color: #666666">=</span> time<span style="color: #666666">.</span>perf_counter()
    manual_utils<span style="color: #666666">.</span>_summarize_manual(client, cache, text, chunking<span style="color: #666666">=</span><span style="color: #BA2121">&quot;auto&quot;</span>, source<span style="color: #666666">=</span><span style="color: #BA2121">&quot;src&quot;</span>)
    duration <span style="color: #666666">=</span> time<span style="color: #666666">.</span>perf_counter() <span style="color: #666666">-</span> start
    <span style="color: #008000; font-weight: bold">assert</span> duration <span style="color: #666666">&lt;</span> delay <span style="color: #666666">*</span> <span style="color: #666666">1.5</span>
</code></pre>
<h3 id="test_hierarchical_merge_logged">test_hierarchical_merge_logged(tmp_path: Path, capsys: pytest.CaptureFixture[str]) -&gt; None</h3>
<p>The function `test_hierarchical_merge_logged` is a unit test for the `_summarize_manual` function from the `manual_utils.py` module. It tests the behavior of the summarization process when using a hierarchical merge strategy.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">test_hierarchical_merge_logged</span>(
    tmp_path: Path, capsys: pytest<span style="color: #666666">.</span>CaptureFixture[<span style="color: #008000">str</span>]
) <span style="color: #666666">-&gt;</span> <span style="color: #008000; font-weight: bold">None</span>:
    big <span style="color: #666666">=</span> <span style="color: #BA2121">&quot;word &quot;</span> <span style="color: #666666">*</span> <span style="color: #666666">5000</span>
    text <span style="color: #666666">=</span> <span style="color: #BA2121">&quot;</span><span style="color: #AA5D1F; font-weight: bold">\n\n</span><span style="color: #BA2121">&quot;</span><span style="color: #666666">.</span>join([big, big])

    <span style="color: #008000; font-weight: bold">class</span> <span style="color: #0000FF; font-weight: bold">Dummy</span>:
        <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">__init__</span>(<span style="color: #008000">self</span>) <span style="color: #666666">-&gt;</span> <span style="color: #008000; font-weight: bold">None</span>:
            <span style="color: #008000">self</span><span style="color: #666666">.</span>calls: <span style="color: #008000">list</span>[<span style="color: #008000">dict</span>] <span style="color: #666666">=</span> []

        <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">summarize</span>(<span style="color: #008000">self</span>, text: <span style="color: #008000">str</span>, prompt_type: <span style="color: #008000">str</span>, system_prompt: <span style="color: #008000">str</span> <span style="color: #666666">=</span> <span style="color: #BA2121">&quot;&quot;</span>) <span style="color: #666666">-&gt;</span> <span style="color: #008000">str</span>:
            <span style="color: #008000">self</span><span style="color: #666666">.</span>calls<span style="color: #666666">.</span>append(
                {<span style="color: #BA2121">&quot;text&quot;</span>: text, <span style="color: #BA2121">&quot;prompt_type&quot;</span>: prompt_type, <span style="color: #BA2121">&quot;system_prompt&quot;</span>: system_prompt}
            )
            <span style="color: #008000; font-weight: bold">if</span> <span style="color: #008000">len</span>(<span style="color: #008000">self</span><span style="color: #666666">.</span>calls) <span style="color: #666666">&lt;=</span> <span style="color: #666666">2</span>:
                <span style="color: #008000; font-weight: bold">return</span> big
            <span style="color: #008000; font-weight: bold">return</span> <span style="color: #BA2121">&quot;short&quot;</span>

    client <span style="color: #666666">=</span> Dummy()
    cache <span style="color: #666666">=</span> ResponseCache(<span style="color: #008000">str</span>(tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;cache.json&quot;</span>))
    logging<span style="color: #666666">.</span>basicConfig(stream<span style="color: #666666">=</span>sys<span style="color: #666666">.</span>stdout, level<span style="color: #666666">=</span>logging<span style="color: #666666">.</span>DEBUG, force<span style="color: #666666">=</span><span style="color: #008000; font-weight: bold">True</span>)
    result <span style="color: #666666">=</span> manual_utils<span style="color: #666666">.</span>_summarize_manual(
        client, cache, text, chunking<span style="color: #666666">=</span><span style="color: #BA2121">&quot;auto&quot;</span>, source<span style="color: #666666">=</span><span style="color: #BA2121">&quot;src&quot;</span>
    )

    <span style="color: #008000; font-weight: bold">assert</span> result <span style="color: #666666">==</span> <span style="color: #BA2121">&quot;short&quot;</span>
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #008000">len</span>(client<span style="color: #666666">.</span>calls) <span style="color: #666666">&gt;</span> <span style="color: #666666">3</span>
    out <span style="color: #666666">=</span> capsys<span style="color: #666666">.</span>readouterr()<span style="color: #666666">.</span>out
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #BA2121">&quot;Hierarchical merge pass&quot;</span> <span style="color: #AA22FF; font-weight: bold">in</span> out
</code></pre>
<h3 id="test_cached_chunks_reused">test_cached_chunks_reused(tmp_path: Path) -&gt; None</h3>
<p>The function `test_cached_chunks_reused` tests the caching mechanism for response chunks in a manual summarization process. It creates a dummy client and cache, simulates two calls to summarize the same text with chunking set to &quot;auto&quot; and source as &quot;src&quot;. The first call results in three summary responses being made, while the second call, using the same cache, retrieves the cached responses without making additional calls. The function asserts that the second call returns the same response as the first and that no new calls were made on the second client, demonstrating that the caching mechanism is working correctly.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">test_cached_chunks_reused</span>(tmp_path: Path) <span style="color: #666666">-&gt;</span> <span style="color: #008000; font-weight: bold">None</span>:
    paragraph <span style="color: #666666">=</span> <span style="color: #BA2121">&quot;word &quot;</span> <span style="color: #666666">*</span> <span style="color: #666666">2000</span>
    text <span style="color: #666666">=</span> <span style="color: #BA2121">&quot;</span><span style="color: #AA5D1F; font-weight: bold">\n\n</span><span style="color: #BA2121">&quot;</span><span style="color: #666666">.</span>join([paragraph, paragraph])

    <span style="color: #008000; font-weight: bold">class</span> <span style="color: #0000FF; font-weight: bold">Dummy</span>:
        <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">__init__</span>(<span style="color: #008000">self</span>) <span style="color: #666666">-&gt;</span> <span style="color: #008000; font-weight: bold">None</span>:
            <span style="color: #008000">self</span><span style="color: #666666">.</span>calls: <span style="color: #008000">list</span>[<span style="color: #008000">dict</span>] <span style="color: #666666">=</span> []

        <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">summarize</span>(<span style="color: #008000">self</span>, text: <span style="color: #008000">str</span>, prompt_type: <span style="color: #008000">str</span>, system_prompt: <span style="color: #008000">str</span> <span style="color: #666666">=</span> <span style="color: #BA2121">&quot;&quot;</span>) <span style="color: #666666">-&gt;</span> <span style="color: #008000">str</span>:
            <span style="color: #008000">self</span><span style="color: #666666">.</span>calls<span style="color: #666666">.</span>append(
                {<span style="color: #BA2121">&quot;text&quot;</span>: text, <span style="color: #BA2121">&quot;prompt_type&quot;</span>: prompt_type, <span style="color: #BA2121">&quot;system_prompt&quot;</span>: system_prompt}
            )
            <span style="color: #008000; font-weight: bold">return</span> <span style="color: #BA2121">f&quot;resp</span><span style="color: #A45A77; font-weight: bold">{</span><span style="color: #008000">len</span>(<span style="color: #008000">self</span><span style="color: #666666">.</span>calls)<span style="color: #A45A77; font-weight: bold">}</span><span style="color: #BA2121">&quot;</span>

    cache_file <span style="color: #666666">=</span> tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;cache.json&quot;</span>
    cache <span style="color: #666666">=</span> ResponseCache(<span style="color: #008000">str</span>(cache_file))
    client1 <span style="color: #666666">=</span> Dummy()
    result1 <span style="color: #666666">=</span> manual_utils<span style="color: #666666">.</span>_summarize_manual(
        client1, cache, text, chunking<span style="color: #666666">=</span><span style="color: #BA2121">&quot;auto&quot;</span>, source<span style="color: #666666">=</span><span style="color: #BA2121">&quot;src&quot;</span>
    )
    <span style="color: #008000; font-weight: bold">assert</span> result1 <span style="color: #666666">==</span> <span style="color: #BA2121">&quot;resp3&quot;</span>
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #008000">len</span>(client1<span style="color: #666666">.</span>calls) <span style="color: #666666">==</span> <span style="color: #666666">3</span>

    client2 <span style="color: #666666">=</span> Dummy()
    cache2 <span style="color: #666666">=</span> ResponseCache(<span style="color: #008000">str</span>(cache_file))
    result2 <span style="color: #666666">=</span> manual_utils<span style="color: #666666">.</span>_summarize_manual(
        client2, cache2, text, chunking<span style="color: #666666">=</span><span style="color: #BA2121">&quot;auto&quot;</span>, source<span style="color: #666666">=</span><span style="color: #BA2121">&quot;src&quot;</span>
    )
    <span style="color: #008000; font-weight: bold">assert</span> result2 <span style="color: #666666">==</span> <span style="color: #BA2121">&quot;resp3&quot;</span>
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #008000">len</span>(client2<span style="color: #666666">.</span>calls) <span style="color: #666666">==</span> <span style="color: #666666">0</span>
</code></pre>
<h3 id="test_chunking_none_no_llm_calls">test_chunking_none_no_llm_calls(tmp_path: Path, monkeypatch: pytest.MonkeyPatch) -&gt; None</h3>
<p>The function `test_chunking_none_no_llm_calls` is a test case designed to verify the behavior of the code summarization process when chunking is disabled and no LLM calls are expected. It uses a temporary directory (`tmp_path`) and a mock object (`Dummy`) to simulate the environment during testing.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">test_chunking_none_no_llm_calls</span>(tmp_path: Path, monkeypatch: pytest<span style="color: #666666">.</span>MonkeyPatch) <span style="color: #666666">-&gt;</span> <span style="color: #008000; font-weight: bold">None</span>:
    big_text <span style="color: #666666">=</span> <span style="color: #BA2121">&quot;data &quot;</span> <span style="color: #666666">*</span> <span style="color: #666666">5000</span>
    (tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;README.md&quot;</span>)<span style="color: #666666">.</span>write_text(<span style="color: #BA2121">&quot;# Overview</span><span style="color: #AA5D1F; font-weight: bold">\n</span><span style="color: #BA2121">&quot;</span> <span style="color: #666666">+</span> big_text, encoding<span style="color: #666666">=</span><span style="color: #BA2121">&quot;utf-8&quot;</span>)

    <span style="color: #008000; font-weight: bold">class</span> <span style="color: #0000FF; font-weight: bold">Dummy</span>:
        <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">__init__</span>(<span style="color: #008000">self</span>) <span style="color: #666666">-&gt;</span> <span style="color: #008000; font-weight: bold">None</span>:
            <span style="color: #008000">self</span><span style="color: #666666">.</span>calls: <span style="color: #008000">list</span>[<span style="color: #008000">dict</span>] <span style="color: #666666">=</span> []

        <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">summarize</span>(<span style="color: #008000">self</span>, text: <span style="color: #008000">str</span>, prompt_type: <span style="color: #008000">str</span>, system_prompt: <span style="color: #008000">str</span> <span style="color: #666666">=</span> <span style="color: #BA2121">&quot;&quot;</span>) <span style="color: #666666">-&gt;</span> <span style="color: #008000">str</span>:
            <span style="color: #008000">self</span><span style="color: #666666">.</span>calls<span style="color: #666666">.</span>append(
                {<span style="color: #BA2121">&quot;text&quot;</span>: text, <span style="color: #BA2121">&quot;prompt_type&quot;</span>: prompt_type, <span style="color: #BA2121">&quot;system_prompt&quot;</span>: system_prompt}
            )
            <span style="color: #008000; font-weight: bold">return</span> <span style="color: #BA2121">&quot;done&quot;</span>

    dummy <span style="color: #666666">=</span> Dummy()
    monkeypatch<span style="color: #666666">.</span>setattr(explaincode, <span style="color: #BA2121">&quot;LLMClient&quot;</span>, <span style="color: #008000; font-weight: bold">lambda</span>: dummy)
    main([<span style="color: #BA2121">&quot;--path&quot;</span>, <span style="color: #008000">str</span>(tmp_path), <span style="color: #BA2121">&quot;--chunking&quot;</span>, <span style="color: #BA2121">&quot;none&quot;</span>])

    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #008000">len</span>(dummy<span style="color: #666666">.</span>calls) <span style="color: #666666">==</span> <span style="color: #666666">5</span>
    call <span style="color: #666666">=</span> dummy<span style="color: #666666">.</span>calls[<span style="color: #666666">0</span>]
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #BA2121">&quot;Overview&quot;</span> <span style="color: #AA22FF; font-weight: bold">in</span> call[<span style="color: #BA2121">&quot;system_prompt&quot;</span>]
</code></pre>
<h3 id="test_llm_generate_manual_sanitizes_and_caches">test_llm_generate_manual_sanitizes_and_caches(tmp_path: Path, monkeypatch: pytest.MonkeyPatch) -&gt; None</h3>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">test_llm_generate_manual_sanitizes_and_caches</span>(tmp_path: Path, monkeypatch: pytest<span style="color: #666666">.</span>MonkeyPatch) <span style="color: #666666">-&gt;</span> <span style="color: #008000; font-weight: bold">None</span>:
    docs <span style="color: #666666">=</span> {Path(<span style="color: #BA2121">&quot;readme.md&quot;</span>): <span style="color: #BA2121">&quot;# Overview</span><span style="color: #AA5D1F; font-weight: bold">\n</span><span style="color: #BA2121">Example&quot;</span>}
    cache <span style="color: #666666">=</span> ResponseCache(<span style="color: #008000">str</span>(tmp_path <span style="color: #666666">/</span> <span style="color: #BA2121">&quot;cache.json&quot;</span>))
    client <span style="color: #666666">=</span> explaincode<span style="color: #666666">.</span>LLMClient(<span style="color: #BA2121">&quot;http://fake&quot;</span>)

    <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">fake_summarize</span>(prompt: <span style="color: #008000">str</span>, prompt_type: <span style="color: #008000">str</span>, system_prompt: <span style="color: #008000">str</span> <span style="color: #666666">=</span> <span style="color: #BA2121">&quot;&quot;</span>) <span style="color: #666666">-&gt;</span> <span style="color: #008000">str</span>:
        <span style="color: #008000; font-weight: bold">return</span> (
            <span style="color: #BA2121">&quot;You are a documentation engine. Summarize the following.</span><span style="color: #AA5D1F; font-weight: bold">\n</span><span style="color: #BA2121">&quot;</span>
            <span style="color: #BA2121">&quot;It prints output.&quot;</span>
        )

    monkeypatch<span style="color: #666666">.</span>setattr(client, <span style="color: #BA2121">&quot;summarize&quot;</span>, fake_summarize)
    manual, _, _ <span style="color: #666666">=</span> explaincode<span style="color: #666666">.</span>llm_generate_manual(docs, client, cache, chunking<span style="color: #666666">=</span><span style="color: #BA2121">&quot;none&quot;</span>)
    lower <span style="color: #666666">=</span> manual<span style="color: #666666">.</span>lower()
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #BA2121">&quot;documentation engine&quot;</span> <span style="color: #AA22FF; font-weight: bold">not</span> <span style="color: #AA22FF; font-weight: bold">in</span> lower
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #BA2121">&quot;summarize the following&quot;</span> <span style="color: #AA22FF; font-weight: bold">not</span> <span style="color: #AA22FF; font-weight: bold">in</span> lower

    section_map, _ <span style="color: #666666">=</span> explaincode<span style="color: #666666">.</span>map_evidence_to_sections(docs)
    entries <span style="color: #666666">=</span> section_map[<span style="color: #BA2121">&quot;Overview&quot;</span>]
    context <span style="color: #666666">=</span> <span style="color: #BA2121">&quot;</span><span style="color: #AA5D1F; font-weight: bold">\n\n</span><span style="color: #BA2121">&quot;</span><span style="color: #666666">.</span>join(snippet <span style="color: #008000; font-weight: bold">for</span> _, snippet <span style="color: #AA22FF; font-weight: bold">in</span> entries)
    prompt <span style="color: #666666">=</span> (
        <span style="color: #BA2121">&quot;Write the &#39;Overview&#39; section of a user manual using the &quot;</span>
        <span style="color: #BA2121">&quot;following documentation snippets.</span><span style="color: #AA5D1F; font-weight: bold">\n\n</span><span style="color: #BA2121">&quot;</span> <span style="color: #666666">+</span> context
    )
    key <span style="color: #666666">=</span> ResponseCache<span style="color: #666666">.</span>make_key(<span style="color: #BA2121">&quot;section:Overview&quot;</span>, prompt)
    cached <span style="color: #666666">=</span> cache<span style="color: #666666">.</span>get(key)
    <span style="color: #008000; font-weight: bold">assert</span> cached <span style="color: #AA22FF; font-weight: bold">is</span> <span style="color: #AA22FF; font-weight: bold">not</span> <span style="color: #008000; font-weight: bold">None</span>
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #BA2121">&quot;documentation engine&quot;</span> <span style="color: #AA22FF; font-weight: bold">not</span> <span style="color: #AA22FF; font-weight: bold">in</span> cached<span style="color: #666666">.</span>lower()
</code></pre>
<details>
<summary>Subfunction: fake_summarize(prompt: str, prompt_type: str, system_prompt: str=&#x27;&#x27;) -&gt; str</summary>
<h4 id="fake_summarize">fake_summarize(prompt: str, prompt_type: str, system_prompt: str=&#x27;&#x27;) -&gt; str</h4>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">fake_summarize</span>(prompt: <span style="color: #008000">str</span>, prompt_type: <span style="color: #008000">str</span>, system_prompt: <span style="color: #008000">str</span> <span style="color: #666666">=</span> <span style="color: #BA2121">&quot;&quot;</span>) <span style="color: #666666">-&gt;</span> <span style="color: #008000">str</span>:
        <span style="color: #008000; font-weight: bold">return</span> (
            <span style="color: #BA2121">&quot;You are a documentation engine. Summarize the following.</span><span style="color: #AA5D1F; font-weight: bold">\n</span><span style="color: #BA2121">&quot;</span>
            <span style="color: #BA2121">&quot;It prints output.&quot;</span>
        )
</code></pre>
</details>
    </div>
    <script src="static/toggle.js"></script>
</body>
</html>
