import os
import sys
from pathlib import Path

sys.path.insert(0, os.path.abspath(os.path.join(os.path.dirname(__file__), "..")))
from html_writer import write_index, write_module_page, _highlight


def test_write_index(tmp_path: Path) -> None:
    links = [("module<1>", "module1.html"), ("module&2", "module2.html")]
    summaries = {"module<1>": "First module.", "module&2": ""}
    write_index(str(tmp_path), "Project <summary> & data", links, summaries)
    html = (tmp_path / "index.html").read_text(encoding="utf-8")
    assert html.splitlines()[0].strip() == "<!-- Generated by DocGen-LM -->"
    assert "Project &lt;summary&gt; &amp; data" in html
    assert html.count("module1.html") == 2
    assert html.count("module2.html") == 2
    assert "module&lt;1&gt;" in html
    assert "module&amp;2" in html
    assert "<h2>Modules" in html
    assert "<ul" in html
    assert "<small>First module." in html
    # only one summary should be rendered
    assert html.count("<small>") == 1
    assert "<h1>Project Documentation" in html


def test_write_module_page(tmp_path: Path) -> None:
    links = [("OtherModule", "other.html")]
    module_data = {
        "name": "module1",
        "summary": "Module <summary>",
        "variables": [
            {
                "name": "MOD_VAR",
                "docstring": "Module <var>",
                "source": "MOD_VAR = 1",
            }
        ],
        "classes": [
            {
                "name": "Bar",
                "summary": "Class <summary>",
                "docstring": "Bar docs & stuff",
                "variables": [
                    {
                        "name": "attr",
                        "docstring": "Attr <docs>",
                        "source": "attr = 1",
                    }
                ],
                "methods": [
                    {
                        "name": "baz",
                        "signature": "def baz(self): pass",
                        "docstring": "Baz <docs>",
                        "source": "def baz(self):\n    pass",
                    }
                ],
            }
        ],
        "functions": [
            {
                "name": "foo",
                "signature": "def foo(): pass",
                "summary": "Func summary & stuff",
                "docstring": "Foo docs",
                "source": "def foo():\n    pass",
            }
        ],
    }
    write_module_page(str(tmp_path), module_data, links)
    html = (tmp_path / "module1.html").read_text(encoding="utf-8")
    assert html.splitlines()[0].strip() == "<!-- Generated by DocGen-LM -->"
    assert '<a href="index.html"><strong>üè† Project Overview</strong></a>' in html
    assert html.count('other.html') == 1
    assert "Module &lt;summary&gt;" in html
    assert "<h2 id=\"Bar\">Class: Bar</h2>" in html
    assert "Bar docs &amp; stuff" in html
    assert "Method: def baz(self): pass" in html
    assert "Baz &lt;docs&gt;" in html
    assert "<h3 id=\"Bar-variables\">Variables</h3>" in html
    assert "<h4 id=\"attr\">attr</h4>" in html
    assert "Attr &lt;docs&gt;" in html
    assert "attr <span" in html
    assert "<h2 id=\"variables\">Variables</h2>" in html
    assert "<h3 id=\"MOD_VAR\">MOD_VAR</h3>" in html
    assert "Module &lt;var&gt;" in html
    assert "MOD_VAR <span" in html
    assert "Func summary &amp; stuff" in html
    assert "<h2>Functions" in html
    assert "def foo(): pass" in html
    assert html.count("<pre><code>") == 4


def test_subfunction_rendering(tmp_path: Path) -> None:
    links = []
    module_data = {
        "name": "mod",
        "summary": "",
        "classes": [],
        "functions": [
            {
                "name": "outer",
                "signature": "def outer(x)",
                "source": "def outer(x):\n    def inner(y):\n        pass\n    return inner(x)",
                "subfunctions": [
                    {
                        "name": "inner",
                        "signature": "def inner(y)",
                        "summary": "Inner summary",
                        "docstring": "",
                        "source": "def inner(y):\n    pass",
                        "subfunctions": [],
                    }
                ],
            }
        ],
    }
    write_module_page(str(tmp_path), module_data, links)
    html = (tmp_path / "mod.html").read_text(encoding="utf-8")
    assert "<details>" in html
    assert "Subfunction: def inner(y)" in html
    assert "Inner summary" in html
    # outer and inner source should both be highlighted
    assert html.count("<pre><code>") == 2


def test_subclass_rendering(tmp_path: Path) -> None:
    links = []
    module_data = {
        "name": "mod",
        "summary": "",
        "functions": [],
        "classes": [
            {
                "name": "A",
                "docstring": "",
                "methods": [],
                "subclasses": [
                    {
                        "name": "B",
                        "summary": "B summary",
                        "docstring": "",
                        "methods": [
                            {
                                "name": "m",
                                "signature": "def m(self)",
                                "source": "def m(self):\n    pass",
                                "subfunctions": [],
                            }
                        ],
                        "subclasses": [],
                    }
                ],
            }
        ],
    }
    write_module_page(str(tmp_path), module_data, links)
    html = (tmp_path / "mod.html").read_text(encoding="utf-8")
    assert "<details>" in html
    assert "Class: B" in html
    assert "B summary" in html
    assert "def m(self)" in html
    assert html.count("<pre><code>") == 1


def test_cpp_java_highlighting() -> None:
    cpp_html = _highlight("int main() { return 0; }", "cpp")
    java_html = _highlight("class T { int x; }", "java")
    assert "<span" in cpp_html
    assert "<span" in java_html
